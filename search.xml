<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ARMv8-aarch64寄存器和指令集</title>
    <url>/post/7190.html</url>
    <content><![CDATA[<p><img data-src="/images/2019/02/armv8_a.png" alt="armv8-a"></p>
<span id="more"></span>

<h2 id="ARMv8-A处理器属性"><a href="#ARMv8-A处理器属性" class="headerlink" title="ARMv8-A处理器属性"></a>ARMv8-A处理器属性</h2><p><img data-src="/images/2019/02/armv8_a_properties.png" alt="armv8-a-properties"></p>
<blockquote>
<p>Rockchip RK3399 SoC integrates dual-core <code>Cortex-A72</code> and quad-core <code>Cortex-A53</code> with separate NEON coprocessor, and with ARM Mali-T864 GPU.</p>
</blockquote>
<h2 id="异常等级"><a href="#异常等级" class="headerlink" title="异常等级"></a>异常等级</h2><p>软件运行异常级别：</p>
<ul>
<li><code>EL0</code>： 普通用户应用程序</li>
<li><code>EL1</code>： 操作系统内核通常被描述为特权</li>
<li><code>EL2</code>： 管理程序</li>
<li><code>EL3</code>： 低级固件，包括安全监视器</li>
</ul>
<h2 id="ARMv8寄存器"><a href="#ARMv8寄存器" class="headerlink" title="ARMv8寄存器"></a>ARMv8寄存器</h2><p>AArch拥有<code>31</code>个通用寄存器，系统运行在64位状态下的时候名字叫<code>Xn</code>，运行在32位的时候就叫<code>Wn</code>.</p>
<p><img data-src="/images/2019/02/armv8_reg.png" alt="armv8-reg"></p>
<blockquote>
<p>32位W寄存器构成相应64位X寄存器的下半部分。 也就是说，W0<br>映射到X0的低位字，W1映射到X1的低位字。</p>
</blockquote>
<h3 id="特殊寄存器"><a href="#特殊寄存器" class="headerlink" title="特殊寄存器"></a>特殊寄存器</h3><p><img data-src="/images/2019/02/armv8%E7%89%B9%E6%AE%8A%E5%AF%84%E5%AD%98%E5%99%A8.png" alt="armv8特殊寄存器"></p>
<table>
<thead>
<tr>
<th align="center">Name</th>
<th align="center">Size</th>
<th align="center">Description</th>
</tr>
</thead>
<tbody><tr>
<td align="center">WZR</td>
<td align="center">32bits</td>
<td align="center">Zero register</td>
</tr>
<tr>
<td align="center">XZR</td>
<td align="center">64bits</td>
<td align="center">Zero register</td>
</tr>
<tr>
<td align="center">WSP</td>
<td align="center">32bits</td>
<td align="center">Current stack pointer</td>
</tr>
<tr>
<td align="center">SP</td>
<td align="center">64bits</td>
<td align="center">Current stack pointer</td>
</tr>
<tr>
<td align="center">pC</td>
<td align="center">64bits</td>
<td align="center">Program counter</td>
</tr>
</tbody></table>
<h2 id="ARM-64位架构的ABI"><a href="#ARM-64位架构的ABI" class="headerlink" title="ARM 64位架构的ABI"></a>ARM 64位架构的ABI</h2><p>ARM体系结构的应用程序二进制接口（<code>ABI</code>， Application Binary Interface）指定了基本规则所有可执行的本机代码模块必须遵守，以便它们可以正常工作。</p>
<h3 id="通用寄存器"><a href="#通用寄存器" class="headerlink" title="通用寄存器"></a>通用寄存器</h3><p>通用寄存器分为4组：</p>
<p><img data-src="/images/2019/02/armv8_register.png" alt="armv8-register"></p>
<ul>
<li><p>参数寄存器<code>（X0-X7）</code>： 用作临时寄存器或可以保存的调用者保存的寄存器变量函数内的中间值，调用其他函数之间的值（8个寄存器可用于传递参数）</p>
</li>
<li><p>调用者保存的临时寄存器<code>（X9-X15）</code>： 如果调用者要求在任何这些寄存器中保留值调用另一个函数，调用者必须将受影响的寄存器保存在自己的堆栈中帧。 它们可以通过被调用的子程序进行修改，而无需保存并在返回调用者之前恢复它们。</p>
</li>
<li><p>被调用者保存的寄存器<code>（X19-X29）</code>： 这些寄存器保存在被调用者帧中。 它们可以被被调用者修改子程序，只要它们在返回之前保存并恢复。</p>
</li>
<li><p>特殊用途寄存器<code>（X8，X16-X18，X29，X30）</code>：</p>
<ul>
<li><code>X8</code>： 是间接结果寄存器,用于保存子程序返回地址，<code>尽量不使用</code></li>
<li><code>X16</code>和<code>X17</code>： 程序内调用临时寄存器</li>
<li><code>X18</code>： 平台寄存器，保留用于平台ABI，<code>尽量不使用</code></li>
<li><code>X29</code>： 帧指针寄存器（FP）</li>
<li><code>X30</code>： 链接寄存器（LR）</li>
<li><code>X31</code>： 堆栈指针寄存器SP或零寄存器ZXR</li>
</ul>
</li>
</ul>
<h3 id="NEON和浮点寄存器"><a href="#NEON和浮点寄存器" class="headerlink" title="NEON和浮点寄存器"></a>NEON和浮点寄存器</h3><p><img data-src="/images/2019/02/armv8_simd_reg.png" alt="armv8-simd-reg"></p>
<h2 id="A64指令集"><a href="#A64指令集" class="headerlink" title="A64指令集"></a>A64指令集</h2><h3 id="A64特点"><a href="#A64特点" class="headerlink" title="A64特点"></a>A64特点</h3><ul>
<li>移除了批量加载寄存器指令 LDM&#x2F;STM, PUSH&#x2F;POP, 使用STP&#x2F;LDP 一对加载寄存器指令代替；</li>
<li>没有提供访问CPSR的单一寄存器，但是提供访问PSTATE的状态域寄存器；</li>
<li>A64没有协处理器的概念，没有协处理器指令MCR,MRC；</li>
<li>相比A32少了很多条件执行指令，只有条件跳转和少数数据处理这类指令才有条件执行.附件为条件指令码；</li>
</ul>
<h3 id="指令格式"><a href="#指令格式" class="headerlink" title="指令格式"></a>指令格式</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;Opcode&gt;&#123;&lt;Cond&gt;&#125;&lt;S&gt;  &lt;Rd&gt;, &lt;Rn&gt; &#123;,&lt;Opcode2&gt;&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li><code>Opcode</code>：操作码，也就是助记符，说明指令需要执行的操作类型</li>
<li><code>Cond</code>：指令执行条件码，查看附件图；</li>
<li><code>S</code>：条件码设置项,决定本次指令执行是否影响PSTATE寄存器响应状态位值</li>
<li><code>Rd/Xt</code>：目标寄存器，A32指令可以选择R0-R14,T32指令大部分只能选择RO-R7，A64指令可以选择X0-X30；</li>
<li><code>Rn/Xn</code>：第一个操作数的寄存器，和Rd一样，不同指令有不同要求；</li>
<li><code>Opcode2</code>：第二个操作数，可以是立即数，寄存器Rm和寄存器移位方式（Rm，#shit）；</li>
</ul>
</blockquote>
<h3 id="内存访问指令"><a href="#内存访问指令" class="headerlink" title="内存访问指令"></a>内存访问指令</h3><ul>
<li>加载指令<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LDR Rt, &lt;addr&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li><code>LDRB</code> (8-bit, zero extended).</li>
<li><code>LDRSB</code> (8-bit, sign extended).</li>
<li><code>LDRH</code> (16-bit, zero extended).</li>
<li><code>LDRSH</code> (16-bit, sign extended).</li>
<li><code>LDRSW</code> (32-bit, sign extended).</li>
</ul>
</blockquote>
</li>
</ul>
<p><img data-src="/images/2019/02/armv8%E5%8A%A0%E8%BD%BD%E6%8C%87%E4%BB%A4%E7%9A%84%E5%9C%B0%E5%9D%80%E5%81%8F%E7%A7%BB.png" alt="armv8加载指令的地址偏移"></p>
<ul>
<li>存储指令<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">STR Rn, &lt;addr&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="/downloads/arm/DEN0024A_v8_architecture_PG.pdf">Programmer’s Guide for ARMv8-A</a>&#x3D;</li>
</ul>
]]></content>
      <categories>
        <category>ARM</category>
      </categories>
      <tags>
        <tag>arm64</tag>
      </tags>
  </entry>
  <entry>
    <title>ARMv8异常处理</title>
    <url>/post/5c89cc1d.html</url>
    <content><![CDATA[<p><img data-src="/images/2021/11/arm64_spec_regs.png" alt="arm64_spec_regs"></p>
<p>在ARM64中<code>SP</code>（栈指针），由于存在<code>EL0～EL3</code>四种异常级别，因此存在四个<code>SP</code>；但是<code>PC</code>指针只有一个（单核）</p>
<span id="more"></span>

<ul>
<li><code>XZR/WZR</code>(Zero register):零寄存器用作源寄存器时读为零，用作目标寄存器时丢弃结果。你可以在大多数（但不是所有）指令中使用零寄存器。</li>
<li><code>PC</code>（Program Counter）：程序计数器</li>
<li><code>SP</code>（Stack pointer）： 堆栈指针（SP）是一个指向堆栈顶部的寄存器。 选择使用的堆栈指针在某种程度上与“异常”级别是分开的。 默认情况下，发生异常时会为目标异常级别选择堆栈指针（SP_ELn）</li>
<li><code>SPSR</code>（Program Status Register）： 发生异常时，处理器状态存储在相关的保存程序状态寄存器 (SPSR) 中，类似于ARMv7中的CPSR。 SPSR在发生异常之前保存PSTATE的值，用于在执行异常返回时恢复PSTATE的值</li>
<li><code>ELR</code>(Exception Link Register): 异常链接寄存器,保存导致异常的指令的地址</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EL0为普通用户程序</span><br><span class="line">EL1是操作系统内核相关</span><br><span class="line">EL2是Hypervisor, 可以理解为上面跑多个虚拟OS</span><br><span class="line">EL3是Secure Monitor(ARM Trusted Firmware)</span><br></pre></td></tr></table></figure>

<p><img data-src="/images/2021/11/arm64_exception_handling.png" alt="arm64_exception_handling"></p>
<p>异常类型：</p>
<ul>
<li>中断（Interrupts）</li>
<li>中止（Aborts）</li>
<li>重置（Reset）</li>
<li>异常指令（Exception generating instructions）</li>
</ul>
<h2 id="异常处理寄存器"><a href="#异常处理寄存器" class="headerlink" title="异常处理寄存器"></a>异常处理寄存器</h2><p>如果发生异常，PSTATE 信息将保存在<code>Saved Program Status Register</code>(SPSR_ELn) 中，该寄存器以<code>SPSR_EL3</code>、<code>SPSR_EL2</code>和<code>SPSR_EL1</code>的形式存在。</p>
<p><img data-src="/images/2021/11/arm64%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E5%AF%84%E5%AD%98%E5%99%A8.png" alt="arm64异常处理寄存器"></p>
<blockquote>
<p><code>SPRSR.M</code>字段（第4位）用于记录执行状态（<code>0</code>表示AArch64，<code>1</code>表示AArch32）。</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">PSTATE fields</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">NZCV</td>
<td align="center">条件标志</td>
</tr>
<tr>
<td align="center">Q</td>
<td align="center">累积饱和位</td>
</tr>
<tr>
<td align="center">DAIF</td>
<td align="center">异常掩码位</td>
</tr>
<tr>
<td align="center">SPSel</td>
<td align="center">SP选择（EL0或ELn），不适用于EL0</td>
</tr>
<tr>
<td align="center">E</td>
<td align="center">数据字节序（仅限 AArch32）</td>
</tr>
<tr>
<td align="center">IL</td>
<td align="center">非法标志</td>
</tr>
<tr>
<td align="center">SS</td>
<td align="center">软件步进位(单步调试)</td>
</tr>
</tbody></table>
<p>异常掩码位(DAIF)允许屏蔽异常事件，设置该位时不发生异常。</p>
<ul>
<li><code>D</code>：Debug exceptions mask.</li>
<li><code>A</code>：SError interrupt Process state mask, for example, asynchronous External Abort.</li>
<li><code>I</code>：IRQ interrupt Process state mask</li>
<li><code>F</code>：FIQ interrupt Process state mask.</li>
</ul>
<p>当导致异常的事件发生时，处理器硬件会自动执行某些操作。 更新<code>SPSR_EL</code>（其中n是发生异常的异常级别），以存储在异常结束时正确返回所需的<code>PSTATE</code>信息。 <code>PSTATE</code>被更新以反映新的处理器状态（这可能意味着异常级别被提升，或者它可能保持不变）。 异常结束时使用的返回地址存储在<code>ELR_ELn</code>中。</p>
<p><img data-src="/images/2021/11/arm64%E5%BC%82%E5%B8%B8%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B.png" alt="arm64异常事件处理流程"></p>
<p>请记住，寄存器名称上的<code>_ELn</code>后缀表示这些寄存器的多个副本存在于不同的异常级别。 例如，<code>SPSR_EL1</code>与<code>SPSR_EL2</code>是不同的物理寄存器。 此外，在同步或SError异常的情况下，ESR_ELn也会更新为指示异常原因的值。</p>
<p>必须通过软件告知处理器何时从异常中返回。 这是通过执行<code>ERET</code>指令来完成的。 这会从<code>SPSR_ELn</code>恢复异常前的<code>PSTATE</code>，并通过从<code>ELR_ELn</code>恢复<code>PC</code>将程序执行返回到原始位置。</p>
<p>我们已经看到SPSR如何记录异常返回所需的状态信息。 我们现在将查看用于存储程序地址信息的链接寄存器。 该架构为函数调用和异常返回提供了单独的链接寄存器。</p>
<p>在A64指令集，寄存器<code>X30</code>用于与<code>RET</code>指令结合）从子程序返回。 每当我们执行带有链接指令（BL或BLR）的分支时，它的值都会使用要返回的指令的地址进行更新。</p>
<p><code>ELR_ELn</code>寄存器用于存储异常的返回地址。该寄存器中的值（实际上是几个寄存器，正如我们所见）在进入异常时自动写入，并作为执行用于从异常返回的<code>ERET</code>指令的效果之一写入<code>PC</code>。</p>
<p><strong>注</strong>：从异常返回时，如果<code>SPSR</code>中的值与系统寄存器中的设置冲突，您将看到错误。</p>
<h2 id="同步和异步异常"><a href="#同步和异步异常" class="headerlink" title="同步和异步异常"></a>同步和异步异常</h2><p>在AArch64中，异常可能是同步的，也可能是异步的。 如果异常是作为指令流的执行或尝试执行的结果而生成的，并且返回地址提供了使用它的指令的详细信息，则该异常被描述为同步异常。 执行指令不会生成异步异常，而返回地址可能并不总是提供导致异常的原因的详细信息。</p>
<p><code>异步异常</code>的来源是IRQ（正常优先级中断）、FIQ（快速中断）或SError（系统错误）。 系统错误有多种可能的原因，最常见的是异步数据中止（例如，由脏数据从缓存行写回外部存储器触发的中止）。</p>
<p><code>同步异常</code>有多种来源：</p>
<ul>
<li>来自MMU的指令中止。 例如，通过从标记为从不执行的内存位置读取指令。</li>
<li>来自MMU的数据中止。 例如，权限失败或对齐检查。</li>
<li>SP和PC对齐检查。</li>
<li>同步外部中止。 例如，读取翻译表时中止。</li>
<li>未分配的指令。</li>
<li>调试异常。</li>
</ul>
<h2 id="AArch64异常表"><a href="#AArch64异常表" class="headerlink" title="AArch64异常表"></a>AArch64异常表</h2><p>当异常发生时，处理器必须执行与异常对应的处理程序代码。 存储处理程序的内存位置称为异常向量。 在ARM架构中，异常向量存储在一个表中，称为<code>异常向量表</code>。 每个异常级别都有自己的向量表，即EL3、EL2和EL1各有一个向量表。 该表包含要执行的指令，而不是一组地址。 个别异常的向量位于距表开头的固定偏移量处。每个表基址的虚拟地址由向量基址寄存器（Vector Based Address Registers）<code>VBAR_EL3</code>、<code>VBAR_EL2</code>和<code>VBAR_EL1</code>设置。</p>
<h2 id="中断处理"><a href="#中断处理" class="headerlink" title="中断处理"></a>中断处理</h2><p>ARM通常使用中断来表示中断信号。 在ARM A-profile和R-profile处理器上，这意味着外部IRQ或FIQ中断信号。 该架构没有指定如何使用这些信号。 FIQ通常保留用于安全中断源。 在早期的体系结构版本中，FIQ和IRQ用于表示高标准中断优先级，但在ARMv8-A中并非如此。</p>
<p>当处理器对AArch64执行状态发生异常时，所有<code>PSTATE</code>中断掩码都会自动设置，这意味着禁用更多异常。 如果软件要支持嵌套异常，例如，允许较高优先级的中断中断较低优先级源的处理，则软件需要明确地重新启用中断。</p>
<h2 id="中断控制器"><a href="#中断控制器" class="headerlink" title="中断控制器"></a>中断控制器</h2><p>ARM提供了一个标准的中断控制器，可用于ARMv8-A系统，该中断控制器的编程接口在GIC架构中定义。GIC架构规范有多个版本，本文档侧重于版本2(GICv2)。 ARMv8-A处理器通常连接到GIC，例如GIC-400或GIC-500。通用中断控制器 (GIC) 支持在多核系统中的内核之间路由软件生成的、私有的和共享的外设中断。</p>
<p>GIC架构提供的寄存器可用于管理中断源和行为以及（在多核系统中）用于将中断路由到各个内核。它使软件能够屏蔽、启用和禁用来自各个源的中断，对（在硬件中）各个源进行优先级排序并生成软件中断。 GIC接受在系统级别断言的中断，并可以将它们发送给它所连接的每个内核，这可能会导致发生IRQ或FIQ异常。</p>
<p>从软件的角度来看，GIC 有两个主要功能块：</p>
<ul>
<li><p><code>Distributor</code>（分发器）</p>
<ul>
<li>系统中所有中断源都连接到它。 Distributor具有寄存器来控制各个中断的属性，例如优先级、状态、安全性、路由信息和启用状态。 分配器通过附加的CPU接口确定将哪个中断转发到内核。</li>
</ul>
</li>
<li><p><code>CPU Interface</code>（中央处理器接口）</p>
<ul>
<li>内核通过它接收中断。 CPU接口托管寄存器以屏蔽、识别和控制转发到该内核的中断的状态。 系统中的每个内核都有一个单独的CPU接口。</li>
</ul>
</li>
</ul>
<p>中断在软件中由一个数字标识，称为<code>中断ID</code>。 一个中断ID唯一对应一个中断源，软件可以使用中断ID来识别中断源并调用相应的处理程序来服务中断，提供给软件的确切中断ID由系统设计决定。</p>
<h3 id="中断可以有多种不同的类型："><a href="#中断可以有多种不同的类型：" class="headerlink" title="中断可以有多种不同的类型："></a>中断可以有多种不同的类型：</h3><ul>
<li><p>Software Generated Interrupt (SGI) —— 软件产生中断</p>
<ul>
<li>这是由软件通过写入专用分配器寄存器（软件生成中断寄存器 (GICD_SGIR)）显式生成的，它最常用于内核间通信。SGI可以是全部目标，也可以是系统中选定的一组核心。<code>中断ID0-15</code>是为此保留的，用于给定中断的中断ID由生成它的软件设置。</li>
</ul>
</li>
<li><p>Private Peripheral Interrupt (PPI) —— 私有外设中断</p>
<ul>
<li>这是一个<code>全局外设中断</code>，分发器可以将其路由到指定的一个或多个内核。 <code>中断ID16-31</code>是为此保留的，它们标识<code>内核私有的中断源</code>，并且独立于另一个内核上的相同源，例如每内核定时器。</li>
</ul>
</li>
<li><p>Shared Peripheral Interrupt (SPI) —— 共享外设中断</p>
<ul>
<li>这是由GIC可以路由到多个内核的<code>外设</code>生成的。 <code>中断ID32-1020</code>用于此目的， SPI用于从整个系统中可访问的各种<code>外设发出中断信号</code>。</li>
</ul>
</li>
<li><p>Locality-specific Peripheral Interrupt (LPI) —— 特定于本地的外设中断</p>
<ul>
<li>这些是路由到特定内核的基于消息的中断。 GICv2或GICv1不支持LPI。</li>
</ul>
</li>
</ul>
<h3 id="中断状态"><a href="#中断状态" class="headerlink" title="中断状态"></a>中断状态</h3><p>中断可以是边沿触发的（当 GIC 检测到相关输入的上升沿时被认为是有效的，并保持有效直到被清除）或电平敏感（仅当 GIC 的相关输入为高时才被认为是有效的 ）。</p>
<p>中断可以处于多种不同的状态：</p>
<ul>
<li><code>Inactive</code> —— 意味着当前没有中断</li>
<li><code>Pending</code> —— 意味着中断源已被中断，但正在等待内核处理。待处理的中断是被转发到CPU接口，然后再转发到内核的候选者</li>
<li><code>Active</code> —— 意味着已被内核确认并且当前正在服务的中断</li>
<li><code>Active and pending</code> —— 这描述了内核正在为中断提供服务并且GIC也有来自同一源的挂起中断的情况</li>
</ul>
<p>中断状态变化的经典顺序：</p>
<ul>
<li>Inactive -&gt; Pending： 当外设发出中断时</li>
<li>Pending -&gt; Active： 当处理程序确认中断时</li>
<li>Active -&gt; Inactive： 当句柄处理完中断时</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># cat /proc/interrupts</span><br><span class="line">           CPU0       CPU1</span><br><span class="line"></span><br><span class="line">  7:        272          0     GIC-0  66 Level     ttyS0</span><br><span class="line">  9:         71          0     GIC-0  45 Level     mmc0</span><br><span class="line"> 10:       1130          0     GIC-0  46 Level     mmc1</span><br><span class="line"></span><br><span class="line">IPI0:      3834      12053       Rescheduling interrupts</span><br><span class="line">IPI1:         4          4       Function call interrupts</span><br><span class="line">IPI2:         0          0       CPU stop interrupts</span><br><span class="line">IPI3:         0          0       CPU stop (for crash dump) interrupts</span><br><span class="line">IPI4:         0          0       Timer broadcast interrupts</span><br><span class="line">IPI5:         0          0       IRQ work interrupts</span><br><span class="line">IPI6:         0          0       CPU wake-up interrupts</span><br><span class="line">Err:          0</span><br><span class="line">#</span><br></pre></td></tr></table></figure>

<p>GIC-V2中SPI中断不支持多核迁移，GIC-V3中SPI中断支持多核迁移</p>
<h2 id="GIC设备树"><a href="#GIC设备树" class="headerlink" title="GIC设备树"></a>GIC设备树</h2><blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9lbGl4aXIuYm9vdGxpbi5jb20vbGludXgvdjUuNC4xMTAvc291cmNlL0RvY3VtZW50YXRpb24vZGV2aWNldHJlZS9iaW5kaW5ncy9pbnRlcnJ1cHQtY29udHJvbGxlci9hcm0sZ2ljLnlhbWw=">Documentation&#x2F;devicetree&#x2F;bindings&#x2F;interrupt-controller&#x2F;arm,gic.yaml<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;#interrupt-cells&quot;:</span><br><span class="line">  const: 3</span><br><span class="line">  description: |</span><br><span class="line">    The 1st cell is the interrupt type; 0 for SPI interrupts, 1 for PPI</span><br><span class="line">    interrupts.</span><br><span class="line"></span><br><span class="line">    The 2nd cell contains the interrupt number for the interrupt type.</span><br><span class="line">    SPI interrupts are in the range [0-987].  PPI interrupts are in the</span><br><span class="line">    range [0-15].</span><br><span class="line"></span><br><span class="line">    The 3rd cell is the flags, encoded as follows:</span><br><span class="line">      bits[3:0] trigger type and level flags.</span><br><span class="line">        1 = low-to-high edge triggered</span><br><span class="line">        2 = high-to-low edge triggered (invalid for SPIs)</span><br><span class="line">        4 = active high level-sensitive</span><br><span class="line">        8 = active low level-sensitive (invalid for SPIs).</span><br><span class="line">      bits[15:8] PPI interrupt cpu mask.  Each bit corresponds to each of</span><br><span class="line">      the 8 possible cpus attached to the GIC.  A bit set to &#x27;1&#x27; indicated</span><br><span class="line">      the interrupt is wired to that CPU.  Only valid for PPI interrupts.</span><br><span class="line">      Also note that the configurability of PPI interrupts is IMPLEMENTATION</span><br><span class="line">      DEFINED and as such not guaranteed to be present (most SoC available</span><br><span class="line">      in 2014 seem to ignore the setting of this flag and use the hardware</span><br><span class="line">      default value).</span><br></pre></td></tr></table></figure>

<p>第二个单元格包含中断号,在配置SPI中断号时，由于硬件中断号的前32个中断号被PPI中断使用，因此在设备树中配置时应该是硬件中断号减去32。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li>DEN0024A_v8_architecture_PG.pdf</li>
</ul>
]]></content>
      <categories>
        <category>ARM</category>
      </categories>
      <tags>
        <tag>arm64</tag>
        <tag>异常处理</tag>
      </tags>
  </entry>
  <entry>
    <title>armv8缓存——cache</title>
    <url>/post/223c631e.html</url>
    <content><![CDATA[<p>缓存是位于核心和主内存之间的小而快速的内存块。 它在主内存中保存项目的副本。 对高速缓冲存储器的访问比对主存储器的访问快得多。 每当内核读取或写入特定地址时，它首先会在缓存中查找。 如果它在高速缓存中找到地址，它就使用高速缓存中的数据，而不是执行对主存储器的访问。 通过减少缓慢的外部存储器访问时间的影响，这显着提高了系统的潜在性能。 通过避免驱动外部信号的需要，它还降低了系统的功耗。</p>
<p><img data-src="/images/2021/12/armv8_cache.png" alt="armv8 cache"></p>
<p>实现ARMv8-A架构的处理器通常使用<code>两级</code>或更多级缓存来实现。 这通常意味着处理器的每个内核都有小的L1<code>指令</code>和<code>数据</code>缓存。 Cortex-A53和Cortex-A57处理器通常采用两级或更多级缓存来实现，即小的L1指令和数据缓存和更大的、统一的L2缓存，在集群中的多个内核之间共享。 此外，可以有一个外部L3缓存作为外部硬件块，在集群之间共享。</p>
<span id="more"></span>

<p><img data-src="/images/2021/12/cache_transfer.png" alt="cache transfer"></p>
<ul>
<li>Data is transferred in the form of words between the cache memory and the CPU.</li>
<li>Data is transferred in the form of blocks or pages between the cache memory and the main memory.</li>
</ul>
<h2 id="Cache-terminology"><a href="#Cache-terminology" class="headerlink" title="Cache terminology"></a>Cache terminology</h2><p><img data-src="/images/2021/12/armv8_cache_terminology.png" alt="armv8 cache terminology"></p>
<ul>
<li><p><code>tag</code>:<br>tag是存储在缓存中的内存地址的一部分，用于标识与数据行相关联的主内存地址。<br>64位地址的最高位告诉缓存信息来自主内存中的哪里，称为tag。 尽管用于保存标签值的RAM不包括在计算中，但总缓存大小是对其可以保存的数据量的度量。 但是，该标签会占用缓存中的物理空间。</p>
</li>
<li><p><code>line</code>:<br>为每个标签地址保存一个数据字是低效的，因此通常将多个位置组合在同一标签下。 这个逻辑块通常被称为cacheline，是指缓存的最小可加载单元，来自主内存的连续字块。 缓存行在包含缓存数据或指令时被称为有效，如果不包含则称为无效。<br>与每一行数据相关联的是一个或多个状态位。 通常，您有一个有效位将行标记为包含可以使用的数据。 这意味着地址标签代表了一些实际值。 在数据缓存中，您可能还有一个或多个脏位，用于标记缓存行（或其一部分）是否保存与主内存内容不同（更新）的数据。</p>
</li>
<li><p><code>index</code>:<br>index是内存地址的一部分，它确定可以在缓存的哪些行中找到该地址。<br>地址或索引的中间位标识该行。 索引用作高速缓存RAM的地址，不需要作为标记的一部分进行存储。 本章稍后将对此进行更详细的介绍。</p>
</li>
<li><p><code>way</code>:<br>way是高速缓存的细分，每路具有相同的大小并以相同的方式编入索引。 一组由共享特定索引的所有方式的缓存行组成。</p>
</li>
<li><p><code>set</code>:</p>
</li>
</ul>
<h3 id="linux下cache相关数据"><a href="#linux下cache相关数据" class="headerlink" title="linux下cache相关数据"></a>linux下cache相关数据</h3><ul>
<li>一级cache大小<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat /sys/devices/system/cpu/cpu0/cache/index0/size</span><br><span class="line">32K</span><br></pre></td></tr></table></figure></li>
<li>一级cache中set个数<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat /sys/devices/system/cpu/cpu0/cache/index0/number_of_sets</span><br><span class="line">64</span><br></pre></td></tr></table></figure></li>
<li>一级cache中set的cacheline个数<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat /sys/devices/system/cpu/cpu0/cache/index0/ways_of_associativity</span><br><span class="line">8</span><br></pre></td></tr></table></figure></li>
<li>一级cache中cacheline大小<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat /sys/devices/system/cpu/cpu0/cache/index0/coherency_line_size</span><br><span class="line">64</span><br></pre></td></tr></table></figure>
<blockquote>
<p>cache的大小是：64×8×64&#x2F;1024&#x3D;32KB</p>
</blockquote>
</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li>DEN0024A_v8_architecture_PG.pdf</li>
<li><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8zNzc0OTQ0Mw==">计算机缓存Cache以及Cache Line详解<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>ARM</category>
      </categories>
      <tags>
        <tag>arm64</tag>
        <tag>cache</tag>
      </tags>
  </entry>
  <entry>
    <title>anbox_build_for_android</title>
    <url>/post/22129.html</url>
    <content><![CDATA[<p>Anbox 是 “Android in a box” 的缩写。Anbox 是一个基于<code>容器</code>的方法，可以在普通的GNU&#x2F;Linux系统上启动完整的Android系统。</p>
<blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FuYm94L2FuYm94L2Jsb2IvbWFzdGVyL2RvY3MvYnVpbGQtYW5kcm9pZC5tZA==">https://github.com/anbox/anbox/blob/master/docs/build-android.md<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<span id="more"></span>

<h2 id="Anbox"><a href="#Anbox" class="headerlink" title="Anbox"></a>Anbox</h2><h3 id="Error"><a href="#Error" class="headerlink" title="Error"></a>Error</h3><p>ubuntu18.04 for ARM64</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">error: ISO C forbids conversion of object pointer to function pointer type [-Werror=pedantic]</span><br><span class="line">   func = (getauxval_func_t*)dlsym(libc_handle, &quot;getauxval&quot;);</span><br><span class="line">             ^</span><br><span class="line">cc1: all warnings being treated as errors</span><br></pre></td></tr></table></figure>

<blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMzE1MjY4NzYvY2FzdGluZy13aGVuLXVzaW5nLWRsc3lt">https://stackoverflow.com/questions/31526876/casting-when-using-dlsym<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-set(C_AND_CXX_WARNINGS &quot;-pedantic -Wall -Wextra&quot;)</span><br><span class="line">+set(C_AND_CXX_WARNINGS &quot;-Wextra&quot;)</span><br></pre></td></tr></table></figure>
<p>删除掉<code>-Wall</code>和<code>-pedantic</code>这两个编译选项，可以正常编译</p>
<ul>
<li><code>-Wall</code>：</li>
<li><code>-pedantic</code>:</li>
</ul>
<h2 id="anbox-modules-binder-ashmem"><a href="#anbox-modules-binder-ashmem" class="headerlink" title="anbox-modules: binder ashmem"></a>anbox-modules: binder ashmem</h2><h3 id="编译binder"><a href="#编译binder" class="headerlink" title="编译binder"></a>编译binder</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@server:# dkms install kernel/binder</span><br><span class="line">Error! DKMS tree already contains: anbox-binder-1</span><br><span class="line">You cannot add the same module/version combo more than once.</span><br><span class="line">root@server:# dkms remove anbox-binder/1 --all</span><br><span class="line"></span><br><span class="line">------------------------------</span><br><span class="line">Deleting module version: 1</span><br><span class="line">completely from the DKMS tree.</span><br><span class="line">------------------------------</span><br><span class="line">Done.</span><br></pre></td></tr></table></figure>


<h2 id="Android-for-anbox"><a href="#Android-for-anbox" class="headerlink" title="Android-for-anbox"></a>Android-for-anbox</h2><h3 id="Download"><a href="#Download" class="headerlink" title="Download"></a>Download</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl https://mirrors.tuna.tsinghua.edu.cn/git/git-repo -o repo</span><br><span class="line">chmod +x repo</span><br><span class="line">export REPO_URL=&#x27;https://mirrors.tuna.tsinghua.edu.cn/git/git-repo/&#x27;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">repo init -u https://github.com/anbox/platform_manifests.git -b anbox --depth=1</span><br><span class="line">repo sync -j4</span><br><span class="line">while [ $? -ne 0 ]</span><br><span class="line">do</span><br><span class="line">    repo sync -j4</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<blockquote>
<p>全部代码下载完成后总大小：144G， .repo的大小：125G</p>
</blockquote>
<p>在进行repo sync之前使用清华的源替代谷歌源：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;remote  name=&quot;aosp&quot;</span><br><span class="line">         revision=&quot;refs/tags/android-7.1.1_r13&quot;</span><br><span class="line">-           fetch=&quot;https://android.googlesource.com/&quot; /&gt;</span><br><span class="line">+           fetch=&quot;https://aosp.tuna.tsinghua.edu.cn/&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;default revision=&quot;refs/tags/android-7.1.1_r13&quot;</span><br><span class="line">         remote=&quot;aosp&quot;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>From: .repo&#x2F;manifests&#x2F;default.xml</p>
</blockquote>
<h3 id="Build"><a href="#Build" class="headerlink" title="Build"></a>Build</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt install openjdk-8-jdk</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export LC_ALL=C</span><br><span class="line">source build/envsetup.sh</span><br><span class="line">lunch anbox_x86_64-userdebug</span><br><span class="line">make -j3</span><br></pre></td></tr></table></figure>


<h3 id="Error-1"><a href="#Error-1" class="headerlink" title="Error"></a>Error</h3><h4 id="aidl-language-l"><a href="#aidl-language-l" class="headerlink" title="aidl_language_l"></a>aidl_language_l</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ninja: Entering directory `.&#x27;</span><br><span class="line">[  0% 33/48163] Lex: aidl &lt;= system/tools/aidl/aidl_language_l.ll</span><br><span class="line">FAILED: /bin/bash -c &quot;prebuilts/misc/linux-x86/flex/flex-2.5.39 -oout/host/linux-x86/obj/STATIC_LIBRARIES/libaidl-common_intermediates/aidl_language_l.cpp system/tools/aidl/aidl_language_l.ll&quot;</span><br><span class="line">flex-2.5.39: loadlocale.c:130:_nl_intern_locale_data: ?? &#x27;cnt &lt; (sizeof (_nl_value_type_LC_TIME) / sizeof (_nl_value_type_LC_TIME[0]))&#x27; ???</span><br><span class="line">Aborted (core dumped)</span><br><span class="line">[  0% 33/48163] JarJar: out/target/common/obj/JAVA_LIBRARIES/bouncycastle_intermediates/classes-jarjar.jar</span><br><span class="line">ninja: build stopped: subcommand failed.</span><br><span class="line">build/core/ninja.mk:148: recipe for target &#x27;ninja_wrapper&#x27; failed</span><br><span class="line">make: *** [ninja_wrapper] Error 1</span><br></pre></td></tr></table></figure>

<p>解决方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export LC_ALL=C</span><br></pre></td></tr></table></figure>


<h4 id="VM"><a href="#VM" class="headerlink" title="VM"></a>VM</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[ 30% 14248/46548] Building with Jack: out/target/common/obj/JAVA_LIBRARIES/framework_intermediates/with-local/classes.dex</span><br><span class="line">FAILED: /bin/bash out/target/common/obj/JAVA_LIBRARIES/framework_intermediates/with-local/classes.dex.rsp</span><br><span class="line">Out of memory error (version 1.2-rc4 &#x27;Carnac&#x27; (298900 f95d7bdecfceb327f9d201a1348397ed8a843843 by android-jack-team@google.com)).</span><br><span class="line">GC overhead limit exceeded.</span><br><span class="line">Try increasing heap size with java option &#x27;-Xmx&lt;size&gt;&#x27;.</span><br><span class="line">Warning: This may have produced partial or corrupted output.</span><br><span class="line">[ 30% 14248/46548] host C++: libartd &lt;= art/runtime/native/java_lang_ref_FinalizerReference.cc</span><br><span class="line">ninja: build stopped: subcommand failed.</span><br><span class="line">build/core/ninja.mk:148: recipe for target &#x27;ninja_wrapper&#x27; failed</span><br><span class="line">make: *** [ninja_wrapper] Error 1&gt;</span><br></pre></td></tr></table></figure>

<p>错误日志里边列出了问题并且已经给出了解决方案 - 增加Java虚拟机的<code>-Xmx&lt;size&gt;</code>，即设置一个较大的堆内存上限</p>
<ul>
<li>修改Jack的配置文件<code>prebuilts/sdk/tools/jack-admin</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JACK_SERVER_COMMAND=&quot;java -XX:MaxJavaStackTraceDepth=-1 -Djava.io.tmpdir=$TMPDIR $JACK_SERVER_VM_ARGUMENTS -cp $LAUNCHER_JAR $LAUNCHER_NAME&quot;</span><br></pre></td></tr></table></figure>
<p>修改内存：<code>-Xmx4096m</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JACK_SERVER_COMMAND=&quot;java -XX:MaxJavaStackTraceDepth=-1 -Djava.io.tmpdir=$TMPDIR $JACK_SERVER_VM_ARGUMENTS -Xmx4096m -cp $LAUNCHER_JAR $LAUNCHER_NAME&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li>重启jack-admin服务</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./prebuilts/sdk/tools/jack-admin stop-server</span><br><span class="line">./prebuilts/sdk/tools/jack-admin start-server</span><br></pre></td></tr></table></figure>

<h2 id="anbox-images"><a href="#anbox-images" class="headerlink" title="anbox-images"></a>anbox-images</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ cd $HOME/anbox-work/anbox</span><br><span class="line">$ scripts/create-package.sh \</span><br><span class="line">    $PWD/../out/target/product/x86_64/ramdisk.img \</span><br><span class="line">    $PWD/../out/target/product/x86_64/system.img</span><br></pre></td></tr></table></figure>

<h2 id="anbox-modules"><a href="#anbox-modules" class="headerlink" title="anbox-modules"></a>anbox-modules</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/anbox/anbox-modules.git</span><br></pre></td></tr></table></figure>

<p>在anbox-modules安装完成后，需要对系统进行reboot，否则无法生成<code>/dev/binder</code>节点</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo modprobe binder_linux num_devices=9</span><br></pre></td></tr></table></figure>
<blockquote>
<p>多容器编译生成binder节点，<code>/dev/binder[0-9]</code></p>
</blockquote>
<h2 id="Boot"><a href="#Boot" class="headerlink" title="Boot"></a>Boot</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=Anbox Container Manager</span><br><span class="line">After=network.target</span><br><span class="line">Wants=network.target</span><br><span class="line">ConditionPathExists=/home/xxx/work1/android-for-anbox/anbox/android.img</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">ExecStartPre=/sbin/modprobe ashmem_linux</span><br><span class="line">ExecStartPre=/sbin/modprobe binder_linux</span><br><span class="line">ExecStart=/usr/local/bin/anbox container-manager --daemon --privileged --data-path=/home/xxx/work1/android-for-anbox/anbox-data/ --android-image=/home/xxx/work1/android-for-anbox/anbox/android.img --use-rootfs-overlay</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>服务配置文件： <code>/lib/systemd/system/anbox-container-manager.service</code>或<code>/etc/systemd/system/anbox-container-manager.service</code></li>
<li><code>anbox-data</code>为空目录，具体内容容器启动后生成。</li>
</ul>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo systemctl start anbox-container-manager</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">anbox launch --package=org.anbox.appmgr --component=org.anbox.appmgr.AppViewActivity</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl | grep &quot;anbox&quot;</span><br><span class="line"></span><br><span class="line">anbox system-info</span><br></pre></td></tr></table></figure>

<h3 id="设置anbox服务自动运行"><a href="#设置anbox服务自动运行" class="headerlink" title="设置anbox服务自动运行"></a>设置anbox服务自动运行</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo systemctl enable anbox-container-manager.service</span><br></pre></td></tr></table></figure>


<h2 id="手动启动"><a href="#手动启动" class="headerlink" title="手动启动"></a>手动启动</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo anbox container-manager --privileged --data-path=/home/xxx/work1/android-for-anbox/anbox-data/ --android-image=/home/xxx/work1/android-for-anbox/anbox/android.img</span><br></pre></td></tr></table></figure>

<h2 id="Net"><a href="#Net" class="headerlink" title="Net"></a>Net</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nmcli con add type bridge ifname anbox0 -- connection.id anbox-net ipv4.method shared ipv4.addresses 192.168.250.1/24</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpYW5ndGlhbm1lbmcvYXJ0aWNsZS9kZXRhaWxzLzg5NTIyMDky">解决Out of memory error (version 1.2-rc4 ‘Carnac’ (298900 … by android-jack-team@google.com)).<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9tYWdhemluZS5vZHJvaWQuY29tL2FydGljbGUvbGludXgtZ2FtaW5nLWFuYm94LWFuZHJvaWQtaW4tYS1ib3gv">Linux Gaming: Anbox - Android In A Box<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9iYnMuZGVlcGluLm9yZy9mb3J1bS5waHA/bW9kPXZpZXd0aHJlYWQmdGlkPTE3NjgyMA==">安卓运行环境Anbox安装&#x2F;编译说明（20190426)<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC83N2U1MWM2NDc1ZmM=">运行 Anbox<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9wb3J0YWwtd3d3LXNvZnR3YXJlLm9icy5jbi1ub3J0aC0xLm15aHVhd2VpY2xvdWQuY29tLyVFOCVCRCVBRiVFNCVCQiVCNi8lRTUlOUYlQkElRTQlQkElOEUlRTklQjIlQjIlRTklQjklOEY5MTYlRTclOUElODRyb2JveCVFNSVBRSU4OSVFNSU4RCU5MyVFNSVBRSVCOSVFNSU5OSVBOCVFNyU4RSVBRiVFNSVBMiU4MyVFNiU5RSU4NCVFNSVCQiVCQSVFNiU4QyU4NyVFNSVBRiVCQyVFNCVCOSVBNi5kb2N4">robox安卓容器环境搭建指导书<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>anbox</tag>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android ANR分析</title>
    <url>/post/35493.html</url>
    <content><![CDATA[<blockquote>
<p>ANR是<code>Application Not Response</code>的简写就是应用没有响应。Android应用主线程卡住的时候系统会提示用户是否需要结束掉此App，这是Android系统优化用户体验的一种做法，类似的Windows系统也有类似“程序没有响应”的提示。就是<strong>主线程无法及时响应用户输入</strong></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">E/ActivityManager(  373): ANR in com.android.settings (com.android.settings/.Settings)</span><br><span class="line">E/ActivityManager(  373): PID: 803</span><br><span class="line">E/ActivityManager(  373): Reason: Input dispatching timed out (Waiting because no window has focus but there is a focused application that may eventually add a window when it finishes starting up.)</span><br></pre></td></tr></table></figure>

<span id="more"></span>


<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><ol>
<li>主线程被阻塞</li>
<li>主线程有耗时操作,比如IO</li>
<li>主线程异常操作比如Thread.sleep,Thread.wait</li>
<li>(Activity)应用在5秒内没有响应用户输入（例如键盘输入, 触摸屏幕等）</li>
<li>BroadcastReceiver10秒钟没有响应</li>
<li>获取不到CPU时间片（CPU太满了）</li>
</ol>
<h3 id="CPU占有率100"><a href="#CPU占有率100" class="headerlink" title="CPU占有率100%"></a>CPU占有率100%</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">E/ActivityManager(  373): ANR in com.android.settings (com.android.settings/.Settings)</span><br><span class="line">E/ActivityManager(  373): PID: 803</span><br><span class="line">E/ActivityManager(  373): Reason: Input dispatching timed out (Waiting because no window has focus but there is a focused application that may eventually add a window when it finishes starting up.)</span><br><span class="line">	Load: 1.43 / 2.3 / 1.84</span><br><span class="line">	//表示ANR发生之前的一段时间内的CPU使用率，并不是某一时刻的值</span><br><span class="line">	CPU usage from 810ms to -13732ms ago:</span><br><span class="line">	63% 803/com.android.settings: 17% user + 45% kernel / faults: 3557 minor 225 major</span><br><span class="line">	55% 373/system_server: 22% user + 33% kernel / faults: 3423 minor</span><br><span class="line">	...</span><br><span class="line">	1% 569/android.process.acore: 0% user + 1% kernel / faults: 1 minor</span><br><span class="line">	1% 777/Binder_4: 0% user + 1% kernel</span><br><span class="line">100% TOTAL: 39% user + 60% kernel</span><br></pre></td></tr></table></figure>

<h2 id="traces-memory"><a href="#traces-memory" class="headerlink" title="traces memory"></a>traces memory</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Heap: 15% free, 1338KB/`1585KB`; 51388 objects</span><br></pre></td></tr></table></figure>
<blockquote>
<p>虚拟机堆会动态扩展，<code>1585KB</code>代表堆扩展到的大小，1338KB代表堆上使用的大小，15%是使用的百分比, 51388创建的对象数量</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. //Total number of allocations 170340</span><br><span class="line">2. //Total bytes allocated 13MB</span><br><span class="line">3. //Free memory 247KB</span><br><span class="line">4. //Free memory until GC 247KB</span><br><span class="line">5. //Free memory until OOME 62MB</span><br><span class="line">6. //Total memory `1585KB`</span><br><span class="line">7. //Max memory 64MB</span><br></pre></td></tr></table></figure>
<blockquote>
<ol>
<li>进程创建到现在一共创建的对象数</li>
<li>进程创建到现在一共申请的内存</li>
<li>不扩展堆的情况下可用的内存</li>
<li>可回收的大小</li>
<li>还能扩展多少内存达到Max memory</li>
<li><code>堆扩展</code>后的大小</li>
<li>进程最多能申请的内存</li>
</ol>
</blockquote>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><span class="exturl" data-url="aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdGFiYWN0aXZpdHkvYXJ0aWNsZS9kZXRhaWxzLzUyOTQ1MzQz">ANR机制以及问题分析<i class="fa fa-external-link-alt"></i></span></li>
</ol>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android and Linux</title>
    <url>/post/38002.html</url>
    <content><![CDATA[<p>Android相关笔记</p>
<span id="more"></span>

<h2 id="Linux-kernel"><a href="#Linux-kernel" class="headerlink" title="Linux kernel"></a>Linux kernel</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">git <span class="built_in">clone</span> https://android.googlesource.com/kernel/goldfish.git</span></span><br></pre></td></tr></table></figure>

<p>更改<span class="exturl" data-url="aHR0cHM6Ly9taXJyb3JzLnR1bmEudHNpbmdodWEuZWR1LmNuL2hlbHAvQU9TUC8=">清华源<i class="fa fa-external-link-alt"></i></span>下载：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">git <span class="built_in">clone</span> https://aosp.tuna.tsinghua.edu.cn/kernel/goldfish.git</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android ART编译预优化</title>
    <url>/post/40126.html</url>
    <content><![CDATA[<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Enable dex-preoptimization to speed up the first boot sequence</span><br><span class="line"># of an SDK AVD. Note that this operation only works on Linux for now</span><br><span class="line">ifeq ($(HOST_OS),linux)</span><br><span class="line">	ifeq ($(WITH_DEXPREOPT),)</span><br><span class="line">		WITH_DEXPREOPT := true</span><br><span class="line">	endif</span><br><span class="line">endif</span><br></pre></td></tr></table></figure>
<blockquote>
<p>device&#x2F;xxx&#x2F;xxx&#x2F;BoardConfig.mk</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">WITH_DEXPREOPT</th>
<th align="center"></th>
</tr>
</thead>
<tbody><tr>
<td align="center">true</td>
<td align="center">system image 就会被预先优化. 由于在启动时不再需要进行app的dex文件进行优化(dex2oat操作)从而提升其启动速度.</td>
</tr>
<tr>
<td align="center">false</td>
<td align="center">禁止预编译优化，在系统启动时编译</td>
</tr>
</tbody></table>
<span id="more"></span>


<h2 id="ART"><a href="#ART" class="headerlink" title="ART"></a>ART</h2><p>ART兼容Dalvik.也就是说ART 能运行”dex”(Dalvik执行文件).因此对Androidapp的开发者来说,他们没有什么区别.两者最大的区别是:ART把JIT(Just-in-Time)变成了AOT(Ahead-of-Time).JIT需要在每次运行app时都需要执行一遍,而AOT 只需要执行一次,而后续再运行此app是不需要再执行,其明显提高了性能.当然ART 这样做,也是有代价的,那就是以空间换时间.ART能对应用的所有code做优化,其把bitcode 编译为ELF文件.而ELF文件也往往比odex文件大很多.而JIT<br>只能对local&#x2F;method做优化.ART的另一个缺点是其第一次执行优化时需要更长的时间.这也是导致第一次开机时间过长的原因</p>
<h2 id="dex2oat"><a href="#dex2oat" class="headerlink" title="dex2oat"></a>dex2oat</h2><p><code>dex2oat</code>顾名思义dex file to oat file，就是在新旧两种运行时文件的转换。</p>
<blockquote>
<p><code>dex</code>文件字节码，（多个class每个文件都有的共有信息合成一体）<br><code>oat</code>文件格式:ELF</p>
</blockquote>
<h2 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h2><ol>
<li>优化开机速度，减少启动时间(不是第一次)</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><span class="exturl" data-url="aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDE2NDE5MC9hcnRpY2xlL2RldGFpbHMvNTE0NjM0OTI=">Android 开机速度优化—–ART 预先优化<i class="fa fa-external-link-alt"></i></span></li>
</ol>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android Systrace</title>
    <url>/post/7f0df936.html</url>
    <content><![CDATA[<p>Android性能分析工具</p>
<span id="more"></span>

<h2 id="下载android-sdk-platform-tools"><a href="#下载android-sdk-platform-tools" class="headerlink" title="下载android-sdk-platform-tools"></a>下载android-sdk-platform-tools</h2><blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5nb29nbGUuY24vc3R1ZGlvL3JlbGVhc2VzL3BsYXRmb3JtLXRvb2xzP2hsPXpoLWNu">https://developer.android.google.cn/studio/releases/platform-tools?hl=zh-cn<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<p>解压后直接使用</p>
<h2 id="获取systrace日志并转换为html"><a href="#获取systrace日志并转换为html" class="headerlink" title="获取systrace日志并转换为html"></a>获取systrace日志并转换为html</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">ip=&quot;127.0.0.1&quot;</span><br><span class="line">port=&quot;5555&quot;</span><br><span class="line"></span><br><span class="line">TRACE_BUFFER_SZ_KB=16384 #16MB</span><br><span class="line">TRACE_FILE=&quot;/data/local/tmp/trace_$port.log&quot;</span><br><span class="line"></span><br><span class="line">adb disconnect</span><br><span class="line">adb connect $ip:$port</span><br><span class="line">adb root</span><br><span class="line"></span><br><span class="line">sleep 1</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">adb shell atrace --list_categories</span></span><br><span class="line">tracedump=$(echo `adb shell atrace --list_categories | awk &#x27;&#123;print $1&#125;&#x27;` | sed &#x27;s/\n//g&#x27;)</span><br><span class="line"></span><br><span class="line">adb shell &quot;atrace -b $TRACE_BUFFER_SZ_KB -t 30 -z $tracedump &gt; $TRACE_FILE&quot;</span><br><span class="line">adb pull $TRACE_FILE</span><br><span class="line"></span><br><span class="line">python platform-tools/systrace/systrace.py  -b $TRACE_BUFFER_SZ_KB --from-file trace_$port.log -o trace_$port.html</span><br></pre></td></tr></table></figure>

<h2 id="查看trace文件的快捷键"><a href="#查看trace文件的快捷键" class="headerlink" title="查看trace文件的快捷键"></a>查看trace文件的快捷键</h2><table>
<thead>
<tr>
<th align="center">快捷键</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">w</td>
<td align="center">放大</td>
</tr>
<tr>
<td align="center">s</td>
<td align="center">缩小</td>
</tr>
<tr>
<td align="center">a</td>
<td align="center">左移</td>
</tr>
<tr>
<td align="center">e</td>
<td align="center">右移</td>
</tr>
</tbody></table>
<h2 id="使用Systrace-检测卡顿丢帧问题"><a href="#使用Systrace-检测卡顿丢帧问题" class="headerlink" title="使用Systrace 检测卡顿丢帧问题"></a>使用Systrace 检测卡顿丢帧问题</h2><ul>
<li>Systrace报告列出了每个进程呈现UI frame，并显示沿着时间线的每个渲染帧。 在<code>绿色框</code>架圆圈中，是指在16.6ms内呈现每秒稳定60帧， 花费16.6ms以上渲染的帧用<code>黄色或红色圆</code>圈表示。</li>
</ul>
<h2 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h2><h3 id="ImportError-No-module-named-six"><a href="#ImportError-No-module-named-six" class="headerlink" title="ImportError: No module named six"></a>ImportError: No module named six</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install python-six</span><br></pre></td></tr></table></figure>

<h3 id="权限问题"><a href="#权限问题" class="headerlink" title="权限问题"></a>权限问题</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">error opening /sys/kernel/debug/tracing/options/overwrite: Permission denied (13)</span><br><span class="line">error opening /sys/kernel/debug/tracing/buffer_size_kb: Permission denied (13)</span><br><span class="line">error opening /sys/kernel/debug/tracing/trace_clock: Permission denied (13)</span><br><span class="line">error opening /sys/kernel/debug/tracing/tracing_on: Permission denied (13)</span><br><span class="line">error opening /sys/kernel/debug/tracing/tracing_on: Permission denied (13)</span><br><span class="line">unable to start tracing</span><br><span class="line">error opening /sys/kernel/debug/tracing/options/overwrite: Permission denied (13)</span><br><span class="line">error opening /sys/kernel/debug/tracing/buffer_size_kb: Permission denied (13)</span><br></pre></td></tr></table></figure>

<p>通过<code>adb root</code>获取权限</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC83NWFhODhkMWI1NzU=">Android Systrace 使用详解<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>systrace</tag>
      </tags>
  </entry>
  <entry>
    <title>Android模拟器</title>
    <url>/post/40058.html</url>
    <content><![CDATA[<p>Android模拟器开发和调试应用肯定比使用真机方便</p>
<span id="more"></span>

<h2 id="模拟器源码下载"><a href="#模拟器源码下载" class="headerlink" title="模拟器源码下载"></a>模拟器源码下载</h2><p>Android 模拟器源码的下载与 Android AOSP 源码库的下载过程类似。</p>
<p>模拟器的分支：在 <span class="exturl" data-url="aHR0cHM6Ly9hbmRyb2lkLmdvb2dsZXNvdXJjZS5jb20vcGxhdGZvcm0vbWFuaWZlc3QvK3JlZnM=">https://android.googlesource.com/platform/manifest/+refs<i class="fa fa-external-link-alt"></i></span> 可以看到所有可以指定的分支，包括 Android 分支和模拟器分支，其中模拟器分支主要有如下这些：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">emu-1.4-release</span><br><span class="line">emu-1.5-release</span><br><span class="line">emu-2.0-release</span><br><span class="line">emu-2.2-release</span><br><span class="line">emu-2.3-release</span><br><span class="line">emu-2.4-arc</span><br><span class="line">emu-2.4-release</span><br><span class="line">emu-2.5-release</span><br><span class="line">emu-2.6-release</span><br><span class="line">emu-2.7-release</span><br><span class="line">emu-2.8-release</span><br><span class="line">emu-29.0-release</span><br><span class="line">emu-3.0-release</span><br><span class="line">emu-3.1-release</span><br><span class="line">emu-gn-dev</span><br><span class="line">emu-master-dev</span><br><span class="line">emu-master-qemu</span><br><span class="line">emu-master-qemu-release</span><br></pre></td></tr></table></figure>

<p>下载最新模拟器代码：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">repo init -u https://android.googlesource.com/platform/manifest -b emu-master-dev</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>在国内可以使用清华源更快下载:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">repo init -u https://aosp.tuna.tsinghua.edu.cn/platform/manifest -b emu-master-dev</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd external/qemu/android/</span><br><span class="line">./rebuild.sh --no-tests</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li><code>--no-tests</code>: 告诉编译系统，编译完成之后不要执行测试程序，以节省时间，提高效率</li>
</ul>
</blockquote>
<h2 id="Android-Hardware-OpenGLES-emulation-design-overview"><a href="#Android-Hardware-OpenGLES-emulation-design-overview" class="headerlink" title="Android Hardware OpenGLES emulation design overview"></a>Android Hardware OpenGLES emulation design overview</h2><blockquote>
<p>path: <code>external/qemu/android/android-emugl/DESIGN</code></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_________            __________          __________</span><br><span class="line">|         |          |          |        |          |</span><br><span class="line">|EMULATION|          |EMULATION |        |EMULATION |     GUEST</span><br><span class="line">|   EGL   |          | GLES 1.1 |        | GLES 2.0 |     SYSTEM</span><br><span class="line">|_________|          |__________|        |__________|     LIBRARIES</span><br><span class="line">    ^                    ^                    ^</span><br><span class="line">    |                    |                    |</span><br><span class="line">- - | - - - - - - - - -  | - - - - - - - - -  | - - - - -</span><br><span class="line">    |                    |                    |</span><br><span class="line">____v____________________v____________________v____      GUEST</span><br><span class="line">|                                                   |     KERNEL</span><br><span class="line">|                       QEMU PIPE                   |</span><br><span class="line">|___________________________________________________|</span><br><span class="line">                        ^</span><br><span class="line">                        |</span><br><span class="line"> - - - - - - - - - - - -|- - - - - - - - - - - - - - - -</span><br><span class="line">                        |</span><br><span class="line">                        |    PROTOCOL BYTE STREAM</span><br><span class="line">                   _____v_____</span><br><span class="line">                  |           |</span><br><span class="line">                  |  EMULATOR |</span><br><span class="line">                  |___________|</span><br><span class="line">                        ^</span><br><span class="line">                        |   UNMODIFIED PROTOCOL BYTE STREAM</span><br><span class="line">                   _____v_____</span><br><span class="line">                  |           |</span><br><span class="line">                  |  RENDERER |</span><br><span class="line">                  |___________|</span><br><span class="line">                      ^ ^  ^</span><br><span class="line">                      | |  |</span><br><span class="line">    +-----------------+ |  +-----------------+</span><br><span class="line">    |                   |                    |</span><br><span class="line">____v____            ___v______          ____v_____</span><br><span class="line">|         |          |          |        |          |</span><br><span class="line">|TRANSLATOR          |TRANSLATOR|        |TRANSLATOR|     HOST</span><br><span class="line">|   EGL   |          | GLES 1.1 |        | GLES 2.0 |     TRANSLATOR</span><br><span class="line">|_________|          |__________|        |__________|     LIBRARIES</span><br><span class="line">    ^                    ^                    ^</span><br><span class="line">    |                    |                    |</span><br><span class="line">- - | - - - - - - - - -  | - - - - - - - - -  | - - - - -</span><br><span class="line">    |                    |                    |</span><br><span class="line">____v____            ____v_____          _____v____      HOST</span><br><span class="line">|         |          |          |        |          |     SYSTEM</span><br><span class="line">|   GLX   |          |  GL 2.0  |        |  GL 2.0  |     LIBRARIES</span><br><span class="line">|_________|          |__________|        |__________|</span><br><span class="line"></span><br><span class="line">(NOTE: &#x27;GLX&#x27; is for Linux only, replace &#x27;AGL&#x27; on OS X, and &#x27;WGL&#x27; on Windows).</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android开发相关记录</title>
    <url>/post/2578.html</url>
    <content><![CDATA[<p>记录Android开发中遇到的一些方法和问题。</p>
<span id="more"></span>

<h2 id="remount-system分区可读可写"><a href="#remount-system分区可读可写" class="headerlink" title="remount system分区可读可写"></a>remount system分区可读可写</h2><ol>
<li><p>查看挂载点</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># cat /proc/mounts</span><br><span class="line">rootfs / rootfs ro,relatime 0 0</span><br><span class="line">tmpfs /dev tmpfs rw,nosuid,relatime,mode=755 0 0</span><br><span class="line">devpts /dev/pts devpts rw,relatime,mode=600,ptmxmode=000 0 0</span><br><span class="line">proc /proc proc rw,relatime 0 0</span><br><span class="line">sysfs /sys sysfs rw,relatime 0 0</span><br><span class="line">debugfs /sys/kernel/debug debugfs rw,relatime 0 0</span><br><span class="line">tmpfs /mnt/asec tmpfs rw,relatime,mode=755,gid=1000 0 0</span><br><span class="line">tmpfs /mnt/obb tmpfs rw,relatime,mode=755,gid=1000 0 0</span><br><span class="line">tmpfs /storage/external_storage tmpfs rw,relatime,mode=775,uid=1000,gid=1023 0 0</span><br><span class="line">adb /dev/usb-ffs/adb functionfs rw,relatime 0 0</span><br><span class="line">/dev/block/system /system ext4 ro,noatime,nodiratime,noauto_da_alloc,data=ordered 0 0</span><br><span class="line">/dev/block/data /data ext4 rw,nosuid,nodev,noatime,nodiratime,noauto_da_alloc,data=ordered 0 0</span><br><span class="line">/dev/block/cache /cache ext4 rw,nosuid,nodev,noatime,nodiratime,noauto_da_alloc,data=ordered 0 0</span><br><span class="line">/dev/fuse /mnt/shell/emulated fuse rw,nosuid,nodev,relatime,user_id=1023,group_id=1023,default_permissions,allow_other 0 0</span><br><span class="line">/dev/block/zram0 /swap_zram0 ext2 rw,relatime,errors=continue 0 0</span><br></pre></td></tr></table></figure>
</li>
<li><p>重新挂载system分区</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># mount -o remount -rw /dev/block/system</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>FFmpeg学习笔记——颜色编码</title>
    <url>/post/49519.html</url>
    <content><![CDATA[<p>颜色编码：<code>YUV</code>、<code>RGB</code></p>
<p><img data-src="/images/2018/09/bt601_uv_yuv.png" alt="BT601_UV_YUV "></p>
<blockquote>
<ul>
<li>BT601 UV 的坐标图（量化后）： （横坐标为u，纵坐标为v，左下角为原点）</li>
<li><code>U越大, 蓝色越蓝</code>; <code>V越大，红色越红</code></li>
</ul>
</blockquote>
<span id="more"></span>

<h2 id="YUV"><a href="#YUV" class="headerlink" title="YUV"></a>YUV</h2><p>YUV，分为三个分量，<code>“Y”</code>表示明亮度（Luminance或Luma），也就是灰度值（gray）；而<code>“U”</code>和<code>“V”</code> 表示的则是色度（Chrominance或Chroma），作用是描述影像色彩及饱和度，用于指定像素的颜色。</p>
<p><strong>作用：</strong> 主要用于电视系统以及模拟视频领域，它将亮度信息（Y）与色彩信息（UV）分离，没有UV信息一样可以显示完整的图像，只不过是黑白的，这样的设计很好地解决了彩色电视机与黑白电视的兼容问题。并且，YUV不像RGB那样要求三个独立的视频信号同时传输，所以<code>用YUV方式传送占用极少的频宽</code>。</p>
<h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><p>YUV Formats分成两个格式：</p>
<ul>
<li><code>紧缩格式（packed formats）</code>：将Y、U、V值储存成Macro Pixels阵列，和RGB的存放方式类似, 将YUV分量存放在同一个数组中，通常是几个相邻的像素组成一个<code>宏像素</code>（macro-pixel）。</li>
<li><code>平面格式（planar formats）</code>：将Y、U、V的三个分量分别存放在不同的矩阵中, 使用三个数组分开存放YUV三个分量，就像是一个三维平面一样。</li>
</ul>
<h3 id="采样方式"><a href="#采样方式" class="headerlink" title="采样方式"></a>采样方式</h3><p>主流的采样方式有三种，<code>YUV4:4:4</code>，<code>YUV4:2:2</code>，<code>YUV4:2:0</code></p>
<ul>
<li><code>YUV4:4:4</code>:表示完全取样。</li>
<li><code>YUV4:2:2</code>:表示2:1的水平取样，垂直完全采样。</li>
<li><code>YUV4:2:0</code>:表示2:1的水平取样，垂直2：1采样。</li>
</ul>
<p><img data-src="/images/2018/08/yuv_sample_way.png" alt="yuv_sample_way"></p>
<blockquote>
<ul>
<li><code>黑点</code>:表示采样该像素点的Y分量;</li>
<li><code>空心圆圈</code>:表示采用该像素点的UV分量。</li>
</ul>
</blockquote>
<ol>
<li><code>YUV 4:4:4</code>采样，每一个Y对应一组UV分量， 每个像素32bit。</li>
<li><code>YUV 4:2:2</code>采样，每两个Y共用一组UV分量， 每个像素16bit。</li>
<li><code>YUV 4:2:0</code>采样，每四个Y共用一组UV分量， 每个像素16bit。</li>
</ol>
<h3 id="存储方式"><a href="#存储方式" class="headerlink" title="存储方式"></a>存储方式</h3><p>下面我用图的形式给出常见的YUV码流的存储方式，并在存储方式后面附有取样每个像素点的YUV数据的方法，其中，Cb、Cr的含义等同于U、V。</p>
<h4 id="YUYV格式-（属于YUV422）"><a href="#YUYV格式-（属于YUV422）" class="headerlink" title="YUYV格式 （属于YUV422）"></a>YUYV格式 （属于YUV422）</h4><blockquote>
<p>YUV 4:2:2</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">start + 0:    Y&#x27;00    Cb00    Y&#x27;01    Cr00    Y&#x27;02    Cb01    Y&#x27;03    Cr01</span><br><span class="line">start + 8:    Y&#x27;10    Cb10    Y&#x27;11    Cr10    Y&#x27;12    Cb11    Y&#x27;13    Cr11</span><br><span class="line">start +16:    Y&#x27;20    Cb20    Y&#x27;21    Cr20    Y&#x27;22    Cb21    Y&#x27;23    Cr21</span><br><span class="line">start +24:    Y&#x27;30    Cb30    Y&#x27;31    Cr30    Y&#x27;32    Cb31    Y&#x27;33    Cr31</span><br></pre></td></tr></table></figure>

<p>YUYV为YUV422采样的存储格式中的一种，相邻的两个Y共用其相邻的两个Cb、Cr，分析，对于像素点Y’00、Y’01 而言，其Cb、Cr的值均为 Cb00、Cr00，其他的像素点的YUV取值依次类推。</p>
<h4 id="UYVY格式（属于YUV422）"><a href="#UYVY格式（属于YUV422）" class="headerlink" title="UYVY格式（属于YUV422）"></a>UYVY格式（属于YUV422）</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">start + 0:    Cb00    Y&#x27;00    Cr00    Y&#x27;01    Cb01    Y&#x27;02    Cr01    Y&#x27;03</span><br><span class="line">start + 8:    Cb10    Y&#x27;10    Cr10    Y&#x27;11    Cb11    Y&#x27;12    Cr11    Y&#x27;13</span><br><span class="line">start +16:    Cb20    Y&#x27;20    Cr20    Y&#x27;21    Cb21    Y&#x27;22    Cr21    Y&#x27;23</span><br><span class="line">start +24:    Cb30    Y&#x27;30    Cr30    Y&#x27;31    Cb31    Y&#x27;32    Cr31    Y&#x27;33</span><br></pre></td></tr></table></figure>

<p>每四字节代表两个像素，包含两个Y’，一个Cb和Cr。两个Y是两个像素的数据，而Cb和Cr对于两个像素来说都是一样的。如你所见，Cr和Cb部分只有相对于Y部分的一半竖向分辨率。</p>
<h4 id="YV12，YU12格式（属于YUV420）"><a href="#YV12，YU12格式（属于YUV420）" class="headerlink" title="YV12，YU12格式（属于YUV420）"></a>YV12，YU12格式（属于YUV420）</h4><blockquote>
<p>YUV4:2:0</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">start + 0:    Y&#x27;00    Y&#x27;01    Y&#x27;02    Y&#x27;03</span><br><span class="line">start + 4:    Y&#x27;10    Y&#x27;11    Y&#x27;12    Y&#x27;13</span><br><span class="line">start + 8:    Y&#x27;20    Y&#x27;21    Y&#x27;22    Y&#x27;23</span><br><span class="line">start +12:    Y&#x27;30    Y&#x27;31    Y&#x27;32    Y&#x27;33</span><br><span class="line">start +16:    Cr00    Cr01</span><br><span class="line">start +18:    Cr10    Cr11</span><br><span class="line">start +20:    Cb00    Cb01</span><br><span class="line">start +22:    Cb10    Cb11</span><br></pre></td></tr></table></figure>

<p>YU12和YV12属于YUV420格式，也是一种Plane模式，将Y、U、V分量分别打包，依次存储。其每一个像素点的YUV数据提取遵循YUV420格式的提取方式，即4个Y分量共用一组UV。注意，上图中，Y’00、Y’01、Y’10、Y’11共用Cr00、Cb00，其他依次类推。</p>
<h4 id="NV12、NV21格式（属于YUV420）"><a href="#NV12、NV21格式（属于YUV420）" class="headerlink" title="NV12、NV21格式（属于YUV420）"></a>NV12、NV21格式（属于YUV420）</h4><blockquote>
<p>YUV4:2:0</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">start + 0:    Y&#x27;00    Y&#x27;01    Y&#x27;02    Y&#x27;03</span><br><span class="line">start + 4:    Y&#x27;10    Y&#x27;11    Y&#x27;12    Y&#x27;13</span><br><span class="line">start + 8:    Y&#x27;20    Y&#x27;21    Y&#x27;22    Y&#x27;23</span><br><span class="line">start +12:    Y&#x27;30    Y&#x27;31    Y&#x27;32    Y&#x27;33</span><br><span class="line">start +16:    Cb00    Cr00    Cb01    Cr01</span><br><span class="line">start +20:    Cb10    Cr10    Cb11    Cr11</span><br></pre></td></tr></table></figure>
<p>NV12和NV21属于YUV420格式，是一种two-plane模式，即Y和UV分为两个Plane，但是UV（CbCr）为交错存储，而不是分为三个plane。其提取方式与上一种类似，即Y’00、Y’01、Y’10、Y’11共用Cr00、Cb00</p>
<h3 id="存储空间"><a href="#存储空间" class="headerlink" title="存储空间"></a>存储空间</h3><p>假设，图片大小：<code>w</code>，<code>h</code></p>
<blockquote>
<p>这里的<code>w</code>和<code>h</code>，代表的是<code>y</code>在整个编码中的个数</p>
</blockquote>
<h4 id="YUV420"><a href="#YUV420" class="headerlink" title="YUV420"></a>YUV420</h4><blockquote>
<ul>
<li>Y &#x3D; w * h</li>
<li>UV &#x3D; (w * h)&#x2F;2</li>
<li>所占内存：YUV &#x3D; Y + UV &#x3D; (w * h * 3) &#x2F; 2</li>
</ul>
</blockquote>
<h4 id="YUV422"><a href="#YUV422" class="headerlink" title="YUV422"></a>YUV422</h4><blockquote>
<ul>
<li>所占内存：YUV &#x3D; (w * h) * 2</li>
</ul>
</blockquote>
<h2 id="RGB"><a href="#RGB" class="headerlink" title="RGB"></a>RGB</h2><p><code>RGB：</code> 三原色光模式（RGB color model），又称RGB颜色模型或红绿蓝颜色模型，是一种<code>加色模型</code>，将<code>红（Red）</code>、<code>绿（Green）</code>、<code>蓝（Blue）</code>三原色的色光以不同的比例相加，以产生多种多样的色光。(且三原色的红绿蓝不可能用其他单色光合成)</p>
<p><img data-src="/images/2018/08/rgb.png" alt="rgb"></p>
<blockquote>
<p>三原色光的相加：<code>红光加绿光为黄光</code>，<code>黄光加蓝光为白光</code></p>
</blockquote>
<h3 id="RGB颜色查询对照表"><a href="#RGB颜色查询对照表" class="headerlink" title="RGB颜色查询对照表"></a>RGB颜色查询对照表</h3><ul>
<li><span class="exturl" data-url="aHR0cDovL3d3dy4xMTRsYS5jb20vb3RoZXIvcmdiLmh0bQ==">RGB颜色查询对照表<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<h3 id="格式-1"><a href="#格式-1" class="headerlink" title="格式"></a>格式</h3><ul>
<li><code>RGB565</code>: 每个像素用16位表示，RGB分量分别使用5位、6位、5位</li>
<li><code>RGB555</code>: 每个像素用16位表示，RGB分量都使用5位（剩下1位不用）</li>
<li><code>RGB24</code>: 每个像素用24位表示，RGB分量各使用8位</li>
<li><code>RGB32</code>: 每个像素用32位表示，RGB分量各使用8位（剩下8位不用）</li>
<li><code>ARGB32</code>: 每个像素用32位表示，RGB分量各使用8位（剩下的8位用于表示Alpha通道值）</li>
</ul>
<h3 id="存储方式-1"><a href="#存储方式-1" class="headerlink" title="存储方式"></a>存储方式</h3><h4 id="RGB565"><a href="#RGB565" class="headerlink" title="RGB565"></a>RGB565</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">high                         low</span><br><span class="line">7 6 5 4 3 2 1 0  7 6 5 4 3 2 1 0</span><br><span class="line">R R R R R G G G  G G G B B B B B</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> RGB565_MASK_RED    0xF800</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RGB565_MASK_GREEN  0x07E0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RGB565_MASK_BLUE   0x001F</span></span><br><span class="line"></span><br><span class="line">R = (wPixel &amp; RGB565_MASK_RED) &gt;&gt; <span class="number">11</span>;   <span class="comment">// 取值范围0-31</span></span><br><span class="line">G = (wPixel &amp; RGB565_MASK_GREEN) &gt;&gt; <span class="number">5</span>;  <span class="comment">// 取值范围0-63</span></span><br><span class="line">B =  wPixel &amp; RGB565_MASK_BLUE;         <span class="comment">// 取值范围0-31</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RGB(r,g,b) (unsigned int)( (r|0x08 &lt;&lt; 10) | (g|0x08 &lt;&lt; 5) | b|0x08 )</span></span><br></pre></td></tr></table></figure>

<h4 id="RGB555"><a href="#RGB555" class="headerlink" title="RGB555"></a>RGB555</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">X R R R R R G G  G G G B B B B B</span><br></pre></td></tr></table></figure>

<h3 id="RGB24"><a href="#RGB24" class="headerlink" title="RGB24"></a>RGB24</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">rgb24</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> rgbtBlue;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> rgbtGreen;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> rgbtRed;</span><br><span class="line">&#125; RGB;</span><br></pre></td></tr></table></figure>
<h3 id="RGB32"><a href="#RGB32" class="headerlink" title="RGB32"></a>RGB32</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">rgb32</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> rgbBlue;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> rgbGreen;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> rgbRed;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> rgbReserved;</span><br><span class="line">&#125; RGB；</span><br></pre></td></tr></table></figure>

<h2 id="YUV模型和RGB模型的关系"><a href="#YUV模型和RGB模型的关系" class="headerlink" title="YUV模型和RGB模型的关系"></a>YUV模型和RGB模型的关系</h2><p>YUV色彩模型来源于RGB模型，该模型的特点是将<code>亮度</code>和<code>色度</code>分离开，从而适合于图像处理领域。</p>
<ol>
<li><p>应用——模拟领域</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Y&#x27;= 0.299*R&#x27; + 0.587*G&#x27; + 0.114*B&#x27;</span><br><span class="line">U&#x27;= -0.147*R&#x27; - 0.289*G&#x27; + 0.436*B&#x27; = 0.492*(B&#x27;- Y&#x27;)</span><br><span class="line">V&#x27;= 0.615*R&#x27; - 0.515*G&#x27; - 0.100*B&#x27; = 0.877*(R&#x27;- Y&#x27;)</span><br><span class="line">R&#x27; = Y&#x27; + 1.140*V&#x27;</span><br><span class="line">G&#x27; = Y&#x27; - 0.394*U&#x27; - 0.581*V&#x27;</span><br><span class="line">B&#x27; = Y&#x27; + 2.032*U&#x27;</span><br></pre></td></tr></table></figure>
</li>
<li><p>应用——数字领域</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Y’ = 0.257*R&#x27; + 0.504*G&#x27; + 0.098*B&#x27; + 16</span><br><span class="line">Cb&#x27; = -0.148*R&#x27; - 0.291*G&#x27; + 0.439*B&#x27; + 128</span><br><span class="line">Cr&#x27; = 0.439*R&#x27; - 0.368*G&#x27; - 0.071*B&#x27; + 128</span><br><span class="line">R&#x27; = 1.164*(Y’-16) + 1.596*(Cr&#x27;-128)</span><br><span class="line">G&#x27; = 1.164*(Y’-16) - 0.813*(Cr&#x27;-128) - 0.392*(Cb&#x27;-128)</span><br><span class="line">B&#x27; = 1.164*(Y’-16) + 2.017*(Cb&#x27;-128)</span><br></pre></td></tr></table></figure>
<p>YCbCr模型来源于YUV模型。YCbCr是 YUV 颜色空间的偏移版本.</p>
<blockquote>
<p>上面各个符号都带了一撇，表示该符号在原值基础上进行了<code>伽马校正</code>,伽马校正有助于弥补在抗锯齿的过程中，线性分配伽马值所带来的细节损失，使图像细节更加丰富。在没有采用伽马校正的情况下，暗部细节不容易显现出来，而采用了这一图像增强技术以后，图像的层次更加明晰了。所以说<code>H264</code>里面的YUV应属于<code>YCbCr</code>.</p>
</blockquote>
</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FpcmswMDAvYXJ0aWNsZS9kZXRhaWxzLzI1MDMyOTAx">V4L2文档翻译（十）<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vbHVveWluamllL3AvNzIxOTMxOS5odG1s">YUV与RGB互转各种公式<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC9lNDk4MzI2YTU1YjE=">运用NEON指令集加速RGB与YUV相互转换<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>FFmpeg</category>
      </categories>
      <tags>
        <tag>ffmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title>FFmpeg学习笔记——环境搭建</title>
    <url>/post/24238.html</url>
    <content><![CDATA[<ul>
<li>本地环境：<code>ubuntu18.04</code></li>
<li>FFmpeg版本：<code>3.4.4</code></li>
</ul>
<span id="more"></span>

<h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><h3 id="本地环境"><a href="#本地环境" class="headerlink" title="本地环境"></a>本地环境</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get install -y  nasm</span><br></pre></td></tr></table></figure>

<h3 id="编译FFmpeg"><a href="#编译FFmpeg" class="headerlink" title="编译FFmpeg"></a>编译FFmpeg</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">PWD=`pwd`</span><br><span class="line">build_dir=&quot;ffmpeg&quot;</span><br><span class="line">ffmpeg_version=&quot;n3.4.4&quot;</span><br><span class="line">build_out=&quot;out&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function local_env_prepare()</span><br><span class="line">&#123;</span><br><span class="line">	sudo apt-get install -y  nasm</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function ffmpeg_prepare()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	if [ ! -d $build_dir ]; then</span><br><span class="line">		mkdir $build_dir</span><br><span class="line">	fi</span><br><span class="line">	echo &quot;Download FFmpeg ...&quot;</span><br><span class="line"></span><br><span class="line">	if [ -f $&#123;PWD&#125;/$&#123;build_dir&#125;/$&#123;ffmpeg_version&#125;.tar.gz ]; then</span><br><span class="line">		return 3</span><br><span class="line">	fi</span><br><span class="line"></span><br><span class="line">	wget -P $build_dir https://github.com/FFmpeg/FFmpeg/archive/$&#123;ffmpeg_version&#125;.tar.gz</span><br><span class="line"></span><br><span class="line">	tar zxvf $build_dir/$&#123;ffmpeg_version&#125;.tar.gz -C $build_dir</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function ffmpeg_build()</span><br><span class="line">&#123;</span><br><span class="line">	local root_pwd=$PWD</span><br><span class="line">	cd ./$&#123;build_dir&#125;/FFmpeg-$&#123;ffmpeg_version&#125;</span><br><span class="line">	echo &quot;Currect dir $PWD&quot;</span><br><span class="line"></span><br><span class="line">	if [ -d $&#123;root_pwd&#125;/$&#123;build_dir&#125;/$&#123;build_out&#125; ]; then</span><br><span class="line">		return 4</span><br><span class="line">	fi</span><br><span class="line"></span><br><span class="line">	./configure --enable-shared  --prefix=$&#123;root_pwd&#125;/$&#123;build_dir&#125;/$&#123;build_out&#125;</span><br><span class="line">	echo &quot;./configure --enable-shared  --prefix=$&#123;root_pwd&#125;/$&#123;build_dir&#125;/$&#123;build_out&#125;&quot;</span><br><span class="line">	make</span><br><span class="line">	make install</span><br><span class="line"></span><br><span class="line">	cd -</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">main</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">local_env_prepare</span></span><br><span class="line"></span><br><span class="line">ffmpeg_prepare</span><br><span class="line">if [ $? == 3 ]; then</span><br><span class="line">	echo &quot;FFmpeg Installation package [$&#123;ffmpeg_version&#125;.tar.gz] already exists&quot;</span><br><span class="line">	exit 1</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">ffmpeg_build</span><br><span class="line">if [ $? == 4 ]; then</span><br><span class="line">	echo &quot;Already built exit !!!&quot;</span><br><span class="line">	exit 1</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<h2 id="环境测试"><a href="#环境测试" class="headerlink" title="环境测试"></a>环境测试</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __STDC_CONSTANT_MACROS</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;libavcodec/avcodec.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;libavformat/avformat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;libavutil/avutil.h&quot;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;FFmpeg Test!&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">av_register_all</span>();</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;FFmpeg version:&quot;</span> &lt;&lt; <span class="built_in">avcodec_version</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所有代码：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1dpbmRkb2luZy9mZm1wZWctc3R1ZHkuZ2l0">https://github.com/Winddoing/ffmpeg-study.git<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>FFmpeg</category>
      </categories>
      <tags>
        <tag>ffmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title>FFmpeg学习笔记——ffmpeg命令</title>
    <url>/post/41754.html</url>
    <content><![CDATA[<p>ffmpeg命令相关用法。</p>
<blockquote>
<ul>
<li>环境： <code>ubuntu 18.04</code></li>
<li>ffmpeg版本： <code>3.4.4-0ubuntu0.18.04.1</code></li>
</ul>
</blockquote>
<span id="more"></span>

<h2 id="制作ts流"><a href="#制作ts流" class="headerlink" title="制作ts流"></a>制作ts流</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ffmpeg -i test.mp4 -ss 00:00:12 -to 00:00:13 -vcodec libx264 -g 1 -crf 1 test.ts</span><br></pre></td></tr></table></figure>
<blockquote>
<p>ts流中包含I帧</p>
</blockquote>
<p>参数解析：</p>
<ul>
<li><code>-i</code>： 设定输入流（input）</li>
<li><code>-ss time_off</code>： 开始时间</li>
<li><code>-to time_stop</code>： 结束时间</li>
<li><code>-vcodec codec </code>：设定视频编解码器，未设定时则使用与输入流相同的编解码器，(‘copy’ to copy stream)<ul>
<li>libx264： ts流</li>
</ul>
</li>
<li><code>-g &lt;int&gt;</code>：关键帧(I帧)间隔控制</li>
<li><code>-crf &lt;int&gt;</code>：（Constant Rate Factor） 量化比例的范围为0~51，其中0为无损模式，23为缺省值，51可能是最差的。该数字越小，图像质量越好</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ffmpeg -i water.mp4 -codec copy -bsf:v h264_mp4toannexb water.ts</span><br></pre></td></tr></table></figure>

<h2 id="转H264"><a href="#转H264" class="headerlink" title="转H264"></a>转H264</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ffmpeg -i water.mp4 -c:v copy -bsf:v h264_mp4toannexb -an water.h264</span><br></pre></td></tr></table></figure>

<h2 id="wav转mp4"><a href="#wav转mp4" class="headerlink" title="wav转mp4"></a>wav转mp4</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ffmpeg -i water.wmv -c:v libx264 -strict -2 water.mp4</span><br></pre></td></tr></table></figure>

<h2 id="mp4转yuv"><a href="#mp4转yuv" class="headerlink" title="mp4转yuv"></a>mp4转yuv</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ffmpeg -i food.mp4 food.yuv</span><br></pre></td></tr></table></figure>

<h2 id="ffmpge帮助信息"><a href="#ffmpge帮助信息" class="headerlink" title="ffmpge帮助信息"></a>ffmpge帮助信息</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ffmpeg -h full &gt; help.txt</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>FFmpeg</category>
      </categories>
      <tags>
        <tag>ffmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title>[译]GPU体系结构：数据并行吞吐量的结构</title>
    <url>/post/b5b80551.html</url>
    <content><![CDATA[<p>根据Wikipedia的说法，GPU卡（也称为图形卡或视频卡）是一种专用的电子电路。 它是专门为快速处理和更改内存而设计的，以加快在帧缓冲区中创建图像的速度，因此可以输出到诸如计算机监视器或电视屏幕之类的显示设备。</p>
<p>现代GPU架构在处理图形以及图像处理方面非常有效。 高度并行的结构使其比用于并行处理大型数据块的通用CPU（中央处理单元）体系结构更有效。</p>
<p>在PC内，GPU可以嵌入扩展卡（视频卡）中，预先安装在主板上（专用GPU）或集成到CPU裸片（集成GPU）中。</p>
<span id="more"></span>

<h2 id="GPU架构"><a href="#GPU架构" class="headerlink" title="GPU架构"></a>GPU架构</h2><p>在谈到视频卡体系结构时，它总是涉及CPU体系结构或与之比较。</p>
<h3 id="GPU-vs-CPU架构"><a href="#GPU-vs-CPU架构" class="headerlink" title="GPU vs CPU架构"></a>GPU vs CPU架构</h3><p><img data-src="/images/2021/03/cpu_vs_gpu.png" alt="CPU vs GPU"></p>
<p>GPU的功能是优化数据吞吐量。它允许一次通过其内部推送尽可能多的任务，这比CPU一次可以处理的任务多得多。这是因为通常情况下，图形卡具有比CPU多得多的内核。</p>
<p>但是，实际上，我们称内核为CUDA（计算统一设备体系结构）内核，该内核由GPU中的全流水线整数ALU（算术逻辑单元）和FPU（浮点单元）组成。在NVIDIA GPU架构中，ALU支持所有指令的完整32位精度。并且，对整数ALU进行了优化，以有效地支持64位扩展精度运算以及各种指令，例如布尔运算，比较，转换，移动，移位，位反向插入，位域提取和填充计数。</p>
<p>通常，GPU的体系结构与CPU的体系结构非常相似。它们都利用高速缓存层，全局内存和内存控制器的内存构造。</p>
<p>高级GPU架构仅涉及数据并行吞吐量计算，并使可用的内核正常工作，而不是像CPU那样专注于低延迟高速缓存的访问。</p>
<blockquote>
<p>注意：详细的图形卡体系结构在很大程度上取决于不同制造商的品牌和型号。 Nvidia GPU架构与AMD GPU架构不同。</p>
</blockquote>
<h2 id="GPU体系结构基础"><a href="#GPU体系结构基础" class="headerlink" title="GPU体系结构基础"></a>GPU体系结构基础</h2><p>在GPU设备中，有多个处理器集群（PC），其中包含多个流式多处理器（SM）。 并且，每个SM都包含一个1层指令高速缓存层及其相关的内核。 通常，一个SM在从全局GDDR-5存储器中提取数据之前，会采用专用的第1层高速缓存和共享的第2层高速缓存。 因此，GPU处理器体系结构可容忍内存延迟。</p>
<p><img data-src="/images/2021/03/nvidia_gpu_architecture.png" alt="Nvidia GPU Architecture"></p>
<h3 id="GCA-Graphics-Compute-Array"><a href="#GCA-Graphics-Compute-Array" class="headerlink" title="GCA (Graphics Compute Array)"></a>GCA (Graphics Compute Array)</h3><p>通常，GCA（也称为3D引擎）由像素着色器，顶点着色器或统一着色器，流处理器（CUDA核心），纹理映射单元（TMU），渲染输出单元（ROP），二级缓存，几何处理器， 等等。</p>
<h3 id="GMC-Graphics-Memory-Controller"><a href="#GMC-Graphics-Memory-Controller" class="headerlink" title="GMC (Graphics Memory Controller)"></a>GMC (Graphics Memory Controller)</h3><p>GMC，也称为内存芯片控制器（MCC）或内存控制器单元（MCU），是一种数字电路，用于控制进出计算机图形内存的数据流。 它可以是单独的芯片； 它也可以集成到另一个芯片中，例如放置在同一芯片上或作为微处理器的组成部分。 如果GMC作为组成部分存在，则称为IMC（集成内存控制器）。<br>内存GMC控件包括VRAM，WRAM，MDRAM，DDR，GDDR和HBM。</p>
<h3 id="VGA-BIOS-Video-Graphics-Array-Basic-Input-x2F-Output-System"><a href="#VGA-BIOS-Video-Graphics-Array-Basic-Input-x2F-Output-System" class="headerlink" title="VGA BIOS (Video Graphics Array Basic Input&#x2F;Output System)"></a>VGA BIOS (Video Graphics Array Basic Input&#x2F;Output System)</h3><p>VGA BIOS，也称为视频BIOS，是计算机中图形卡的BIOS。 它是位于图形卡上的独立芯片，不是GPU的一部分。</p>
<h3 id="BIF-Bus-Interface"><a href="#BIF-Bus-Interface" class="headerlink" title="BIF (Bus Interface)"></a>BIF (Bus Interface)</h3><p>总线接口（BI）是用于将小型外围设备（例如闪存）与处理器接口的计算机总线。 通常，它包括SA，VLB，PCI，AGP和PCIe。</p>
<h3 id="PMU-Power-Management-Unit"><a href="#PMU-Power-Management-Unit" class="headerlink" title="PMU (Power Management Unit)"></a>PMU (Power Management Unit)</h3><p>PMU是控制数字平台电源功能的微控制器（微芯片）。 它具有许多与普通计算机类似的组件，例如CPU，内存，固件，软件等。PMU是为数不多的几个组件之一，即使计算机完全关闭，该组件仍由备用电池供电，这些组件仍可以保持活动状态。</p>
<p>在便携式计算机中，PMU协调以下功能：</p>
<ul>
<li>监视电源连接和电池电量。</li>
<li>闲置时，请关闭不必要的系统部件。</li>
<li>控制睡眠和电源功能（打开或关闭）。</li>
<li>控制其他集成电路的电源。</li>
<li>管理内置键盘或触控板的界面。</li>
<li>必要时给电池充电。</li>
<li>调节实时时钟（RTC）。</li>
</ul>
<h3 id="VPU-Video-Processing-Unit"><a href="#VPU-Video-Processing-Unit" class="headerlink" title="VPU (Video Processing Unit)"></a>VPU (Video Processing Unit)</h3><p>VPU是一种专用处理器，将视频流作为输入，并且可以对输入流执行非常复杂的过程。 它通常用于机器学习应用程序和设备中，并充当那些设备中的辅助组件。</p>
<p>VPU是负责视频编码和解码的视频编解码器。 因此，它也被称为视频编码器和解码器。 VPU执行MPEG2，Theora，VP8，H.264，H.265，VP9，VC-1等的压缩或解压缩。</p>
<h3 id="DIF-Display-Interface"><a href="#DIF-Display-Interface" class="headerlink" title="DIF (Display Interface)"></a>DIF (Display Interface)</h3><p>显示接口，也称为显示控制器，定义了主机，图像数据源和目标设备之间的串行总线和通信协议。 它包括RAMDAC，HDMI音频，DP音频，视频底图（VGA，DVI，HDMI，DisplayPort，S-Video，复合视频，分量视频），PHY（LVDS，TIMDS）和EDID。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cucGFydGl0aW9ud2l6YXJkLmNvbS9wYXJ0aXRpb25tYWdpYy9ncHUtYXJjaGl0ZWN0dXJlLmh0bWw=">GPU Architecture: A Structure for Data Parallel Throughput<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>GPU</category>
      </categories>
      <tags>
        <tag>gpu</tag>
        <tag>nvidia</tag>
      </tags>
  </entry>
  <entry>
    <title>GCC内嵌汇编(mips)</title>
    <url>/post/55412.html</url>
    <content><![CDATA[<blockquote>
<p>以MIPS架构的汇编为主进行说明</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">__asm__ __volatile__(</span><br><span class="line">	&quot;1: ll  %1, %2  # arch_read_lock    \n&quot;</span><br><span class="line">	&quot;   bltz    %1, 1b              \n&quot;</span><br><span class="line">	&quot;    addu   %1, 1               \n&quot;</span><br><span class="line">	&quot;2: sc  %1, %0              \n&quot;</span><br><span class="line">	: &quot;=m&quot; (rw-&gt;lock), &quot;=&amp;r&quot; (tmp)</span><br><span class="line">	: &quot;m&quot; (rw-&gt;lock)</span><br><span class="line">	: &quot;memory&quot;);</span><br></pre></td></tr></table></figure>
<ul>
<li>基本形式： <code>__asm__ __volatile__(&quot;ssnop\n\t&quot;);</code><blockquote>
<p><code>ssnop</code>: 空指令</p>
</blockquote>
</li>
</ul>
<p>汇编扩展以<code>__asm__</code>开头表示后面部分为汇编,<code>__volatile__</code>严禁将此处的汇编语句和其他语句进行重组优化，就是希望gcc不要修改我们这个部分。</p>
<span id="more"></span>

<h2 id="构成"><a href="#构成" class="headerlink" title="构成"></a>构成</h2><p>主要由四部分构成,之间以<code>:</code>分隔：</p>
<ol>
<li><code>instruction指令</code>:每条指令之后最好使用<code>&quot;\n\t&quot;</code>结尾,这样在gcc产生汇编格式比较好.</li>
<li><code>output operand输出</code>:每个输出部分使用,分隔.”&#x3D;”作为修饰符,”m”表示<code>存放位置/约束符</code>,()里面表示对应C程序值.</li>
<li><code>input operand输入</code>:这个部分和输出是一样的.</li>
<li><code>clobber(装备)</code>:这个部分是告诉gcc在这条指令里面我们会修改什么值.</li>
</ol>
<h3 id="约束符"><a href="#约束符" class="headerlink" title="约束符"></a>约束符</h3><p>束符影响的内容包括:</p>
<blockquote>
<p>whether an operand may be in a register<br>which kinds of register<br>whether the operand can be a memory reference<br>which kinds of address<br>whether the operand may be an immediate constant<br>which possible values it may have</p>
</blockquote>
<p>约束符包括:</p>
<ul>
<li>p 内存地址</li>
<li>m 内存变量</li>
<li>o 内存变量,但是寻址方式必须是偏移量的,就是基址寻址或者是基址变址寻址.</li>
<li>V 内存变量,但是寻址方式是非偏移量的.</li>
<li>r general寄存器操作数</li>
<li>i 立即操作数,内容在编译器可以确定.</li>
<li>n 立即操作数.有些系统不支持字(双字节)以外的立即操作数,这些操作数以n非i来表示.</li>
<li>E&#x2F;F 浮点常数</li>
<li>g 内存操作数,整数常数,非genernal寄存器操作数</li>
<li>X 任何操作数</li>
<li>0,1,2…9 和编号指定操作数匹配的操作数束符影响的内容包括</li>
</ul>
<h3 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h3><p>修饰符包括:</p>
<ul>
<li><code>=</code> 操作数是write only的</li>
<li><code>+</code> 操作数是可读可写的</li>
<li><code>&amp;</code> 常用于输出限定符,表示某个寄存器不会被输入所使用.</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">__asm__ __volatile__(</span><br><span class="line">&quot;   .set    mips3               \n&quot;</span><br><span class="line">&quot;   ll  %0, %1      # atomic_sub    \n&quot;</span><br><span class="line">&quot;   subu    %0, %2              \n&quot;</span><br><span class="line">&quot;   sc  %0, %1              \n&quot;</span><br><span class="line">&quot;   .set    mips0               \n&quot;</span><br><span class="line">: &quot;=&amp;r&quot; (temp), &quot;+m&quot; (v-&gt;counter)</span><br><span class="line">: &quot;Ir&quot; (i));</span><br></pre></td></tr></table></figure>

<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><h3 id="读取CP0-25号硬件计数寄存器的值"><a href="#读取CP0-25号硬件计数寄存器的值" class="headerlink" title="读取CP0 25号硬件计数寄存器的值"></a>读取CP0 25号硬件计数寄存器的值</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int get_counter()</span><br><span class="line">&#123;</span><br><span class="line">	int rst;</span><br><span class="line"></span><br><span class="line">	__asm__ __volatile__(	/* mfc0 为取cp0 寄存器值的指令 */</span><br><span class="line">	&quot;mfc0	%0, $25\n\t&quot;	/* %0 表示列表开始的第一个寄存器 */</span><br><span class="line">	: &quot;=r&quot; (rst)		/* 告诉gcc 让rst对应一个通用寄存器 */</span><br><span class="line">	);</span><br><span class="line"></span><br><span class="line">	return rst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>“&#x3D;r” 中，’&#x3D;’ 为修饰符，表示该操作对象只写，一般用于修饰输出参数列表中。’r’ 表示任意一个通用寄存器</p>
</blockquote>
<h3 id="设置CP0-24号硬件计数寄存器的值"><a href="#设置CP0-24号硬件计数寄存器的值" class="headerlink" title="设置CP0 24号硬件计数寄存器的值"></a>设置CP0 24号硬件计数寄存器的值</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">unsigned int op = 0x80f;</span><br><span class="line"></span><br><span class="line">__asm__ __volatile__(</span><br><span class="line">&quot;mtc0 %0, $24\n\t&quot;</span><br><span class="line">:				/* 没有输出，列表为空 */</span><br><span class="line">:&quot;r&quot;(op)		/* 输入参数，告诉gcc 让op对应一个通用寄存器 */</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h3 id="重设后，读取CP0-24号寄存器的值"><a href="#重设后，读取CP0-24号寄存器的值" class="headerlink" title="重设后，读取CP0 24号寄存器的值"></a>重设后，读取CP0 24号寄存器的值</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">unsigned int rst;</span><br><span class="line">unsigned int op = 0x80f;</span><br><span class="line"></span><br><span class="line">__asm__ __volatile__(</span><br><span class="line">&quot;mtc0	%1, $24\n\t&quot;	/* %1 表示 op 对应的寄存器 */</span><br><span class="line">&quot;mfc0	%0, $25\n\t&quot;	/* %0 表示 rst 对应的寄存器 */</span><br><span class="line">: &quot;=r&quot; (rst)</span><br><span class="line">: &quot;r&quot; (op)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>输入输出参数列表，按先后顺序，从0开始编号, %0, %1。</p>
</blockquote>
<h3 id="解读开头汇编代码"><a href="#解读开头汇编代码" class="headerlink" title="解读开头汇编代码"></a>解读开头汇编代码</h3><p>读写锁中读锁上锁的汇编实现：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">__asm__ __volatile__(</span><br><span class="line">	&quot;1: ll  %1, %2  # arch_read_lock    \n&quot;</span><br><span class="line">	&quot;   bltz    %1, 1b              \n&quot;</span><br><span class="line">	&quot;    addu   %1, 1               \n&quot;</span><br><span class="line">	&quot;2: sc  %1, %0              \n&quot;</span><br><span class="line">	: &quot;=m&quot; (rw-&gt;lock), &quot;=&amp;r&quot; (tmp)</span><br><span class="line">	: &quot;m&quot; (rw-&gt;lock)</span><br><span class="line">	: &quot;memory&quot;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>&quot;=m&quot; (rw-&gt;lock)</code>: 只写内存操作<br><code>&quot;=&amp;r&quot; (tmp)</code> : 只写的输出变量，使用一个通用寄存器<br><code>&quot;memory&quot;</code>: 告诉gcc编译，该指令会修改内存中的值</p>
</blockquote>
<ol>
<li>通过原子操作<code>ll</code>,将<code>rw-&gt;lock</code>读到<code>tmp</code></li>
<li>加一：<code>tmp = tmp + 1</code></li>
<li>通过原子操作<code>sc</code>,将<code>tmp</code>写入<code>rw-&gt;lock</code></li>
</ol>
<h2 id="barrier"><a href="#barrier" class="headerlink" title="barrier"></a>barrier</h2><p>内存屏障：保证前后指令的执行顺序</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> barrier() __asm__ __volatile__(<span class="string">&quot;&quot;</span>: : :<span class="string">&quot;memory&quot;</span>)</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>file: include&#x2F;linux&#x2F;compiler-gcc.h</p>
</blockquote>
<p><code>&quot;memory&quot;</code>作为clobber部分另外一个作用是可以让在这条指令之后的指令,告诉gcc应该刷新内存状态.内存的状态可能发生修改,如果需要操作的话,需要重新把内存内容载入寄存器</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NvbWNhdC9hcnRpY2xlL2RldGFpbHMvMTU1Nzk2Mw==">MIPS GCC 嵌入式汇编<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9kaXJ0eXNhbHQuZ2l0aHViLmlvL2h0bWwvZ2NjLWFzbS5odG1s">GCC内嵌汇编<i class="fa fa-external-link-alt"></i></span></li>
</ol>
]]></content>
      <categories>
        <category>MIPS</category>
      </categories>
      <tags>
        <tag>mips</tag>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title>mips指令集</title>
    <url>/post/25760.html</url>
    <content><![CDATA[<p>注意使用<code>jr.hb</code>、<code>jal.hb</code>等硬件屏障指令。(hardware barrier)</p>
]]></content>
      <categories>
        <category>MIPS</category>
      </categories>
      <tags>
        <tag>mips</tag>
        <tag>指令</tag>
      </tags>
  </entry>
  <entry>
    <title>Cache</title>
    <url>/post/50757.html</url>
    <content><![CDATA[<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+----+  +----+   +----+  +----+</span><br><span class="line">|CPU0|  |CPU1|   |CPU2|  |CPU3|</span><br><span class="line">+----+  +----+   +----+  +----+</span><br><span class="line">  +-+     +-+     +-+      +-+</span><br><span class="line">    |     |         |      |</span><br><span class="line">+---v-----v--+   +--v------v--+</span><br><span class="line">|   L1 Cache |   |  L2 Cache  |</span><br><span class="line">+------+-----+   +------+-----+</span><br><span class="line">       |                |</span><br><span class="line">+------v----------------v-----+</span><br><span class="line">|         L2 Cache            |</span><br><span class="line">+-----------------------------+</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="Cache-初始化"><a href="#Cache-初始化" class="headerlink" title="Cache 初始化"></a>Cache 初始化</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kernel_start</span><br><span class="line">	\-&gt;setup_arch</span><br><span class="line">		\-&gt;cpu_cache_init</span><br><span class="line">			\-&gt;r4k_cache_init</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> cpu_dcache_size()           (32 * 1024)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cpu_dcache_ways()           8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cpu_dcache_line_size()      32</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cpu_icache_size()           (32 * 1024)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cpu_icache_ways()           8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cpu_icache_line_size()      32</span></span><br></pre></td></tr></table></figure>


<h2 id="cpuinfo-mips"><a href="#cpuinfo-mips" class="headerlink" title="cpuinfo_mips"></a>cpuinfo_mips</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cpuinfo_mips</span> &#123;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>        udelay_val;</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 *Capability and feature descriptor structure for MIPS CPU</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>        processor_id;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>        fpu_id;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>        msa_id;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>        cputype;</span><br><span class="line">	...</span><br><span class="line">&#125; __attribute__((aligned(SMP_CACHE_BYTES)));</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">cpuinfo_mips</span> <span class="title">cpu_data</span>[];</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> current_cpu_data cpu_data[smp_processor_id()]</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> raw_current_cpu_data cpu_data[raw_smp_processor_id()]</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>file: arch&#x2F;mips&#x2F;include&#x2F;asm&#x2F;cpu-info.h</p>
</blockquote>
<ul>
<li>初始化：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cpuinfo_mips</span> <span class="title">cpu_data</span>[<span class="title">NR_CPUS</span>] __<span class="title">read_mostly</span>;</span></span><br><span class="line">EXPORT_SYMBOL(cpu_data);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>file:  arch&#x2F;mips&#x2F;kernel&#x2F;setup.c</p>
</blockquote>
</li>
</ul>
]]></content>
      <categories>
        <category>MIPS</category>
      </categories>
      <tags>
        <tag>cache</tag>
        <tag>mips</tag>
        <tag>kernel</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux应用调试方法---Debug</title>
    <url>/post/43503.html</url>
    <content><![CDATA[<p>常用的Linux应用调试方法：<code>GDB</code></p>
<span id="more"></span>
<h2 id="strace"><a href="#strace" class="headerlink" title="strace"></a>strace</h2><h3 id="用法："><a href="#用法：" class="headerlink" title="用法："></a>用法：</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">strace ./a.out</span><br></pre></td></tr></table></figure>

<h2 id="gdb"><a href="#gdb" class="headerlink" title="gdb"></a>gdb</h2><p>core dump</p>
<h3 id="查看core设置"><a href="#查看core设置" class="headerlink" title="查看core设置"></a>查看core设置</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ulimit -a</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">core file size          (blocks, -c) 0</span><br><span class="line">data seg size           (kbytes, -d) unlimited</span><br><span class="line">scheduling priority             (-e) 0</span><br><span class="line">file size               (blocks, -f) unlimited</span><br><span class="line">pending signals                 (-i) 30956</span><br><span class="line">max locked memory       (kbytes, -l) 16384</span><br><span class="line">max memory size         (kbytes, -m) unlimited</span><br><span class="line">open files                      (-n) 1024</span><br><span class="line">pipe size            (512 bytes, -p) 8</span><br><span class="line">POSIX message queues     (bytes, -q) 819200</span><br><span class="line">real-time priority              (-r) 0</span><br><span class="line">stack size              (kbytes, -s) 8192</span><br><span class="line">cpu time               (seconds, -t) unlimited</span><br><span class="line">max user processes              (-u) 30956</span><br><span class="line">virtual memory          (kbytes, -v) unlimited</span><br><span class="line">file locks                      (-x) unlimited</span><br></pre></td></tr></table></figure>

<h3 id="开启core-file"><a href="#开启core-file" class="headerlink" title="开启core file"></a>开启core file</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ulimit -c unlimited</span><br></pre></td></tr></table></figure>

<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><blockquote>
<p>ubuntu18.04 64bit</p>
</blockquote>
<ul>
<li>异常程序(段错误)</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> *a;</span><br><span class="line"></span><br><span class="line">    *a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>编译*<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gcc -g test.c</span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li><p>运行异常程序后,生成core文件</p>
</li>
<li><p>使用gdb查看异常位置</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gdb ./a.out core</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GNU gdb (Ubuntu 8.1-0ubuntu3) 8.1.0.20180409-git</span><br><span class="line">Copyright (C) 2018 Free Software Foundation, Inc.</span><br><span class="line">License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;</span><br><span class="line">This is free software: you are free to change and redistribute it.</span><br><span class="line">There is NO WARRANTY, to the extent permitted by law.  Type &quot;show copying&quot;</span><br><span class="line">and &quot;show warranty&quot; for details.</span><br><span class="line">This GDB was configured as &quot;x86_64-linux-gnu&quot;.</span><br><span class="line">Type &quot;show configuration&quot; for configuration details.</span><br><span class="line">For bug reporting instructions, please see:</span><br><span class="line">&lt;http://www.gnu.org/software/gdb/bugs/&gt;.</span><br><span class="line">Find the GDB manual and other documentation resources online at:</span><br><span class="line">&lt;http://www.gnu.org/software/gdb/documentation/&gt;.</span><br><span class="line">For help, type &quot;help&quot;.</span><br><span class="line">Type &quot;apropos word&quot; to search for commands related to &quot;word&quot;...</span><br><span class="line">Reading symbols from ./a.out...done.</span><br><span class="line"></span><br><span class="line">warning: exec file is newer than core file.</span><br><span class="line">[New LWP 20661]</span><br><span class="line">Core was generated by `./a.out&#x27;.</span><br><span class="line">Program terminated with signal SIGSEGV, Segmentation fault.</span><br><span class="line">#0  0x0000563a00047609 in main (argc=1, argv=0x7ffe99b73178) at tst.c:8</span><br><span class="line">8	    *a = 1;</span><br></pre></td></tr></table></figure>

<h3 id="ARM平台"><a href="#ARM平台" class="headerlink" title="ARM平台"></a>ARM平台</h3><blockquote>
<p>本地编译支持arm平台的gdb</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">PWD=`pwd`</span><br><span class="line"></span><br><span class="line">mkdir tmp</span><br><span class="line">cd tmp</span><br><span class="line"></span><br><span class="line">if [ ! -f gdb-8.2.tar.gz ]; then</span><br><span class="line">    wget http://101.110.118.57/ftp.gnu.org/gnu/gdb/gdb-8.2.tar.gz</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">rm gdb-8.2 -rf</span><br><span class="line">tar zxvf gdb-8.2.tar.gz</span><br><span class="line"></span><br><span class="line">cd gdb-8.2</span><br><span class="line"></span><br><span class="line">./configure --target=arm-linux --prefix=$PWD/_install  --enable-static</span><br><span class="line">make -j2</span><br><span class="line">make install</span><br><span class="line"></span><br><span class="line">cd .. #gdb-8.2</span><br><span class="line">cd .. #tmp</span><br></pre></td></tr></table></figure>

<h3 id="交叉编译"><a href="#交叉编译" class="headerlink" title="交叉编译"></a>交叉编译</h3><p>目标平台直接使用gdb调试</p>
<h2 id="gdb调试"><a href="#gdb调试" class="headerlink" title="gdb调试"></a>gdb调试</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gdb ./a,out</span><br></pre></td></tr></table></figure>

<ul>
<li>动态的改变你程序的执行环境</li>
</ul>
<h3 id="启动调试"><a href="#启动调试" class="headerlink" title="启动调试"></a>启动调试</h3><table>
<thead>
<tr>
<th align="center">启动方式</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>$gdb</code></td>
<td align="left">直接进去交互模式</td>
</tr>
<tr>
<td align="center"><code>$gdb -tui</code></td>
<td align="left">启动可以直接将屏幕分成两个部分，上面显示源代码,上下方向键可以查看源代码,想要命令行使用上下键就用<code>Ctrl+n</code>和<code>Ctrl+p</code></td>
</tr>
<tr>
<td align="center"><code>$gdb app</code></td>
<td align="left">启动gdb调试指定程序app</td>
</tr>
<tr>
<td align="center"><code>$gdb &lt;program&gt; &lt;PID&gt;</code></td>
<td align="left"><program>是程序的可执行文件名，<PID>是要调试程序的PID</td>
</tr>
<tr>
<td align="center"><code>$gdb &lt;PID&gt;</code></td>
<td align="left"><PID>是要调试程序的PID, 此时无法查看源码，使用<code>file</code>命令指明可执行文件就可以显示源代码</td>
</tr>
</tbody></table>
<h3 id="调试交互"><a href="#调试交互" class="headerlink" title="调试交互"></a>调试交互</h3><blockquote>
<p>以下所有命令可以在调试时，使用<code>Tab</code>进行补全</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">别名</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>help</code></td>
<td align="center"></td>
<td align="left">显示帮助信息</td>
</tr>
<tr>
<td align="center"><code>file app</code></td>
<td align="center"></td>
<td align="left">载入指定的程序,编译app的时候要加入<code>-g</code>调试选项</td>
</tr>
<tr>
<td align="center"><code>list n1 n2</code></td>
<td align="center"><code>l</code></td>
<td align="left">列出指定区域(n1到n2之间)的代码<a href="#list">详见list</a></td>
</tr>
<tr>
<td align="center"><code>start</code></td>
<td align="center"></td>
<td align="left">开始执行程序,在main函数的第一条语句前面停下来</td>
</tr>
<tr>
<td align="center"><code>run</code></td>
<td align="center"><code>r</code></td>
<td align="left">重新运行调试的程序, 它后面可以跟随发给该程序的任何参数，包括标准输入和标准输出说明符(&lt;和&gt; )和shell通配符（*、？、[、]）在内</td>
</tr>
<tr>
<td align="center"><code>continue</code></td>
<td align="center"></td>
<td align="left">继续运行程序直接运行到下一个断点</td>
</tr>
<tr>
<td align="center"><code>next</code></td>
<td align="center"><code>n</code></td>
<td align="left">执行下一步(执行一行代码，如果是函数也会跳过函数)</td>
</tr>
<tr>
<td align="center"><code>next N </code></td>
<td align="center"><code>n N</code></td>
<td align="left">执行N次下一步</td>
</tr>
<tr>
<td align="center"><code>step</code></td>
<td align="center"></td>
<td align="left">单步进入(执行一行代码，如果遇到函数进入函数的内部，再一行一行的执行)</td>
</tr>
<tr>
<td align="center"><code>finish</code></td>
<td align="center"></td>
<td align="left">执行完当前函数返回到调用它的函数</td>
</tr>
<tr>
<td align="center"><code>until</code></td>
<td align="center"><code>u</code></td>
<td align="left">指定程序直到退出当前循环体</td>
</tr>
<tr>
<td align="center"><code>jump 5</code></td>
<td align="center"><code>j 5</code></td>
<td align="left">跳转执行程序到第5行</td>
</tr>
<tr>
<td align="center"><code>return</code></td>
<td align="center"></td>
<td align="left">强制返回当前函数</td>
</tr>
<tr>
<td align="center"><code>call &lt;expr&gt;</code></td>
<td align="center"></td>
<td align="left">强制调用函数, 如果函数的返回类型是void那么就不会打印函数的返回值</td>
</tr>
<tr>
<td align="center"><code>print &lt;expr&gt;</code></td>
<td align="center"></td>
<td align="left">强制调用函数, 如果函数的返回值是void那么call不会打印返回值</td>
</tr>
<tr>
<td align="center"><code>break 6</code></td>
<td align="center"><code>b 6</code></td>
<td align="left">在当前的文件中某一行（假设为6）设定断点</td>
</tr>
<tr>
<td align="center"><code>break 46 if testsize==100</code></td>
<td align="center"></td>
<td align="left">设置条件断点(如果testsize&#x3D;&#x3D;100就在46行处断点)</td>
</tr>
<tr>
<td align="center"><code>watch &lt;expr&gt;</code></td>
<td align="center"></td>
<td align="left"><expr> 为表达式（变量）expr设置一个观察点。一量表达式值有变化时，马上停住程序(也是一种断点)</td>
</tr>
<tr>
<td align="center"><code>watch i != 10</code></td>
<td align="center"></td>
<td align="left">检测表达式变化则停住,i !&#x3D; 10这个表达式一旦变化，则停住</td>
</tr>
<tr>
<td align="center"><code>break func</code></td>
<td align="center"><code>b func</code></td>
<td align="left">在当前的文件中为某一函数(假设为func)处设定断点</td>
</tr>
<tr>
<td align="center"><code>break fileName:N</code></td>
<td align="center"><code>b fileName:N</code></td>
<td align="left">给指定文件（fileName）的某个行（N）处设置断点</td>
</tr>
<tr>
<td align="center"><code>info breakpoints</code></td>
<td align="center"><code>info break</code></td>
<td align="left">显示当前gdb断点信息</td>
</tr>
<tr>
<td align="center"><code>print var</code></td>
<td align="center"></td>
<td align="left">print显示变量(var)值<a href="#print">详见print</a></td>
</tr>
<tr>
<td align="center"><code>set var name=v</code></td>
<td align="center"></td>
<td align="left">设置变量的值</td>
</tr>
<tr>
<td align="center"><code>delete N</code></td>
<td align="center"></td>
<td align="left">删除N号断点</td>
</tr>
<tr>
<td align="center"><code>delete</code></td>
<td align="center"></td>
<td align="left">删除所有断点</td>
</tr>
<tr>
<td align="center"><code>clear N</code></td>
<td align="center"></td>
<td align="left">清除行N上面的所有断点</td>
</tr>
<tr>
<td align="center"><code>clear</code></td>
<td align="center"></td>
<td align="left">清除所有断点</td>
</tr>
<tr>
<td align="center"><code>backtrace</code></td>
<td align="center"><code>bt</code></td>
<td align="left">显示当前调用函数堆栈中的函数</td>
</tr>
<tr>
<td align="center"><code>frame</code></td>
<td align="center"><code>f</code></td>
<td align="left">查看栈帧</td>
</tr>
<tr>
<td align="center"><code>set args no</code></td>
<td align="center"></td>
<td align="left">修改发送给程序的参数</td>
</tr>
<tr>
<td align="center"><code>show args</code></td>
<td align="center"></td>
<td align="left">显示缺省的参数列表</td>
</tr>
<tr>
<td align="center"><code>show language</code></td>
<td align="center"></td>
<td align="left">查看当前调试程序的语言环境,默认是c语言</td>
</tr>
<tr>
<td align="center"><code>info function</code></td>
<td align="center"></td>
<td align="left">查看当前函数的程序语言</td>
</tr>
<tr>
<td align="center"><code>set language c++</code></td>
<td align="center"></td>
<td align="left">手动设置当前的程序语言为c++</td>
</tr>
<tr>
<td align="center"><code>set language</code></td>
<td align="center"></td>
<td align="left">查看可以设置的程序语言</td>
</tr>
<tr>
<td align="center"><code>kill</code></td>
<td align="center"></td>
<td align="left">终止一个正在调试的程序</td>
</tr>
<tr>
<td align="center"><code>whatis var</code></td>
<td align="center"></td>
<td align="left">显示一个变量var的类型</td>
</tr>
<tr>
<td align="center"><code>ptype var</code></td>
<td align="center"></td>
<td align="left">以更详细的方式显示变量var的类型, 会打印出var的结构定义</td>
</tr>
<tr>
<td align="center"><code>info source</code></td>
<td align="center"></td>
<td align="left">显示当前的调试源文件</td>
</tr>
<tr>
<td align="center"><code>info locals</code></td>
<td align="center"><code>i locals</code></td>
<td align="left">查看当前程序栈的局部变量</td>
</tr>
<tr>
<td align="center"><code>info registers</code></td>
<td align="center"></td>
<td align="left">查看当前寄存器的值(不包括浮点寄存器)</td>
</tr>
<tr>
<td align="center"><code>info all-registers</code></td>
<td align="center"></td>
<td align="left">查看当前寄存器的值,包括浮点寄存器</td>
</tr>
<tr>
<td align="center"><code>info frame</code></td>
<td align="center"></td>
<td align="left">查看当前程序栈的信息</td>
</tr>
<tr>
<td align="center"><code>x/10x $sp</code></td>
<td align="center"></td>
<td align="left">查看当前程序栈的内容</td>
</tr>
<tr>
<td align="center"><code>display</code></td>
<td align="center"></td>
<td align="left">跟踪查看某个变量,每次停下来都显示它的值</td>
</tr>
<tr>
<td align="center"><code>[Enter]</code></td>
<td align="center"></td>
<td align="left">直接回车，执行上一步命令</td>
</tr>
<tr>
<td align="center"><code>quit</code></td>
<td align="center"><code>q</code></td>
<td align="left">退出gdb环境</td>
</tr>
</tbody></table>
<h4 id="list"><a href="#list" class="headerlink" title="list"></a>list</h4><p><code>list</code>默认显示当前行和之后的10行，再执行又下滚10行</p>
<p>list后可以使用不同参数：</p>
<ul>
<li><code>&lt;linenum&gt;</code> : 行号</li>
<li><code>&lt;+offset&gt;</code> : 当前行号的正偏移量</li>
<li><code>&lt;-offset&gt;</code> : 当前行号的负偏移量</li>
<li><code>&lt;filename:linenum&gt;</code> : 哪个文件的哪一行</li>
<li><code>&lt;function&gt;</code> : 函数名</li>
<li><code>&lt;filename:function&gt;</code> : 哪个文件中的哪个函数</li>
<li><code>&lt;*address&gt;</code> : 程序运行时的语句在内存中的地址</li>
</ul>
<h4 id="print"><a href="#print" class="headerlink" title="print"></a>print</h4><p><code>print</code>有打印显示变量（数组、结构体）与修改运行时变量的功能</p>
<ul>
<li><code>print /x var</code>: 用16进制显示(var)值<blockquote>
<p>print可以指定显示的格式，这里用’&#x2F;x’表示16进制的格式</p>
<ul>
<li><code>x</code>: 按十六进制格式显示变量。</li>
<li><code>d</code>: 按十进制格式显示变量。</li>
<li><code>u</code>: 按十六进制格式显示无符号整型。</li>
<li><code>o</code>: 按八进制格式显示变量。</li>
<li><code>t</code>: 按二进制格式显示变量。</li>
<li><code>a</code>: 按十六进制格式显示变量。</li>
<li><code>c</code>: 按字符格式显示变量。</li>
<li><code>f</code>: 按浮点数格式显示变量。</li>
</ul>
</blockquote>
</li>
</ul>
<p><strong>使用打印功能时：<code>var</code>可以是变量、数组、结构体</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">(gdb) print aa <span class="comment">//数组</span></span><br><span class="line">$<span class="number">1</span> = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">12</span>, <span class="number">33</span>, <span class="number">66</span>, <span class="number">12</span>, <span class="number">67</span>&#125;</span><br><span class="line">(gdb) print tst <span class="comment">//结构体</span></span><br><span class="line">$<span class="number">2</span> = &#123;a = <span class="number">11</span>, b = <span class="number">88</span>, c = <span class="number">44</span>&#125;</span><br><span class="line">(gdb) print i <span class="comment">//变量</span></span><br><span class="line">$<span class="number">3</span> = <span class="number">9</span></span><br><span class="line">(gdb) print /x i</span><br><span class="line">$<span class="number">4</span> = <span class="number">0x9</span></span><br><span class="line">(gdb) print /x tst</span><br><span class="line">$<span class="number">5</span> = &#123;a = <span class="number">0xb</span>, b = <span class="number">0x58</span>, c = <span class="number">0x2c</span>&#125;</span><br><span class="line">(gdb) print /x aa</span><br><span class="line">$<span class="number">6</span> = &#123;<span class="number">0x1</span>, <span class="number">0x3</span>, <span class="number">0x5</span>, <span class="number">0x6</span>, <span class="number">0xc</span>, <span class="number">0x21</span>, <span class="number">0x42</span>, <span class="number">0xc</span>, <span class="number">0x43</span>&#125;</span><br></pre></td></tr></table></figure>

<h4 id="打印内存地址"><a href="#打印内存地址" class="headerlink" title="打印内存地址"></a>打印内存地址</h4><p><code>x[/n] &lt;address&gt;</code>打印内存地址的值,n表示后面连续n个地址的值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) x/10 0x7ffffffee3c8</span><br><span class="line">0x7ffffffee3c8: 0xfffee5f7      0x00007fff      0x00000000      0x00000000</span><br><span class="line">0x7ffffffee3d8: 0xfffee60f      0x00007fff      0xfffeec01      0x00007fff</span><br><span class="line">0x7ffffffee3e8: 0xfffeec11      0x00007fff</span><br><span class="line">(gdb) x 0x7ffffffee3c8</span><br><span class="line">0x7ffffffee3c8: 0xfffee5f7</span><br></pre></td></tr></table></figure>

<h2 id="图形化gdb调试"><a href="#图形化gdb调试" class="headerlink" title="图形化gdb调试"></a>图形化gdb调试</h2><h3 id="cgdb"><a href="#cgdb" class="headerlink" title="cgdb"></a>cgdb</h3><p>cgdb是GNU调试器（GDB）的轻量级curses（基于终端）接口。 除了标准的gdb控制台之外，cgdb还提供了一个分屏视图，可以在执行时显示源代码。</p>
<blockquote>
<p>官网： <span class="exturl" data-url="aHR0cDovL2NnZGIuZ2l0aHViLmlvLw==">http://cgdb.github.io<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<p><img data-src="/images/2019/04/cgdb.png" alt="cgdb"></p>
<p>cgdb分为上下两栏，上面类似于vi窗口显示对应的代码，下面gdb窗口进行命令调试操作</p>
<h4 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h4><table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>ESC</code></td>
<td align="center">输入焦点进入VI窗口</td>
</tr>
<tr>
<td align="center"><code>i</code></td>
<td align="center">输入焦点进入gdb控制台</td>
</tr>
</tbody></table>
<h4 id="VI窗口"><a href="#VI窗口" class="headerlink" title="VI窗口"></a>VI窗口</h4><p>调试快捷键</p>
<table>
<thead>
<tr>
<th align="center">功能键</th>
<th align="left">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>F5</code></td>
<td align="left">Send a <code>run</code> command to GDB</td>
</tr>
<tr>
<td align="center"><code>F6</code></td>
<td align="left">Send a <code>continue</code> command to GDB</td>
</tr>
<tr>
<td align="center"><code>F7</code></td>
<td align="left">Send a <code>finish</code> command to GDB</td>
</tr>
<tr>
<td align="center"><code>F8</code></td>
<td align="left">Send a <code>next</code> command to GDB</td>
</tr>
<tr>
<td align="center"><code>F10</code></td>
<td align="left">Send a <code>step</code> command to GDB</td>
</tr>
</tbody></table>
<h4 id="控制台"><a href="#控制台" class="headerlink" title="控制台"></a>控制台</h4><p>进入控制台使用方法与gdb一样</p>
<h2 id="PS"><a href="#PS" class="headerlink" title="PS"></a>PS</h2><h3 id="查看线程CPU占用率"><a href="#查看线程CPU占用率" class="headerlink" title="查看线程CPU占用率"></a>查看线程CPU占用率</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ps H -eo user,pid,ppid,%cpu,cmd --sort=%cpu</span><br></pre></td></tr></table></figure>

<h2 id="VScode"><a href="#VScode" class="headerlink" title="VScode"></a>VScode</h2><p>gdb的图形化调试，方便</p>
<p><img data-src="/images/2019/06/vscode_debug.png" alt="vscode_debug"></p>
<h3 id="常用插件"><a href="#常用插件" class="headerlink" title="常用插件"></a>常用插件</h3><table>
<thead>
<tr>
<th align="center">插件</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">c-cpp-project-generator</td>
<td align="center">直接生成项目文件</td>
</tr>
<tr>
<td align="center">Chinese (Simplified)</td>
<td align="center">汉化</td>
</tr>
<tr>
<td align="center">CMake Tools</td>
<td align="center">cmake</td>
</tr>
<tr>
<td align="center">Code Runner</td>
<td align="center">结合WSL编译调试</td>
</tr>
</tbody></table>
<p>同步配置插件<code>Settings Sync</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CODE SETTINGS SYNC UPLOAD SUMMARY</span><br><span class="line">Version: 3.2.9</span><br><span class="line">--------------------</span><br><span class="line">GitHub Token: b7a56c3cf8a3a7739799e990fad4906ba2c4f324</span><br><span class="line">GitHub Gist: 3789cdfdf898124a04973b2e8feb0d74</span><br><span class="line">GitHub Gist Type: Secret</span><br><span class="line"></span><br><span class="line">Restarting Visual Studio Code may be required to apply color and file icon theme.</span><br></pre></td></tr></table></figure>

<h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><blockquote>
<p>配置文件：task.json</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    // See https://go.microsoft.com/fwlink/?LinkId=733558</span><br><span class="line">    // for the documentation about the tasks.json format</span><br><span class="line">    &quot;version&quot;: &quot;2.0.0&quot;,</span><br><span class="line">    &quot;tasks&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;label&quot;: &quot;build&quot;,</span><br><span class="line">            &quot;type&quot;: &quot;shell&quot;,</span><br><span class="line">            &quot;command&quot;: &quot;bash &amp;&amp; make&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><blockquote>
<p>配置文件：lanuch.json</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    // 使用 IntelliSense 了解相关属性。</span><br><span class="line">    // 悬停以查看现有属性的描述。</span><br><span class="line">    // 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387</span><br><span class="line">    &quot;version&quot;: &quot;0.2.0&quot;,</span><br><span class="line">    &quot;configurations&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;(gdb) Launch&quot;,</span><br><span class="line">            &quot;type&quot;: &quot;cppdbg&quot;,</span><br><span class="line">            &quot;request&quot;: &quot;launch&quot;,</span><br><span class="line">            &quot;program&quot;: &quot;/home/xxx/work/jpeg/jpeg_vgtp_tuning/build/bin/tunning_vgtp_codec&quot;,</span><br><span class="line">            &quot;args&quot;: [</span><br><span class="line">                &quot;-a&quot;, &quot;-f&quot;, &quot;/home/xxx/Pictures/test_yuv/app_JDshopping_1080p_30fps_444_295.yuv&quot;,</span><br><span class="line">                &quot;-r&quot;, &quot;1920x1080&quot;, &quot;-c&quot;, &quot;20&quot;, &quot;-s&quot;, &quot;0&quot;, &quot;-m&quot;, &quot;0&quot;</span><br><span class="line">            ],</span><br><span class="line">            &quot;stopAtEntry&quot;: true,</span><br><span class="line">            &quot;cwd&quot;: &quot;$&#123;workspaceFolder&#125;&quot;,</span><br><span class="line">            &quot;environment&quot;: [],</span><br><span class="line">            &quot;externalConsole&quot;: false,</span><br><span class="line">            &quot;MIMode&quot;: &quot;gdb&quot;,</span><br><span class="line">            &quot;setupCommands&quot;: [</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;description&quot;: &quot;Enable pretty-printing for gdb&quot;,</span><br><span class="line">                    &quot;text&quot;: &quot;-enable-pretty-printing&quot;,</span><br><span class="line">                    &quot;ignoreFailures&quot;: true</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>program</code>: 需要调试的程序（必须为完整程序路径，可以使用VSCode的环境变量）</li>
<li><code>args</code>: 启动时传递给程序的命令行参数的JSON数据。例如： [“arg1”, “arg2].</li>
<li><code>stopAtEntry</code>: 是否停在程序入口点（停在main函数开始）</li>
<li><code>cwd</code>: 设置调试器启动的应用程序的工作目录。</li>
<li><code>environment</code>: 针对调试的程序，要添加到环境中的环境变量. 例如: [ { “name”: “squid”, “value”: “clam” } ]。</li>
<li><code>MIMode</code>:指定连接的调试器，只可以为gdb或lldb</li>
<li><code>miDebuggerPath</code>： 指定gdb路径</li>
</ul>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><h4 id="设置断点失效"><a href="#设置断点失效" class="headerlink" title="设置断点失效"></a>设置断点失效</h4><blockquote>
<p>检查编译时，是否添加<code>-g</code>选项</p>
</blockquote>
<h4 id="Win10使用WSL"><a href="#Win10使用WSL" class="headerlink" title="Win10使用WSL"></a>Win10使用WSL</h4><p>安装插件<code>Code Runner</code></p>
<blockquote>
<p>launch.json</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;version&quot;: &quot;0.2.0&quot;,</span><br><span class="line">    &quot;configurations&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;(gdb) Bash on Windows Launch&quot;,</span><br><span class="line">            &quot;type&quot;: &quot;cppdbg&quot;,</span><br><span class="line">            &quot;request&quot;: &quot;launch&quot;,</span><br><span class="line">            &quot;program&quot;: &quot;/mnt/c/Users/Administrator/Desktop/test/bin/main&quot;,</span><br><span class="line">            &quot;args&quot;: [],</span><br><span class="line">            &quot;stopAtEntry&quot;: true,</span><br><span class="line">            &quot;cwd&quot;: &quot;/mnt/c/Users/Administrator/Desktop/test&quot;,</span><br><span class="line">            &quot;environment&quot;: [],</span><br><span class="line">            &quot;externalConsole&quot;: true,</span><br><span class="line">            &quot;pipeTransport&quot;: &#123;</span><br><span class="line">                &quot;debuggerPath&quot;: &quot;/usr/bin/gdb&quot;,</span><br><span class="line">                &quot;pipeProgram&quot;: &quot;$&#123;env:windir&#125;\\system32\\bash.exe&quot;,</span><br><span class="line">                &quot;pipeArgs&quot;: [&quot;-c&quot;],</span><br><span class="line">                &quot;pipeCwd&quot;: &quot;&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">             &quot;sourceFileMap&quot;: &#123;</span><br><span class="line">                &quot;/mnt/c&quot;: &quot;c:\\&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;setupCommands&quot;: [</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;description&quot;: &quot;Enable pretty-printing for gdb&quot;,</span><br><span class="line">                    &quot;text&quot;: &quot;-enable-pretty-printing&quot;,</span><br><span class="line">                    &quot;ignoreFailures&quot;: true</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="gdb-dashboard"><a href="#gdb-dashboard" class="headerlink" title="gdb-dashboard"></a>gdb-dashboard</h2><blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2N5cnVzLWFuZC9nZGItZGFzaGJvYXJk">https://github.com/cyrus-and/gdb-dashboard<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<p><img data-src="https://raw.githubusercontent.com/wiki/cyrus-and/gdb-dashboard/Screenshot.png" alt="gdb-dashboard Screenshot"></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pjc2hvdWNzZG4vYXJ0aWNsZS9kZXRhaWxzLzYwNDY2NzA3">Visual Studio Code （VSCode） 之 C&#x2F;C++ 调试配置详解<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>Linux内核</category>
      </categories>
      <tags>
        <tag>kernel</tag>
        <tag>debug</tag>
      </tags>
  </entry>
  <entry>
    <title>arm64下内核crash——非法地址</title>
    <url>/post/774c4289.html</url>
    <content><![CDATA[<p>下面是在实际工作中遇到的一次内核（5.4.110）访问非法内存地址（空指针）导致出错的现场，在这里记录一下简单的分析流程为以后遇到类似的问题作为参考。</p>
<span id="more"></span>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[  220.619861] Unable to handle kernel NULL pointer dereference at virtual address 0000000000000023</span><br><span class="line">[  220.628815] Mem abort info:</span><br><span class="line">[  220.631737]   ESR = 0x96000006</span><br><span class="line">[  220.634932]   EC = 0x25: DABT (current EL), IL = 32 bits</span><br><span class="line">[  220.640369]   SET = 0, FnV = 0</span><br><span class="line">[  220.643542]   EA = 0, S1PTW = 0</span><br><span class="line">[  220.646788] Data abort info:</span><br><span class="line">[  220.649783]   ISV = 0, ISS = 0x00000006</span><br><span class="line">[  220.653737]   CM = 0, WnR = 0</span><br><span class="line">[  220.656855] user pgtable: 4k pages, 39-bit VAs, pgdp=000000001149c000</span><br><span class="line">[  220.663422] [0000000000000023] pgd=00000000080dc003, pud=00000000080dc003, pmd=0000000000000000</span><br><span class="line">[  220.672360] Internal error: Oops: 96000006 [#1] SMP</span><br><span class="line">[  220.677359] Modules linked in:</span><br><span class="line">[  220.680627] CPU: 0 PID: 0 Comm: swapper/0 Not tainted 5.4.110-00126-gad9975d0488d-dirty #1</span><br><span class="line">[  220.689008] Hardware name: van_xum,tequila (DT)</span><br><span class="line">[  220.693614] pstate: 20000085 (nzCv daIf -PAN -UAO)</span><br><span class="line">[  220.698626] pc : dwc_descriptor_complete+0x104/0x140</span><br><span class="line">[  220.703775] lr : dwc_descriptor_complete+0x48/0x140</span><br><span class="line">[  220.708772] sp : ffffffc010003d00</span><br><span class="line">[  220.712203] x29: ffffffc010003d00 x28: 0000000000000006</span><br><span class="line">[  220.717699] x27: 0000000000000100 x26: 000000000000000a</span><br><span class="line">[  220.723192] x25: ffffffc010b3363b x24: ffffff80102a3080</span><br><span class="line">[  220.728684] x23: 0000000000000001 x22: ffffff8010104860</span><br><span class="line">[  220.734172] x21: 0000000000000000 x20: ffffff80101047f0</span><br><span class="line">[  220.739664] x19: ffffffc010ed6460 x18: 0000000000000000</span><br><span class="line">[  220.745152] x17: 0000000000000000 x16: 0000000000000000</span><br><span class="line">[  220.750635] x15: 0000000000000000 x14: 0000000000000000</span><br><span class="line">[  220.756117] x13: 0000000000000000 x12: 0000000000000000</span><br><span class="line">[  220.761603] x11: 0000000000000000 x10: ffffffc010d329d8</span><br><span class="line">[  220.767093] x9 : 0000000000000005 x8 : ffffffc010d329b8</span><br><span class="line">[  220.772582] x7 : 0000000000000000 x6 : 0000000000000000</span><br><span class="line">[  220.778067] x5 : 0000000000000000 x4 : 0000000000000000</span><br><span class="line">[  220.783555] x3 : ffffffc010ed64a0 x2 : ffffffffffffffdf</span><br><span class="line">[  220.789048] x1 : ffffffffffffffff x0 : ffffffc010ed6490</span><br><span class="line">[  220.794528] Call trace:</span><br><span class="line">[  220.797177]  dwc_descriptor_complete+0x104/0x140</span><br><span class="line">[  220.801978]  dwc_scan_descriptors+0x1e4/0x32c</span><br><span class="line">[  220.806510]  dw_dma_tasklet+0x37c/0x380</span><br><span class="line">[  220.810551]  tasklet_action_common.constprop.0+0xb0/0x10c</span><br><span class="line">[  220.816140]  tasklet_action+0x34/0x40</span><br><span class="line">[  220.819966]  __do_softirq+0x1e8/0x2b8</span><br><span class="line">[  220.823810]  irq_exit+0x64/0xb4</span><br><span class="line">[  220.827134]  __handle_domain_irq+0x7c/0xa8</span><br><span class="line">[  220.831394]  gic_handle_irq+0x84/0xc8</span><br><span class="line">[  220.835213]  el1_irq+0xb8/0x140</span><br><span class="line">[  220.838536]  arch_local_irq_enable+0x8/0x10</span><br><span class="line">[  220.842908]  finish_task_switch+0x10c/0x194</span><br><span class="line">[  220.847250]  __schedule+0x3f0/0x530</span><br><span class="line">[  220.850893]  schedule_idle+0x34/0x48</span><br><span class="line">[  220.854640]  do_idle+0x94/0x268</span><br><span class="line">[  220.857955]  cpu_startup_entry+0x2c/0x48</span><br><span class="line">[  220.862068]  rest_init+0xc8/0xd8</span><br><span class="line">[  220.865489]  arch_call_rest_init+0x18/0x20</span><br><span class="line">[  220.869769]  start_kernel+0x448/0x480</span><br><span class="line">[  220.873658] Code: 97f276b0 a9057fff f90033ff 17ffffe2 (b9404441)</span><br><span class="line">[  220.879910] ---[ end trace 6df1a29c28ae9694 ]---</span><br><span class="line">[  220.884668] Kernel panic - not syncing: Fatal exception in interrupt</span><br><span class="line">[  220.891172] SMP: stopping secondary CPUs</span><br><span class="line">[  220.895297] Kernel Offset: disabled</span><br><span class="line">[  220.898920] CPU features: 0x0002,20002004</span><br><span class="line">[  220.903036] Memory Limit: none</span><br><span class="line">[  220.906301] ---[ end Kernel panic - not syncing: Fatal exception in interrupt ]---</span><br></pre></td></tr></table></figure>
<blockquote>
<p>该问题初步分析是进行DMA传输时，可能将函数调用栈信息冲掉所致</p>
</blockquote>
<h2 id="dump信息说明"><a href="#dump信息说明" class="headerlink" title="dump信息说明"></a>dump信息说明</h2><ul>
<li><code>pc</code>：（Program Counter）pc指针，记录当前执行哪一条指令；存储当前CPU正在执行指令的地址</li>
<li><code>lr</code>：（Link Register）<code>x30</code>寄存器，保存函数返回地址</li>
<li><code>sp</code>：（Stack Pointer）栈指针</li>
<li><code>fp</code>：（Frame Pointer）<code>x29</code>寄存器</li>
</ul>
<h2 id="根据dump出的函数调用定位具体出错的代码"><a href="#根据dump出的函数调用定位具体出错的代码" class="headerlink" title="根据dump出的函数调用定位具体出错的代码"></a>根据dump出的函数调用定位具体出错的代码</h2><p>最终出错代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pc : dwc_descriptor_complete+0x104/0x140</span><br></pre></td></tr></table></figure>
<p>gdb定位具体代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">$aarch64-none-linux-gnu-gdb <span class="title function_">vmlinux</span></span><br><span class="line"></span><br><span class="line"><span class="params">(gdb)</span> <span class="built_in">list</span> *<span class="params">(dwc_descriptor_complete+<span class="number">0x104</span>)</span></span><br><span class="line">0xffffffc01040f7c8 is in <span class="title function_">dwc_descriptor_complete</span> <span class="params">(./include/linux/dmaengine.h:<span class="number">1189</span>)</span>.</span><br><span class="line">1184	<span class="type">void</span> <span class="title function_">dma_async_tx_descriptor_init</span><span class="params">(<span class="keyword">struct</span> dma_async_tx_descriptor *tx,</span></span><br><span class="line"><span class="params"><span class="number">1185</span>					  <span class="keyword">struct</span> dma_chan *chan)</span>;</span><br><span class="line"><span class="number">1186</span></span><br><span class="line"><span class="number">1187</span>	<span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">async_tx_ack</span><span class="params">(<span class="keyword">struct</span> dma_async_tx_descriptor *tx)</span></span><br><span class="line">1188	&#123;</span><br><span class="line"><span class="number">1189</span>		tx-&gt;flags |= DMA_CTRL_ACK;    <span class="comment">//在进行flags赋值是出错，也就是tx出现空指针</span></span><br><span class="line"><span class="number">1190</span>	&#125;</span><br><span class="line"><span class="number">1191</span></span><br><span class="line"><span class="number">1192</span>	<span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">async_tx_clear_ack</span><span class="params">(<span class="keyword">struct</span> dma_async_tx_descriptor *tx)</span></span><br><span class="line">1193	&#123;</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure>

<h2 id="定位具体出错指令"><a href="#定位具体出错指令" class="headerlink" title="定位具体出错指令"></a>定位具体出错指令</h2><p>由于出错的接口函数中只是一个普通的赋值操作，因此需要进一步确认出错时，CPU执行的汇编指令是否存在异常或者特殊性</p>
<p>查看<code>dwc_descriptor_complete</code>接口函数的汇编实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">(gdb) disassemble dwc_descriptor_complete</span><br><span class="line">Dump of assembler code <span class="keyword">for</span> function dwc_descriptor_complete:</span><br><span class="line">   <span class="number">0xffffffc01040f6c4</span> &lt;+<span class="number">0</span>&gt;:	stp	x29, x30, [sp, #<span class="number">-112</span>]!</span><br><span class="line">   <span class="number">0xffffffc01040f6c8</span> &lt;+<span class="number">4</span>&gt;:	mov	x29, sp</span><br><span class="line">   <span class="number">0xffffffc01040f6cc</span> &lt;+<span class="number">8</span>&gt;:	stp	x19, x20, [sp, #<span class="number">16</span>]</span><br><span class="line">   <span class="number">0xffffffc01040f6d0</span> &lt;+<span class="number">12</span>&gt;:	stp	x21, x22, [sp, #<span class="number">32</span>]</span><br><span class="line">   <span class="number">0xffffffc01040f6d4</span> &lt;+<span class="number">16</span>&gt;:	str	x23, [sp, #<span class="number">48</span>]</span><br><span class="line">   <span class="number">0xffffffc01040f6d8</span> &lt;+<span class="number">20</span>&gt;:	xpaclri</span><br><span class="line">   <span class="number">0xffffffc01040f6dc</span> &lt;+<span class="number">24</span>&gt;:	mov	x19, x1     <span class="comment">//第二个入参被转存到x19  &lt;------------------ [6]</span></span><br><span class="line">   <span class="number">0xffffffc01040f6e0</span> &lt;+<span class="number">28</span>&gt;:	mov	x20, x0</span><br><span class="line">   <span class="number">0xffffffc01040f6e4</span> &lt;+<span class="number">32</span>&gt;:	and	w23, w2, #<span class="number">0xff</span></span><br><span class="line">   <span class="number">0xffffffc01040f6e8</span> &lt;+<span class="number">36</span>&gt;:	mov	x0, x30</span><br><span class="line">   <span class="number">0xffffffc01040f6ec</span> &lt;+<span class="number">40</span>&gt;:	bl	<span class="number">0xffffffc01009647c</span> &lt;_mcount&gt;</span><br><span class="line">   <span class="number">0xffffffc01040f6f0</span> &lt;+<span class="number">44</span>&gt;:	mrs	x0, sp_el0</span><br><span class="line">   <span class="number">0xffffffc01040f6f4</span> &lt;+<span class="number">48</span>&gt;:	add	x22, x20, #<span class="number">0x70</span></span><br><span class="line">   <span class="number">0xffffffc01040f6f8</span> &lt;+<span class="number">52</span>&gt;:	ldr	x1, [x0, #<span class="number">1240</span>]</span><br><span class="line">   <span class="number">0xffffffc01040f6fc</span> &lt;+<span class="number">56</span>&gt;:	str	x1, [sp, #<span class="number">104</span>]</span><br><span class="line">   <span class="number">0xffffffc01040f700</span> &lt;+<span class="number">60</span>&gt;:	mov	x1, #<span class="number">0x0</span>                   	<span class="comment">// #0</span></span><br><span class="line">   <span class="number">0xffffffc01040f704</span> &lt;+<span class="number">64</span>&gt;:	mov	x0, x22</span><br><span class="line">   <span class="number">0xffffffc01040f708</span> &lt;+<span class="number">68</span>&gt;:	bl	<span class="number">0xffffffc01093b10c</span> &lt;_raw_spin_lock_irqsave&gt;</span><br><span class="line">   <span class="number">0xffffffc01040f70c</span> &lt;+<span class="number">72</span>&gt;:	mov	x21, x0</span><br><span class="line">   <span class="number">0xffffffc01040f710</span> &lt;+<span class="number">76</span>&gt;:	ldr	w0, [x19, #<span class="number">64</span>]   <span class="comment">// 第二个入参的第一次使用 ( dma_cookie_complete(txd);) &lt;------- [7]</span></span><br><span class="line">   <span class="number">0xffffffc01040f714</span> &lt;+<span class="number">80</span>&gt;:	add	x3, x19, #<span class="number">0x40</span>   <span class="comment">//x3=x19+0x40, 0xffffffc010ed6460+0x40=0xffffffc010ed64a0</span></span><br><span class="line">   <span class="number">0xffffffc01040f718</span> &lt;+<span class="number">84</span>&gt;:	cmp	w0, #<span class="number">0x0</span></span><br><span class="line">   <span class="number">0xffffffc01040f71c</span> &lt;+<span class="number">88</span>&gt;:	b.gt	<span class="number">0xffffffc01040f724</span> &lt;dwc_descriptor_complete+<span class="number">96</span>&gt;  <span class="comment">//判断w0大于0时，进行跳转</span></span><br><span class="line">   <span class="number">0xffffffc01040f720</span> &lt;+<span class="number">92</span>&gt;:	brk	#<span class="number">0x800</span></span><br><span class="line">   <span class="number">0xffffffc01040f724</span> &lt;+<span class="number">96</span>&gt;:	ldr	x1, [x3, #<span class="number">16</span>]</span><br><span class="line">   <span class="number">0xffffffc01040f728</span> &lt;+<span class="number">100</span>&gt;:	str	w0, [x1, #<span class="number">12</span>]</span><br><span class="line">   <span class="number">0xffffffc01040f72c</span> &lt;+<span class="number">104</span>&gt;:	str	wzr, [x19, #<span class="number">64</span>]</span><br><span class="line">   <span class="number">0xffffffc01040f730</span> &lt;+<span class="number">108</span>&gt;:	cbz	w23, <span class="number">0xffffffc01040f7bc</span> &lt;dwc_descriptor_complete+<span class="number">248</span>&gt; <span class="comment">//比较w23为0，进行跳转，w23应该是传入的第三个参数</span></span><br><span class="line">   <span class="number">0xffffffc01040f734</span> &lt;+<span class="number">112</span>&gt;:	ldr	x0, [x3, #<span class="number">40</span>]</span><br><span class="line">   <span class="number">0xffffffc01040f738</span> &lt;+<span class="number">116</span>&gt;:	str	x0, [sp, #<span class="number">80</span>]</span><br><span class="line">   <span class="number">0xffffffc01040f73c</span> &lt;+<span class="number">120</span>&gt;:	ldr	x0, [x3, #<span class="number">48</span>]</span><br><span class="line">   <span class="number">0xffffffc01040f740</span> &lt;+<span class="number">124</span>&gt;:	str	x0, [sp, #<span class="number">88</span>]</span><br><span class="line">   <span class="number">0xffffffc01040f744</span> &lt;+<span class="number">128</span>&gt;:	ldr	x0, [x3, #<span class="number">56</span>]</span><br><span class="line">   <span class="number">0xffffffc01040f748</span> &lt;+<span class="number">132</span>&gt;:	str	x0, [sp, #<span class="number">96</span>]</span><br><span class="line">   <span class="number">0xffffffc01040f74c</span> &lt;+<span class="number">136</span>&gt;:	mov	x0, x19          <span class="comment">//将x19赋值到x0    &lt;---------------- [5]</span></span><br><span class="line">   <span class="number">0xffffffc01040f750</span> &lt;+<span class="number">140</span>&gt;:	ldr	x2, [x0, #<span class="number">48</span>]!   <span class="comment">//x2=*(x0 + 0x30),读取内存地址的值赋值x2  &lt;-------------- [4]</span></span><br><span class="line">   <span class="number">0xffffffc01040f754</span> &lt;+<span class="number">144</span>&gt;:	sub	x2, x2, #<span class="number">0x20</span>    <span class="comment">//x2第一次处理，x2减0x20 （&amp;desc-&gt;tx_list） &lt;------------- [3]</span></span><br><span class="line">   <span class="number">0xffffffc01040f758</span> &lt;+<span class="number">148</span>&gt;:	add	x1, x2, #<span class="number">0x20</span>    <span class="comment">//x1是在x2基础上又加了0x20,因此变成了全F</span></span><br><span class="line">   <span class="number">0xffffffc01040f75c</span> &lt;+<span class="number">152</span>&gt;:	cmp	x1, x0</span><br><span class="line">   <span class="number">0xffffffc01040f760</span> &lt;+<span class="number">156</span>&gt;:	b.ne	<span class="number">0xffffffc01040f7c8</span> &lt;dwc_descriptor_complete+<span class="number">260</span>&gt;  <span class="comment">// b.any x1不对于x0时，跳转执行 &lt;----------- [2]</span></span><br><span class="line">   <span class="number">0xffffffc01040f764</span> &lt;+<span class="number">160</span>&gt;:	ldr	w0, [x3, #<span class="number">4</span>]</span><br><span class="line">   <span class="number">0xffffffc01040f768</span> &lt;+<span class="number">164</span>&gt;:	mov	x1, x19</span><br><span class="line"></span><br><span class="line">   ....</span><br><span class="line">   <span class="number">0xffffffc01040f7ac</span> &lt;+<span class="number">232</span>&gt;:	subs	x1, x1, x2</span><br><span class="line">   <span class="number">0xffffffc01040f7b0</span> &lt;+<span class="number">236</span>&gt;:	mov	x2, #<span class="number">0x0</span>                   	<span class="comment">// #0</span></span><br><span class="line">   <span class="number">0xffffffc01040f7b4</span> &lt;+<span class="number">240</span>&gt;:	b.eq	<span class="number">0xffffffc01040f7f0</span> &lt;dwc_descriptor_complete+<span class="number">300</span>&gt;  <span class="comment">// b.none</span></span><br><span class="line">   <span class="number">0xffffffc01040f7b8</span> &lt;+<span class="number">244</span>&gt;:	bl	<span class="number">0xffffffc0100ad278</span> &lt;__stack_chk_fail&gt;</span><br><span class="line">   <span class="number">0xffffffc01040f7bc</span> &lt;+<span class="number">248</span>&gt;:	stp	xzr, xzr, [sp, #<span class="number">80</span>]</span><br><span class="line">   <span class="number">0xffffffc01040f7c0</span> &lt;+<span class="number">252</span>&gt;:	str	xzr, [sp, #<span class="number">96</span>]</span><br><span class="line">   <span class="number">0xffffffc01040f7c4</span> &lt;+<span class="number">256</span>&gt;:	b	<span class="number">0xffffffc01040f74c</span> &lt;dwc_descriptor_complete+<span class="number">136</span>&gt;</span><br><span class="line">   <span class="number">0xffffffc01040f7c8</span> &lt;+<span class="number">260</span>&gt;:	ldr	w1, [x2, #<span class="number">68</span>]  <span class="comment">// 出错指令 w1=*(x2 + 0x44) &lt;----------- [1]</span></span><br><span class="line">   <span class="number">0xffffffc01040f7cc</span> &lt;+<span class="number">264</span>&gt;:	orr	w1, w1, #<span class="number">0x2</span></span><br><span class="line">   <span class="number">0xffffffc01040f7d0</span> &lt;+<span class="number">268</span>&gt;:	str	w1, [x2, #<span class="number">68</span>]</span><br><span class="line">   <span class="number">0xffffffc01040f7d4</span> &lt;+<span class="number">272</span>&gt;:	ldr	x2, [x2, #<span class="number">32</span>]</span><br><span class="line">   ....</span><br></pre></td></tr></table></figure>

<ul>
<li>[1]: 此处为具体出错指令，意思是将寄存器X2中的值加上68后作为内存地址，并将该内存地址的数据取出，存到w1寄存器中。非法内存地址也就是X2加68（0x44）得到的，根据crash dump出的寄存器值此时<code>X2=ffffffffffffffdf</code>，0xffffffffffffffdf+0x44&#x3D;<code>0x0000000000000023</code>刚好是非法内存地址，也就是说出错的因为<code>x2</code>寄存器的值保存错了。</li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
<p>以上流程中表明<code>x2</code>寄存器出现<code>FFFFFFFFFFFFFFFF</code>的可能性存在两种：</p>
<ol>
<li>dwc_descriptor_complete接口函数传参时，第二个参数是个错误的指针。这样就会使<code>x0</code>寄存器错误导致在<a href="%60x2%60%EF%BC%88FFFFFFFFFFFFFFFF%EF%BC%89%E6%98%AF%E9%80%9A%E8%BF%87%60x0%60%E5%AF%84%E5%AD%98%E5%99%A8%E7%9A%84%E5%80%BC%E5%8A%A048%E5%90%8E%E7%9A%84%E8%BF%99%E4%B8%AA%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80%E4%B8%AD%E8%AF%BB%E5%8F%96%E5%87%BA%E7%9A%84%E3%80%82">4</a>时，通过内存地址读取数据赋值该<code>x2</code>时，出现全F的值（一个错误的指针指向了错误的内存区域所致）。<ul>
<li>由于在[7]处对第二个参数已经使用过（读写），因此可以证明传入的第二个参数指针是正确的。如果错误应该会在[7]处直接报错。</li>
</ul>
</li>
<li>dwc_descriptor_complete接口函数传参时，第二个参数是正确的。但是在<a href="%60x2%60%EF%BC%88FFFFFFFFFFFFFFFF%EF%BC%89%E6%98%AF%E9%80%9A%E8%BF%87%60x0%60%E5%AF%84%E5%AD%98%E5%99%A8%E7%9A%84%E5%80%BC%E5%8A%A048%E5%90%8E%E7%9A%84%E8%BF%99%E4%B8%AA%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80%E4%B8%AD%E8%AF%BB%E5%8F%96%E5%87%BA%E7%9A%84%E3%80%82">4</a>时，通过内存地址读取数据赋值给<code>x2</code>时，原来正确的数据被别的程序覆盖掉了（踩内存）</li>
</ol>
<p>** 通过以上流程的分析我认为是在<a href="%60x2%60%EF%BC%88FFFFFFFFFFFFFFFF%EF%BC%89%E6%98%AF%E9%80%9A%E8%BF%87%60x0%60%E5%AF%84%E5%AD%98%E5%99%A8%E7%9A%84%E5%80%BC%E5%8A%A048%E5%90%8E%E7%9A%84%E8%BF%99%E4%B8%AA%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80%E4%B8%AD%E8%AF%BB%E5%8F%96%E5%87%BA%E7%9A%84%E3%80%82">4</a>处，读取相关内存地址中的数据时，原有的正确数据被错误数据覆盖 **</p>
<p>C源码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">(gdb) <span class="built_in">list</span> dwc_descriptor_complete</span><br><span class="line"><span class="number">271</span>	<span class="comment">/*----------------------------------------------------------------------*/</span></span><br><span class="line"><span class="number">272</span></span><br><span class="line"><span class="number">273</span>	<span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="number">274</span>	dwc_descriptor_complete(<span class="keyword">struct</span> dw_dma_chan *dwc, <span class="keyword">struct</span> dw_desc *desc,</span><br><span class="line"><span class="number">275</span>			<span class="type">bool</span> callback_required)</span><br><span class="line"><span class="number">276</span>	&#123;</span><br><span class="line"><span class="number">277</span>		<span class="class"><span class="keyword">struct</span> <span class="title">dma_async_tx_descriptor</span>	*<span class="title">txd</span> =</span> &amp;desc-&gt;txd;</span><br><span class="line"><span class="number">278</span>		<span class="class"><span class="keyword">struct</span> <span class="title">dw_desc</span>			*<span class="title">child</span>;</span></span><br><span class="line"><span class="number">279</span>		<span class="type">unsigned</span> <span class="type">long</span>			flags;</span><br><span class="line"><span class="number">280</span>		<span class="class"><span class="keyword">struct</span> <span class="title">dmaengine_desc_callback</span>	<span class="title">cb</span>;</span></span><br><span class="line">(gdb)</span><br><span class="line"><span class="number">281</span></span><br><span class="line"><span class="number">282</span>		dev_vdbg(chan2dev(&amp;dwc-&gt;chan), <span class="string">&quot;descriptor %u complete\n&quot;</span>, txd-&gt;cookie);</span><br><span class="line"><span class="number">283</span></span><br><span class="line"><span class="number">284</span>		spin_lock_irqsave(&amp;dwc-&gt;lock, flags);</span><br><span class="line"><span class="number">285</span>		dma_cookie_complete(txd);</span><br><span class="line"><span class="number">286</span>		<span class="keyword">if</span> (callback_required)</span><br><span class="line"><span class="number">287</span>			dmaengine_desc_get_callback(txd, &amp;cb);</span><br><span class="line"><span class="number">288</span>		<span class="keyword">else</span></span><br><span class="line"><span class="number">289</span>			<span class="built_in">memset</span>(&amp;cb, <span class="number">0</span>, <span class="keyword">sizeof</span>(cb));</span><br><span class="line"><span class="number">290</span></span><br><span class="line">(gdb)</span><br><span class="line"><span class="number">291</span>		<span class="comment">/* async_tx_ack */</span></span><br><span class="line"><span class="number">292</span>		list_for_each_entry(child, &amp;desc-&gt;tx_list, desc_node)</span><br><span class="line"><span class="number">293</span>			async_tx_ack(&amp;child-&gt;txd);</span><br><span class="line"><span class="number">294</span>		async_tx_ack(&amp;desc-&gt;txd);</span><br><span class="line"><span class="number">295</span>		dwc_desc_put(dwc, desc);</span><br><span class="line"><span class="number">296</span>		spin_unlock_irqrestore(&amp;dwc-&gt;lock, flags);</span><br><span class="line"><span class="number">297</span></span><br><span class="line"><span class="number">298</span>		dmaengine_desc_callback_invoke(&amp;cb, <span class="literal">NULL</span>);</span><br><span class="line"><span class="number">299</span>	&#125;</span><br><span class="line"><span class="number">300</span></span><br></pre></td></tr></table></figure>

<p>通过对以上汇编代码的分析出错的原因主要是<code>[4]</code>,读取内存数据（ldr	x2, [x0, #48]!）时出错。该指令对应的C代码实现主要在<code>list_for_each_entry(child, &amp;desc-&gt;tx_list, desc_node)</code>接口</p>
<p>这样结合之前分析的出错原因，可能是别的程序写内存时覆盖了tx_list链表数据（踩内存）；不过还存在一种可能就是tx_list的操作出错了，由dma驱动代码本身所造成的bug。</p>
<h2 id="MMU错误信息"><a href="#MMU错误信息" class="headerlink" title="MMU错误信息"></a>MMU错误信息</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">[  <span class="number">220.619861</span>] Unable to handle kernel <span class="literal">NULL</span> pointer dereference at virtual address <span class="number">0000000000000023</span></span><br><span class="line"><span class="comment">// 解析ESR_EL1寄存器</span></span><br><span class="line">[  <span class="number">220.628815</span>] Mem <span class="built_in">abort</span> info:</span><br><span class="line">[  <span class="number">220.631737</span>]   ESR = <span class="number">0x96000006</span></span><br><span class="line">[  <span class="number">220.634932</span>]   EC = <span class="number">0x25</span>: DABT (current EL), IL = <span class="number">32</span> bits</span><br><span class="line">[  <span class="number">220.640369</span>]   SET = <span class="number">0</span>, FnV = <span class="number">0</span></span><br><span class="line">[  <span class="number">220.643542</span>]   EA = <span class="number">0</span>, S1PTW = <span class="number">0</span></span><br><span class="line">[  <span class="number">220.646788</span>] Data <span class="built_in">abort</span> info:</span><br><span class="line">[  <span class="number">220.649783</span>]   ISV = <span class="number">0</span>, ISS = <span class="number">0x00000006</span></span><br><span class="line">[  <span class="number">220.653737</span>]   CM = <span class="number">0</span>, WnR = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">[  <span class="number">220.656855</span>] user pgtable: <span class="number">4</span>k pages, <span class="number">39</span>-bit VAs, pgdp=<span class="number">000000001149</span>c000</span><br><span class="line">[  <span class="number">220.663422</span>] [<span class="number">0000000000000023</span>] pgd=<span class="number">00000000080</span>dc003, pud=<span class="number">00000000080</span>dc003, pmd=<span class="number">0000000000000000</span></span><br><span class="line">[  <span class="number">220.672360</span>] Internal error: Oops: <span class="number">96000006</span> [#<span class="number">1</span>] SMP</span><br></pre></td></tr></table></figure>

<p>以上信息主要是在内核出现<code>do_page_fault</code>时的一些log信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">do_page_fault</span><br><span class="line">  \-&gt;__do_kernel_fault</span><br><span class="line">    \-&gt;die_kernel_fault</span><br><span class="line">      \-&gt;mem_abort_decode</span><br><span class="line">        \-&gt;data_abort_decode</span><br><span class="line">      \-&gt;show_pte</span><br><span class="line">      \-&gt;die(Oops)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>from: arch&#x2F;arm64&#x2F;mm&#x2F;fault.c</p>
</blockquote>
<p><code>mem_abort_decode</code>函数主要是解析<code>ESR_ELx</code>寄存器，在内核模式下为<code>ESR_EL1</code></p>
<p><img data-src="/images/2021/12/arm64_esr_el1.png" alt="arm64_ESR_EL1"></p>
<blockquote>
<p>参考：DDI0487D_a_armv8_arm.pdf —— D12.2.36 ESR_EL1, Exception Syndrome Register (EL1)</p>
</blockquote>
<p><code>EC, bits [31:26]</code>,  EC &#x3D; 0x25， DABT (current EL)，异常级别未更改的数据中止。用于数据访问产生的MMU错误、除堆栈指针未对齐引起的对齐错误和同步外部中止（包括同步奇偶校验或ECC错误）之外的对齐错误。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EC == 0b010101</span><br><span class="line">  SVC instruction execution in AArch64 state.</span><br><span class="line">  See ISS encoding for an exception from HVC or SVC instruction execution on</span><br><span class="line">  page D12-2785.</span><br><span class="line"></span><br><span class="line">EC == 0b100101</span><br><span class="line">  Data Abort taken without a change in Exception level.</span><br><span class="line">  Used for MMU faults generated by data accesses, alignment faults other than those</span><br><span class="line">  caused by Stack Pointer misalignment, and synchronous External aborts, including</span><br><span class="line">  synchronous parity or ECC errors. Not used for debug related exceptions.</span><br><span class="line">  See ISS encoding for an exception from a Data Abort.</span><br></pre></td></tr></table></figure>

<ul>
<li>SVC：Supervisor Call instruction</li>
</ul>
<h2 id="gdb调试vmlinux技巧"><a href="#gdb调试vmlinux技巧" class="headerlink" title="gdb调试vmlinux技巧"></a>gdb调试vmlinux技巧</h2><h3 id="查看特定位置的代码"><a href="#查看特定位置的代码" class="headerlink" title="查看特定位置的代码"></a>查看特定位置的代码</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) list * [函数名]或[函数名+函数内偏移]</span><br></pre></td></tr></table></figure>

<p>命令： <code>list</code>或<code>l</code> 列出指定的函数或行<br>格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">list [FUNCTION/*ADDRESS]</span><br></pre></td></tr></table></figure>
<ul>
<li><code>LINENUM</code>，在当前文件中围绕该行列出，</li>
<li><code>FILE:LINENUM</code>，列出该文件中的该行，</li>
<li><code>FUNCTION</code>，列出该函数的开头，</li>
<li><code>FILE:FUNCTION</code>，用于区分同名的静态函数。</li>
<li><code>*ADDRESS</code>，在包含该地址的行周围列出。</li>
</ul>
<h3 id="查看特定函数的汇编实现"><a href="#查看特定函数的汇编实现" class="headerlink" title="查看特定函数的汇编实现"></a>查看特定函数的汇编实现</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">disassemble [函数名]</span><br></pre></td></tr></table></figure>

<p>命令： <code>disassemble</code> 反汇编内存地址部分（也可以用函数名）<br>格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">disassemble[/m|/r|/s] START [, END]</span><br></pre></td></tr></table></figure>
<ul>
<li><code>/m</code>: 被弃用了推荐使用<code>/s</code></li>
<li><code>/r</code>: 包含十六进制的原始指令。</li>
<li><code>/s</code>: 包括源代码行（如果可用）。 在此模式下，输出按PC地址顺序显示，并显示所有相关源文件的文件名和内容。</li>
</ul>
<h3 id="查看特定地址信息"><a href="#查看特定地址信息" class="headerlink" title="查看特定地址信息"></a>查看特定地址信息</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) x [内存地址]</span><br></pre></td></tr></table></figure>

<p>命令：<code>x</code> 查看内存地址中的值<br>格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x /&lt;n/f/u&gt;  &lt;addr&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>n</code> 是正整数，表示需要显示的内存单元的个数，即从当前地址向后显示n个内存单元的内容，一个内存单元的大小由第三个参数u定义。</li>
<li><code>f</code> 表示addr指向的内存内容的输出格式，s对应输出字符串，此处需特别注意输出整型数据的格式：</li>
<li><code>x</code> 按十六进制格式显示变量。</li>
<li><code>d</code> 按十进制格式显示变量。</li>
<li><code>u</code> 按十六进制格式显示无符号整型。</li>
<li><code>o</code> 按八进制格式显示变量。</li>
<li><code>t</code> 按二进制格式显示变量。</li>
<li><code>a</code> 按十六进制格式显示变量。</li>
<li><code>c</code> 按字符格式显示变量。</li>
<li><code>f</code> 按浮点数格式显示变量。</li>
<li><code>i</code> instruction以汇编指令显示。</li>
<li><code>u</code>:就是指以多少个字节作为一个内存单元-unit,默认为4。当然u还可以用被一些字符表示，如b&#x3D;1 byte, h&#x3D;2 bytes,w&#x3D;4 bytes,g&#x3D;8 bytes.</li>
<li><code>&lt;addr&gt;</code> 表示内存地址。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) x 0xffffffc01041b1cc  #当前地址数据，表示机器码</span><br><span class="line">0xffffffc01041b1cc &lt;dwc_desc_get+108&gt;:	0xf0ffffe0</span><br><span class="line"></span><br><span class="line">(gdb) x /i 0xffffffc01041b1cc #将机器码以汇编代码形式输出</span><br><span class="line">0xffffffc01041b1cc &lt;dwc_desc_get+108&gt;:	adrp	x0, 0xffffffc01041a000 &lt;dmatest_func+1252&gt;</span><br></pre></td></tr></table></figure>


<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYXJtLmNvbS9kb2N1bWVudGF0aW9uL2RkaTA0ODcvZ2Iv">DDI0487D_a_armv8_arm.pdf<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9jb3Vyc2VzLmNzLndhc2hpbmd0b24uZWR1L2NvdXJzZXMvY3NlNDY5LzIwd2kvYXJtNjQucGRm">ARMv8 A64 Quick Reference<i class="fa fa-external-link-alt"></i></span> —— 汇编指令</li>
</ul>
]]></content>
      <categories>
        <category>Linux内核</category>
      </categories>
      <tags>
        <tag>arm64</tag>
        <tag>kernel</tag>
        <tag>crash</tag>
      </tags>
  </entry>
  <entry>
    <title>Centos7内核编译及RPM包的制作</title>
    <url>/post/cb2d9d77.html</url>
    <content><![CDATA[<p>特定内核的编译安装</p>
<span id="more"></span>

<h2 id="源码编译安装"><a href="#源码编译安装" class="headerlink" title="源码编译安装"></a>源码编译安装</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum -y groups install &quot;Development Tools&quot;</span><br><span class="line">yum install ncurses-devel make gcc bc openssl-devel</span><br><span class="line"></span><br><span class="line">wget https://mirrors.edge.kernel.org/pub/linux/kernel/v4.x/linux-4.14.105.tar.gz</span><br><span class="line"></span><br><span class="line">tar zxvf linux-4.14.105.tar.gz</span><br><span class="line"></span><br><span class="line">cp /boot/config-`uname -r` ./linux-4.14.105/.config</span><br><span class="line"></span><br><span class="line">cd linux-4.14.105</span><br><span class="line"></span><br><span class="line">make menuconfig  #进入后直接保存保存配置</span><br><span class="line">make oldconfig</span><br><span class="line"></span><br><span class="line">make kernelversion</span><br><span class="line">make INSTALL_MOD_STRIP=1 all -j32</span><br><span class="line"></span><br><span class="line">make INSTALL_MOD_STRIP=1 modules_install</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">ls</span> -lh /lib/modules</span></span><br><span class="line"></span><br><span class="line">make INSTALL_MOD_STRIP=1 install</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">ls</span> -lh /boot</span></span><br></pre></td></tr></table></figure>
<p>通过以上命令可以完成内核的编译。</p>
<blockquote>
<p>Use the INSTALL_MOD_STRIP option for removing debugging symbols:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make INSTALL_MOD_STRIP=1 modules_install</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="打包——RPM"><a href="#打包——RPM" class="headerlink" title="打包——RPM"></a>打包——RPM</h2><p>在源码编译的基础上进行rpm包的制作，主要是利用在源码编译阶段生成对内核的配置<code>.config</code>文件后，不进行安装而是直接打包。</p>
<p>安装rpm包制作工具：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum -y install rpm-build</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make rpm-pkg -j32</span><br></pre></td></tr></table></figure>
<p>编译完成在<code>~/rpmbuild/RPMS/x86_64/</code>目录下生成rpm安装包：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls -lh ~/rpmbuild/RPMS/x86_64/</span><br><span class="line">-rw-r--r-- 1 root root 515M 10月 10 06:28 /root/rpmbuild/RPMS/x86_64/kernel-4.14.105-1.x86_64.rpm</span><br><span class="line">-rw-r--r-- 1 root root 135M 10月 10 06:30 /root/rpmbuild/RPMS/x86_64/kernel-devel-4.14.105-1.x86_64.rpm</span><br><span class="line">-rw-r--r-- 1 root root 1.2M 10月 10 06:28 /root/rpmbuild/RPMS/x86_64/kernel-headers-4.14.105-1.x86_64.rpm</span><br></pre></td></tr></table></figure>
<blockquote>
<p>为啥rpm包这么大，官方rpm包一般五六十兆大小？？？</p>
<blockquote>
<p>主要是编译生成的<code>ko</code>文件增大所致，应该包含了debug信息和符号表</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make INSTALL_MOD_STRIP=1 rpm-pkg</span><br></pre></td></tr></table></figure>
</blockquote>
</blockquote>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rpm -iUv ~/rpmbuild/RPMS/x86_64/kernel-*.rpm</span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install ~/rpmbuild/RPMS/x86_64/kernel-*.rpm</span><br></pre></td></tr></table></figure>

<h2 id="内核编译命令"><a href="#内核编译命令" class="headerlink" title="内核编译命令"></a>内核编译命令</h2><p>编译内核生成<code>centos rpm</code>或<code>ubuntu deb</code>包</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make rpm          #生成带源码的RPM包</span><br><span class="line">make rpm-pkg      #生成带源码的RPM包,同上</span><br><span class="line">make binrpm-pkg   #生成包含内核和驱动的RMP包</span><br><span class="line">make deb-pkg      #生成带源码的debian包</span><br><span class="line">make bindeb-pkg   #生成包含内核和驱动的debian包</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>rpm-pkg</code>: 每次编译前会先clean,重复编译会很慢</p>
</blockquote>
<p>linux内核<code>make help</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Kernel packaging:</span><br><span class="line">  rpm-pkg             - Build both source and binary RPM kernel packages</span><br><span class="line">  binrpm-pkg          - Build only the binary kernel RPM package</span><br><span class="line">  deb-pkg             - Build both source and binary deb kernel packages</span><br><span class="line">  bindeb-pkg          - Build only the binary kernel deb package</span><br><span class="line">  tar-pkg             - Build the kernel as an uncompressed tarball</span><br><span class="line">  targz-pkg           - Build the kernel as a gzip compressed tarball</span><br><span class="line">  tarbz2-pkg          - Build the kernel as a bzip2 compressed tarball</span><br><span class="line">  tarxz-pkg           - Build the kernel as a xz compressed tarball</span><br><span class="line">  perf-tar-src-pkg    - Build perf-4.14.105.tar source tarball</span><br><span class="line">  perf-targz-src-pkg  - Build perf-4.14.105.tar.gz source tarball</span><br><span class="line">  perf-tarbz2-src-pkg - Build perf-4.14.105.tar.bz2 source tarball</span><br><span class="line">  perf-tarxz-src-pkg  - Build perf-4.14.105.tar.xz source tarball</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make clean            #删除编译中间文件，但是保留配置</span><br><span class="line">make mrproper         #删除包括配置文件的所有构建文件</span><br><span class="line">make distclean        #执行mrproper所做的一切，并删除备份文件</span><br><span class="line"></span><br><span class="line">make menuconfig       #文本图形方式配置内核</span><br><span class="line">make oldconfig        #基于当前的.config文件提示更新内核</span><br><span class="line">make defconfig        #生成默认的内核配置</span><br><span class="line">make allmodconfig     #所有的可选的选项构建成模块</span><br><span class="line">make allyesconfig     #生成全部选择是内核配置</span><br><span class="line">make noconfig         #生成全部选择否的内核配置</span><br><span class="line"></span><br><span class="line">make all              #构建所有目标</span><br><span class="line">make bzImage          #构建内核映像</span><br><span class="line">make modules          #构建所有驱动</span><br><span class="line">make dir/             #构建指定目录</span><br><span class="line">make dir/file.[s|o|i] #构建指定文件</span><br><span class="line">make dir/file.ko      #构建指定驱动</span><br><span class="line"></span><br><span class="line">make install          #安装内核</span><br><span class="line">make modules_install  #安装驱动</span><br><span class="line"></span><br><span class="line">make xmldocs          #生成xml文档</span><br><span class="line">make pdfdocs          #生成pdf文档</span><br><span class="line">maek htmldocs         #生成html文档</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly93aWtpLmNlbnRvcy5vcmcvemgvSG93VG9zL0lfbmVlZF90aGVfS2VybmVsX1NvdXJjZQ==">我需要内核的源代码<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93aWtpLmNlbnRvcy5vcmcvemgvSG93VG9zL0N1c3RvbV9LZXJuZWw=">我需要创建一个自设的内核<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL3d3dy5vd2xyaXZlci5jb20vdGlwcy9ub24tcm9vdC8=">Building Source RPM as non-root under CentOS*<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vd2FuZ2pxMTk5MjAyMTAvcC8xMDgxOTU0MS5odG1s">kernel 4.18.18 rpm 制作<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NzdWppYW5neXUvYXJ0aWNsZS9kZXRhaWxzLzg0NzE4NzUw">Linux kernel编译指南<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>Linux内核</category>
      </categories>
      <tags>
        <tag>kernel</tag>
        <tag>centos</tag>
        <tag>rpm</tag>
      </tags>
  </entry>
  <entry>
    <title>电源管理——P-State和C-State</title>
    <url>/post/4a7ca2c.html</url>
    <content><![CDATA[<p>CPU电源状态：<code>C-state</code>(CPU Power states）)<br>CPU性能状态：<code>P-state</code>(CPU Performance states)</p>
<blockquote>
<p> The concepts of C&#x2F;P-states originally come from  ACPI (Advanced Configuration and Power Interface) specification, Cx talk about processor sleep status, while P about running status. please check wiki for more details:</p>
</blockquote>
<span id="more"></span>
<h2 id="C-state"><a href="#C-state" class="headerlink" title="C-state"></a>C-state</h2><p>C-state有C0，C1…Cn多种模式，但只有<code>C0</code>是正常工作模式（active），其他方式都是idle状态，只是idle的程度不同，<code>C后的数越高，CPU睡眠得越深，CPU的功耗被降低得越多</code>，同时需要更多的时间回到C0模式</p>
<h3 id="C1状态（挂起）"><a href="#C1状态（挂起）" class="headerlink" title="C1状态（挂起）"></a>C1状态（挂起）</h3><ul>
<li>可以通过执行汇编指令“HLT（挂起）”进入这一状态</li>
<li>唤醒时间超快！（快到只需10纳秒！）</li>
<li>可以节省70%的CPU功耗</li>
<li>所有现代处理器都必须支持这一功耗状态</li>
</ul>
<h3 id="C2状态（停止允许）"><a href="#C2状态（停止允许）" class="headerlink" title="C2状态（停止允许）"></a>C2状态（停止允许）</h3><ul>
<li>处理器时钟频率和I&#x2F;O缓冲被停止</li>
<li>换言之，处理器执行引擎和I&#x2F;0缓冲已经没有时钟频率</li>
<li>在C2状态下也可以节约70%的CPU和平台能耗</li>
<li>从C2切换到C0状态需要100纳秒以上</li>
</ul>
<h3 id="C3状态（深度睡眠）"><a href="#C3状态（深度睡眠）" class="headerlink" title="C3状态（深度睡眠）"></a>C3状态（深度睡眠）</h3><ul>
<li>总线频率和PLL均被锁定</li>
<li>在多核心系统下，缓存无效</li>
<li>在单核心系统下，内存被关闭，但缓存仍有效</li>
<li>可以节省70%的CPU功耗，但平台功耗比C2状态下大一些</li>
<li>唤醒时间需要50微妙</li>
</ul>
<h3 id="C4状态（更深度睡眠）"><a href="#C4状态（更深度睡眠）" class="headerlink" title="C4状态（更深度睡眠）"></a>C4状态（更深度睡眠）</h3><ul>
<li>与C3相似，但有两大区别</li>
<li>一是核心电压低于1.0V</li>
<li>二是二级缓存内的数据存储将有所减少</li>
<li>可以节约98%的CPU最大功耗</li>
<li>唤醒时间比较慢，但不超过1秒</li>
</ul>
<h3 id="C5状态"><a href="#C5状态" class="headerlink" title="C5状态"></a>C5状态</h3><ul>
<li>二级缓存的数据被减为零</li>
<li>唤醒时间超过200微妙</li>
</ul>
<h3 id="C6状态"><a href="#C6状态" class="headerlink" title="C6状态"></a>C6状态</h3><ul>
<li>这是Penryn处理器中新增的功耗管理模式</li>
<li>二级缓存减至零后，CPU的核心电压更低</li>
<li>不保存CPU context</li>
<li>功耗未知，应该接近零</li>
<li>唤醒时间未知</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><span class="exturl" data-url="aHR0cDovL2Jsb2cuY2hpbmF1bml4Lm5ldC91aWQtMjg1NDEzNDctaWQtNTgyMjI4OC5odG1s">linux电源管理——C-state,P-state,turbo分析<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL2Jsb2cuY2hpbmF1bml4Lm5ldC91aWQtMjU4NzExMDQtaWQtMzA3MjU4Mi5odG1s">关于CPU C-States 省电模式，你需要知道的事情<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>Linux内核</category>
      </categories>
      <tags>
        <tag>kernel</tag>
        <tag>power</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>uImage dump成反汇编</title>
    <url>/post/17694.html</url>
    <content><![CDATA[<blockquote>
<p>通过Linux调试使用的uImage文件,进行反汇编查看CPU的具体执行指令</p>
</blockquote>
<span id="more"></span>

<h2 id="uImage的组成"><a href="#uImage的组成" class="headerlink" title="uImage的组成"></a>uImage的组成</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+------+-----------------------------+</span><br><span class="line">|      |                             |</span><br><span class="line">|  64k |          zImage             |</span><br><span class="line">|      |                             |</span><br><span class="line">+------+-----------------------------+</span><br></pre></td></tr></table></figure>

<h2 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h2><p>如果时zImage可以直接进行解压操作</p>
<h3 id="去除64k头信息"><a href="#去除64k头信息" class="headerlink" title="去除64k头信息"></a>去除64k头信息</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dd if=uImage of=Image.gz bs=1 skip=64</span><br></pre></td></tr></table></figure>
<h3 id="zip解压"><a href="#zip解压" class="headerlink" title="zip解压"></a>zip解压</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gunzip Image.gz</span><br></pre></td></tr></table></figure>
<p>生成’Image’,CPU执行的二进制代码</p>
<h2 id="获取二进制的执行指令码"><a href="#获取二进制的执行指令码" class="headerlink" title="获取二进制的执行指令码"></a>获取二进制的执行指令码</h2><blockquote>
<p>通过gcc的工具将二进制的指令码反汇编,CPU的取指是以word进行,也就是每一个wrod对应一条指令</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    FILE *ifp = fopen(argv[<span class="number">1</span>],<span class="string">&quot;r&quot;</span>);</span><br><span class="line">	FILE *ofp = fopen(argv[<span class="number">2</span>],<span class="string">&quot;wt&quot;</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(ofp,<span class="string">&quot;#include &lt;stdio.h&gt;\n&quot;</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(ofp,<span class="string">&quot;int main(int argc, char *argv[])\n&quot;</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(ofp,<span class="string">&quot;&#123;&quot;</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(ofp,<span class="string">&quot;\tasm volatile (&quot;</span>);</span><br><span class="line">	<span class="keyword">while</span>(!feof(ifp))&#123;</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">int</span> d;</span><br><span class="line">		fread(&amp;d,<span class="number">1</span>,<span class="number">4</span>,ifp);</span><br><span class="line">		<span class="built_in">fprintf</span>(ofp,<span class="string">&quot;\t\t\&quot;.word 0x%08x   \\t\\n\&quot;\n&quot;</span>,d);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">fprintf</span>(ofp,<span class="string">&quot;\t);&quot;</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(ofp,<span class="string">&quot;return 0;&quot;</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(ofp,<span class="string">&quot;&#125;&quot;</span>);</span><br><span class="line">	fclose(ifp);</span><br><span class="line">	fclose(ofp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gcc m.c -o m</span><br><span class="line"></span><br><span class="line">./m Image Image.c</span><br></pre></td></tr></table></figure>
<p>Image.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;	<span class="keyword">asm</span> <span class="title function_">volatile</span> <span class="params">(		<span class="string">&quot;.word 0x00000000   \t\n&quot;</span></span></span><br><span class="line"><span class="params">		<span class="string">&quot;.word 0x00000000   \t\n&quot;</span></span></span><br><span class="line"><span class="params">		<span class="string">&quot;.word 0x00000000   \t\n&quot;</span></span></span><br><span class="line"><span class="params">		<span class="string">&quot;.word 0x00000000   \t\n&quot;</span></span></span><br><span class="line"><span class="params">		<span class="string">&quot;.word 0x00000000   \t\n&quot;</span></span></span><br><span class="line"><span class="params">		<span class="string">&quot;.word 0x00000000   \t\n&quot;</span></span></span><br><span class="line"><span class="params">		...</span></span><br><span class="line"><span class="params">	)</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="反汇编"><a href="#反汇编" class="headerlink" title="反汇编"></a>反汇编</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$mips-linux-gnu-gcc Image.c -o Image</span><br><span class="line">$mips-linux-gnu-objdump -Dz Image &gt; Image.S</span><br></pre></td></tr></table></figure>

<p>Image.S</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00400640 &lt;main&gt;:</span><br><span class="line">400640:   27bdfff8    addiu   sp,sp,-8</span><br><span class="line">400644:   afbe0004    sw  s8,4(sp)</span><br><span class="line">400648:   03a0f025    move    s8,sp</span><br><span class="line">40064c:   afc40008    sw  a0,8(s8)</span><br><span class="line">400650:   afc5000c    sw  a1,12(s8)</span><br><span class="line">400654:   00000000    nop</span><br><span class="line">...</span><br><span class="line">400a54:   3c05805f    lui a1,0x805f &lt;==== Load Address: 80010000</span><br><span class="line">400a58:   3c06805f    lui a2,0x805f</span><br><span class="line">400a5c:   aca404cc    sw  a0,1228(a1)</span><br><span class="line">400a60:   24c60444    addiu   a2,a2,1092</span><br><span class="line">400a64:   0804078d    j   101e34 &lt;_DYNAMIC-0x2fe384&gt;</span><br><span class="line">400a68:   24a504cc    addiu   a1,a1,1228</span><br><span class="line">400a6c:   3c028065    lui v0,0x8065</span><br><span class="line">400a70:   90422000    lbu v0,8192(v0)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><em>注意</em>:无法进行函数跳转的判断</p>
<h2 id="将PC指针替换成内核入口地址"><a href="#将PC指针替换成内核入口地址" class="headerlink" title="将PC指针替换成内核入口地址"></a>将PC指针替换成内核入口地址</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"></span><br><span class="line">fp = <span class="built_in">open</span>(<span class="string">&quot;Image.S&quot;</span>,<span class="string">&quot;r&quot;</span>)</span><br><span class="line">iaddr = <span class="number">0x80010000</span></span><br><span class="line">flag = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> fp.readlines():</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&quot;400654: 00000000&quot;</span> <span class="keyword">in</span> line:</span><br><span class="line">        flag = <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> flag == <span class="number">1</span>:</span><br><span class="line">        s = line.split(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(s) &gt; <span class="number">1</span>:</span><br><span class="line">            addr = s[<span class="number">0</span>]</span><br><span class="line">            data = s[<span class="number">1</span>]</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;%08x:\t %s&quot;</span> % (iaddr,s[<span class="number">1</span>])),</span><br><span class="line">            iaddr = iaddr + <span class="number">4</span></span><br><span class="line">fp.close()</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python a.py &gt; uImage.S</span><br></pre></td></tr></table></figure>
<p><em>注意</em>:文件权限问题,可以无法读取文件数据</p>
<h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><h3 id="uImage-S"><a href="#uImage-S" class="headerlink" title="uImage.S"></a>uImage.S</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">800103f8:       00000000    nop</span><br><span class="line">800103fc:       00000000    nop</span><br><span class="line">80010400:       3c05805f    lui a1,0x805f</span><br><span class="line">80010404:       3c06805f    lui a2,0x805f</span><br><span class="line">80010408:       aca404cc    sw  a0,1228(a1)</span><br><span class="line">8001040c:       24c60444    addiu   a2,a2,1092</span><br><span class="line">80010410:       0804078d    j   101e34 &lt;_DYNAMIC-0x2fe384&gt;</span><br><span class="line">80010414:       24a504cc    addiu   a1,a1,1228</span><br></pre></td></tr></table></figure>
<h3 id="vmlinux-S"><a href="#vmlinux-S" class="headerlink" title="vmlinux.S"></a>vmlinux.S</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">80010400 &lt;run_init_process&gt;:</span><br><span class="line">80010400:   3c05805f    lui a1,0x805f</span><br><span class="line">80010404:   3c06805f    lui a2,0x805f</span><br><span class="line">80010408:   aca404cc    sw  a0,1228(a1)</span><br><span class="line">8001040c:   24c60444    addiu   a2,a2,1092</span><br><span class="line">80010410:   0804078d    j   80101e34 &lt;do_execve&gt;</span><br><span class="line">80010414:   24a504cc    addiu   a1,a1,1228</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux内核</category>
      </categories>
      <tags>
        <tag>umage</tag>
        <tag>反汇编</tag>
      </tags>
  </entry>
  <entry>
    <title>idr与ida</title>
    <url>/post/e5599899.html</url>
    <content><![CDATA[<ul>
<li><code>IDR</code>在Linux内核中指的是整数ID管理机制。实质上来讲，这就是一种将一个整数ID号和一个指针关联在一起的机制。</li>
<li><code>IDA</code>是用IDR来实现的ID分配机制,与IDR的区别是IDA仅仅<code>分配</code>与<code>管理</code>ID,并不将ID与指针相关联.</li>
</ul>
<span id="more"></span>


<h2 id="IDR"><a href="#IDR" class="headerlink" title="IDR"></a>IDR</h2><blockquote>
<p>所谓IDR，其实就是和身份证的含义差不多，我们知道，每个人有一个身份证，身份证只是一串数字，从数字，我们就能知道这个人的信息。同样道理，idr的要完成的任务是给要管理的对象分配一个数字，可以通过这个数字找到要管理的对象。</p>
</blockquote>
<h2 id="IDA"><a href="#IDA" class="headerlink" title="IDA"></a>IDA</h2>]]></content>
      <categories>
        <category>Linux内核</category>
      </categories>
      <tags>
        <tag>kernel</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Energy Aware Scheduling</title>
    <url>/post/58199.html</url>
    <content><![CDATA[<p><code>Energy Aware Scheduling(EAS)</code>,EAS调度器的设计目标是在保证系统性能的前提下尽可能地降低功耗。</p>
<ul>
<li>EAS调度器，在Android 7.x之后开始使用???</li>
<li>内核版本:Arm posts v10 of ‘<span class="exturl" data-url="aHR0cHM6Ly9sb3JlLmtlcm5lbC5vcmcvcGF0Y2h3b3JrL2NvdmVyLzEwMjA0MzIv">Energy Aware Scheduling<i class="fa fa-external-link-alt"></i></span>‘ - merged into Linux-5.0</li>
</ul>
<span id="more"></span>


<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cubGluYXJvLm9yZy9ibG9nL2VuZXJneS1hd2FyZS1zY2hlZHVsaW5nLWVhcy1wcm9ncmVzcy11cGRhdGUv">Energy Aware Scheduling (EAS) progress update<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYXJtLmNvbS90b29scy1hbmQtc29mdHdhcmUvb3Blbi1zb3VyY2Utc29mdHdhcmUvbGludXgta2VybmVsL2VuZXJneS1hd2FyZS1zY2hlZHVsaW5n">Energy Aware Scheduling (EAS)<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Jpa2V5b25lL2FydGljbGUvZGV0YWlscy84ODM0MjM4Mg==">HMP调度器和EAS调度器<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3B3bDk5OS9hcnRpY2xlL2RldGFpbHMvNzg4MTc5MDY=">Linux schedule 5、EAS(Energy-Aware Scheduling)<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>Linux内核</category>
      </categories>
      <tags>
        <tag>schedule</tag>
      </tags>
  </entry>
  <entry>
    <title>内核常见问题</title>
    <url>/post/57226.html</url>
    <content><![CDATA[<p>常见错误的总结；</p>
<span id="more"></span>

<h2 id="Unhandled-kernel-unaligned-access"><a href="#Unhandled-kernel-unaligned-access" class="headerlink" title="Unhandled kernel unaligned access"></a>Unhandled kernel unaligned access</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h3><ol>
<li>数据被冲掉(也就是其他数据的覆盖)</li>
<li>DDR出错(除非新调试的内存,不然机率很小)</li>
</ol>
<h3 id="alignment-fault的代码编写方式"><a href="#alignment-fault的代码编写方式" class="headerlink" title="alignment fault的代码编写方式"></a>alignment fault的代码编写方式</h3><h4 id="指针转换："><a href="#指针转换：" class="headerlink" title="指针转换："></a>指针转换：</h4><p>将低位宽类型的指针转换为高位宽类型的指针，如：将<code>char *</code> 转为<code>int *</code>，或将<code>void *</code>转为结构体指针。这类操作是导致alignment fault的最主要的来源，在分析定位问题时，需要特别关注。对于出现异常却又必须这样使用的场景，对这类转换后的指针进行访问时，如果不能确认其对应的地址是对齐的，则应该使用memcpy访问(memcpy方式不存在对齐问题)。另外，建议转换后立即使用，不要将其传递到其他函数和模块，防止扩展，带来潜在的问题。</p>
<h4 id="使用packed属性或者编译选项"><a href="#使用packed属性或者编译选项" class="headerlink" title="使用packed属性或者编译选项"></a>使用packed属性或者编译选项</h4><p>这样的操作会关闭编译器的自动填充功能，从而使结构体中各个字段紧凑排列，如果排列时未处理好对齐，则可能导致alignment fault。一些场景下(内核中也较常见)确实需要用户自行紧凑排列结构体，可节省空间(在内存资源稀缺的场景下，很有用)，此时需要特别关注对齐问题，建议通过填充的方法尽量对齐，如此可能会导致空间浪费，但是会提升访问性能，典型的“以空间换时间”的思路。如果对空间有强烈要求，而可以接受性能损失，也可以不考虑对齐，不做padding，但在访问这些结构体的数据时，需要全部使用memcpy的方式。</p>
<h2 id="BUG-soft-lockup-CPU-0-stuck-for-22s"><a href="#BUG-soft-lockup-CPU-0-stuck-for-22s" class="headerlink" title="BUG: soft lockup - CPU#0 stuck for 22s!"></a>BUG: soft lockup - CPU#0 stuck for 22s!</h2><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路:"></a>思路:</h3><ol>
<li>死锁</li>
<li>死循环</li>
</ol>
<h2 id="not-syncing-softlockup-hung-tasks"><a href="#not-syncing-softlockup-hung-tasks" class="headerlink" title="not syncing: softlockup: hung tasks"></a>not syncing: softlockup: hung tasks</h2>]]></content>
      <categories>
        <category>Linux内核</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>内存屏障</title>
    <url>/post/15089.html</url>
    <content><![CDATA[<blockquote>
<p>Memory barrier能够让<code>CPU</code>或<code>编译器</code>在内存访问上有序。一个Memory barrier之前的<strong>内存访问操作必定先于其之后的完成</strong>。</p>
</blockquote>
<p>程序在运行时内存实际的访问顺序和程序代码编写的访问顺序不一定一致，这就是内存乱序访问。内存乱序访问行为出现的理由是为了提升程序运行时的性能.</p>
<p>Linux kernel doc: <span class="exturl" data-url="aHR0cHM6Ly93d3cua2VybmVsLm9yZy9kb2MvRG9jdW1lbnRhdGlvbi9tZW1vcnktYmFycmllcnMudHh0">memory-barriers<i class="fa fa-external-link-alt"></i></span></p>
<p>内存乱序访问主要发生在两个阶段：</p>
<ul>
<li>编译时，编译器优化导致内存乱序访问（指令重排）</li>
<li>运行时，多CPU间交互引起内存乱序访问</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> wmb()       fast_wmb()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rmb()       fast_rmb()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mb()        fast_mb()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> iob()       fast_iob()</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#  <span class="keyword">define</span> smp_mb()  __asm__ __volatile__(<span class="string">&quot;sync&quot;</span> : : :<span class="string">&quot;memory&quot;</span>)</span></span><br><span class="line"><span class="meta">#  <span class="keyword">define</span> smp_rmb() __asm__ __volatile__(<span class="string">&quot;sync&quot;</span> : : :<span class="string">&quot;memory&quot;</span>)</span></span><br><span class="line"><span class="meta">#  <span class="keyword">define</span> smp_wmb() __asm__ __volatile__(<span class="string">&quot;sync&quot;</span> : : :<span class="string">&quot;memory&quot;</span>)</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>[MIPS] file: arch&#x2F;mips&#x2F;include&#x2F;asm&#x2F;barrier.h</p>
</blockquote>
<span id="more"></span>

<h2 id="smp-mb"><a href="#smp-mb" class="headerlink" title="smp_mb"></a>smp_mb</h2><p>作用对象：CPU与CPU</p>
<h2 id="mb"><a href="#mb" class="headerlink" title="mb"></a>mb</h2><p>作用对象：CPU与IO</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><span class="exturl" data-url="aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd29ybGRfaGVsbG9fMTAwL2FydGljbGUvZGV0YWlscy81MDEzMTQ5Nw==">理解 Memory barrier（内存屏障）<i class="fa fa-external-link-alt"></i></span></li>
</ol>
]]></content>
      <categories>
        <category>Linux内核</category>
      </categories>
      <tags>
        <tag>mem</tag>
        <tag>barrier</tag>
      </tags>
  </entry>
  <entry>
    <title>cpu_cache_init与rixi</title>
    <url>/post/30991.html</url>
    <content><![CDATA[<p><code>cpu_cache_init</code>接口：</p>
<ul>
<li>初始化cache（r4k_cache_init）</li>
<li>设置cache的保护权限（setup_protection_map）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kernel_start</span><br><span class="line">	\-&gt;setup_arch</span><br><span class="line">		\-&gt;cpu_cache_init()</span><br></pre></td></tr></table></figure>
<blockquote>
<p>file: arch&#x2F;mips&#x2F;mm&#x2F;cache.c</p>
</blockquote>
<span id="more"></span>

<h2 id="r4k-cache-init"><a href="#r4k-cache-init" class="headerlink" title="r4k_cache_init"></a>r4k_cache_init</h2><h2 id="setup-protection-map"><a href="#setup-protection-map" class="headerlink" title="setup_protection_map"></a>setup_protection_map</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">setup_protection_map</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (cpu_has_rixi) &#123;</span><br><span class="line">        protection_map[<span class="number">0</span>]  = __pgprot(_page_cachable_default | _PAGE_PRESENT | _PAGE_NO_EXEC | _PAGE_NO_READ);</span><br><span class="line">        protection_map[<span class="number">1</span>]  = __pgprot(_page_cachable_default | _PAGE_PRESENT | _PAGE_NO_EXEC);</span><br><span class="line">        protection_map[<span class="number">2</span>]  = __pgprot(_page_cachable_default | _PAGE_PRESENT | _PAGE_NO_EXEC | _PAGE_NO_READ);</span><br><span class="line">        protection_map[<span class="number">3</span>]  = __pgprot(_page_cachable_default | _PAGE_PRESENT | _PAGE_NO_EXEC);</span><br><span class="line">        protection_map[<span class="number">4</span>]  = __pgprot(_page_cachable_default | _PAGE_PRESENT | _PAGE_NO_READ);</span><br><span class="line">        protection_map[<span class="number">5</span>]  = __pgprot(_page_cachable_default | _PAGE_PRESENT);</span><br><span class="line">        protection_map[<span class="number">6</span>]  = __pgprot(_page_cachable_default | _PAGE_PRESENT | _PAGE_NO_READ);</span><br><span class="line">        protection_map[<span class="number">7</span>]  = __pgprot(_page_cachable_default | _PAGE_PRESENT);</span><br><span class="line"></span><br><span class="line">        protection_map[<span class="number">8</span>]  = __pgprot(_page_cachable_default | _PAGE_PRESENT | _PAGE_NO_EXEC | _PAGE_NO_READ);</span><br><span class="line">        protection_map[<span class="number">9</span>]  = __pgprot(_page_cachable_default | _PAGE_PRESENT | _PAGE_NO_EXEC);</span><br><span class="line">        protection_map[<span class="number">10</span>] = __pgprot(_page_cachable_default | _PAGE_PRESENT | _PAGE_NO_EXEC | _PAGE_WRITE | _PAGE_NO_READ);</span><br><span class="line">        protection_map[<span class="number">11</span>] = __pgprot(_page_cachable_default | _PAGE_PRESENT | _PAGE_NO_EXEC | _PAGE_WRITE);</span><br><span class="line">        protection_map[<span class="number">12</span>] = __pgprot(_page_cachable_default | _PAGE_PRESENT | _PAGE_NO_READ);</span><br><span class="line">        protection_map[<span class="number">13</span>] = __pgprot(_page_cachable_default | _PAGE_PRESENT);</span><br><span class="line">        protection_map[<span class="number">14</span>] = __pgprot(_page_cachable_default | _PAGE_PRESENT | _PAGE_WRITE  | _PAGE_NO_READ);</span><br><span class="line">        protection_map[<span class="number">15</span>] = __pgprot(_page_cachable_default | _PAGE_PRESENT | _PAGE_WRITE);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        protection_map[<span class="number">0</span>] = PAGE_NONE;</span><br><span class="line">        protection_map[<span class="number">1</span>] = PAGE_READONLY;</span><br><span class="line">        protection_map[<span class="number">2</span>] = PAGE_COPY;</span><br><span class="line">        protection_map[<span class="number">3</span>] = PAGE_COPY;</span><br><span class="line">        protection_map[<span class="number">4</span>] = PAGE_READONLY;</span><br><span class="line">        protection_map[<span class="number">5</span>] = PAGE_READONLY;</span><br><span class="line">        protection_map[<span class="number">6</span>] = PAGE_COPY;</span><br><span class="line">        protection_map[<span class="number">7</span>] = PAGE_COPY;</span><br><span class="line">        protection_map[<span class="number">8</span>] = PAGE_NONE;</span><br><span class="line">        protection_map[<span class="number">9</span>] = PAGE_READONLY;</span><br><span class="line">        protection_map[<span class="number">10</span>] = PAGE_SHARED;</span><br><span class="line">        protection_map[<span class="number">11</span>] = PAGE_SHARED;</span><br><span class="line">        protection_map[<span class="number">12</span>] = PAGE_READONLY;</span><br><span class="line">        protection_map[<span class="number">13</span>] = PAGE_READONLY;</span><br><span class="line">        protection_map[<span class="number">14</span>] = PAGE_SHARED;</span><br><span class="line">        protection_map[<span class="number">15</span>] = PAGE_SHARED;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>setup_protection_map</code>函数主要是对<code>protection_map</code>结构体数组的初始化<br>cpu_has_rixi: 需要CPU中rixi的硬件支持</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* description of effects of mapping type and prot in current implementation.</span></span><br><span class="line"><span class="comment"> * this is due to the limited x86 page protection hardware.  The expected</span></span><br><span class="line"><span class="comment"> * behavior is in parens:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * map_type prot</span></span><br><span class="line"><span class="comment"> *      PROT_NONE   PROT_READ   PROT_WRITE  PROT_EXEC</span></span><br><span class="line"><span class="comment"> * MAP_SHARED   r: (no) no  r: (yes) yes    r: (no) yes r: (no) yes</span></span><br><span class="line"><span class="comment"> *      w: (no) no  w: (no) no  w: (yes) yes    w: (no) no</span></span><br><span class="line"><span class="comment"> *      x: (no) no  x: (no) yes x: (no) yes x: (yes) yes</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * MAP_PRIVATE  r: (no) no  r: (yes) yes    r: (no) yes r: (no) yes</span></span><br><span class="line"><span class="comment"> *      w: (no) no  w: (no) no  w: (copy) copy  w: (no) no</span></span><br><span class="line"><span class="comment"> *      x: (no) no  x: (no) yes x: (no) yes x: (yes) yes</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">pgprot_t</span> protection_map[<span class="number">16</span>] = &#123;</span><br><span class="line">    __P000, __P001, __P010, __P011, __P100, __P101, __P110, __P111,</span><br><span class="line">    __S000, __S001, __S010, __S011, __S100, __S101, __S110, __S111</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>file: mm&#x2F;mmap.c</p>
</blockquote>
<p><code>protection_map</code>定义16种内存访问权限，其中映射类型<code>MAP_PRIVATE</code>和<code>MAP_SHARED</code></p>
<blockquote>
<p><code>__P000</code> 的意思是 P ( private)，0 ( No Exec)，0 ( No Write)，0 ( No Read)；</p>
</blockquote>
<blockquote>
<p><code>__P001</code> 的意思是 P ( private)，0 ( No Exec)，0 ( No Write)，0 ( Read)；</p>
</blockquote>
<blockquote>
<p><code>__S111</code> 的意思是 S ( Shared)，1 (Exec)，1 ( Write)，1 ( Read)；</p>
</blockquote>
<h2 id="rixi"><a href="#rixi" class="headerlink" title="rixi"></a>rixi</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> cpu_has_rixi                    1</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>arch&#x2F;mips&#x2F;xburst2&#x2F;soc-x2000&#x2F;include&#x2F;cpu-feature-overrides.h</p>
</blockquote>
<p>使能该功能</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__pgprot(_page_cachable_default | _PAGE_PRESENT | _PAGE_NO_EXEC | _PAGE_NO_READ);</span><br></pre></td></tr></table></figure>
<p>相应宏定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_JZRISC_PEP) &amp;&amp; defined(CONFIG_CPU_MIPS32)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _PAGE_PRESENT_SHIFT 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _PAGE_PRESENT       (1 &lt;&lt; _PAGE_PRESENT_SHIFT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _PAGE_READ_SHIFT    1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _PAGE_READ      (1 &lt;&lt; _PAGE_READ_SHIFT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _PAGE_WRITE_SHIFT   2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _PAGE_WRITE     (1 &lt;&lt; _PAGE_WRITE_SHIFT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _PAGE_ACCESSED_SHIFT    3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _PAGE_ACCESSED      (1 &lt;&lt; _PAGE_ACCESSED_SHIFT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _PAGE_MODIFIED_SHIFT    4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _PAGE_MODIFIED      (1 &lt;&lt; _PAGE_MODIFIED_SHIFT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _PAGE_FILE      (1 &lt;&lt; 4)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _PAGE_NO_EXEC       (1 &lt;&lt; 5)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _PAGE_GLOBAL        (1 &lt;&lt; 6)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _PAGE_VALID_SHIFT   7</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _PAGE_VALID     (1 &lt;&lt; _PAGE_VALID_SHIFT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _PAGE_SILENT_READ   (1 &lt;&lt; 7)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _PAGE_DIRTY_SHIFT   8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _PAGE_DIRTY     (1 &lt;&lt; _PAGE_DIRTY_SHIFT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _PAGE_SILENT_WRITE  (1 &lt;&lt; 8)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _CACHE_SHIFT        (9)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _CACHE_MASK     (7 &lt;&lt; _CACHE_SHIFT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _PFN_SHIFT      (PAGE_SHIFT - 12 + _CACHE_SHIFT + 3)</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>file: arch&#x2F;mips&#x2F;include&#x2F;asm&#x2F;pgtable-bits.h</p>
</blockquote>
<h3 id="page-cachable-default"><a href="#page-cachable-default" class="headerlink" title="_page_cachable_default"></a>_page_cachable_default</h3><blockquote>
<p>定义MMU的类型</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> __cpuinit <span class="title function_">coherency_setup</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (mips_cca &lt; <span class="number">0</span> || mips_cca &gt; <span class="number">7</span>)</span><br><span class="line">        mips_cca = read_c0_config() &amp; CONF_CM_CMASK;</span><br><span class="line">    _page_cachable_default = mips_cca &lt;&lt; _CACHE_SHIFT;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>file: arch&#x2F;mips&#x2F;mm&#x2F;c-r4k.c</p>
</blockquote>
<p>c0_config: Config寄存器主要描述CPU资源信息和配置，<code>CONF_CM_CMASK</code>(#define CONF_CM_CMASK 7)Config[7:9]为MT，表示MMU的类型</p>
<blockquote>
<p>Config[7:9]: MT MMU类型</p>
</blockquote>
<blockquote>
<p>0: None； 1: MIPS32&#x2F;64标准的TLB； 2：BAT类型； 3： MIPS32标准的FMT固定映射</p>
</blockquote>
<h3 id="cpu-has-rixi-x3D-1-和-cpu-has-rixi-x3D-0-区别"><a href="#cpu-has-rixi-x3D-1-和-cpu-has-rixi-x3D-0-区别" class="headerlink" title="cpu_has_rixi &#x3D; 1 和 cpu_has_rixi &#x3D; 0 区别"></a>cpu_has_rixi &#x3D; 1 和 cpu_has_rixi &#x3D; 0 区别</h3><ul>
<li><p>cpu_has_rixi &#x3D; 1</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">protection_map[<span class="number">0</span>]  = __pgprot(_page_cachable_default | _PAGE_PRESENT | _PAGE_NO_EXEC | _PAGE_NO_READ);</span><br></pre></td></tr></table></figure>
</li>
<li><p>cpu_has_rixi &#x3D; 0</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CACHE_CACHABLE_NONCOHERENT (3&lt;&lt;_CACHE_SHIFT)  <span class="comment">/* R4[0246]00      */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAGE_NONE   __pgprot(_PAGE_PRESENT | _CACHE_CACHABLE_NONCOHERENT)</span></span><br><span class="line"></span><br><span class="line">protection_map[<span class="number">0</span>] = PAGE_NONE;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>通过对<code>protection_map[0]</code>定义的对比，在使能rixi后，其属性增加了 <code>_PAGE_NO_EXEC</code>和<code>_PAGE_NO_READ</code><br>也就是rixi在内存的访问权限上增加了<code>_PAGE_WRITE</code>, <code>_PAGE_READ</code>,<code>_PAGE_NO_READ</code>, <code>_PAGE_NO_EXEC</code>的属性控制</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><span class="exturl" data-url="aHR0cDovL3d3dy4zNjBkb2MuY29tL2NvbnRlbnQvMTUvMDMxMC8xNi8xODI1MjQ4N180NTQwNzM3NDguc2h0bWw=">内核初始化<i class="fa fa-external-link-alt"></i></span></li>
</ol>
]]></content>
      <categories>
        <category>Linux内核</category>
      </categories>
      <tags>
        <tag>cache</tag>
        <tag>kernel</tag>
      </tags>
  </entry>
  <entry>
    <title>多核互锁</title>
    <url>/post/28384.html</url>
    <content><![CDATA[<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[15299.717341] BUG: spinlock lockup suspected on CPU#1, rixitest/4186</span><br><span class="line">[15299.723758]  lock: 0x8c77d644, .magic: dead4ead, .owner: rixitest/4161, .owner_cpu: 0</span><br><span class="line">[15299.731858] CPU: 1 PID: 4186 Comm: rixitest Not tainted 3.10.14-00058-g5afe79c #3</span><br></pre></td></tr></table></figure>
<span id="more"></span>

<h2 id="死锁检测"><a href="#死锁检测" class="headerlink" title="死锁检测"></a>死锁检测</h2><p>以<code>spin_lock</code>进行死锁机制的检测流程说明：</p>
<h3 id="raw-lock"><a href="#raw-lock" class="headerlink" title="raw_lock"></a>raw_lock</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">raw_spinlock</span> &#123;</span></span><br><span class="line">    <span class="type">arch_spinlock_t</span> raw_lock;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_GENERIC_LOCKBREAK</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> break_lock;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEBUG_SPINLOCK</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> magic, owner_cpu;</span><br><span class="line">	<span class="type">void</span> *owner;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEBUG_LOCK_ALLOC</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">lockdep_map</span> <span class="title">dep_map</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125; <span class="type">raw_spinlock_t</span>;</span><br></pre></td></tr></table></figure>

<p>死锁的检测内核需要配置<code>CONFIG_DEBUG_SPINLOCK</code>,它主要使用的数据有<code>magic</code>, <code>owner_cpu</code>,<code>*owner</code>:</p>
<table>
<thead>
<tr>
<th align="center">type</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">magic</td>
<td align="center">幻数,表示锁以及初始化</td>
</tr>
<tr>
<td align="center">owner_cpu</td>
<td align="center">raw_smp_processor_id(),<code>锁</code>所在的当前CPU号</td>
</tr>
<tr>
<td align="center">*ower</td>
<td align="center">current,<code>锁</code>所在的当前进程</td>
</tr>
</tbody></table>
<h3 id="Init"><a href="#Init" class="headerlink" title="Init"></a>Init</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SPINLOCK_MAGIC		0xdead4ead</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPINLOCK_OWNER_INIT	((void *)-1L)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEBUG_SPINLOCK</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> SPIN_DEBUG_INIT(lockname)		\</span></span><br><span class="line"><span class="meta">	.magic = SPINLOCK_MAGIC,		\</span></span><br><span class="line"><span class="meta">	.owner_cpu = -1,			\</span></span><br><span class="line"><span class="meta">	.owner = SPINLOCK_OWNER_INIT,</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> SPIN_DEBUG_INIT(lockname)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>初始化时<code>owner_cpu=-1</code>表示该锁不属于任何CPU，并且不属于任何进程(<code>owner=(void *)-1L</code>)</p>
<h3 id="Use"><a href="#Use" class="headerlink" title="Use"></a>Use</h3><blockquote>
<p>在什么时候指明该锁属于哪一个CPU，哪一个进程。</p>
</blockquote>
<ol>
<li>上锁时指定：<code>spin_lock</code></li>
<li>解锁时恢复：<code>spin_unlock</code></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spin_lock</span><br><span class="line">	|</span><br><span class="line">_raw_spin_lock</span><br><span class="line">	|</span><br><span class="line">__raw_spin_lock --&gt; &#123;</span><br><span class="line">		preempt_disable();</span><br><span class="line">		spin_acquire(&amp;lock-&gt;dep_map, 0, 0, _RET_IP_);</span><br><span class="line">		LOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>file: include&#x2F;linux&#x2F;spinlock.h</p>
</blockquote>
<h4 id="do-raw-spin-trylock"><a href="#do-raw-spin-trylock" class="headerlink" title="do_raw_spin_trylock"></a>do_raw_spin_trylock</h4><p>定义：CONFIG_LOCK_STAT</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">debug_spin_lock_before</span><span class="params">(<span class="type">raw_spinlock_t</span> *lock)</span></span><br><span class="line">&#123;</span><br><span class="line">	SPIN_BUG_ON(lock-&gt;magic != SPINLOCK_MAGIC, lock, <span class="string">&quot;bad magic&quot;</span>);</span><br><span class="line">	<span class="comment">//进程重入</span></span><br><span class="line">	SPIN_BUG_ON(lock-&gt;owner == current, lock, <span class="string">&quot;recursion&quot;</span>);</span><br><span class="line">	<span class="comment">//CPU重入</span></span><br><span class="line">	SPIN_BUG_ON(lock-&gt;owner_cpu == raw_smp_processor_id(),</span><br><span class="line">							lock, <span class="string">&quot;cpu recursion&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">debug_spin_lock_after</span><span class="params">(<span class="type">raw_spinlock_t</span> *lock)</span></span><br><span class="line">&#123;</span><br><span class="line">	lock-&gt;owner_cpu = raw_smp_processor_id();</span><br><span class="line">	lock-&gt;owner = current;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">定义：CONFIG_LOCK_STAT</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOCK_CONTENDED(_lock, try, lock)			\</span></span><br><span class="line"><span class="meta">do &#123;								\</span></span><br><span class="line"><span class="meta">	<span class="keyword">if</span> (!try(_lock)) &#123;					\</span></span><br><span class="line"><span class="meta">		lock_contended(&amp;(_lock)-&gt;dep_map, _RET_IP_);	\</span></span><br><span class="line"><span class="meta">		lock(_lock);					\</span></span><br><span class="line"><span class="meta">	&#125;							\</span></span><br><span class="line"><span class="meta">	lock_acquired(&amp;(_lock)-&gt;dep_map, _RET_IP_);			\</span></span><br><span class="line"><span class="meta">&#125; while (0)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">do_raw_spin_trylock</span><span class="params">(<span class="type">raw_spinlock_t</span> *lock)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret = arch_spin_trylock(&amp;lock-&gt;raw_lock);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">		debug_spin_lock_after(lock);  <span class="comment">//上锁成功后进行重新赋值</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CONFIG_SMP</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Must not happen on UP:</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	SPIN_BUG_ON(!ret, lock, <span class="string">&quot;trylock failure on UP&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>file: lib&#x2F;spinlock_debug.c</p>
</blockquote>
<h4 id="do-raw-spin-lock"><a href="#do-raw-spin-lock" class="headerlink" title="do_raw_spin_lock"></a>do_raw_spin_lock</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LOCK_CONTENDED(_lock, try, lock) \</span></span><br><span class="line"><span class="meta">	lock(_lock)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">do_raw_spin_lock</span><span class="params">(<span class="type">raw_spinlock_t</span> *lock)</span></span><br><span class="line">&#123;</span><br><span class="line">	debug_spin_lock_before(lock);</span><br><span class="line">	<span class="keyword">if</span> (unlikely(!arch_spin_trylock(&amp;lock-&gt;raw_lock)))</span><br><span class="line">		__spin_lock_debug(lock);</span><br><span class="line">	debug_spin_lock_after(lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>file: lib&#x2F;spinlock_debug.c</p>
</blockquote>
<p><code>arch_spin_trylock</code>主要实现不同架构的实际<code>加锁</code>的功能函数。如果上锁失败将进入<code>_spin_lock_debug</code>函数，打印上锁失败的原因。在<code>do_raw_spin_lock</code>函数中除路上锁的关键函数，其他函数均为debug函数，这里主要说明debug函数的原理和死锁出现后的debug info的具体含义。</p>
<h2 id="Debug-Info"><a href="#Debug-Info" class="headerlink" title="Debug Info"></a>Debug Info</h2><p>如果上锁失败，将不断尝试上锁直到超时，内核认为出现死锁，主要的引起原因有：<code>该锁没有被释放</code>（排除CPU硬件错误）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> __spin_lock_debug(<span class="type">raw_spinlock_t</span> *lock)</span><br><span class="line">&#123;</span><br><span class="line">	u64 i;</span><br><span class="line">	u64 loops = loops_per_jiffy * HZ;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; loops; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (arch_spin_trylock(&amp;lock-&gt;raw_lock))</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		__delay(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* lockup suspected: */</span></span><br><span class="line">	spin_dump(lock, <span class="string">&quot;lockup suspected&quot;</span>);</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> loops_per_jiffy = (<span class="number">1</span>&lt;&lt;<span class="number">12</span>);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>file: &#x2F;init&#x2F;main.c</p>
</blockquote>
<p><code>loops_per_jiffy</code>:定义超时时间, (4096)_delay(1)为4096s</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[15299.717341] BUG: spinlock lockup suspected on CPU#1, rixitest/4186</span><br><span class="line">[15299.723758]  lock: 0x8c77d644, .magic: dead4ead, .owner: rixitest/4161, .owner_cpu: 0</span><br><span class="line">[15299.731858] CPU: 1 PID: 4186 Comm: rixitest Not tainted 3.10.14-00058-g5afe79c #3</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">spin_dump</span><span class="params">(<span class="type">raw_spinlock_t</span> *lock, <span class="type">const</span> <span class="type">char</span> *msg)</span></span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">	printk(KERN_EMERG <span class="string">&quot;BUG: spinlock %s on CPU#%d, %s/%d\n&quot;</span>,</span><br><span class="line">		msg, raw_smp_processor_id(),</span><br><span class="line">		current-&gt;comm, task_pid_nr(current));</span><br><span class="line">	printk(KERN_EMERG <span class="string">&quot; lock: %pS, .magic: %08x, .owner: %s/%d, &quot;</span></span><br><span class="line">			<span class="string">&quot;.owner_cpu: %d\n&quot;</span>,</span><br><span class="line">		lock, lock-&gt;magic,</span><br><span class="line">		owner ? owner-&gt;comm : <span class="string">&quot;&lt;none&gt;&quot;</span>,</span><br><span class="line">		owner ? task_pid_nr(owner) : <span class="number">-1</span>,</span><br><span class="line">		lock-&gt;owner_cpu);</span><br><span class="line">	dump_stack();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>lockup suspected on CPU#1</code>: 说明当前检测到死锁的CPU为核1<br><code>.owner_cpu: 0</code>:说明之前上锁的CPU为核0</p>
</blockquote>
<blockquote>
<p>以上log说明有一把锁，在核0上锁后，没有释放之前核1有一次去上锁，从而导致死锁</p>
</blockquote>
<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><h3 id="信号异常造成的死锁"><a href="#信号异常造成的死锁" class="headerlink" title="信号异常造成的死锁"></a>信号异常造成的死锁</h3><blockquote>
<p>两核互锁</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[   50.920653] BUG: spinlock lockup suspected on CPU#0, rixitest/835</span><br><span class="line">[   50.933282]  lock: 0x8c57c9e4, .magic: dead4ead, .owner: rixitest/507, .owner_cpu: 1</span><br><span class="line">[   50.941294] CPU: 0 PID: 835 Comm: rixitest Not tainted 3.10.14-00058-g5afe79c-dirty</span><br><span class="line"></span><br><span class="line">[   50.949568] Stack : 8211374a 0000004b 80510000 80510000 00000343 80050000 8c888d40</span><br><span class="line"></span><br><span class="line">	8049e028 00000000 00000343 82112ee0 8004eee8 8cff7ee8 82120000 803e79ac</span><br><span class="line">	80510000 8003b454 8c57c9e4 00000000 8049fb4c 8cff7d74 8cff7d74 8c888d40</span><br><span class="line">	00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000</span><br><span class="line">	00000000 00000000 00000000 00000000 00000000 00000000 00000000 8cff7d08</span><br><span class="line">	...</span><br><span class="line">[   50.986508] Call Trace:</span><br><span class="line">[   50.989051] [&lt;80021cf4&gt;] show_stack+0x48/0x70</span><br><span class="line">[   50.993564] [&lt;8021c804&gt;] do_raw_spin_lock+0x12c/0x184 //spin_lock_irq(&amp;sighand-&gt;siglock)</span><br><span class="line">[   50.998793] [&lt;8004ecc0&gt;] get_signal_to_deliver+0xb8/0x690</span><br><span class="line">[   51.004378] [&lt;8001fb08&gt;] do_signal+0x30/0x1fc</span><br><span class="line">[   51.008887] [&lt;80020c84&gt;] do_notify_resume+0x34/0x90</span><br><span class="line">[   51.013940] [&lt;8001b8a4&gt;] work_notifysig+0x10/0x18</span><br><span class="line">[   51.018802]</span><br><span class="line">[   64.332523] SMP[0] action:1 will reenter, mailbox:1, timeout:16777216</span><br><span class="line">[   64.339172] CPU: 1 PID: 507 Comm: rixitest Not tainted 3.10.14-00058-g5afe79c-dirty</span><br><span class="line"></span><br><span class="line">[   64.347425] Stack : 8211374a 0000004b 80510000 80510000 000001fb 01000000 8c54b9c0</span><br><span class="line"></span><br><span class="line">	8049e028 00000001 000001fb 82112ee0 00000000 8c551ee8 82120000 803e79ac</span><br><span class="line">	00000000 8003b454 00000006 00000000 8049fb4c 8c551c14 8c551c14 8c54b9c0</span><br><span class="line">	00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000</span><br><span class="line">	00000000 00000000 00000000 00000000 00000000 00000000 00000000 8c551ba8</span><br><span class="line">	...</span><br><span class="line">[   64.384270] Call Trace:</span><br><span class="line">[   64.386796] [&lt;80021cf4&gt;] show_stack+0x48/0x70</span><br><span class="line">[   64.391295] [&lt;80011eb4&gt;] xburst2_send_ipi_single+0xb4/0x114</span><br><span class="line">[   64.397051] [&lt;8006d800&gt;] try_to_wake_up+0x298/0x31c</span><br><span class="line">[   64.402093] [&lt;8004c7fc&gt;] signal_wake_up_state+0x44/0x68</span><br><span class="line">[   64.407489] [&lt;80138e44&gt;] zap_process+0x80/0xbc    //spin_lock_irq(&amp;tsk-&gt;sighand-&gt;siglock);</span><br><span class="line">[   64.412077] [&lt;8013926c&gt;] do_coredump+0x160/0xc24</span><br><span class="line">[   64.416843] [&lt;8004f24c&gt;] get_signal_to_deliver+0x644/0x690</span><br><span class="line">[   64.422504] [&lt;8001fb08&gt;] do_signal+0x30/0x1fc</span><br><span class="line">[   64.427002] [&lt;80020c84&gt;] do_notify_resume+0x34/0x90</span><br><span class="line">[   64.432040] [&lt;8001b8a4&gt;] work_notifysig+0x10/0x18</span><br><span class="line">[   64.436889]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>死锁的产生和发送IPI的先后顺序：先死锁后发送IPI</p>
</blockquote>
<ol>
<li>最开始的两个打印可以得到，CPU0进行上锁时，发现该锁被CPU1所持有，所以造成两核互锁</li>
<li>CPU1上完<code>spin_lock_irq(siglock)</code>锁后，发送IPI（sched调度），此时信号处理进程被调度到CPU0，并且也进行<code>spin_lock_irq(siglock)</code>上锁，由于CPU1上完锁后等待IPI的完成，但是此时CPU1已经<em><strong>关闭中断的IE位，其中包括IPI中断，因此IPI无法完成</strong></em>，CPU1的锁无法释放，同时CPU0又在上同一把锁<code>siglock</code>,从而造成死锁</li>
</ol>
]]></content>
      <categories>
        <category>Linux内核</category>
      </categories>
      <tags>
        <tag>sync</tag>
        <tag>spinlock</tag>
        <tag>死锁</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux内核调试方法---Debug</title>
    <url>/post/53462.html</url>
    <content><![CDATA[<p>常用的Linux调试方法：</p>
<span id="more"></span>

<table>
<thead>
<tr>
<th align="center">工具</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">debugfs文件系统</td>
<td align="center">提供了 procfs, sysfs, debugfs以及 relayfs 来与用户空间进行数据交互, 尤其是 debugfs, 这是内核开发者们实现的专门用来调试的文件系统接口. 其他的工具或者接口, 多数都依赖于 debugfs</td>
</tr>
<tr>
<td align="center">printk</td>
<td align="center">强大的输出系统, 没有什么逻辑上的bug是用PRINT解决不了的</td>
</tr>
<tr>
<td align="center">ftrace以及其前端工具trace-cmd等</td>
<td align="center">内核提供了 ftrace 工具来实现检查点, 事件等的检测, 这一框架依赖于 debugfs, 他在 debugfs 中的 tracing 子系统中为用户提供了丰富的操作接口, 我们可以通过该系统对内核实现检测和分析. 功能虽然强大, 但是其操作并不是很简单, 因此使用者们为实现了 trace-cmd 等前端工具, 简化了 ftrace 的使用.</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<h2 id="objdump"><a href="#objdump" class="headerlink" title="objdump"></a>objdump</h2><h3 id="用法："><a href="#用法：" class="headerlink" title="用法："></a>用法：</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">objdump -D a.out &gt; a.dump</span><br></pre></td></tr></table></figure>
<h3 id="常用参数："><a href="#常用参数：" class="headerlink" title="常用参数："></a>常用参数：</h3><ul>
<li>-d:将代码段反汇编</li>
<li>-D:表示对全部文件进行反汇编</li>
<li>-S:将代码段反汇编的同时，将<code>反汇编代码和源代码交替显示</code>，编译时需要给出-g，即需要调试信息。</li>
<li>-C:将C++符号名逆向解析。</li>
<li>-l:反汇编代码中插入源代码的文件名和行号。</li>
<li>-j section:仅反汇编指定的section。可以有多个-j参数来选择多个section。</li>
</ul>
<blockquote>
<p>$mips-linux-gnu-objdump -d vmlinux &gt; a.s</p>
</blockquote>
<h2 id="addr2line"><a href="#addr2line" class="headerlink" title="addr2line"></a>addr2line</h2><p>一个可以将指令的地址和可执行映像转换成文件名、函数名和源代码行数的工具</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">=====&gt;$mips-linux-gnu-addr2line -e out/target/product/xxxxx/symbols/system/lib/libdvm.so 23452</span><br><span class="line">/work/android-4.3-fpga/dalvik/vm/mterp/out/InterpAsm-mips.S:1335</span><br></pre></td></tr></table></figure>
<blockquote>
<p>23452 –&gt; 异常PC</p>
</blockquote>
<blockquote>
<p>mips-linux-gnu-addr2line -e vmlinux 0x802354c0</p>
</blockquote>
<h2 id="汇编定位"><a href="#汇编定位" class="headerlink" title="汇编定位"></a>汇编定位</h2><blockquote>
<p>在函数中添加空指令，确认该代码段反汇编后的具体位置.</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">asm __volatile__(&quot;ssnop\n\t&quot;);</span><br><span class="line">asm __volatile__(&quot;ssnop\n\t&quot;);</span><br><span class="line"></span><br><span class="line">for (i = 0; i &lt;= MAXJSAMPLE; i++)</span><br><span class="line">	table[i] = (JSAMPLE) i;</span><br><span class="line"></span><br><span class="line">asm __volatile__(&quot;ssnop\n\t&quot;);</span><br><span class="line">asm __volatile__(&quot;ssnop\n\t&quot;);</span><br></pre></td></tr></table></figure>
<h2 id="ftrace"><a href="#ftrace" class="headerlink" title="ftrace"></a>ftrace</h2><p>ftrace 是内建于 Linux 内核的跟踪工具，从 2.6.27 开始加入主流内核。使用 ftrace 可以调试或者分析内核中发生的事情。ftrace 提供了不同的跟踪器，以用于不同的场合，比如跟踪内核函数调用、对上下文切换进行跟踪、查看中断被关闭的时长、跟踪内核态中的延迟以及性能问题等</p>
<blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9lbGl4aXIuYm9vdGxpbi5jb20vbGludXgvdjQuMTYtcmM1L3NvdXJjZS9Eb2N1bWVudGF0aW9uL3RyYWNl">Documentation&#x2F;trace&#x2F;ftrace.txt<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<h3 id="kernel配置"><a href="#kernel配置" class="headerlink" title="kernel配置"></a>kernel配置</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Symbol: FTRACE [=y]</span><br><span class="line">Type  : boolean</span><br><span class="line">Prompt: Tracers</span><br><span class="line">  Location:</span><br><span class="line">      -&gt; Kernel hacking</span><br><span class="line">	    Defined at kernel/trace/Kconfig:135</span><br><span class="line">		  Depends on: TRACING_SUPPORT [=y]</span><br><span class="line"></span><br><span class="line">--- Tracers</span><br><span class="line">-*-   Kernel Function Tracer</span><br><span class="line">[*]     Kernel Function Graph Tracer</span><br><span class="line">[*]   Interrupts-off Latency Tracer</span><br><span class="line">[*]   Preemption-off Latency Tracer</span><br><span class="line">[*]   Scheduling Latency Tracer</span><br><span class="line">-*-   Create a snapshot trace buffer</span><br><span class="line">-*-     Allow snapshot to swap per CPU</span><br><span class="line">Branch Profiling (No branch profiling)  ---&gt;</span><br><span class="line">[*]   Trace max stack</span><br><span class="line">[*]   Support for tracing block IO actions</span><br><span class="line">[*]   enable/disable function tracing dynamically</span><br><span class="line">[ ]   Kernel function profiler</span><br><span class="line">[ ]   Perform a startup test on ftrace</span><br><span class="line">&lt; &gt;   Ring buffer benchmark stress tester</span><br><span class="line">[ ]   Ring buffer startup self test</span><br></pre></td></tr></table></figure>

<h3 id="Use"><a href="#Use" class="headerlink" title="Use"></a>Use</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">mount -t debugfs none /mnt/</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># cd /mnt/tracing/</span><br><span class="line"># ls</span><br><span class="line">README                      set_event</span><br><span class="line">available_events            set_ftrace_filter</span><br><span class="line">available_filter_functions  set_ftrace_notrace</span><br><span class="line">available_tracers           set_ftrace_pid</span><br><span class="line">buffer_size_kb              set_graph_function</span><br><span class="line">buffer_total_size_kb        snapshot</span><br><span class="line">current_tracer              stack_max_size</span><br><span class="line">dyn_ftrace_total_info       stack_trace</span><br><span class="line">enabled_functions           stack_trace_filter</span><br><span class="line">events                      trace</span><br><span class="line">free_buffer                 trace_clock</span><br><span class="line">instances                   trace_marker</span><br><span class="line">max_graph_depth             trace_options</span><br><span class="line">options                     trace_pipe</span><br><span class="line">per_cpu                     tracing_cpumask</span><br><span class="line">printk_formats              tracing_max_latency</span><br><span class="line">saved_cmdlines              tracing_on</span><br><span class="line">saved_tgids                 tracing_thresh</span><br></pre></td></tr></table></figure>

<h3 id="available-tracers"><a href="#available-tracers" class="headerlink" title="available_tracers"></a>available_tracers</h3><p>记录了当前编译进内核的跟踪器的列表</p>
<blockquote>
<p>available_tracers     - list of configured tracers for current_tracer</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">cat</span> available_tracers</span></span><br><span class="line">blk function_graph wakeup_rt wakeup preemptirqsoff preemptoff irqsoff function nop</span><br></pre></td></tr></table></figure>

<h3 id="current-tracer"><a href="#current-tracer" class="headerlink" title="current_tracer"></a>current_tracer</h3><p>用于设置或显示当前使用的跟踪器；<br>使用<code>echo</code>将跟踪器名字写入该文件可以切换到不同的跟踪器。系统启动后，其缺省值为<code>nop</code> ，即不做任何跟踪操作。在执行完一段跟踪任务后，可以通过向该文件写入<code>nop</code>来重置跟踪器。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">echo</span> wakeup &gt; current_tracer</span></span><br></pre></td></tr></table></figure>

<h3 id="trace"><a href="#trace" class="headerlink" title="trace"></a>trace</h3><p>文件提供了查看获取到的跟踪信息的接口。</p>
<p>通过 cat 等命令查看该文件以查看跟踪到的内核活动记录，也可以将其内容保存为记录文件以备后续查看。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">cat</span> trace</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">tracer: wakeup</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># wakeup latency trace v1.1.5 on 3.10.14-00042-ge40985e</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--------------------------------------------------------------------</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">latency: 624 us, <span class="comment">#174/174, CPU#0 | (M:preempt VP:0, KP:0, SP:0 HP:0 #P:2)</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">   -----------------</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">   | task: ksdioirqd/mmc1-155 (uid:0 <span class="built_in">nice</span>:0 policy:1 rt_prio:1)</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">   -----------------</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment">#                  _------=&gt; CPU#</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">                / _-----=&gt; irqs-off</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">               | / _----=&gt; need-resched</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">               || / _---=&gt; hardirq/softirq</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">               ||| / _--=&gt; preempt-depth</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">               |||| /     delay</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"> cmd     pid   ||||| time  |   <span class="built_in">caller</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">    \   /      |||||  \    |   /</span></span><br><span class="line">&lt;idle&gt;-0       0dNh4    4us+:      0:120:R   + [000]   155: 98:R ksdioirqd/mmc1</span><br><span class="line">&lt;idle&gt;-0       0dNh4   12us+: 0</span><br><span class="line">&lt;idle&gt;-0       0dNh4   17us+: task_woken_rt &lt;-ttwu_do_wakeup</span><br><span class="line">&lt;idle&gt;-0       0dNh4   21us+: _raw_spin_unlock &lt;-try_to_wake_up</span><br><span class="line">&lt;idle&gt;-0       0dNh4   24us+: sub_preempt_count &lt;-_raw_spin_unlock</span><br><span class="line">&lt;idle&gt;-0       0dNh3   28us+: _raw_spin_unlock_irqrestore &lt;-try_to_wake_up</span><br><span class="line">....</span><br></pre></td></tr></table></figure>

<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><blockquote>
<p>内核中断</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">echo</span> 0 &gt; tracing_on</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">echo</span> &gt; trace</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">echo</span> nop &gt; current_tracer</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">echo</span> irq &gt; set_event</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">echo</span> 1 &gt; tracing_on</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">cat</span> trace_pipe</span></span><br><span class="line">		sh-100   [000] d.h3  1333.894909: irq_handler_entry: irq=58 name=uart1</span><br><span class="line">		sh-100   [000] d.h3  1333.894931: irq_handler_exit: irq=58 ret=handled</span><br><span class="line">	&lt;idle&gt;-0     [000] d.h2  1333.902444: irq_handler_entry: irq=34 name=jz-timerirq</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">cat</span> trace</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">tracer: nop</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># entries-in-buffer/entries-written: 5510/5510   #P:1</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment">#                              _-----=&gt; irqs-off</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">                            / _----=&gt; need-resched</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">                           | / _---=&gt; hardirq/softirq</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">                           || / _--=&gt; preempt-depth</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">                           ||| /     delay</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">          TASK-PID   CPU<span class="comment">#  ||||    TIMESTAMP  FUNCTION</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">             | |       |   ||||       |         |</span></span><br><span class="line">              sh-100   [000] d.h3  1342.498892: irq_handler_exit: irq=58 ret=handled</span><br><span class="line">		&lt;idle&gt;-0     [000] d.h2  1342.673707: irq_handler_entry: irq=34 name=jz-timerirq</span><br><span class="line">		&lt;idle&gt;-0     [000] d.h2  1342.673717: irq_handler_exit: irq=34 ret=handled</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><span class="exturl" data-url="aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ2F0aWVtZS9hcnRpY2xlL2RldGFpbHMvNjg5NDgwODA=">Linux内核调试的方式以及工具集锦<i class="fa fa-external-link-alt"></i></span></li>
</ol>
]]></content>
      <categories>
        <category>Linux内核</category>
      </categories>
      <tags>
        <tag>kernel</tag>
        <tag>debug</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux内核DMA机制</title>
    <url>/post/59370.html</url>
    <content><![CDATA[<blockquote>
<ul>
<li>DMA的映射机制</li>
<li>DMA的数据处理</li>
<li>DMA物理通道和逻辑通道</li>
<li>DMA地址空间的排布</li>
<li>一致性和流式DMA的定义和区别</li>
</ul>
</blockquote>
<span id="more"></span>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><span class="exturl" data-url="aHR0cHM6Ly9teS5vc2NoaW5hLm5ldC91LzE3NDI0Mi9ibG9nLzcwMzU5">Linux 内核DMA机制<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cua2VybmVsLm9yZy9kb2MvRG9jdW1lbnRhdGlvbi9ETUEtQVBJLUhPV1RPLnR4dA==">内核文档<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cubGludXhqb3VybmFsLmNvbS9hcnRpY2xlLzcxMDQ=">Kernel Korner - Using DMA<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9zdGF0aWMubHduLm5ldC9pbWFnZXMvcGRmL0xERDMvY2gxNS5wZGY=">LDD3-ch15<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL2xpbnV4cGVyZi5jb20vP3A9Njc=">DMAR 与 IOMMU<i class="fa fa-external-link-alt"></i></span></li>
</ol>
]]></content>
      <categories>
        <category>Linux内核</category>
      </categories>
      <tags>
        <tag>kernel</tag>
        <tag>dma</tag>
      </tags>
  </entry>
  <entry>
    <title>Hung Task</title>
    <url>/post/16306.html</url>
    <content><![CDATA[<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[10505.024599] INFO: task ps:26540 blocked for more than 120 seconds.</span><br><span class="line">[10505.199520] &quot;echo 0 &gt; /proc/sys/kernel/hung_task_timeout_secs&quot; disables this message.</span><br><span class="line">[10507.707796] ps              D 804059d4     0 26540    110 0x00100000</span><br><span class="line">[10510.574054] Stack : 00000000 8ba75900 807d2ff0 8008c99c 8052c27c 8057e800 00000003 880022</span><br><span class="line"></span><br><span class="line">	8ba75900 80402e34 880180a0 00000001 880180a4 80580000 804bac00 8ba75900</span><br><span class="line">	804be4ec 880180c4 80ab0000 804059d4 ffffff69 8ba75900 004bb030 880180a0</span><br><span class="line">	00000001 80402dc8 8aa7cb80 00000001 8a531df8 800f6b3c 00000002 00000000</span><br><span class="line">	800f7c84 8a531df8 8bc8bd60 880180c4 8ba75900 8a531d00 8a531df8 00000001</span><br><span class="line">	...</span><br><span class="line">[10530.536867] Call Trace:</span><br><span class="line">[10532.061092] [&lt;80405324&gt;] __schedule+0x5d4/0x814</span><br><span class="line">[10533.833196] [&lt;804059d4&gt;] schedule_preempt_disabled+0x18/0x30</span><br><span class="line">[10535.744720] [&lt;80402dc8&gt;] mutex_lock_nested+0x264/0x468</span><br><span class="line">[10537.733761] [&lt;800f7c84&gt;] lookup_slow+0x44/0xd4</span><br><span class="line">[10539.417797] [&lt;800f9590&gt;] path_lookupat+0x13c/0x804</span><br><span class="line">[10541.347068] [&lt;800f9c8c&gt;] filename_lookup.isra.10+0x34/0xa0</span><br><span class="line">[10543.326101] [&lt;800fbd70&gt;] user_path_at_empty+0x60/0xa0</span><br><span class="line">[10545.166088] [&lt;800fbdc4&gt;] user_path_at+0x14/0x20</span><br><span class="line">[10546.921821] [&lt;800f1fe8&gt;] vfs_fstatat+0x64/0xc4</span><br><span class="line">[10548.672953] [&lt;800f25a4&gt;] SyS_stat64+0x18/0x3c</span><br><span class="line">[10550.256996] [&lt;800250b4&gt;] stack_done+0x20/0x44</span><br><span class="line">[10551.912049]</span><br><span class="line">[10552.654893] 1 lock held by ps/26540:</span><br><span class="line">[10553.986958]  #0:  (&amp;sb-&gt;s_type-&gt;i_mutex_key)&#123;+.+.+.&#125;, at: [&lt;800f7c84&gt;] lookup_slow+0x44/0xd4</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<blockquote>
<p>Detecting hung tasks in Linux</p>
</blockquote>
<blockquote>
<p>Sometimes tasks under Linux are blocked forever (essentially hung). Recent Linux kernels have an infrastructure to detect hung tasks. When this infrastructure is active it will periodically get activated to find out hung tasks and present a stack dump of those hung tasks (and maybe locks held). Additionally we can choose to panic the system when we detect atleast one hung task in the system. I will try to explain how khungtaskd works.</p>
</blockquote>
<blockquote>
<p>The infrastructure is based on a single kernel thread named as “khungtaskd”. So if you do a ps in your system and see that there is entry like [khungtaskd] you know it is there. I have one in my system: “136 root SW [khungtaskd]”</p>
</blockquote>
<blockquote>
<p>The loop of the khungtaskd daemon is a call to the scheduler for waking it up after ever 120 seconds (default value). The core algorithm is like this:</p>
</blockquote>
<blockquote>
<ol>
<li>Iterate over all the tasks in the system which are marked as <code>TASK_UNINTERRUPTIBLE</code> (additionally it does not consider UNINTERRUPTIBLE frozen tasks &amp; UNINTERRUPTIBLE tasks that are newly created and never been scheduled out).</li>
</ol>
</blockquote>
<blockquote>
<ol start="2">
<li>If a task has not been switched out by the scheduler atleast once in the last 120 seconds it is considered as a hung task and its stack dump is displayed. If CONFIG_LOCKDEP is defined then it will also show all the locks the hung task is holding.</li>
</ol>
</blockquote>
<blockquote>
<p>One can change the sampling interval of khungtaskd through the sysctl interface <code>/proc/sys/kernel/hung_task_timeout_secs</code>.</p>
</blockquote>
<p>该现象是内核的保护机制造成, D状态即无法中断的休眠进程，是由于在等待IO，比如磁盘IO，网络IO，其他外设IO，如果进程正在等待的IO在较长的时间内都没有响应.</p>
<p>检测每一个进程控制块；当进程处于TASK_UNINTERRUPTIBLE状态时，调用check_hung_task；<br>内核通过khungtaskd线程在<code>hung_task_timeout_secs</code>时间内唤醒，并检测每一个进程控制块，判断该进程是否挂起(TASK_UNINTERRUPTIBLE),如果存在挂起的任务，将调用<code>check_hung_task</code>。</p>
<h2 id="错误日志输出原因："><a href="#错误日志输出原因：" class="headerlink" title="错误日志输出原因："></a>错误日志输出原因：</h2><p>通过栈的dump信息，可以得到出错的主要原因是由于<code>SyS_stat64</code>系统调用引起。在C语言库里的函数是stat, fstat, lstat. 获取文件的状态。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$man stat64</span><br><span class="line">NAME</span><br><span class="line">       stat, fstat, lstat - get file status</span><br><span class="line">DESCRIPTION</span><br><span class="line">       These  functions  return  information about a file.  No permissions are required on the file itself, but—in the case of stat() and lstat() — execute (search) permission is required on all of the  directories  in  path  that lead to the file.</span><br></pre></td></tr></table></figure>

<h2 id="产生的原因"><a href="#产生的原因" class="headerlink" title="产生的原因"></a>产生的原因</h2><ul>
<li>IO阻塞</li>
<li>内核模块出错</li>
</ul>
<h2 id="amdgpu"><a href="#amdgpu" class="headerlink" title="amdgpu"></a>amdgpu</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">23:02:20 localhost.localdomain kernel: amdgpu 0001:01:00.0: GPU fault detected: 146 0x0080442c</span><br><span class="line">23:02:20 localhost.localdomain kernel: amdgpu 0001:01:00.0:   VM_CONTEXT1_PROTECTION_FAULT_ADDR   0x00101A10</span><br><span class="line">23:02:20 localhost.localdomain kernel: amdgpu 0001:01:00.0:   VM_CONTEXT1_PROTECTION_FAULT_STATUS 0x0804402C</span><br><span class="line">23:02:20 localhost.localdomain kernel: amdgpu 0001:01:00.0: VM fault (0x2c, vmid 4) at page 1055248, read from &#x27;TC1&#x27; (0x54433100) (68)</span><br><span class="line">23:02:34 localhost.localdomain kernel: amdgpu 0001:01:00.0: GPU fault detected: 146 0x00183d0c</span><br><span class="line">23:02:34 localhost.localdomain kernel: amdgpu 0001:01:00.0:   VM_CONTEXT1_PROTECTION_FAULT_ADDR   0x00101A03</span><br><span class="line">23:02:34 localhost.localdomain kernel: amdgpu 0001:01:00.0:   VM_CONTEXT1_PROTECTION_FAULT_STATUS 0x0A03D00C</span><br><span class="line">23:02:34 localhost.localdomain kernel: amdgpu 0001:01:00.0: VM fault (0x0c, vmid 5) at page 1055235, read from &#x27;SDM1&#x27; (0x53444d31) (61)</span><br><span class="line">23:05:11 localhost.localdomain kernel: INFO: task qemu-system-aar:8361 blocked for more than 120 seconds.</span><br><span class="line">23:05:11 localhost.localdomain kernel:       Tainted: G        W      ------------   4.14.0-115.10.1.el7a.aarch64 #1</span><br><span class="line">23:05:11 localhost.localdomain kernel: &quot;echo 0 &gt; /proc/sys/kernel/hung_task_timeout_secs&quot; disables this message.</span><br><span class="line">23:05:11 localhost.localdomain kernel: qemu-system-aar D    0  8361  30794 0x00000200</span><br><span class="line">23:05:11 localhost.localdomain kernel: Call trace:</span><br><span class="line">23:05:11 localhost.localdomain kernel: [&lt;ffff000008085eb4&gt;] __switch_to+0x8c/0xa8</span><br><span class="line">23:05:11 localhost.localdomain kernel: [&lt;ffff00000885f9f0&gt;] __schedule+0x340/0x914</span><br><span class="line">23:05:11 localhost.localdomain kernel: [&lt;ffff00000885fff8&gt;] schedule+0x34/0x8c</span><br><span class="line">23:05:11 localhost.localdomain kernel: [&lt;ffff000005aac1f8&gt;] amd_sched_entity_push_job+0x98/0x148 [amdgpu]</span><br><span class="line">23:05:11 localhost.localdomain kernel: [&lt;ffff000005aacfa4&gt;] amdgpu_job_submit+0x88/0xa4 [amdgpu]</span><br><span class="line">23:05:11 localhost.localdomain kernel: [&lt;ffff000005a233ac&gt;] amdgpu_vm_bo_update_mapping.constprop.21+0x2b0/0x354 [amdgpu]</span><br><span class="line">23:05:11 localhost.localdomain kernel: [&lt;ffff000005a23b38&gt;] amdgpu_vm_clear_freed+0xc8/0x1d0 [amdgpu]</span><br><span class="line">23:05:11 localhost.localdomain kernel: [&lt;ffff000005a0efe8&gt;] amdgpu_gem_va_ioctl+0x400/0x478 [amdgpu]</span><br><span class="line">23:05:11 localhost.localdomain kernel: [&lt;ffff0000057b63c4&gt;] drm_ioctl_kernel+0x74/0xd8 [drm]</span><br><span class="line">23:05:11 localhost.localdomain kernel: [&lt;ffff0000057b6710&gt;] drm_ioctl+0x2b4/0x3ec [drm]</span><br><span class="line">23:05:11 localhost.localdomain kernel: [&lt;ffff0000059f0054&gt;] amdgpu_drm_ioctl+0x54/0x90 [amdgpu]</span><br><span class="line">23:05:11 localhost.localdomain kernel: [&lt;ffff0000082c2ee8&gt;] do_vfs_ioctl+0xcc/0x8f0</span><br><span class="line">23:05:11 localhost.localdomain kernel: [&lt;ffff0000082c379c&gt;] SyS_ioctl+0x90/0xa4</span><br><span class="line">23:05:11 localhost.localdomain kernel: Exception stack(0xffff0000379cfec0 to 0xffff0000379d0000)</span><br><span class="line">23:05:11 localhost.localdomain kernel: fec0: 0000000000000014 00000000c0286448 0000fffffb7cfbb0 00000000c0286400</span><br><span class="line">23:05:11 localhost.localdomain kernel: fee0: 00000000c0006400 000000000000000e 0000000000000002 0000000000410000</span><br><span class="line">23:05:11 localhost.localdomain kernel: ff00: 000000000000001d 0000000017a53200 0000000000000289 000000002e6d71d2</span><br><span class="line">23:05:11 localhost.localdomain kernel: ff20: 0000000000000018 000000005d731dca 0021ee150a5f677c 0000e05d5e15bff7</span><br><span class="line">23:05:11 localhost.localdomain kernel: ff40: 0000ffffa16802a8 0000ffffa17660e0 0000000000000a00 0000ffff9c81f000</span><br><span class="line">23:05:11 localhost.localdomain kernel: ff60: 0000fffffb7cfbb0 00000000c0286448 0000000000000014 0000000000000040</span><br><span class="line">23:05:11 localhost.localdomain kernel: ff80: 0000000017a53818 000000001ad84f30 00000000000003e8 0000000017a53858</span><br><span class="line">23:05:11 localhost.localdomain kernel: ffa0: 000000001ad84f10 0000fffffb7cfb50 0000ffffa1655c48 0000fffffb7cfb50</span><br><span class="line">23:05:11 localhost.localdomain kernel: ffc0: 0000ffffa17660ec 0000000080000000 0000000000000014 000000000000001d</span><br><span class="line">23:05:11 localhost.localdomain kernel: ffe0: 0000000000000000 0000000000000000 0000000000000000 0000000000000000</span><br><span class="line">23:05:11 localhost.localdomain kernel: [&lt;ffff00000808392c&gt;] __sys_trace_return+0x0/0x4</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ps aux | grep &quot;qemu&quot;</span><br><span class="line">root      8361  9.4  6.8 11088576 4540480 pts/2 Dl+ 11:56  67:19 qemu-system-aarch64 -m 8192 -enable-kvm -machine virt-4.0,accel=kvm,gic-version=3 -cpu host -smp 8,sockets=2,cores=4,threads=1 -append console=ttyAMA0,38400 earlycon=pl011,0x09000000 nosmp drm.debug=0x0 rootwait rootdelay=5 androidboot.selinux=permissive -serial mon:stdio -kernel Image -initrd ramdisk.img -drive index=0,if=none,id=system,file=system.img -device virtio-blk-pci,drive=system -drive index=1,if=none,id=cache,file=cache.img -device virtio-blk-pci,drive=cache -drive index=2,if=none,id=userdata,file=userdata.img -device virtio-blk-pci,drive=userdata -netdev user,id=mynet,hostfwd=tcp::5550-:5555 -device virtio-net-pci,netdev=mynet -device virtio-gpu-pci,id=video0,virgl=on,max_outputs=1 -vnc :3 -device virtio-serial-pci -display gtk,gl=on -device qemu-xhci,id=usb -device usb-kbd -device usb-mouse</span><br></pre></td></tr></table></figure>
<blockquote>
<p>进程状态：<code>Dl+</code></p>
</blockquote>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><span class="exturl" data-url="aHR0cDovL2Jsb2cuY2hpbmF1bml4Lm5ldC94bWxycGMucGhwP3I9YmxvZy9hcnRpY2xlJnVpZD0yNTU2NDU4MiZpZD01MjA0MTc3">khungtaskd 检测处于TASK_UNINTERRUPTIBLE状态的进程<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbHVja3lhcHBsZTEwMjgvYXJ0aWNsZS9kZXRhaWxzLzUxOTMxMjEw">Linux内核调试技术——进程D状态死锁检测<i class="fa fa-external-link-alt"></i></span></li>
</ol>
]]></content>
      <categories>
        <category>Linux内核</category>
      </categories>
      <tags>
        <tag>task</tag>
      </tags>
  </entry>
  <entry>
    <title>高端内存</title>
    <url>/post/19487.html</url>
    <content><![CDATA[<p>Linux高端内存是针对物理内存来说的，虚拟内存没有高端这个概念。Linux系统将虚拟内存分为两个部分，即<code>用户地址空间</code>和<code>内核地址空间</code>，对于32位系统来说，虚拟地址空间为4GB，其中用户空间范围为0-3GB，内核空间范围为3-4GB。Linux将3GB开始的内核虚拟地址空间的<code>896M</code>地址直接映射到物理地址空间的0-896M，这部分是永久性映射，剩下的<code>128M</code>则可根据需要进行动态映射，也称临时性映射。如果没有动态映射，那么1GB的内核虚拟地址空间最多只能访问1GB的物理内存，那么如果物理内存大于1GB，就会有一部分物理内存无法被内核访问到，显然不是我们想要的。因此，对于32位系统来说，高端物理内存是内核虚拟地址空间后128M可动态映射使内核得以访问的物理内存，用户空间虚拟地址也是映射到这部分物理内存</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">          ________________ _____    ________________</span><br><span class="line">         |Other KernelData|___  |  |                |</span><br><span class="line">         |----------------|   | |__|                |</span><br><span class="line">         |     Kernel     |\  |____|   Real Other   |</span><br><span class="line">3 GB ---&gt;|----------------| \      |   Kernel Data  |</span><br><span class="line">         |                |\ \     |                |</span><br><span class="line">         |              __|_\_\____|__   Real       |</span><br><span class="line">         |      Tasks     |  \ \   |     Tasks      |</span><br><span class="line">         |              __|___\_\__|__   Space      |</span><br><span class="line">         |                |    \ \ |                |</span><br><span class="line">         |                |     \ \|----------------|</span><br><span class="line">         |                |      \ |Real KernelSpace|</span><br><span class="line">         |________________|       \|________________|</span><br><span class="line"></span><br><span class="line">         Logical Addresses          Physical Addresses</span><br></pre></td></tr></table></figure>
<span id="more"></span>

<h2 id="启动参数”mem-x3D-”"><a href="#启动参数”mem-x3D-”" class="headerlink" title="启动参数”mem&#x3D;”"></a>启动参数”mem&#x3D;”</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mem=255M@0x0 mem=256M@0x30000000</span><br></pre></td></tr></table></figure>
<p>内核解析：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">early_param(&quot;mem&quot;, early_parse_mem);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>file:arch&#x2F;mips&#x2F;kernel&#x2F;setup.c</p>
</blockquote>
<p>mem参数由early_parse_mem函数处理。每一个<code>mem=size@addr</code>格式的参数，表示从<code>addr地址（物理地址）</code>开始的size大小的内存区域。如果没有”@addr”则默认起始地址为<code>0</code>。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><span class="exturl" data-url="aHR0cDovL2lsaW51eGtlcm5lbC5jb20vP3A9MTAxMw==">Linux内核高端内存<i class="fa fa-external-link-alt"></i></span></li>
</ol>
]]></content>
      <categories>
        <category>Linux内核</category>
      </categories>
      <tags>
        <tag>内存</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux内核--中断</title>
    <url>/post/21246.html</url>
    <content><![CDATA[<p>中断有两种：</p>
<ol>
<li>由CPU外部产生。（被动）</li>
<li>由CPU本身在执行程序的时候产生。（主动）</li>
</ol>
<p>中断服务程序一般都是在中断请求关闭的条件下执行的，以避免嵌套而使中断控制复杂化。但是，中断是一个随机事件，它随时会到来，如果关中断的时间太长，CPU就不能及时响应其他的中断请求，从而造成中断的丢失。因此为了保证所有的中断都被响应，并且相对公平的执行，引入了中断下半部，主要有<code>tasklet</code>，<code>工作队列</code>，<code>软中断</code>和<code>线程化irq</code></p>
<span id="more"></span>

<table>
<thead>
<tr>
<th align="center">条件</th>
<th align="center">tasklet</th>
<th align="center">workqueue</th>
<th align="center">softirq</th>
</tr>
</thead>
<tbody><tr>
<td align="center">运行上下文</td>
<td align="center">软中断</td>
<td align="center">进程（内核态）</td>
<td align="center">软中断</td>
</tr>
<tr>
<td align="center">是否sleep</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
</tr>
<tr>
<td align="center">是否关中断</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
</tr>
<tr>
<td align="center">是否可重新调度</td>
<td align="center">是</td>
<td align="center">否</td>
<td align="center">否</td>
</tr>
<tr>
<td align="center">是否可带参数</td>
<td align="center">是</td>
<td align="center">否</td>
<td align="center">否</td>
</tr>
<tr>
<td align="center">谁被触发，谁执行</td>
<td align="center">是</td>
<td align="center">默认是（进程调度）</td>
<td align="center">是</td>
</tr>
<tr>
<td align="center">可同时多CPU执行</td>
<td align="center">同一个Tasklet在任意时刻, 只能被一个CPU执行</td>
<td align="center">有进程调度决定</td>
<td align="center">同一个softirq_action, 可同时被多个CPU执行</td>
</tr>
<tr>
<td align="center">是否可延时执行</td>
<td align="center">否</td>
<td align="center">是</td>
<td align="center">否</td>
</tr>
<tr>
<td align="center">数据结构</td>
<td align="center">softirq_action(中断服务), irq_cpustat_t(触发状态)</td>
<td align="center">tasklet_struct, tasklet_head</td>
<td align="center">work_struct, workqueue_struct</td>
</tr>
<tr>
<td align="center">初始化</td>
<td align="center">open_softirq</td>
<td align="center">tasklet_init, DECLARE_TASKLET</td>
<td align="center">INIT_DELAYED_WORK</td>
</tr>
<tr>
<td align="center">改变运行状态</td>
<td align="center"></td>
<td align="center">tasklet_trylock, tasklet_unlock</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">使能&#x2F;停止</td>
<td align="center"></td>
<td align="center">tasklet_enable, tasklet_disable</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">触发</td>
<td align="center">raise_softirq, raise_softirq_irqoff</td>
<td align="center">tasklet_schedule, tasklet_hi_schedule</td>
<td align="center">schedule_work, queue_work, schedule_delayed_work</td>
</tr>
<tr>
<td align="center">执行</td>
<td align="center">do_softirq</td>
<td align="center">tasklet_action, tasklet_hi_action</td>
<td align="center">resouer_thread被CPU调度执行</td>
</tr>
<tr>
<td align="center">创建线程</td>
<td align="center"></td>
<td align="center"></td>
<td align="center">alloc_workqueue</td>
</tr>
<tr>
<td align="center">结束</td>
<td align="center"></td>
<td align="center">tasklet_kill</td>
<td align="center">destroy_weoker, destroy_weokequeue</td>
</tr>
</tbody></table>
<h2 id="上半部"><a href="#上半部" class="headerlink" title="上半部"></a>上半部</h2><blockquote>
<ol>
<li>实时性要求高</li>
<li>不能被中断</li>
</ol>
</blockquote>
<p>  上半部的功能是响应中断。当中断发生时，它就把设备驱动程序中中断处理例程的下半部挂到设备的下半部执行队列中去，然后继续等待新的中断到来</p>
<h2 id="下半部"><a href="#下半部" class="headerlink" title="下半部"></a>下半部</h2><p>下半部所负责的工作一般是查看设备以获得产生中断的事件信息，并根据这些信息（一般通过读设备上的寄存器得来）进行相应的处理。</p>
<h2 id="上半部与下半部的区分？"><a href="#上半部与下半部的区分？" class="headerlink" title="上半部与下半部的区分？"></a>上半部与下半部的区分？</h2><blockquote>
<p>下半部和上半部最大的区别是可中断，而上半部却不可中断</p>
</blockquote>
<p>对于一个中断，如何划分上下两部分呢？哪些处理放在上半部，哪些处理放在下半部？</p>
<ol>
<li>如果一个任务对时间十分敏感，将其放在上半部</li>
<li>如果一个任务和硬件有关，将其放在上半部</li>
<li>如果一个任务要保证不被其他中断打断，将其放在上半部</li>
<li>其他所有任务，考虑放在下半部</li>
</ol>
<h2 id="下半部的实现方式"><a href="#下半部的实现方式" class="headerlink" title="下半部的实现方式"></a>下半部的实现方式</h2><h3 id="软中断"><a href="#软中断" class="headerlink" title="软中断"></a>软中断</h3><p>linux中，执行软中断有专门的内核线程，每个处理器对应一个线程，名称<code>ksoftirqd/n</code> (n对应处理器号)</p>
<h3 id="Tasklet"><a href="#Tasklet" class="headerlink" title="Tasklet"></a>Tasklet</h3><h3 id="工作队列"><a href="#工作队列" class="headerlink" title="工作队列"></a>工作队列</h3><h3 id="线程化irq"><a href="#线程化irq" class="headerlink" title="线程化irq"></a>线程化irq</h3><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ol>
<li>什么时候选择哪种方式更好？</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><span class="exturl" data-url="aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbXlhcnJvdy9hcnRpY2xlL2RldGFpbHMvOTI4NzE2OQ==">中断处理“下半部”机制<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vd2FuZ195Yi9hcmNoaXZlLzIwMTMvMDQvMjMvMzAzNzI2OC5odG1s">《Linux内核设计与实现》读书笔记（八）- 中断下半部的处理<i class="fa fa-external-link-alt"></i></span></li>
</ol>
]]></content>
      <categories>
        <category>Linux内核</category>
      </categories>
      <tags>
        <tag>中断</tag>
      </tags>
  </entry>
  <entry>
    <title>jiffies &amp;&amp; HZ</title>
    <url>/post/33522.html</url>
    <content><![CDATA[<h2 id="jiffies"><a href="#jiffies" class="headerlink" title="jiffies"></a>jiffies</h2><p>全局变量<code>jiffies</code>用来记录自系统启动以来产生的节拍的总数。启动时，内核将该变量初始化为0，此后，每次时钟中断处理程序都会增加该变量的(jiffies是记录着从电脑开机到现在总共的时钟中断次数),一秒内时钟中断的次数等于Hz，所以jiffies一秒内增加的值也就是Hz。系统运行时间以秒为单位，等于i<code>jiffies/Hz</code>。</p>
<p><strong>注意</strong>: jiffies类型为<code>无符号长整型(unsigned long)</code>，其他任何类型存放它都不正确。</p>
<ul>
<li>将以秒为单位的时间转化为jiffies： seconds * Hz (jiffies)</li>
<li>将jiffies转化为以秒为单位的时间： jiffies &#x2F; Hz (s)</li>
</ul>
<h2 id="HZ"><a href="#HZ" class="headerlink" title="HZ"></a>HZ</h2><p>LINUX系统时钟频率是一个常数HZ来决定的， 通常<code>HZ＝100</code>，那么他的精度度就是10ms（毫秒）。也就是说每10ms一次中断。</p>
<span id="more"></span>

<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><h3 id="时间比较"><a href="#时间比较" class="headerlink" title="时间比较"></a>时间比较</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">time_after(a,b)</span><br><span class="line">time_before(a,b)</span><br><span class="line">time_after_eq(a,b)</span><br><span class="line">time_before_eq(a,b)</span><br><span class="line">time_in_range(a,b,c)</span><br></pre></td></tr></table></figure>

<h3 id="时间转换"><a href="#时间转换" class="headerlink" title="时间转换"></a>时间转换</h3><p>jiffies和msecs以及usecs的转换：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">unsigned int jiffies_to_msecs(const unsigned long);</span><br><span class="line">unsigned int jiffies_to_usecs(const unsigned long);</span><br><span class="line">unsigned long msecs_to_jiffies(const unsigned int m);</span><br><span class="line">unsigned long usecs_to_jiffies(const unsigned int u);</span><br></pre></td></tr></table></figure>

<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><ol>
<li>watchdog_timeo &#x3D; 2 * HZ;</li>
</ol>
<p>将2s转换为jiffies, 设定2s延时。</p>
<ol start="2">
<li>mod_timer(&amp;host-&gt;timer, jiffies + 10 * HZ);</li>
</ol>
<p>设定10s的定时时间。</p>
]]></content>
      <categories>
        <category>Linux内核</category>
      </categories>
      <tags>
        <tag>kernel</tag>
        <tag>time</tag>
      </tags>
  </entry>
  <entry>
    <title>MIPS架构下的中断处理</title>
    <url>/post/61535.html</url>
    <content><![CDATA[<p>内核版本: 3.10.14</p>
<p>linux内核出入文件:arch&#x2F;mips&#x2F;kernel&#x2F;traps.c</p>
<h2 id="函数调用关系"><a href="#函数调用关系" class="headerlink" title="函数调用关系"></a>函数调用关系</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set_except_vector(0, using_rollback_handler() ? rollback_handle_int: handle_int)</span><br><span class="line">	-&gt; handle_int</span><br><span class="line">		-&gt; plat_irq_dispatch</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="trap-init"><a href="#trap-init" class="headerlink" title="trap_init"></a>trap_init</h2><p>在Linux内核启动时注册，main.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> __init <span class="title function_">trap_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">	set_except_vector(<span class="number">0</span>, using_rollback_handler() ? rollback_handle_int</span><br><span class="line">	                          : handle_int);</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>file: arch&#x2F;mips&#x2F;kernel&#x2F;traps.c</p>
</blockquote>
<h2 id="handle-int"><a href="#handle-int" class="headerlink" title="handle_int"></a>handle_int</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">NESTED(handle_int, PT_SIZE, sp)</span><br><span class="line">	SAVE_ALL</span><br><span class="line">	CLI</span><br><span class="line">	TRACE_IRQS_OFF</span><br><span class="line"></span><br><span class="line">	LONG_L  s0, TI_REGS($<span class="number">28</span>)</span><br><span class="line">	LONG_S  sp, TI_REGS($<span class="number">28</span>)</span><br><span class="line">	PTR_LA  ra, ret_from_irq</span><br><span class="line">	PTR_LA  v0, plat_irq_dispatch</span><br><span class="line">	jr  v0</span><br><span class="line"><span class="title function_">END</span><span class="params">(handle_int)</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>file: arch&#x2F;mips&#x2F;kernel&#x2F;genex.S</p>
</blockquote>
<h2 id="plat-irq-dispatch"><a href="#plat-irq-dispatch" class="headerlink" title="plat_irq_dispatch"></a>plat_irq_dispatch</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">asmlinkage <span class="type">void</span> <span class="title function_">plat_irq_dispatch</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> r = (read_c0_status() &amp; read_c0_cause()) &gt;&gt; <span class="number">8</span>;</span><br><span class="line">	do_IRQ(MIPS_CPU_IRQ_BASE + __ffs(r &amp; <span class="number">0xff</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>file: arch&#x2F;mips&#x2F;xburst2&#x2F;soc-x2000&#x2F;common&#x2F;irq.c</p>
</blockquote>
<h2 id="ret-from-irq"><a href="#ret-from-irq" class="headerlink" title="ret_from_irq"></a>ret_from_irq</h2><h2 id="代码跳转-反汇编"><a href="#代码跳转-反汇编" class="headerlink" title="代码跳转(反汇编)"></a>代码跳转(反汇编)</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">80014780 &lt;handle_int&gt;:</span><br><span class="line">80014780:   401a6000    mfc0    k0,c0_status</span><br><span class="line">80014784:   335a0001    andi    k0,k0,0x1</span><br><span class="line">80014788:   17400002    bnez    k0,80014794 &lt;handle_int+0x14&gt;</span><br><span class="line">8001478c:   00000000    nop</span><br><span class="line">	.</span><br><span class="line">	.</span><br><span class="line">80014898:   27ff43e0    addiu   ra,ra,17376</span><br><span class="line">8001489c:   3c028001    lui v0,0x8001</span><br><span class="line">800148a0:   24421404    addiu   v0,v0,5124</span><br><span class="line">800148a4:   00400008    jr  v0       #jr -&gt; 0x80011404</span><br><span class="line">800148a8:   00000000    nop</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">80011404 &lt;plat_irq_dispatch&gt;:</span><br><span class="line">80011404:   40076000    mfc0    a3,c0_status</span><br><span class="line">80011408:   40066800    mfc0    a2,c0_cause</span><br><span class="line">8001140c:   00e61024    and v0,a3,a2</span><br><span class="line">80011410:   00021202    srl v0,v0,0x8</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="jr-v0"><a href="#jr-v0" class="headerlink" title="jr v0"></a>jr v0</h3><p>handle_int中jr跳转的函数地址v0的计算:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lui v0 0x8001</span><br><span class="line">addiu v0,v0,5124 #0x80011404</span><br></pre></td></tr></table></figure>

<h3 id="lui-amp-addiu"><a href="#lui-amp-addiu" class="headerlink" title="lui &amp; addiu"></a>lui &amp; addiu</h3><p>具体的指令码,可参考MIPS手册.<br>这两个指令码的低十六位为立即数的十六进制数.</p>
<h2 id="handle-int函数的组合"><a href="#handle-int函数的组合" class="headerlink" title="handle_int函数的组合"></a>handle_int函数的组合</h2>]]></content>
      <categories>
        <category>Linux内核</category>
      </categories>
      <tags>
        <tag>中断</tag>
      </tags>
  </entry>
  <entry>
    <title>setup_per_cpu_areas</title>
    <url>/post/23122.html</url>
    <content><![CDATA[<blockquote>
<p>为了对内核的内存管理<code>（mm）</code>进行初始化而调用的函数之一。只在<code>SMP</code>系统中调用，<code>UP</code>（单核）中不执行任何操作。<br>为SMP的每个处理器生成per-cpu数据</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">start_kernel</span><br><span class="line">	\-&gt;setup_per_cpu_areas</span><br></pre></td></tr></table></figure>
<blockquote>
<p>file: init&#x2F;main.c</p>
</blockquote>
<span id="more"></span>



<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><span class="exturl" data-url="aHR0cDovL2Jsb2cuY3Nkbi5uZXQveWluMjYyL2FydGljbGUvZGV0YWlscy80Njc4Nzg3OQ==">start_kernel——setup_per_cpu_areas<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL2Jsb2cuY3Nkbi5uZXQveHlsb3ZlemYvYXJ0aWNsZS9kZXRhaWxzLzY4Mjg5Mjk=">对Linux内核中percpu data进行分析<i class="fa fa-external-link-alt"></i></span></li>
</ol>
]]></content>
      <categories>
        <category>Linux内核</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>mmu</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux内核中的read_mostly</title>
    <url>/post/59553.html</url>
    <content><![CDATA[<blockquote>
<p>Linux内核版本: linux4.4.166</p>
</blockquote>
<h2 id="read-mostly"><a href="#read-mostly" class="headerlink" title="read_mostly"></a>read_mostly</h2><p><code>__read_mostly</code>原语将定义的变量为存放在<code>.data..read_mostly</code>段中.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define __read_mostly __attribute__((__section__(&quot;.data..read_mostly&quot;)))</span><br></pre></td></tr></table></figure>
<blockquote>
<p>file: arch&#x2F;arm&#x2F;include&#x2F;asm&#x2F;cache.h</p>
</blockquote>
<span id="more"></span>

<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> RW_DATA_SECTION(cacheline, pagealigned, inittask)       \</span></span><br><span class="line"><span class="meta">    . = ALIGN(PAGE_SIZE);                       \</span></span><br><span class="line"><span class="meta">    .data : AT(ADDR(.data) - LOAD_OFFSET) &#123;             \</span></span><br><span class="line"><span class="meta">        INIT_TASK_DATA(inittask)                \</span></span><br><span class="line"><span class="meta">        NOSAVE_DATA                     \</span></span><br><span class="line"><span class="meta">        PAGE_ALIGNED_DATA(pagealigned)              \</span></span><br><span class="line"><span class="meta">        CACHELINE_ALIGNED_DATA(cacheline)           \</span></span><br><span class="line"><span class="meta">        READ_MOSTLY_DATA(cacheline)             \</span></span><br><span class="line"><span class="meta">        DATA_DATA                       \</span></span><br><span class="line"><span class="meta">        CONSTRUCTORS                        \</span></span><br><span class="line"><span class="meta">    &#125;</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> READ_MOSTLY_DATA(align)                     \</span></span><br><span class="line"><span class="meta">    . = ALIGN(align);                       \</span></span><br><span class="line"><span class="meta">    *(.data..read_mostly)                       \</span></span><br><span class="line"><span class="meta">    . = ALIGN(align);</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>file: include&#x2F;asm-generic&#x2F;vmlinux.lds.h</p>
</blockquote>
<h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>因为<code>__read_mostly</code>修饰的变量均放在<code>.data..read_mostly</code>段中，因此，我们可以将经常需要被读取的数据定义为<code>__read_mostly</code>类型， 这样Linux内核被加载时,该数据将自动被存放到Cache中,以提高整个系统的执行效率。</p>
<p>如果所在平台没有Cache，或者虽然有Cache，但是并不提供存放数据的接口，(也就是并不允许人工放置数据在Cache中), 那么定义为<code>__read_mostly</code>类型的数据将不能存放在Linux内核中，甚至也不能够被加载到系统内存去执行。</p>
<p>如果数据不能存放在linux内核，甚至也不能够被加载到系统内存去执行，后果非常严重，将造成Linux 内核启动失败。</p>
]]></content>
      <categories>
        <category>Linux内核</category>
      </categories>
      <tags>
        <tag>编译</tag>
      </tags>
  </entry>
  <entry>
    <title>OOM</title>
    <url>/post/53957.html</url>
    <content><![CDATA[<p>内核出现OOM的log分析：</p>
<span id="more"></span>


<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[  128.496873] min_free_kbytes invoked oom-killer: gfp_mask=0x200da, order=0, oom_score_adj=0</span><br><span class="line">[  128.505497] min_free_kbytes cpuset=/ mems_allowed=0</span><br><span class="line">[  128.510968] CPU: 0 PID: 118 Comm: min_free_kbytes Not tainted 3.10.14-00062-g277665d-dirty #322</span><br><span class="line">[  128.523967] Stack : 00000000 00000000 00000000 00000000 80624582 00000053 805b0000 805ad500</span><br><span class="line">		8c3933a0 805ad407 8053d15c 00000076 80623d20 805ad500 00000000 00000000</span><br><span class="line">		805ad500 8046cffc 805c0000 8003b3bc 80b3324c 00000000 8053eecc 890019ac</span><br><span class="line">		00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000</span><br><span class="line">		00000000 00000000 00000000 00000000 00000000 00000000 00000000 89001938</span><br><span class="line">		...</span><br><span class="line">[  128.607831] Call Trace:</span><br><span class="line">[  128.612474] [&lt;800209e0&gt;] show_stack+0x48/0x70</span><br><span class="line">[  128.621191] [&lt;8046daf0&gt;] dump_header.isra.4+0x88/0x260</span><br><span class="line">[  128.628626] [&lt;800bd78c&gt;] oom_kill_process+0xd0/0x478</span><br><span class="line">[  128.635875] [&lt;800be070&gt;] out_of_memory+0x318/0x390</span><br><span class="line">[  128.642951] [&lt;800c1ef4&gt;] __alloc_pages_nodemask+0x8b8/0x900</span><br><span class="line">[  128.650833] [&lt;800d9104&gt;] handle_pte_fault+0xae4/0xc5c</span><br><span class="line">[  128.660245] [&lt;800d9358&gt;] handle_mm_fault+0xdc/0x11c</span><br><span class="line">[  128.667406] [&lt;800298d8&gt;] do_page_fault+0x158/0x480</span><br><span class="line">[  128.674477] [&lt;8001a784&gt;] resume_userspace_check+0x0/0x10</span><br><span class="line">[  128.684178]</span><br><span class="line">[  128.687833] Mem-Info:</span><br><span class="line">[  128.692287] Normal per-cpu:</span><br><span class="line">[  128.699351] CPU    0: hi:   90, btch:  15 usd:  32</span><br><span class="line">[  128.706406] HighMem per-cpu:</span><br><span class="line">[  128.711486] CPU    0: hi:   90, btch:  15 usd:  15</span><br><span class="line">[  128.718564] active_anon:120239 inactive_anon:11 isolated_anon:0</span><br><span class="line">[  128.718564]  active_file:5 inactive_file:2 isolated_file:0</span><br><span class="line">[  128.718564]  unevictable:0 dirty:0 writeback:0 unstable:0</span><br><span class="line">[  128.718564]  free:4617 slab_reclaimable:150 slab_unreclaimable:600</span><br><span class="line">[  128.718564]  mapped:1 shmem:15 pagetables:150 bounce:0</span><br><span class="line">[  128.718564]  free_cma:0</span><br><span class="line">[  128.754330] Normal free:18244kB min:10084kB low:12604kB high:15124kB active_anon:219220kB inactive_anon:0kB active_file</span><br><span class="line">:20kB inactive_file:8kB unevictable:0kB isolated(anon):0kB isolated(file):0kB present:262144kB managed:241940kB mlocked:0k</span><br><span class="line">B dirty:0kB writeback:0kB mapped:4kB shmem:0kB slab_reclaimable:600kB slab_unreclaimable:2400kB kernel_stack:320kB pagetab</span><br><span class="line">les:600kB unstable:0kB bounce:0kB free_cma:0kB writeback_tmp:0kB pages_scanned:426 all_unreclaimable? yes</span><br><span class="line">[  128.798925] lowmem_reserve[]: 0 2048 2048</span><br><span class="line">[  128.807365] HighMem free:224kB min:256kB low:2984kB high:5716kB active_anon:261736kB inactive_anon:44kB active_file:0kB</span><br><span class="line">inactive_file:0kB unevictable:0kB isolated(anon):0kB isolated(file):0kB present:262144kB managed:262144kB mlocked:0kB dir</span><br><span class="line">ty:0kB writeback:0kB mapped:0kB shmem:60kB slab_reclaimable:0kB slab_unreclaimable:0kB kernel_stack:0kB pagetables:0kB uns</span><br><span class="line">table:0kB bounce:0kB free_cma:0kB writeback_tmp:0kB pages_scanned:31 all_unreclaimable? yes</span><br><span class="line">[  128.850710] lowmem_reserve[]: 0 0 0</span><br><span class="line">[  128.858541] Normal: 1*4kB (R) 0*8kB 0*16kB 0*32kB 1*64kB (R) 0*128kB 1*256kB (R) 1*512kB (R) 1*1024kB (R) 0*2048kB 0*40</span><br><span class="line">96kB 2*8192kB (R) 0*16384kB 0*32768kB 0*65536kB = 18244kB</span><br><span class="line">[  128.896190] HighMem: 0*4kB 0*8kB 0*16kB 1*32kB (R) 1*64kB (R) 1*128kB (R) 0*256kB 0*512kB 0*1024kB 0*2048kB 0*4096kB 0*</span><br><span class="line">8192kB 0*16384kB 0*32768kB 0*65536kB = 224kB</span><br><span class="line">[  128.928406] 22 total pagecache pages</span><br><span class="line">[  128.988524] 262144 pages RAM</span><br><span class="line">[  128.993703] 131072 pages HighMem</span><br><span class="line">[  129.001226] 136074 pages reserved</span><br><span class="line">[  129.006754] 30 pages shared</span><br><span class="line">[  129.011751] 121318 pages non-shared</span><br><span class="line">[  129.017458] [ pid ]   uid  tgid total_vm      rss nr_ptes swapents oom_score_adj name</span><br><span class="line">[  129.027697] [   61]     0    61      883       18       3        0             0 syslogd</span><br><span class="line">[  129.040259] [   64]     0    64      883       18       3        0             0 klogd</span><br><span class="line">[  129.050561] [   86]  1000    86      753       38       4        0             0 dbus-daemon</span><br><span class="line">[  129.061408] [   96]     0    96     1327       70       4        0         -1000 sshd</span><br><span class="line">[  129.071623] [  103]     0   103      899       23       5        0             0 sh</span><br><span class="line">[  129.081664] [  104]     0   104      883       17       3        0             0 telnetd</span><br><span class="line">[  129.094214] [  108]     0   108      753       36       4        0             0 min_free_kbytes</span><br><span class="line">[  129.105410] [  118]     0   118   120817   120018     121        0             0 min_free_kbytes</span><br><span class="line">[  129.116617] Out of memory: Kill process 118 (min_free_kbytes) score 922 or sacrifice child</span><br><span class="line">[  129.129353] Killed process 118 (min_free_kbytes) total-vm:483268kB, anon-rss:480072kB, file-rss:0kB</span><br></pre></td></tr></table></figure>

<h2 id="相关变量说明"><a href="#相关变量说明" class="headerlink" title="相关变量说明"></a>相关变量说明</h2><h3 id="file-rss"><a href="#file-rss" class="headerlink" title="file-rss"></a>file-rss</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[  129.129353] Killed process 118 (min_free_kbytes) total-vm:483268kB, anon-rss:480072kB, file-rss:0kB</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>rss</code>:”Resident Set Size”, 实际驻留”在内存中”的内存数. 不包括已经交换出去的代码. 举一个例子: 如果你有一个程序使用了100K内存, 操作系统交换出40K内存, 那么RSS为60K. RSS还包括了与其它进程共享的内存区域. 这些区域通常用于libc库等.</p>
</blockquote>
<h2 id="处理流程"><a href="#处理流程" class="headerlink" title="处理流程"></a>处理流程</h2><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><span class="exturl" data-url="aHR0cDovL2Jsb2cuMTYzLmNvbS9kaWdvYWxAMTI2L2Jsb2cvc3RhdGljLzE2Mzg3NzA0MDIwMTY1MTQxMDI3NTEyNDEv">Linux中进程内存RSS与cgroup内存的RSS统计 - 差异<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL2Jsb2cuY2hpbmF1bml4Lm5ldC91aWQtMjkwNDM2MjAtaWQtNTc1NDMyNS5odG1s">进程实际内存占用: 私有驻留内存数(Private RSS)介绍<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9lLW1haWxreS5naXRodWIuaW8vMjAxNy0wMS0xNC1vb20=">Out of Memory(OOM)处理流程<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9sd24ubmV0L0FydGljbGVzLzMxNzgxNC8=">Taming the OOM killer<i class="fa fa-external-link-alt"></i></span></li>
</ol>
]]></content>
      <categories>
        <category>Linux内核</category>
      </categories>
      <tags>
        <tag>kernel</tag>
        <tag>oom</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux内核同步机制【rwlock】</title>
    <url>/post/42371.html</url>
    <content><![CDATA[<blockquote>
<p>读写锁实际是一种<code>特殊的自旋锁</code>，它把对共享资源的访问者划分成读者和写者，读者只对共享资源进行读访问，写者则需要对共享资源进行写操作。这种锁相对于自旋锁而言，能提高并发性，因为在多处理器系统中，它允许同时有多个读者来访问共享资源，最大可能的读者数为实际的逻辑CPU数。写者是排他性的，一个读写锁同时只能有一个写者或多个读者（与CPU数相关），但不能同时既有读者又有写者。</p>
</blockquote>
<span id="more"></span>


<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="rwlock-t"><a href="#rwlock-t" class="headerlink" title="rwlock_t"></a>rwlock_t</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="type">arch_rwlock_t</span> raw_lock;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_GENERIC_LOCKBREAK</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> break_lock;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEBUG_SPINLOCK</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> magic, owner_cpu;</span><br><span class="line">	<span class="type">void</span> *owner;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEBUG_LOCK_ALLOC</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">lockdep_map</span> <span class="title">dep_map</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125; <span class="type">rwlock_t</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>file: include&#x2F;linux&#x2F;rwlock_types.h</p>
</blockquote>
<h3 id="arch-rwlock-t"><a href="#arch-rwlock-t" class="headerlink" title="arch_rwlock_t"></a>arch_rwlock_t</h3><h4 id="MIPS"><a href="#MIPS" class="headerlink" title="MIPS"></a>MIPS</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> lock;</span><br><span class="line">&#125; <span class="type">arch_rwlock_t</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>file: arch&#x2F;mips&#x2F;include&#x2F;asm&#x2F;spinlock_types.h</p>
</blockquote>
<h2 id="通用接口API"><a href="#通用接口API" class="headerlink" title="通用接口API"></a>通用接口API</h2><ul>
<li>rwlock_init</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> __ARCH_RW_LOCK_UNLOCKED     &#123; 0 &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __RW_LOCK_UNLOCKED(lockname) \</span></span><br><span class="line"><span class="meta">    (rwlock_t)  &#123;   .raw_lock = __ARCH_RW_LOCK_UNLOCKED,    \</span></span><br><span class="line"><span class="meta">	RW_DEP_MAP_INIT(lockname) &#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> rwlock_init(lock)                  \</span></span><br><span class="line"><span class="meta">    do &#123; *(lock) = __RW_LOCK_UNLOCKED(lock); &#125; while (0)</span></span><br></pre></td></tr></table></figure>

<p>初始化<code>rwlock_t-&gt;raw_lock-&gt;lock=0</code></p>
<ul>
<li>R&#x2F;W lock</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define write_lock(lock)    _raw_write_lock(lock)</span><br><span class="line">#define read_lock(lock)     _raw_read_lock(lock)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>file: include&#x2F;linux&#x2F;rwlock.h</p>
</blockquote>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>读写锁包括读取锁和写入锁，多个读线程可以同时访问共享数据；写线程必须等待所有读线程都释放锁以后，才能取得锁；同样的，读线程必须等待写线程释放锁后，才能取得锁；</p>
<p>也就是说读写锁要确保的是如下互斥关系：可以同时读，但是读-写，写-写都是互斥的；</p>
<ul>
<li>读锁</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">read_lock</span><br><span class="line">  |-&gt;_raw_read_lock</span><br><span class="line">	|-&gt;__raw_read_lock</span><br><span class="line">	  |-&gt;preempt_disable();</span><br><span class="line">	  |-&gt;rwlock_acquire_read(&amp;lock-&gt;dep_map, 0, 0, _RET_IP_);</span><br><span class="line">	  |-&gt;LOCK_CONTENDED(lock, do_raw_read_trylock, do_raw_read_lock);</span><br></pre></td></tr></table></figure>
<p>在读锁上锁时与spinlock的流程基本相同，都会关闭内核抢占，因此读写锁中也不能睡眠</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">define</span> do_raw_read_trylock(rwlock)    arch_read_trylock(&amp;(rwlock)-&gt;raw_lock)</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> do_raw_read_lock(rwlock)   do &#123;__acquire(lock); arch_read_lock(&amp;(rwlock)-&gt;raw_lock); &#125; while (0)</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>file: include&#x2F;linux&#x2F;rwlock.h</p>
</blockquote>
<h3 id="MIPS-1"><a href="#MIPS-1" class="headerlink" title="MIPS"></a>MIPS</h3><p>不同架构的实现：</p>
<h3 id="arch-read-lock"><a href="#arch-read-lock" class="headerlink" title="arch_read_lock"></a>arch_read_lock</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">arch_read_lock</span><span class="params">(<span class="type">arch_rwlock_t</span> *rw)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> tmp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        __asm__ __volatile__(</span><br><span class="line">        <span class="string">&quot;1: ll  %1, %2  # arch_read_lock    \n&quot;</span></span><br><span class="line">        <span class="string">&quot;   bltz    %1, 1b              \n&quot;</span></span><br><span class="line">        <span class="string">&quot;    addu   %1, 1               \n&quot;</span></span><br><span class="line">        <span class="string">&quot;2: sc  %1, %0              \n&quot;</span></span><br><span class="line">        : <span class="string">&quot;=m&quot;</span> (rw-&gt;lock), <span class="string">&quot;=&amp;r&quot;</span> (tmp)</span><br><span class="line">        : <span class="string">&quot;m&quot;</span> (rw-&gt;lock)</span><br><span class="line">        : <span class="string">&quot;memory&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">while</span> (unlikely(!tmp));</span><br><span class="line"></span><br><span class="line">    smp_llsc_mb();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>bltz $s,offset &lt;&#x3D;&#x3D;&gt; if($s&lt; 0) jump(offset « 2); 小于0，跳转</p>
</blockquote>
<p>内嵌汇编源码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">c2020000    ll  v0,0(s0)</span><br><span class="line">0440fffe    bltz    v0,8021c8f8 &lt;do_raw_read_lock+0x38&gt;</span><br><span class="line">00000000    nop</span><br><span class="line">24420001    addiu   v0,v0,1</span><br><span class="line">e2020000    sc  v0,0(s0)</span><br><span class="line">1040fffa    beqz    v0,8021c8f8 &lt;do_raw_read_lock+0x38&gt;</span><br></pre></td></tr></table></figure>
<p>上读锁是通过原子操作对<code>rwlock_t-&gt;raw_lock-&gt;lock += 1</code></p>
<h3 id="arch-read-unlock"><a href="#arch-read-unlock" class="headerlink" title="arch_read_unlock"></a>arch_read_unlock</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">arch_read_unlock</span><span class="params">(<span class="type">arch_rwlock_t</span> *rw)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> tmp;</span><br><span class="line"></span><br><span class="line">    smp_mb__before_llsc();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        __asm__ __volatile__(</span><br><span class="line">        <span class="string">&quot;1: ll  %1, %2  # arch_read_unlock  \n&quot;</span></span><br><span class="line">        <span class="string">&quot;   sub %1, 1               \n&quot;</span></span><br><span class="line">        <span class="string">&quot;   sc  %1, %0              \n&quot;</span></span><br><span class="line">        : <span class="string">&quot;=m&quot;</span> (rw-&gt;lock), <span class="string">&quot;=&amp;r&quot;</span> (tmp)</span><br><span class="line">        : <span class="string">&quot;m&quot;</span> (rw-&gt;lock)</span><br><span class="line">        : <span class="string">&quot;memory&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">while</span> (unlikely(!tmp));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解读锁是通过原子操作对<code>rwlock_t-&gt;raw_lock-&gt;lock -= 1</code></p>
<h3 id="arch-write-lock"><a href="#arch-write-lock" class="headerlink" title="arch_write_lock"></a>arch_write_lock</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">arch_write_lock</span><span class="params">(<span class="type">arch_rwlock_t</span> *rw)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> tmp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        __asm__ __volatile__(</span><br><span class="line">        <span class="string">&quot;1: ll  %1, %2  # arch_write_lock   \n&quot;</span></span><br><span class="line">        <span class="string">&quot;   bnez    %1, 1b              \n&quot;</span></span><br><span class="line">        <span class="string">&quot;    lui    %1, 0x8000          \n&quot;</span></span><br><span class="line">        <span class="string">&quot;2: sc  %1, %0              \n&quot;</span></span><br><span class="line">        : <span class="string">&quot;=m&quot;</span> (rw-&gt;lock), <span class="string">&quot;=&amp;r&quot;</span> (tmp)</span><br><span class="line">        : <span class="string">&quot;m&quot;</span> (rw-&gt;lock)</span><br><span class="line">        : <span class="string">&quot;memory&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">while</span> (unlikely(!tmp));</span><br><span class="line"></span><br><span class="line">    smp_llsc_mb();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>lui $t,imm &lt;&#x3D;&#x3D;&gt; $t&#x3D;(imm « 16)<br>将立即数左移16位，低16位补零</p>
</blockquote>
<p>内嵌汇编反汇编源码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">c2020000    ll  v0,0(s0)</span><br><span class="line">1440fffe    bnez    v0,8021ca08 &lt;do_raw_write_lock+0x70&gt;</span><br><span class="line">00000000    nop</span><br><span class="line">3c028000    lui v0,0x8000</span><br><span class="line">e2020000    sc  v0,0(s0)</span><br><span class="line">1040fffa    beqz    v0,8021ca08 &lt;do_raw_write_lock+0x70&gt;</span><br></pre></td></tr></table></figure>


<h3 id="arch-write-unlock"><a href="#arch-write-unlock" class="headerlink" title="arch_write_unlock"></a>arch_write_unlock</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">arch_write_unlock</span><span class="params">(<span class="type">arch_rwlock_t</span> *rw)</span></span><br><span class="line">&#123;</span><br><span class="line">    smp_mb();</span><br><span class="line"></span><br><span class="line">    __asm__ __volatile__(</span><br><span class="line">    <span class="string">&quot;               # arch_write_unlock \n&quot;</span></span><br><span class="line">    <span class="string">&quot;   sw  $0, %0                  \n&quot;</span></span><br><span class="line">    : <span class="string">&quot;=m&quot;</span> (rw-&gt;lock)</span><br><span class="line">    : <span class="string">&quot;m&quot;</span> (rw-&gt;lock)</span><br><span class="line">    : <span class="string">&quot;memory&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><ol>
<li><p>读锁怎么实现可以存在多个读者进行处理？？</p>
</li>
<li><p>读写锁与SMP多核之间的线程处理关系？？</p>
</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuaWJtLmNvbS9kZXZlbG9wZXJ3b3Jrcy9jbi9saW51eC9sLXJ3bG9ja193cml0aW5nLw==">Linux下写者优先的读写锁的设计<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL2d1b2ppbmcubWUvbGludXgta2VybmVsLWFyY2hpdGVjdHVyZS9wb3N0cy9yZWFkLWFuZC13cml0ZS1zcGluLWxvY2sv">读&#x2F;写自旋锁<i class="fa fa-external-link-alt"></i></span></li>
</ol>
]]></content>
      <categories>
        <category>Linux内核</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>rwlock</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux内核同步机制【spin lock】</title>
    <url>/post/62201.html</url>
    <content><![CDATA[<ol>
<li>spinlock的使用场景，为什么使用？</li>
<li>在spinlock控制临界区中，为什么不能睡眠？如果睡眠会产生什么结果？</li>
<li>spinlock的实现和数据结构，在x86、ARM64、MIPS中的实现方式，不同吗？存在什么差异？</li>
<li>在发生抢锁时，spinlock和信号量处理的区别？</li>
</ol>
<span id="more"></span>

<p>内核版本：linux 4.4.93</p>
<h2 id="spin-lock特点"><a href="#spin-lock特点" class="headerlink" title="spin lock特点"></a>spin lock特点</h2><ul>
<li><p><code>spin lock</code>是一种死等的锁机制。当前的执行thread会不断的重新尝试直到获取锁进入临界区。</p>
<blockquote>
<p>当发生访问资源冲突的时候，可以有两个选择：一个是死等，一个是挂起当前进程，调度其他进程执行。</p>
</blockquote>
</li>
<li><p>只允许一个thread进入。semaphore可以允许多个thread进入，spin lock不行，一次只能有一个thread获取锁并进入临界区，其他的thread都是在门口不断的尝试。</p>
</li>
<li><p>执行时间短。</p>
<blockquote>
<p>由于spin lock死等这种特性，因此它使用在那些代码不是非常复杂的临界区（当然也不能太简单，否则使用原子操作或者其他适用简单场景的同步机制就OK了），如果临界区执行时间太长，那么不断在临界区门口“死等”的那些thread是多么的浪费CPU啊（当然，现代CPU的设计都会考虑同步原语的实现，例如ARM提供了WFE和SEV这样的类似指令，避免CPU进入busy loop的悲惨境地）</p>
</blockquote>
</li>
<li><p>可以在中断上下文执行。由于不睡眠，因此spin lock可以在中断上下文中适用。</p>
</li>
</ul>
<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>spin lock，其保护的资源可能来自多个CPU CORE上的<code>进程上下文</code>和<code>中断上下文</code>的中的访问</p>
<ul>
<li>进程上下文包括：用户进程通过系统调用访问，内核线程直接访问，来自workqueue中work function的访问（本质上也是内核线程）。</li>
<li>中断上下文包括：HW interrupt context（中断handler）、软中断上下文（soft<br>irq，当然由于各种原因，该softirq被推迟到softirqd的内核线程中执行的时候就不属于这个场景了，属于进程上下文那个分类了）、timer的callback函数（本质上也是softirq）、tasklet（本质上也是softirq）。</li>
</ul>
<p>先看最简单的单CPU上的进程上下文的访问。如果一个全局的资源被多个进程上下文访问，这时候，内核如何交错执行呢？对于那些没有打开preemptive选项的内核，所有的系统调用都是串行化执行的，因此不存在资源争抢的问题。</p>
<p>如果内核线程也访问这个全局资源呢？本质上内核线程也是进程，类似普通进程，只不过普通进程时而在用户态运行、时而通过系统调用陷入内核执行，而内核线程永远都是在内核态运行，但是，结果是一样的，对于non-preemptive的linux kernel，只要在内核态，就不会发生进程调度<br>因此，这种场景下，共享数据根本不需要保护（没有并发，谈何保护呢）。</p>
<blockquote>
<p>单核CPU中， 如果系统默认关闭抢占时，spin lock不起任何作用，因为不存在真正并发的条件，不需要进行同步。如果打开内核抢占，其同步机制主要时通过关闭抢占实现</p>
</blockquote>
<h3 id="进程上下文"><a href="#进程上下文" class="headerlink" title="进程上下文"></a>进程上下文</h3><p>当打开premptive选项后，事情变得复杂了，我们考虑下面的场景：</p>
<ul>
<li>进程A在某个系统调用过程中访问了共享资源R</li>
<li>进程B在某个系统调用过程中也访问了共享资源R</li>
</ul>
<p><strong>1.会不会造成冲突呢？</strong></p>
<p>假设在A访问共享资源R的过程中发生了中断，中断唤醒了沉睡中的，优先级更高的B，在中断返回现场的时候，发生进程切换，B启动执行，并通过系统调用访问了R，如果没有锁保护，则会出现两个thread进入临界区，导致程序执行不正确。</p>
<p><strong>2.使用spin lock：</strong></p>
<p>A在进入临界区之前获取了spin lock，同样的，在A访问共享资源R的过程中发生了中断，中断唤醒了沉睡中的，优先级更高的B，B在访问临界区之前仍然会试图获取spin lock，这时候由于A进程持有spin lock而导致B进程进入了永久的spin……怎么破？linux的kernel很简单，在A进程获取spin	lock的时候，禁止本CPU上的抢占（上面的永久spin的场合仅仅在本CPU的进程抢占本CPU的当前进程这样的场景中发生）。</p>
<p>如果是多核CPU，A和B运行在不同的CPU上，那么情况会简单一些：A进程虽然持有spin lock而导致B进程进入spin状态，不过由于运行在不同的CPU上，A进程会持续执行并会很快释放spin lock，解除B进程的spin状态。</p>
<h3 id="中断上下文"><a href="#中断上下文" class="headerlink" title="中断上下文"></a>中断上下文</h3><ul>
<li>运行在CPU0上的进程A在某个系统调用过程中访问了共享资源R</li>
<li>运行在CPU1上的进程B在某个系统调用过程中也访问了共享资源R</li>
<li>外设P的中断handler中也会访问共享资源R</li>
</ul>
<p>在这样的场景下，使用spin lock可以保护访问共享资源R的临界区吗？我们假设CPU0上的进程A持有spin lock进入临界区，这时候，外设P发生了中断事件，并且调度到了CPU1上执行，看起来没有什么问题，执行在CPU1上的handler会稍微等待一会CPU0上的进程A，等它立刻临界区就会释放spin lock的.</p>
<p>但是，如果外设P的中断事件被调度到了CPU0上执行会怎么样？CPU0上的进程A在持有spin lock的状态下被中断上下文抢占，而抢占它的CPU0上的handler在进入临界区之前仍然会试图获取spin lock，悲剧发生了，CPU0上的P外设的中断handler永远的进入spin状态，这时候，CPU1上的进程B也不可避免在试图持有spin lock的时候失败而导致进入spin状态。<br>为了解决这样的问题，linux kernel采用了这样的办法：如果涉及到中断上下文的访问，spin lock需要和禁止本CPU上的中断联合使用。</p>
<p>linux kernel中提供了丰富的bottom half的机制，虽然同属中断上下文，不过还是稍有不同。我们可以把上面的场景简单修改一下：外设P不是中断handler中访问共享资源R，而是在的bottom half中访问。使用spin lock+禁止本地中断当然是可以达到保护共享资源的效果，但是使用牛刀来杀鸡似乎有点小题大做，这时候disable bottom half就OK了。</p>
<p>最后，我们讨论一下中断上下文之间的竞争。同一种中断handler之间在uni core和multi core上都不会并行执行，这是linux kernel的特性。如果不同中断handler需要使用spin lock保护共享资源，对于新的内核（不区分fast handler和slow handler），所有handler都是关闭中断的，因此使用spin lock不需要关闭中断的配合。<br>bottom half又分成softirq和tasklet，同一种softirq会在不同的CPU上并发执行，因此如果某个驱动中的sofirq的handler中会访问某个全局变量，对该全局变量是需要使用spin lock保护的，不用配合disable CPU中断或者bottom half。<br>tasklet更简单，因为同一种tasklet不会多个CPU上并发，具体我就不分析了，大家自行思考吧。</p>
<h2 id="通用代码结构"><a href="#通用代码结构" class="headerlink" title="通用代码结构"></a>通用代码结构</h2><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">raw_spinlock</span> <span class="title">rlock</span>;</span></span><br><span class="line">	&#125;;</span><br><span class="line">&#125; <span class="type">spinlock_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">raw_spinlock</span> &#123;</span></span><br><span class="line">    <span class="type">arch_spinlock_t</span> raw_lock;</span><br><span class="line">&#125; <span class="type">raw_spinlock_t</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>file: include&#x2F;linux&#x2F;spinlock_types.h</p>
</blockquote>
<p>通过<code>arch_spinlock_t</code>结构体定义不同arch下spin lock的实现结构。</p>
<h3 id="接口API"><a href="#接口API" class="headerlink" title="接口API"></a>接口API</h3><p>|		接口类型		|	 spinlock定义		|	raw_spinlock的定义	|<br>|	:—————:	|	:—————:	|	:—————:	|<br>|定义spin lock并初始化	|	DEFINE_SPINLOCK		|	DEFINE_RAW_SPINLOCK	|<br>|动态初始化spin lock	|	spin_lock_init		|	raw_spin_lock_init	|<br>|获取指定的spin lock	|	spin_lock			|	raw_spin_lock		|<br>|获取指定的spin lock同时disable本CPU中断						|spin_lock_irq			|raw_spin_lock_irq			|<br>|保存本CPU当前的irq状态, disable本CPU中断并获取指定的spin lock	|spin_lock_irqsave		|raw_spin_lock_irqsave		|<br>|获取指定的spin lock同时disable本CPU的bottom half				|spin_lock_bh			|raw_spin_lock_bh			|<br>|释放指定的spin lock											|spin_unlock			|raw_spin_unlock			|<br>|释放指定的spin lock同时enable本CPU中断							|spin_unlock_irq		|raw_spin_unock_irq			|<br>|释放指定的spin lock同时恢复本CPU的中断状态						|spin_unlock_irqstore	|raw_spin_unlock_irqstore	|<br>|获取指定的spin lock同时enable本CPU的bottom half				|spin_unlock_bh			|raw_spin_unlock_bh			|<br>|尝试去获取spin lock，如果失败，不会spin，而是返回非零值		|spin_trylock			|raw_spin_trylock			|<br>|判断spin lock是否是locked, 如果其他的thread已经获取了该lock, 那么返回非零值，否则返回0	|spin_is_locked |	raw_spin_is_locked |</p>
<h3 id="调用流程"><a href="#调用流程" class="headerlink" title="调用流程"></a>调用流程</h3><p>spin lock:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spin_lock()</span><br><span class="line">	\-&gt;raw_spin_lock()</span><br><span class="line">		\-&gt;__raw_spin_lock</span><br><span class="line">			&#123;</span><br><span class="line">				preempt_disable(); //关闭内核抢占</span><br><span class="line">				spin_acquire(&amp;lock-&gt;dep_map, 0, 0, _RET_IP_); //获取锁</span><br><span class="line">				LOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);//上锁</span><br><span class="line">			&#125;</span><br><span class="line">			-----------------------------  arch</span><br><span class="line">			-&gt; arch_spin_lock()</span><br><span class="line">			-&gt; arch_spin_trylock()</span><br></pre></td></tr></table></figure>

<h2 id="MIPS架构的实现"><a href="#MIPS架构的实现" class="headerlink" title="MIPS架构的实现"></a>MIPS架构的实现</h2><h3 id="arch-spinlock-t"><a href="#arch-spinlock-t" class="headerlink" title="arch_spinlock_t"></a>arch_spinlock_t</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * bits  0..15 : serving_now</span></span><br><span class="line"><span class="comment">	 * bits 16..31 : ticket</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	u32 lock;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __BIG_ENDIAN</span></span><br><span class="line">		u16 ticket;</span><br><span class="line">		u16 serving_now;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">		u16 serving_now;</span><br><span class="line">		u16 ticket;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	&#125; h;</span><br><span class="line">&#125; <span class="type">arch_spinlock_t</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>file: arch&#x2F;mips&#x2F;include&#x2F;asm&#x2F;spinlock_types.h</p>
</blockquote>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><h4 id="arch-spin-lock"><a href="#arch-spin-lock" class="headerlink" title="arch_spin_lock"></a>arch_spin_lock</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">arch_spin_lock</span><span class="params">(<span class="type">arch_spinlock_t</span> *lock)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> my_ticket;</span><br><span class="line">    <span class="type">int</span> tmp;</span><br><span class="line">    <span class="type">int</span> inc = <span class="number">0x10000</span>;</span><br><span class="line"></span><br><span class="line">     __asm__ __volatile__ (</span><br><span class="line">		<span class="string">&quot;   .set push       # arch_spin_lock    \n&quot;</span></span><br><span class="line"> 		<span class="string">&quot;   .set noreorder                  \n&quot;</span></span><br><span class="line"> 		<span class="string">&quot;                           \n&quot;</span></span><br><span class="line"> 		<span class="string">&quot;1: ll  %[ticket], %[ticket_ptr]        \n&quot;</span></span><br><span class="line"> 		<span class="string">&quot;   addu    %[my_ticket], %[ticket], %[inc]     \n&quot;</span></span><br><span class="line"> 		<span class="string">&quot;   sc  %[my_ticket], %[ticket_ptr]     \n&quot;</span></span><br><span class="line"> 		<span class="string">&quot;   beqz    %[my_ticket], 1b            \n&quot;</span></span><br><span class="line"> 		<span class="string">&quot;    srl    %[my_ticket], %[ticket], 16     \n&quot;</span></span><br><span class="line"> 		<span class="string">&quot;   andi    %[ticket], %[ticket], 0xffff        \n&quot;</span></span><br><span class="line"> 		<span class="string">&quot;   bne %[ticket], %[my_ticket], 4f     \n&quot;</span></span><br><span class="line"> 		<span class="string">&quot;    subu   %[ticket], %[my_ticket], %[ticket]  \n&quot;</span></span><br><span class="line"> 		<span class="string">&quot;2: .insn                       \n&quot;</span></span><br><span class="line"> 		<span class="string">&quot;   .subsection 2                   \n&quot;</span></span><br><span class="line"> 		<span class="string">&quot;4: andi    %[ticket], %[ticket], 0xffff        \n&quot;</span></span><br><span class="line"> 		<span class="string">&quot;   sll %[ticket], 5                \n&quot;</span></span><br><span class="line"> 		<span class="string">&quot;                           \n&quot;</span></span><br><span class="line"> 		<span class="string">&quot;6: bnez    %[ticket], 6b               \n&quot;</span></span><br><span class="line"> 		<span class="string">&quot;    subu   %[ticket], 1                \n&quot;</span></span><br><span class="line"> 		<span class="string">&quot;                           \n&quot;</span></span><br><span class="line"> 		<span class="string">&quot;   lhu %[ticket], %[serving_now_ptr]       \n&quot;</span></span><br><span class="line"> 		<span class="string">&quot;   beq %[ticket], %[my_ticket], 2b     \n&quot;</span></span><br><span class="line"> 		<span class="string">&quot;    subu   %[ticket], %[my_ticket], %[ticket]  \n&quot;</span></span><br><span class="line"> 		<span class="string">&quot;   b   4b                  \n&quot;</span></span><br><span class="line"> 		<span class="string">&quot;    subu   %[ticket], %[ticket], 1         \n&quot;</span></span><br><span class="line"> 		<span class="string">&quot;   .previous                   \n&quot;</span></span><br><span class="line"> 		<span class="string">&quot;   .set pop                    \n&quot;</span></span><br><span class="line"> 		: [ticket_ptr] <span class="string">&quot;+&quot;</span> GCC_OFF_SMALL_ASM() (lock-&gt;lock),</span><br><span class="line"> 		  [serving_now_ptr] <span class="string">&quot;+m&quot;</span> (lock-&gt;h.serving_now),</span><br><span class="line"> 		  [ticket] <span class="string">&quot;=&amp;r&quot;</span> (tmp),</span><br><span class="line"> 		  [my_ticket] <span class="string">&quot;=&amp;r&quot;</span> (my_ticket)</span><br><span class="line"> 		: [inc] <span class="string">&quot;r&quot;</span> (inc));</span><br><span class="line"></span><br><span class="line">    smp_llsc_mb();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>file: arch&#x2F;mips&#x2F;include&#x2F;asm&#x2F;spinlock.h</p>
</blockquote>
<p><strong>算法：<a href="/downloads/kernel/spinlock/mcs.pdf">Ticket lock: A fair lock</a></strong></p>
<h4 id="arch-spin-trylock"><a href="#arch-spin-trylock" class="headerlink" title="arch_spin_trylock"></a>arch_spin_trylock</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">arch_spin_trylock</span><span class="params">(<span class="type">arch_spinlock_t</span> *lock)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> tmp, tmp2, tmp3;</span><br><span class="line">    <span class="type">int</span> inc = <span class="number">0x10000</span>;</span><br><span class="line"></span><br><span class="line">    __asm__ __volatile__ (</span><br><span class="line">		<span class="string">&quot;   .set push       # arch_spin_trylock \n&quot;</span></span><br><span class="line">		<span class="string">&quot;   .set noreorder                  \n&quot;</span></span><br><span class="line">		<span class="string">&quot;                           \n&quot;</span></span><br><span class="line">		<span class="string">&quot;1: ll  %[ticket], %[ticket_ptr]        \n&quot;</span></span><br><span class="line">		<span class="string">&quot;   srl %[my_ticket], %[ticket], 16     \n&quot;</span></span><br><span class="line">		<span class="string">&quot;   andi    %[now_serving], %[ticket], 0xffff   \n&quot;</span></span><br><span class="line">		<span class="string">&quot;   bne %[my_ticket], %[now_serving], 3f    \n&quot;</span></span><br><span class="line">		<span class="string">&quot;    addu   %[ticket], %[ticket], %[inc]        \n&quot;</span></span><br><span class="line">		<span class="string">&quot;   sc  %[ticket], %[ticket_ptr]        \n&quot;</span></span><br><span class="line">		<span class="string">&quot;   beqz    %[ticket], 1b               \n&quot;</span></span><br><span class="line">		<span class="string">&quot;    li %[ticket], 1                \n&quot;</span></span><br><span class="line">		<span class="string">&quot;2: .insn                       \n&quot;</span></span><br><span class="line">		<span class="string">&quot;   .subsection 2                   \n&quot;</span></span><br><span class="line">		<span class="string">&quot;3: b   2b                  \n&quot;</span></span><br><span class="line">		<span class="string">&quot;    li %[ticket], 0                \n&quot;</span></span><br><span class="line">		<span class="string">&quot;   .previous                   \n&quot;</span></span><br><span class="line">		<span class="string">&quot;   .set pop                    \n&quot;</span></span><br><span class="line">		: [ticket_ptr] <span class="string">&quot;+&quot;</span> GCC_OFF_SMALL_ASM() (lock-&gt;lock),</span><br><span class="line">		  [ticket] <span class="string">&quot;=&amp;r&quot;</span> (tmp),</span><br><span class="line">		  [my_ticket] <span class="string">&quot;=&amp;r&quot;</span> (tmp2),</span><br><span class="line">		  [now_serving] <span class="string">&quot;=&amp;r&quot;</span> (tmp3)</span><br><span class="line">		: [inc] <span class="string">&quot;r&quot;</span> (inc));</span><br><span class="line"></span><br><span class="line">     smp_llsc_mb();</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> tmp;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>file: arch&#x2F;mips&#x2F;include&#x2F;asm&#x2F;spinlock.h</p>
</blockquote>
<h4 id="反汇编arch-spin-lock"><a href="#反汇编arch-spin-lock" class="headerlink" title="反汇编arch_spin_lock"></a>反汇编arch_spin_lock</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;lg_local_lock&gt;:</span><br><span class="line">   ...</span><br><span class="line"></span><br><span class="line">   3c030001    lui v1,0x1</span><br><span class="line">   c0440000    ll  a0,0(v0)</span><br><span class="line">   00832821    addu    a1,a0,v1</span><br><span class="line">   e0450000    sc  a1,0(v0)</span><br><span class="line">   10a0fffc    beqz    a1,80071228 &lt;lg_local_lock+0x40&gt;</span><br><span class="line">   00042c02    srl a1,a0,0x10</span><br><span class="line">   14850120    bne a0,a1,800716c4 &lt;lg_double_unlock+0x88&gt;</span><br><span class="line">   00a42023    subu    a0,a1,a0</span><br><span class="line"></span><br><span class="line">   0000000f    sync			//smp_llsc_mb();</span><br><span class="line">   ...</span><br></pre></td></tr></table></figure>
<blockquote>
<p>指令：ll和sc</p>
<blockquote>
<p>ll: 指令的功能是从内存中读取一个字，以实现接下来的 RMW（Read-Modify-Write） 操作</p>
</blockquote>
<blockquote>
<p>sc: 指令的功能是向内存中写入一个字，以完成前面的 RMW 操作</p>
</blockquote>
</blockquote>
<h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><h3 id="为什么要关闭抢占？"><a href="#为什么要关闭抢占？" class="headerlink" title="为什么要关闭抢占？"></a>为什么要关闭抢占？</h3><p>如果不禁止内核抢断(或者不禁止中断)，可能会有以下的情况发生（假设进程B比进程A具有更高的优先级）：</p>
<ul>
<li>进程A获得spinlock lock</li>
<li>进程B运行(抢占进程A)</li>
<li>进程B获取spinlock lock</li>
</ul>
<p>由于进程B比进程A优先级高，所以进程B在进程A之前运行，而进程B需要进程A释放lock之后才能运行，于是，死锁</p>
<h3 id="为什么不能睡眠？"><a href="#为什么不能睡眠？" class="headerlink" title="为什么不能睡眠？"></a>为什么不能睡眠？</h3><p>spinlock中的代码不能有睡眠（schedule()之类的放弃CPU的代码），因为此时内核抢占已经关闭，如果让出CPU正好调度到的另一个进程也需要这个锁，整个系统将形成死锁。</p>
<h3 id="spinlock阶段，来中断？"><a href="#spinlock阶段，来中断？" class="headerlink" title="spinlock阶段，来中断？"></a>spinlock阶段，来中断？</h3><ol>
<li>进程A获取spinlcok锁，访问资源R</li>
<li>中断响应后，在中断处理程序中，也去获取spinlock锁，并访问资源R</li>
</ol>
<p>如果在进程A没有释放spinlock锁时，如果触发中断后，进程A和中断怎么处理？？</p>
<blockquote>
<p>此时不能使用spin_lock,应该使用spin_lock_irq</p>
</blockquote>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><span class="exturl" data-url="aHR0cDovL3d3dy53b3dvdGVjaC5uZXQva2VybmVsX3N5bmNocm9uaXphdGlvbi9zcGlubG9jay5odG1s">Linux内核同步机制之（四）：spin lock<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuaWJtLmNvbS9kZXZlbG9wZXJ3b3Jrcy9jbi9saW51eC9sLWNuLXNwaW5sb2NrX21pcHMvaW5kZXguaHRtbA==">Linux 的 Spinlock 在 MIPS 多核处理器中的设计与实现<i class="fa fa-external-link-alt"></i></span></li>
</ol>
]]></content>
      <categories>
        <category>Linux内核</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>sync</tag>
        <tag>spinlock</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux内存的VM参数</title>
    <url>/post/18938.html</url>
    <content><![CDATA[<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@buildroot ~]# sysctl -a | grep &quot;vm&quot;</span><br><span class="line">sysctl: error reading key &#x27;net.ipv4.route.flush&#x27;: Permission denied</span><br><span class="line">vm.admin_reserve_kbytes = 8192</span><br><span class="line">vm.block_dump = 0</span><br><span class="line">vm.dirty_background_bytes = 0</span><br><span class="line">vm.dirty_background_ratio = 10</span><br><span class="line">vm.dirty_bytes = 0</span><br><span class="line">vm.dirty_expire_centisecs = 3000</span><br><span class="line">vm.dirty_ratio = 20</span><br><span class="line">vm.dirty_writeback_centisecs = 500</span><br><span class="line">vm.drop_caches = 0</span><br><span class="line">vm.extra_free_kbytes = 0</span><br><span class="line">vm.highmem_is_dirtyable = 0</span><br><span class="line">vm.laptop_mode = 0</span><br><span class="line">vm.legacy_va_layout = 0</span><br><span class="line">vm.lowmem_reserve_ratio = 32      32</span><br><span class="line">vm.max_map_count = 65530</span><br><span class="line">vm.min_free_kbytes = 1970</span><br><span class="line">vm.min_free_order_shift = 1</span><br><span class="line">vm.mmap_min_addr = 4096</span><br><span class="line">vm.nr_pdflush_threads = 0</span><br><span class="line">vm.oom_dump_tasks = 1</span><br><span class="line">vm.oom_kill_allocating_task = 0</span><br><span class="line">vm.overcommit_memory = 0</span><br><span class="line">vm.overcommit_ratio = 50</span><br><span class="line">vm.page-cluster = 3</span><br><span class="line">vm.panic_on_oom = 0</span><br><span class="line">vm.percpu_pagelist_fraction = 0</span><br><span class="line">vm.scan_unevictable_pages = 0</span><br><span class="line">vm.stat_interval = 1</span><br><span class="line">vm.swappiness = 60</span><br><span class="line">vm.user_reserve_kbytes = 15712</span><br><span class="line">vm.vfs_cache_pressure = 100</span><br></pre></td></tr></table></figure>
<blockquote>
<p>proc文件系统：<code> ls /proc/sys/vm/</code></p>
</blockquote>
<span id="more"></span>

<h2 id="overcommit-memory"><a href="#overcommit-memory" class="headerlink" title="overcommit_memory"></a>overcommit_memory</h2><blockquote>
<p>内核分配内存的策略，有0，1，2三种</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">overcommit_memory</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">表示内核将检查是否有足够的可用内存供应用进程使用；如果有足够的可用内存，内存申请允许；否则，内存申请失败，并把错误返回给应用进程。</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">表示内核允许分配所有的物理内存，而不管当前的内存状态如何</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">表示内核允许分配超过所有物理内存和交换空间总和的内存</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Linux内核</category>
      </categories>
      <tags>
        <tag>kernel</tag>
        <tag>vm</tag>
      </tags>
  </entry>
  <entry>
    <title>等待队列</title>
    <url>/post/36894.html</url>
    <content><![CDATA[<h3 id="等待队列"><a href="#等待队列" class="headerlink" title="等待队列"></a>等待队列</h3><p>由循环链表实现，其元素包括指向进程描述符的指针。每个等待队列都有一个等待队列头(wait queue head),等待队列头是一个类型为wait_queue_head_t的数据结构</p>
<h3 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h3>]]></content>
      <categories>
        <category>Linux内核</category>
      </categories>
      <tags>
        <tag>process</tag>
        <tag>queue</tag>
      </tags>
  </entry>
  <entry>
    <title>linux kernel之NMI</title>
    <url>/post/98e04b95.html</url>
    <content><![CDATA[<p><code>NMI</code>(non-maskable interrupt)，即非可屏蔽中断。即使在内核代码中设置了屏蔽所有中断的时候，NMI也是不可以被屏蔽的。根据Intel的Software Developer手册Volume 3，NMI可由以下两种方式触发：</p>
<ul>
<li>外部assert了CPU的NMI引脚</li>
<li>CPU从系统总线收到了一个中断请求并且delivery mode是NMI</li>
</ul>
<span id="more"></span>

<ol>
<li>无法恢复的硬件错误通常包括：芯片错误、内存ECC校验错、总线数据损坏等等。</li>
<li>当系统挂起，失去响应的时候，可以人工触发NMI，使系统重置，如果早已配置好了kdump，那么会保存crash dump以供分析。有的服务器提供了NMI按钮，而刀片服务器通常不提供按钮，但可以用iLO命令触发。</li>
<li>Linux还提供一种称为”NMI watchdog“的机制，用于检测系统是否失去响应（也称为lockup），可以配置为在发生lockup时自动触发panic。原理是周期性地生成NMI，由NMI handler检查hrtimer中断的发生次数，如果一定时间内这个数字停顿了，表示系统失去了响应，于是调用panic例程。NMI watchdog的开关是通过内核参数<code>kernel.nmi_watchdog</code>或者在boot parameter中加入<code>”nmi_watchdog=1″</code>参数实现，比如：</li>
</ol>
<p>在centos上编辑<code>/boot/grub2/grub.cfg</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">kernel /vmlinuz-2.6.18-128.el5 ro root=/dev/sda nmi_watchdog=1</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>命令行设置：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sysctl kernel.nmi_watchdog=1</span><br></pre></td></tr></table></figure>

<h2 id="NMI中断的生成"><a href="#NMI中断的生成" class="headerlink" title="NMI中断的生成"></a>NMI中断的生成</h2><ul>
<li>perf性能优化工具使用时，生成大量的NMI中断</li>
</ul>
<blockquote>
<p>Run the ‘perf’ tool in a mode (top or record) that generates many frequent performance monitoring non-maskable interrupts (see “NMI” in &#x2F;proc&#x2F;interrupts).  This exercises the NMI entry&#x2F;exit code which is known to trigger bugs in code paths that did not expect to be interrupted, including nested NMIs.  Using “-c” boosts the rate of NMIs, and using two -c with separate counters encourages nested NMIs and less deterministic behavior.</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">while true; do perf record -c 10000 -e instructions,cycles -a sleep 10; done</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly93aWtpLm9zZGV2Lm9yZy9Ob25fTWFza2FibGVfSW50ZXJydXB0">Non Maskable Interrupt<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9sd24ubmV0L0FydGljbGVzLzQ4NDkzMi8=">The x86 NMI iret problem<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3loYjEwNDc4MTgzODQvYXJ0aWNsZS9kZXRhaWxzLzcwODMzODI1">linux 内核笔记之watchdog<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL2xpbnV4cGVyZi5jb20vP3A9NzI=">NMI是什么<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL2Jsb2cuYnl0ZW1lbS5jb20vcG9zdC9saW51eC1rZXJuZWwtbm1pLWhhbmRsZXIteDg2">Linux内核对x86平台NMI中断的处理<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cua2VybmVsLm9yZy9kb2MvaHRtbC9sYXRlc3QvdHJhY2UvZXZlbnRzLW5taS5odG1s">NMI Trace Events<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>Linux内核</category>
      </categories>
      <tags>
        <tag>kernel</tag>
        <tag>nmi</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux内核工具--Sparse</title>
    <url>/post/22743.html</url>
    <content><![CDATA[<p>Sparse诞生于2004年，是由Linux之父开发的，目的就是提供一个静态检查代码的工具，从而减少Linux内核的隐患。起始，在Sparse之前已经有了一个不错的代码静态检查工具（SWAT），只不过这个工具不是免费软件，使用上有一些限制。所以Linus自己开发了一个静态检查工具。</p>
<blockquote>
<p>版本: linux4.4.166</p>
<p>参考文档:<span class="exturl" data-url="aHR0cHM6Ly9lbGl4aXIuYm9vdGxpbi5jb20vbGludXgvdjQuNC4xNjYvc291cmNlL0RvY3VtZW50YXRpb24vc3BhcnNlLnR4dA==">Documentation&#x2F;sparse.txt<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<span id="more"></span>

<p>Sparse通过gcc的扩展属性<code>__attribute__</code>以及自己定义的<code>__context__</code>来对代码进行静态检查。</p>
<blockquote>
<p><code>__xxx</code>双下划线开头的宏,表示编译器相关的一些属性设置</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __CHECKER__</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __user     __attribute__((noderef, address_space(1)))</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __kernel   __attribute__((address_space(0)))</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __safe     __attribute__((safe))</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __force    __attribute__((force))</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __nocast   __attribute__((nocast))</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __iomem    __attribute__((noderef, address_space(2)))</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __must_hold(x) __attribute__((context(x,1,1)))</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __acquires(x)  __attribute__((context(x,0,1)))</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __releases(x)  __attribute__((context(x,1,0)))</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __acquire(x)   __context__(x,1)</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __release(x)   __context__(x,-1)</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __cond_lock(x,c)   ((c) ? (&#123; __acquire(x); 1; &#125;) : 0)</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __percpu   __attribute__((noderef, address_space(3)))</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __pmem     __attribute__((noderef, address_space(5)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SPARSE_RCU_POINTER</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __rcu      __attribute__((noderef, address_space(4)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __rcu</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> __chk_user_ptr(<span class="type">const</span> <span class="keyword">volatile</span> <span class="type">void</span> __user *);</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> __chk_io_ptr(<span class="type">const</span> <span class="keyword">volatile</span> <span class="type">void</span> __iomem *);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>file: include&#x2F;linux&#x2F;compiler.h</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __CHECKER__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __bitwise__ __attribute__((bitwise))</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __bitwise__</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __CHECK_ENDIAN__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __bitwise __bitwise__</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __bitwise</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>file: tools&#x2F;include&#x2F;linux&#x2F;types.h</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">宏名称</th>
<th align="center">定义</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">__bitwise</td>
<td align="center"><code>__attribute__((bitwise))</code></td>
<td align="center">确保变量是相同的位方式(比如 bit-endian, little-endiandeng)</td>
</tr>
<tr>
<td align="center">__user</td>
<td align="center"><code>__attribute__((noderef, address_space(1)))</code></td>
<td align="center">指针地址必须在用户地址空间</td>
</tr>
<tr>
<td align="center">__kernel</td>
<td align="center"><code>__attribute__((noderef, address_space(0)))</code></td>
<td align="center">指针地址必须在内核地址空间</td>
</tr>
<tr>
<td align="center">__iomem</td>
<td align="center"><code>__attribute__((noderef, address_space(2)))</code></td>
<td align="center">指针地址必须在设备地址空间</td>
</tr>
<tr>
<td align="center">__safe</td>
<td align="center"><code>__attribute__((safe))</code></td>
<td align="center">变量可以为空</td>
</tr>
<tr>
<td align="center">__force</td>
<td align="center"><code>__attribute__((force))</code></td>
<td align="center">变量可以进行强制转换</td>
</tr>
<tr>
<td align="center">__nocast</td>
<td align="center"><code>__attribute__((nocast))</code></td>
<td align="center">参数类型与实际参数类型必须一致</td>
</tr>
<tr>
<td align="center">__acquires(x)</td>
<td align="center"><code>__attribute__((context(x, 0, 1)))</code></td>
<td align="center">参数x 在执行前引用计数必须是0,执行后,引用计数必须为1</td>
</tr>
<tr>
<td align="center">__releases(x)</td>
<td align="center"><code>__attribute__((context(x, 1, 0)))</code></td>
<td align="center">与__acquires(x)相反</td>
</tr>
<tr>
<td align="center">__acquire(x)</td>
<td align="center"><code>__context__(x, 1)</code></td>
<td align="center">参数x的引用计数+1</td>
</tr>
<tr>
<td align="center">__release(x)</td>
<td align="center"><code>__context__(x, 1)</code></td>
<td align="center">与__acquire(x)相反</td>
</tr>
<tr>
<td align="center">__cond_lock(x,c)</td>
<td align="center"><code>((c) ? (&#123; __acquire(x); 1; &#125;) : 0)</code></td>
<td align="center">参数c 不为0时,引用计数 + 1, 并返回1</td>
</tr>
</tbody></table>
<blockquote>
<p>其中<code>__acquires(x)</code>和<code>__releases(x)</code>，<code>__acquire(x)</code>和<code>__release(x)</code>必须配对使用,都和<code>锁</code>有关，否则Sparse会发出警告</p>
</blockquote>
<h2 id="Sparse-在编译内核中的使用"><a href="#Sparse-在编译内核中的使用" class="headerlink" title="Sparse 在编译内核中的使用"></a>Sparse 在编译内核中的使用</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">make C=1 检查所有重新编译的代码</span><br><span class="line">make C=2 检查所有代码, 不管是不是被重新编译</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果进行<code>-Wbitwise</code>的检查,需要定义<code>#define __CHECK_ENDIAN__</code>,可以通过<code>CF</code>进行传参</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">make C=2 CF=&quot;-D__CHECK_ENDIAN__&quot;</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">fb_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">__<span class="title function_">acquires</span><span class="params">(&amp;info-&gt;lock)</span></span><br><span class="line">__<span class="title function_">releases</span><span class="params">(&amp;info-&gt;lock)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在编译阶段检查锁,防止死锁.</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vd2FuZ195Yi9wLzM1NzUwMzkuaHRtbA==">内核工具 – Sparse 简介<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMjEwMTg3Nzgvd2hhdC1kb2VzLXN0YXRpYy1pbnQtZnVuY3Rpb24tYWNxdWlyZXMtcmVsZWFzZXMtbWVhbg==">what-does-static-int-function-acquires-releases-mean<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>Linux内核</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>linux内核数据结构--基础宏</title>
    <url>/post/56380.html</url>
    <content><![CDATA[<p>在阅读内核源码时,存在一些基础的宏定义和函数,这里主要记录一下<code>offsetof</code>和<code>container_of</code></p>
<span id="more"></span>

<h2 id="offsetof"><a href="#offsetof" class="headerlink" title="offsetof"></a>offsetof</h2><p>获得结构体(TYPE)的变量成员(MEMBER)在此结构体中的偏移量。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> offsetof(TYPE, MEMBER)  ((size_t)&amp;((TYPE *)0)-&gt;MEMBER)</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>From file:<span class="exturl" data-url="aHR0cHM6Ly9lbGl4aXIuYm9vdGxpbi5jb20vbGludXgvdjQuNC4xL3NvdXJjZS9pbmNsdWRlL2xpbnV4L3N0ZGRlZi5o">include&#x2F;linux&#x2F;stddef.h<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<ol>
<li><code>((TYPE *)0)</code>:将零转型为TYPE类型指针，即TYPE类型的指针的地址是0。</li>
<li><code>((TYPE *)0)-&gt;MEMBER</code>:访问结构中的数据成员。</li>
<li><code>&amp;(((TYPE *)0)-&gt;MEMBER)</code>:取出数据成员的地址。由于TYPE的地址是0，这里获取到的地址就是相对MEMBER在TYPE中的偏移。</li>
<li><code>(size_t)(&amp;(((TYPE*)0)-&gt;MEMBER))</code>: 结果转换类型。对于32位系统而言，size_t是unsigned int类型；对于64位系统而言，size_t是unsigned long类型。</li>
</ol>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获得结构体(TYPE)的变量成员(MEMBER)在此结构体中的偏移量。</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> offsetof(TYPE, MEMBER) ((size_t) &amp;((TYPE *)0)-&gt;MEMBER)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> gender;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> gender_offset, id_offset, age_offset, name_offset;</span><br><span class="line"></span><br><span class="line">    gender_offset = offsetof(<span class="keyword">struct</span> student, gender);</span><br><span class="line">    id_offset     = offsetof(<span class="keyword">struct</span> student, id);</span><br><span class="line">    age_offset    = offsetof(<span class="keyword">struct</span> student, age);</span><br><span class="line">    name_offset   = offsetof(<span class="keyword">struct</span> student, name);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;gender_offset = %d\n&quot;</span>, gender_offset);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;id_offset = %d\n&quot;</span>, id_offset);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;age_offset = %d\n&quot;</span>, age_offset);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;name_offset = %d\n&quot;</span>, name_offset);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gender_offset = 0</span><br><span class="line">id_offset = 4</span><br><span class="line">age_offset = 8</span><br><span class="line">name_offset = 12</span><br></pre></td></tr></table></figure>

<h3 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h3><p><img data-src="/images/2018/11/list_offsetof.png" alt="list_offsetof"></p>
<p>TYPE是结构体，它代表”整体”；而MEMBER是成员，它是整体中的某一部分。</p>
<p>将offsetof看作一个数学问题来看待，问题就相当简单了：</p>
<blockquote>
<p>已知’整体’和该整体中’某一个部分’，而计算该部分在整体中的偏移。</p>
</blockquote>
<h2 id="container-of"><a href="#container-of" class="headerlink" title="container_of"></a>container_of</h2><p>根据”结构体(type)变量”中的”域成员变量(member)的指针(ptr)”来获取指向整个结构体变量的指针。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> container_of(ptr, type, member) (&#123;          \</span></span><br><span class="line"><span class="meta">        const typeof( ((type *)0)-&gt;member ) *__mptr = (ptr);    \</span></span><br><span class="line"><span class="meta">        (type *)( (char *)__mptr - offsetof(type,member) );&#125;)</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>From file:<span class="exturl" data-url="aHR0cHM6Ly9lbGl4aXIuYm9vdGxpbi5jb20vbGludXgvdjQuNC4xL3NvdXJjZS9pbmNsdWRlL2xpbnV4L2tlcm5lbC5oI0w4MTI=">include&#x2F;linux&#x2F;kernel.h<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<ol>
<li><code>typeof(((type *)0)-&gt;member)</code>: 取出member成员的变量类型。</li>
<li><code>const typeof(((type *)0)-&gt;member) *__mptr = (ptr)</code>: 定义变量<code>__mptr</code>指针，并将ptr赋值给<code>__mptr</code>。经过这一步, <code>__mptr</code>为member数据类型的常量指针，其指向ptr所指向的地址。</li>
<li><code>(char *)__mptr</code>: 将<code>__mptr</code>转换为字节型指针。</li>
<li><code>offsetof(type,member))</code>: 就是获取”member成员”在”结构体type”中的位置偏移。</li>
<li><code>(char *)__mptr - offsetof(type,member))</code>: 就是用来获取”结构体type”的指针的起始地址（为char *型指针）。</li>
<li><code>(type *)((char *)__mptr - offsetof(type,member))</code>: 就是将”char *类型的结构体type的指针”转换为”type *类型的结构体type的指针”。</li>
</ol>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获得结构体(TYPE)的变量成员(MEMBER)在此结构体中的偏移量。</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> offsetof(TYPE, MEMBER) ((size_t) &amp;((TYPE *)0)-&gt;MEMBER)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据&quot;结构体(type)变量&quot;中的&quot;域成员变量(member)的指针(ptr)&quot;来获取指向整个结构体变量的指针</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> container_of(ptr, type, member) (&#123;          \</span></span><br><span class="line"><span class="meta">        const typeof( ((type *)0)-&gt;member ) *__mptr = (ptr);    \</span></span><br><span class="line"><span class="meta">        (type *)( (char *)__mptr - offsetof(type,member) );&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> gender;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">stu</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">student</span> *<span class="title">pstu</span>;</span></span><br><span class="line"></span><br><span class="line">    stu.gender = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">    stu.id = <span class="number">9527</span>;</span><br><span class="line">    stu.age = <span class="number">24</span>;</span><br><span class="line">    <span class="built_in">strcpy</span>(stu.name, <span class="string">&quot;zhouxingxing&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据&quot;id地址&quot; 获取 &quot;结构体的地址&quot;。</span></span><br><span class="line">    pstu = container_of(&amp;stu.id, <span class="keyword">struct</span> student, id);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据获取到的结构体student的地址，访问其它成员</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;gender= %c\n&quot;</span>, pstu-&gt;gender);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;age= %d\n&quot;</span>, pstu-&gt;age);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;name= %s\n&quot;</span>, pstu-&gt;name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gender= 1</span><br><span class="line">age= 24</span><br><span class="line">name= zhouxingxing</span><br></pre></td></tr></table></figure>

<h3 id="图解-1"><a href="#图解-1" class="headerlink" title="图解"></a>图解</h3><p><img data-src="/images/2018/11/list_container_of.png" alt="list_container_of"></p>
<p>type是结构体，它代表”整体”；而member是成员，它是整体中的某一部分，而且member的地址是已知的。<br>将offsetof看作一个数学问题来看待，问题就相当简单了：</p>
<blockquote>
<p>已知’整体’和该整体中’某一个部分’，要根据该部分的地址，计算出整体的地址。</p>
</blockquote>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vc2t5d2FuZzEyMzQ1L3AvMzU2MjE0Ni5odG1s">Linux内核中双向链表的经典实现<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>Linux内核</category>
      </categories>
      <tags>
        <tag>kernel</tag>
      </tags>
  </entry>
  <entry>
    <title>linux内核数据结构--链表</title>
    <url>/post/58180.html</url>
    <content><![CDATA[<p>链表操作接口：<span class="exturl" data-url="aHR0cHM6Ly9lbGl4aXIuYm9vdGxpbi5jb20vbGludXgvdjQuNC4xL3NvdXJjZS9pbmNsdWRlL2xpbnV4L2xpc3QuaA==">include&#x2F;linux&#x2F;list.h<i class="fa fa-external-link-alt"></i></span></p>
<span id="more"></span>

<h2 id="应用层编程使用mylist-h"><a href="#应用层编程使用mylist-h" class="headerlink" title="应用层编程使用mylist.h"></a>应用层编程使用mylist.h</h2><blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL1dpbmRkb2luZy9Db2RlV2hlZWwvbWFzdGVyL0MvbGlzdC9rZXJuZWxfbGlzdC9saXN0Lmg=">mylist.h<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><span class="exturl" data-url="aHR0cDovL3d3dy56aGltZW5nemhlLmNvbS9saW51eC83NTk2Ni5odG1s">list_for_each_entry 和 list_for_each_entry_safe函数分析<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTM5MDQyMjcvYXJ0aWNsZS9kZXRhaWxzLzUwOTMxNTQw">list_head结构体的理解<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>Linux内核</category>
      </categories>
      <tags>
        <tag>kernel</tag>
      </tags>
  </entry>
  <entry>
    <title>linux内核spinlock死锁——两核互锁</title>
    <url>/post/3099dbdc.html</url>
    <content><![CDATA[<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[24881.771099] BUG: spinlock wrong CPU on CPU#0, aplay/691</span><br><span class="line">[24881.777642]  lock: 0xffffff8011d96348, .magic: dead4ead, .owner: aplay/691, .owner_cpu: 1</span><br></pre></td></tr></table></figure>
<blockquote>
<p>软硬件环境：Linux5.4.110, arm64</p>
<blockquote>
<p>CPU0进行上锁时，发现该锁被CPU1所持有，所以造成两核互锁</p>
</blockquote>
</blockquote>
<span id="more"></span>

<p>以上log是在一次测试中出现的，系统打印出上述日志后直接卡死，该日志提示当前进程中的一个spinlock锁是在<code>CPU1核上上锁</code>，但是在<code>CPU0核上解锁</code>，才导致出现以上日志警告。</p>
<h2 id="为什么会出现以上现象？"><a href="#为什么会出现以上现象？" class="headerlink" title="为什么会出现以上现象？"></a>为什么会出现以上现象？</h2><h2 id="死锁的解决方法"><a href="#死锁的解决方法" class="headerlink" title="死锁的解决方法"></a>死锁的解决方法</h2>]]></content>
      <categories>
        <category>Linux内核</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>sync</tag>
        <tag>spinlock</tag>
        <tag>死锁</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux内核调试——dynamic_debug</title>
    <url>/post/cb918227.html</url>
    <content><![CDATA[<p><code>dynamic debug</code> (dyndbg)是内核提供的一个调试功能，允许动态的开关内核打印输出，包含的API：<code>pr_debug()</code>、<code>dev_dbg()</code>、<code>print_hex_dump_debug()</code>、<code>print_hex_dump_bytes()</code>等。<br>dynamic debug通过设置&#x2F;dynamic_debug&#x2F;control文件来控制内核输出，有多种匹配的条件：文件名，函数名，行号，模块名和输出字符的格式；</p>
<span id="more"></span>


<h2 id="开启配置"><a href="#开启配置" class="headerlink" title="开启配置"></a>开启配置</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CONFIG_DEBUG_FS=y</span><br><span class="line">CONFIG_DYNAMIC_DEBUG=y</span><br></pre></td></tr></table></figure>

<p>sys文件系统：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># ls /sys/kernel/debug/dynamic_debug/</span><br><span class="line">control</span><br></pre></td></tr></table></figure>

<p>查询所有开启了<code>dynamic debug</code>选项的文件；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># cat /sys/kernel/debug/dynamic_debug/control</span><br><span class="line"># filename:lineno [module]function flags format</span><br><span class="line">init/main.c:857 [main]initcall_blacklisted =p &quot;initcall %s blacklisted\012&quot;</span><br><span class="line">init/main.c:818 [main]initcall_blacklist =p &quot;blacklisting initcall %s\012&quot;</span><br><span class="line">init/initramfs.c:477 [initramfs]unpack_to_rootfs =_ &quot;Detected %s compressed data\012&quot;</span><br><span class="line">arch/arm64/kernel/setup.c:122 [setup]smp_build_mpidr_hash =_ &quot;mask of set bits %#llx\012&quot;</span><br><span class="line">arch/arm64/kernel/setup.c:156 [setup]smp_build_mpidr_hash =_ &quot;MPIDR hash: aff0[%u] aff1[%u] aff2[%u] aff3[%u] mask[%#llx] bits[%u]\012&quot;</span><br><span class="line">arch/arm64/kernel/traps.c:90 [traps]dump_backtrace =_ &quot;%s(regs = %p tsk = %p)\012&quot;</span><br><span class="line">arch/arm64/kernel/smp.c:667 [smp]of_parse_and_init_cpus =_ &quot;cpu logical map 0x%llx\012&quot;</span><br><span class="line">arch/arm64/kernel/topology.c:56 [topology]store_cpu_topology =_ &quot;CPU%u: cluster %d core %d thread %d mpidr %#016llx\012&quot;</span><br><span class="line">arch/arm64/kernel/armv8_deprecated.c:401 [armv8_deprecated]swp_handler =_ &quot;addr in r%d-&gt;0x%08x, dest is r%d, source in r%d-&gt;0x%08x)\012&quot;</span><br><span class="line">arch/arm64/kernel/armv8_deprecated.c:408 [armv8_deprecated]swp_handler =_ &quot;SWP&#123;B&#125; emulation: access to 0x%08x not allowed!\012&quot;</span><br><span class="line">arch/arm64/kernel/armv8_deprecated.c:326 [armv8_deprecated]emulate_swpX =_ &quot;SWP instruction on unaligned pointer!\012&quot;</span><br><span class="line">arch/arm64/kernel/armv8_deprecated.c:432 [armv8_deprecated]swp_handler =_ &quot;SWP&#123;B&#125; emulation: access caused memory abort!\012&quot;</span><br><span class="line">kernel/params.c:177 [params]parse_args =_ &quot;doing %s, parsing ARGS: &#x27;%s&#x27;\012&quot;</span><br><span class="line">kernel/params.c:139 [params]parse_one =_ &quot;handling %s with %p\012&quot;</span><br><span class="line">kernel/params.c:152 [params]parse_one =_ &quot;doing %s: %s=&#x27;%s&#x27;\012&quot;</span><br><span class="line">kernel/params.c:156 [params]parse_one =_ &quot;Unknown argument &#x27;%s&#x27;\012&quot;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h2 id="control文件的语法格式"><a href="#control文件的语法格式" class="headerlink" title="control文件的语法格式"></a>control文件的语法格式</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">command ::= match-spec* flags-spec</span><br></pre></td></tr></table></figure>

<p>匹配的关键字：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">match-spec ::= &#x27;func&#x27; string |</span><br><span class="line">               &#x27;file&#x27; string |</span><br><span class="line">               &#x27;module&#x27; string |</span><br><span class="line">               &#x27;format&#x27; string |</span><br><span class="line">               &#x27;class&#x27; string |</span><br><span class="line">               &#x27;line&#x27; line-range</span><br><span class="line"></span><br><span class="line">line-range ::= lineno |</span><br><span class="line">               &#x27;-&#x27;lineno |</span><br><span class="line">               lineno&#x27;-&#x27; |</span><br><span class="line">               lineno&#x27;-&#x27;lineno</span><br><span class="line"></span><br><span class="line">lineno ::= unsigned-int</span><br></pre></td></tr></table></figure>

<p><code>flags-spec</code>包括一个更改操作，后跟一个或多个标志字符。更改操作是以下字符之一：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-    remove the given flags</span><br><span class="line">+    add the given flags</span><br><span class="line">=    set the flags to the given flags</span><br></pre></td></tr></table></figure>

<p>flags包括：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">p    enables the pr_debug() callsite.</span><br><span class="line">_    enables no flags.</span><br><span class="line"></span><br><span class="line">Decorator flags add to the message-prefix, in order:</span><br><span class="line">t    Include thread ID, or &lt;intr&gt;</span><br><span class="line">m    Include module name</span><br><span class="line">f    Include the function name</span><br><span class="line">l    Include line number</span><br></pre></td></tr></table></figure>

<p>组合参数就有：</p>
<ul>
<li><code>+mp</code>: 输出打打印包含模块名</li>
<li><code>+mfp</code>： 输出打印包含模块名、函数名</li>
<li><code>+mflp</code>： 输出打印包含模块名、函数名、行号</li>
<li><code>+mflp</code>： 输出打印包含模块名、函数名、行号、线程号</li>
</ul>
<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>内核实现：<code>lib/dynamic_debug.c</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Parse words[] as a ddebug query specification, which is a series</span><br><span class="line">of (keyword, value) pairs chosen from these possibilities:</span><br><span class="line"></span><br><span class="line">func &lt;function-name&gt;</span><br><span class="line">file &lt;full-pathname&gt;</span><br><span class="line">file &lt;base-filename&gt;</span><br><span class="line">module &lt;module-name&gt;</span><br><span class="line">format &lt;escaped-string-to-find-in-format&gt;</span><br><span class="line">line &lt;lineno&gt;</span><br><span class="line">line &lt;first-lineno&gt;-&lt;last-lineno&gt; // where either may be empty</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>开启某个文件中的pr_debug或dev_dbg</strong></p>
</blockquote>
<h3 id="输出打印"><a href="#输出打印" class="headerlink" title="输出打印"></a>输出打印</h3><p>开启后内核日志将输出到<code>dmesg</code>,串口不会输出。也可以在<code>/var/log/messages</code>中查看。</p>
<ul>
<li><p>指定调试文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo &quot;file mm/cma.c +p&quot; &gt; /sys/kernel/debug/dynamic_debug/control</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo &quot;file mm/cma.c +mfplt&quot; &gt; /sys/kernel/debug/dynamic_debug/control</span><br></pre></td></tr></table></figure>

</li>
<li><p>指定调试模块</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo &quot;module cma +p&quot; &gt; /sys/kernel/debug/dynamic_debug/control</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="关闭打印"><a href="#关闭打印" class="headerlink" title="关闭打印"></a>关闭打印</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo &quot;file mm/cma.c -p&quot; &gt; /sys/kernel/debug/dynamic_debug/control</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo &quot;module cma -p&quot; &gt; /sys/kernel/debug/dynamic_debug/control</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cua2VybmVsLm9yZy9kb2MvaHRtbC9sYXRlc3QvYWRtaW4tZ3VpZGUvZHluYW1pYy1kZWJ1Zy1ob3d0by5odG1s">内核文档——Dynamic debug<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>Linux内核</category>
      </categories>
      <tags>
        <tag>debug</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux死锁检测——Lockdep</title>
    <url>/post/1a6384db.html</url>
    <content><![CDATA[<p><code>Lockdep</code>是内核提供协助发现死锁问题的功能，主要是跟踪每个锁的自身状态和各个锁之间的依赖关系，经过一系列的验证规则来确保锁之间依赖关系是正确的。</p>
<p><code>Lockdep</code>检测的锁包括<code>spinlock</code>、<code>rwlock</code>、<code>mutex</code>、<code>rwsem</code>的死锁，锁的错误释放，原子操作中睡眠等错误行为。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Kernel hacking  ---&gt;</span><br><span class="line">  Lock Debugging (spinlocks, mutexes, etc...)  ---&gt;</span><br><span class="line">    [*] Lock debugging: prove locking correctness</span><br><span class="line">    [ ] Lock usage statistics</span><br><span class="line">    -*- RT Mutex debugging, deadlock detection</span><br><span class="line">    -*- Spinlock and rw-lock debugging: basic checks</span><br><span class="line">    -*- Mutex debugging: basic checks</span><br><span class="line">    -*- Wait/wound mutex debugging: Slowpath testing</span><br><span class="line">    -*- RW Semaphore debugging: basic checks</span><br><span class="line">    -*- Lock debugging: detect incorrect freeing of live locks</span><br><span class="line">    [*] Lock dependency engine debugging</span><br><span class="line">    [ ] Sleep inside atomic section checking</span><br><span class="line">    [ ] Locking API boot-time self-tests</span><br><span class="line">    &lt; &gt; torture tests for locking</span><br><span class="line">    &lt; &gt; Wait/wound mutex selftests</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="内核配置说明"><a href="#内核配置说明" class="headerlink" title="内核配置说明"></a>内核配置说明</h2><ul>
<li><p>CONFIG_DEBUG_RT_MUTEXES&#x3D;y</p>
<ul>
<li>检测rt mutex的死锁，并自动报告死锁现场信息。</li>
</ul>
</li>
<li><p>CONFIG_DEBUG_SPINLOCK&#x3D;y</p>
<ul>
<li>检测spinlock的未初始化使用等问题。配合NMI watchdog使用，能发现spinlock死锁。</li>
</ul>
</li>
<li><p>CONFIG_DEBUG_MUTEXES&#x3D;y</p>
<ul>
<li>检测并报告mutex错误</li>
</ul>
</li>
<li><p>CONFIG_DEBUG_WW_MUTEX_SLOWPATH&#x3D;y</p>
<ul>
<li>检测wait&#x2F;wound类型mutex的slowpath测试。</li>
</ul>
</li>
<li><p>CONFIG_DEBUG_LOCK_ALLOC&#x3D;y</p>
<ul>
<li>检测使用中的锁(spinlock&#x2F;rwlock&#x2F;mutex&#x2F;rwsem)被释放，或者使用中的锁被重新初始化，或者在进程退出时持有锁。</li>
</ul>
</li>
<li><p>CONFIG_PROVE_LOCKING&#x3D;y</p>
<ul>
<li>使内核能在死锁发生前报告死锁详细信息。参见&#x2F;proc&#x2F;lockdep_chains。</li>
</ul>
</li>
<li><p>CONFIG_LOCKDEP&#x3D;y</p>
</li>
<li><p>整个Lockdep的总开关。参见&#x2F;proc&#x2F;lockdep、&#x2F;proc&#x2F;lockdep_stats。</p>
</li>
<li><p>CONFIG_LOCK_STAT&#x3D;y</p>
<ul>
<li>记锁持有竞争区域的信息，包括等待时间、持有时间等等信息。参见&#x2F;proc&#x2F;lock_stat。</li>
</ul>
</li>
<li><p>CONFIG_DEBUG_LOCKDEP&#x3D;y</p>
<ul>
<li>会对Lockdep的使用过程中进行更多的自我检测，会增加很多额外开销。</li>
</ul>
</li>
<li><p>CONFIG_DEBUG_ATOMIC_SLEEP&#x3D;y</p>
<ul>
<li>在atomic section中睡眠可能造成很多不可预测的问题，这些atomic section包括spinlock持锁、rcu读操作、禁止内核抢占部分、中断处理中等等。</li>
</ul>
</li>
</ul>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p><code>死锁</code>是指多个进程（线程）因为长时间等待已被其他进程（线程）占有的的资源而陷入阻塞的一种状态。</p>
<p>当等待的资源一直得不到释放，死锁会一直持续下去。死锁一旦发生，程序本身是解决不了的，只能依靠外部力量使得程序恢复运行，例如重启，开门狗复位等</p>
<p>Linux 提供了检测死锁的机制，主要分为<code>D状态死锁</code>和<code>R状态死锁</code>。</p>
<ul>
<li><p>D状态死锁</p>
<p>进程等待I&#x2F;O资源无法得到满足，长时间（系统默认配置 120 秒）处于TASK_UNINTERRUPTIBLE睡眠状态，这种状态下进程不响应异步信号（包括 kill -9）。如：进程与外设硬件的交互（如 read），通常使用这种状态来保证进程与设备的交互过程不被打断，否则设备可能处于不可控的状态。对于这种死锁的检测Linux提供的是hung task机制，MTK也提供hang detect机制来检测Android系统 hang 机问题。触发该问题成因比较复杂多样，可能因为 synchronized_irq、mutex lock、内存不足等。D 状态死锁只是局部多进程间互锁，一般来说只是 hang 机、冻屏，机器某些功能没法使用，但不会导致没喂狗，而被狗咬死。</p>
<p>内核D状态死锁检测就是<code>hung_task机制</code>，主要代码就在kernel&#x2F;hung_task.c文件。</p>
</li>
<li><p>R状态死锁</p>
<p>进程长时间（系统默认配置 60 秒）处于TASK_RUNNING状态垄断CPU而不发生切换，一般情况下是进程<code>关抢占</code>或<code>关中断</code>后长时候执行任务、死循环，此时往往会导致多CPU间互锁，整个系统无法正常调度，导致喂狗线程无法执行，无法喂狗而最终看门狗复位的重启。该问题多为原子操作，spinlock等CPU间并发操作处理不当造成。</p>
<p>内核R状态死锁检测机制就是<code>lockdep机制</code>，入口即是lockup_detector_init函数</p>
</li>
</ul>
<h2 id="lockdep"><a href="#lockdep" class="headerlink" title="lockdep"></a>lockdep</h2><p>死锁:指两个或多个进程因争夺资源而造成的互相等待的现象。</p>
<p>常见的死锁有如下两种：</p>
<ul>
<li><code>递归死锁</code>：中断等延迟操作中使用了锁，和外面的锁构成了递归死锁。</li>
<li><code>AB-BA死锁</code>：多个锁因处理不当而引发死锁，多个内核路径上的所处理顺序不一致也会导致死锁。</li>
</ul>
<h2 id="Runtime-locking-correctness-validator（运行时锁的正确性验证器）"><a href="#Runtime-locking-correctness-validator（运行时锁的正确性验证器）" class="headerlink" title="Runtime locking correctness validator（运行时锁的正确性验证器）"></a>Runtime locking correctness validator（运行时锁的正确性验证器）</h2><blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cua2VybmVsLm9yZy9kb2MvaHRtbC9sYXRlc3QvbG9ja2luZy9sb2NrZGVwLWRlc2lnbi5odG1s">https://www.kernel.org/doc/html/latest/locking/lockdep-design.html<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<h2 id="实际示例"><a href="#实际示例" class="headerlink" title="实际示例"></a>实际示例</h2><p>在ioctl调用的函数路径中的__snd_pcm_lib_xfer接口函数中使用了spinlock锁，而在其接口的更下一级接口中使用了msleep，导致锁的状态不一致。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># arecord -D hw:3,0 -d 5 -r 48000 -f S16_LE -c 2 -t wav /tmp/aaa.wav</span><br><span class="line">Recording WAVE &#x27;/tmp/aaa.wav&#x27; : Signed 16 bit Little Endian, Rate 48000 Hz, Stereo</span><br><span class="line">[   41.781083]</span><br><span class="line">[   41.782590] ================================</span><br><span class="line">[   41.786859] WARNING: inconsistent lock state</span><br><span class="line">[   41.791131] 5.4.197-00339-g5ce0e26a142d-dirty #80 Not tainted</span><br><span class="line">[   41.796875] --------------------------------</span><br><span class="line">[   41.801145] inconsistent &#123;SOFTIRQ-ON-W&#125; -&gt; &#123;IN-SOFTIRQ-W&#125; usage.</span><br><span class="line">[   41.807152] swapper/0/0 [HC0[0]:SC1[1]:HE0:SE0] takes:</span><br><span class="line">[   41.812290] ffffff801ece85a0 (&amp;(&amp;group-&gt;lock)-&gt;rlock)&#123;+.?.&#125;, at: _snd_pcm_stream_lock_irqsave+0x4c/0x50</span><br><span class="line">[   41.821696] &#123;SOFTIRQ-ON-W&#125; state was registered at:</span><br><span class="line">[   41.826581]   lockdep_hardirqs_on+0x198/0x1a8</span><br><span class="line">[   41.830943]   trace_hardirqs_on+0x78/0x88</span><br><span class="line">[   41.834957]   _raw_spin_unlock_irq+0x44/0x54</span><br><span class="line">[   41.839229]   finish_task_switch+0x130/0x1b8</span><br><span class="line">[   41.843501]   __schedule+0x534/0x674</span><br><span class="line">[   41.847078]   schedule+0x74/0x98</span><br><span class="line">[   41.850309]   schedule_timeout+0xd4/0xf4</span><br><span class="line">[   41.854234]   schedule_timeout_uninterruptible+0x30/0x3c</span><br><span class="line">[   41.859549]   msleep+0x3c/0x40</span><br><span class="line">[   41.862610]   es8311_pcm_trigger+0x54/0x68</span><br><span class="line">[   41.866708]   snd_soc_dai_trigger+0x48/0x60</span><br><span class="line">[   41.870894]   soc_pcm_trigger+0xbc/0xe8</span><br><span class="line">[   41.874733]   snd_pcm_do_start+0x3c/0x50</span><br><span class="line">[   41.878658]   snd_pcm_action_single+0x50/0x88</span><br><span class="line">[   41.883017]   snd_pcm_action+0x80/0x84</span><br><span class="line">[   41.886768]   snd_pcm_start+0x34/0x40</span><br><span class="line">[   41.890434]   __snd_pcm_lib_xfer+0x1a4/0x618</span><br><span class="line">[   41.894705]   snd_pcm_common_ioctl+0xa88/0xbd8</span><br><span class="line">[   41.899149]   snd_pcm_ioctl+0x4c/0x68</span><br><span class="line">[   41.902815]   vfs_ioctl+0x5c/0x6c</span><br><span class="line">[   41.906132]   do_vfs_ioctl+0xc0/0x6d8</span><br><span class="line">[   41.909796]   ksys_ioctl+0x54/0x84</span><br><span class="line">[   41.913199]   __arm64_sys_ioctl+0x2c/0x60</span><br><span class="line">[   41.917212]   el0_svc_common.constprop.0+0xac/0x140</span><br><span class="line">[   41.922090]   el0_svc_handler+0x94/0xa0</span><br><span class="line">[   41.925928]   el0_svc+0x8/0x640</span><br><span class="line">[   41.929070] irq event stamp: 109041</span><br><span class="line">[   41.932563] hardirqs last  enabled at (109040): [&lt;ffffffc010a5874c&gt;] _raw_spin_unlock_irqrestore+0x74/0x80</span><br><span class="line">[   41.942216] hardirqs last disabled at (109041): [&lt;ffffffc010a58420&gt;] _raw_spin_lock_irqsave+0x30/0x74</span><br><span class="line">[   41.951437] softirqs last  enabled at (109034): [&lt;ffffffc0100b6da4&gt;] _local_bh_enable+0x30/0x38</span><br><span class="line">[   41.960135] softirqs last disabled at (109035): [&lt;ffffffc0100b7570&gt;] irq_exit+0xac/0x10c</span><br><span class="line">[   41.968222]</span><br><span class="line">[   41.968222] other info that might help us debug this:</span><br><span class="line">[   41.974747]  Possible unsafe locking scenario:</span><br><span class="line">[   41.974747]</span><br><span class="line">[   41.980664]        CPU0</span><br><span class="line">[   41.983110]        ----</span><br><span class="line">[   41.985555]   lock(&amp;(&amp;group-&gt;lock)-&gt;rlock);</span><br><span class="line">[   41.989740]   &lt;Interrupt&gt;</span><br><span class="line">[   41.992360]     lock(&amp;(&amp;group-&gt;lock)-&gt;rlock);</span><br><span class="line">[   41.996718]</span><br><span class="line">[   41.996718]  *** DEADLOCK ***</span><br><span class="line">[   41.996718]</span><br><span class="line">[   42.002628] no locks held by swapper/0/0.</span><br><span class="line">[   42.006636]</span><br><span class="line">[   42.006636] stack backtrace:</span><br><span class="line">[   42.010996] CPU: 0 PID: 0 Comm: swapper/0 Not tainted 5.4.197-00339-g5ce0e26a142d-dirty #80</span><br><span class="line">[   42.019343] Hardware name: Van_xum Tequila Evaluation Board (DT)</span><br><span class="line">[   42.025261] Call trace:</span><br><span class="line">[   42.027714]  dump_backtrace+0x0/0x164</span><br><span class="line">[   42.031377]  show_stack+0x28/0x34</span><br><span class="line">[   42.034695]  dump_stack+0xd0/0x134</span><br><span class="line">[   42.038100]  print_usage_bug+0x1b0/0x1c8</span><br><span class="line">[   42.042024]  mark_lock+0x1b8/0x278</span><br><span class="line">[   42.045428]  __lock_acquire+0x360/0xda8</span><br><span class="line">[   42.049265]  lock_acquire+0x164/0x194</span><br><span class="line">[   42.052930]  _raw_spin_lock_irqsave+0x58/0x74</span><br><span class="line">[   42.057291]  _snd_pcm_stream_lock_irqsave+0x4c/0x50</span><br><span class="line">[   42.062170]  snd_pcm_period_elapsed+0x2c/0xa8</span><br><span class="line">[   42.066529]  dmaengine_pcm_dma_complete+0x6c/0x78</span><br><span class="line">[   42.071236]  dmaengine_desc_callback_invoke.constprop.0+0x5c/0x68</span><br><span class="line">[   42.077330]  dw_dma_tasklet+0x1b0/0x420</span><br><span class="line">[   42.081169]  tasklet_action_common.constprop.0+0xb8/0x11c</span><br><span class="line">[   42.086569]  tasklet_action+0x34/0x40</span><br><span class="line">[   42.090232]  __do_softirq+0x2d4/0x3f4</span><br><span class="line">[   42.093896]  irq_exit+0xac/0x10c</span><br><span class="line">[   42.097128]  __handle_domain_irq+0x7c/0xa8</span><br><span class="line">[   42.101226]  gic_handle_irq+0x84/0xc8</span><br><span class="line">[   42.104890]  el1_irq+0xbc/0x140</span><br><span class="line">[   42.108034]  arch_cpu_idle+0x44/0x64</span><br><span class="line">[   42.111613]  default_idle_call+0x34/0x38</span><br><span class="line">[   42.115538]  do_idle+0x144/0x27c</span><br><span class="line">[   42.118770]  cpu_startup_entry+0x2c/0x48</span><br><span class="line">[   42.122694]  rest_init+0x170/0x180</span><br><span class="line">[   42.126100]  arch_call_rest_init+0x18/0x20</span><br><span class="line">[   42.130199]  start_kernel+0x458/0x490</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">^CAborted by signal Interrupt...</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cua2VybmVsLm9yZy9kb2MvaHRtbC9sYXRlc3QvbG9ja2luZy9pbmRleC5odG1s">Documentation&#x2F;locking&#x2F;<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL2tlcm5lbC5tZWl6dS5jb20vbGludXgtZGVhZC1sb2NrLWRldGVjdC1sb2NrZGVwLmh0bWw=">Linux 死锁检测模块 Lockdep 简介<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>Linux内核</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>sync</tag>
        <tag>死锁</tag>
        <tag>进程</tag>
      </tags>
  </entry>
  <entry>
    <title>Socket Buffer</title>
    <url>/post/21941.html</url>
    <content><![CDATA[<span id="more"></span>
]]></content>
      <categories>
        <category>Linux内核</category>
      </categories>
      <tags>
        <tag>kernel</tag>
        <tag>socket</tag>
      </tags>
  </entry>
  <entry>
    <title>NUMA与PCI</title>
    <url>/post/13d4e2a6.html</url>
    <content><![CDATA[<p><img data-src="/images/2020/10/numa_pci_mapping.png" alt="NUMA PCI mapping"><br>NUMA与PCI之间的关系：</p>
<span id="more"></span>

<p>多物理CPU之间通过<code>QPI</code>总线进行通信</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">lspci -s 02:0.0 -vv</span></span><br><span class="line">02:00.0 VGA compatible controller: xxx [VGA controller])</span><br><span class="line">	Physical Slot: 2</span><br><span class="line">  ...</span><br><span class="line">	Latency: 0</span><br><span class="line">	Interrupt: pin A routed to IRQ 240</span><br><span class="line">	NUMA node: 0         #不同的pci卡槽对应的node节点可能不同，与其绑定的CPU相关</span><br></pre></td></tr></table></figure>

<p>在不同的NUMA node下的pci设备进行内存读写时速度与响应时间存在差异，相同的NUMA node节点下的设备与内存的读写效果会更好。</p>
<p>例如，如果客户机被固定在NUMA节点0-1上，但是其PCI设备中的一个隶属于节点2，那么节点之间的数据传输将花费一段时间。</p>
<p><code>lstopo</code>命令可以查看系统的硬件拓扑结构</p>
<h2 id="安装lstopo命令"><a href="#安装lstopo命令" class="headerlink" title="安装lstopo命令"></a>安装lstopo命令</h2><ul>
<li>ubuntu<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install hwloc</span><br></pre></td></tr></table></figure></li>
<li>centos<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo yum install hwloc-gui</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p><img data-src="/images/2020/10/lstopo_test1.png" alt="lstopo my pc"></p>
<p><img data-src="/images/2020/10/lstopo_test2.png" alt="lstopo test"></p>
<h2 id="虚拟机中资源的最佳分布"><a href="#虚拟机中资源的最佳分布" class="headerlink" title="虚拟机中资源的最佳分布"></a>虚拟机中资源的最佳分布</h2><blockquote>
<p>虚拟机所使用的到的所有硬件资源尽可能的分布在同一个node节点之上，这样将提高设备的利用率和虚拟机性能</p>
</blockquote>
<p><img data-src="/images/2020/10/vm_resources_mapping.png" alt="VM Resources Mapping"></p>
<h2 id="CPU与内存吞吐量测试"><a href="#CPU与内存吞吐量测试" class="headerlink" title="CPU与内存吞吐量测试"></a>CPU与内存吞吐量测试</h2><blockquote>
<p>Intel处理器测试工具:<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL29wY20vcGNt">Processor Counter Monitor<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<ul>
<li>内存的读写速度</li>
<li>多物理CPU之间的QPI速度</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">pcm-202009]# </span><span class="language-bash"><span class="built_in">ls</span> ./pcm-*.x</span></span><br><span class="line">./pcm-core.x  ./pcm-latency.x  ./pcm-memory.x  ./pcm-msr.x   ./pcm-pcicfg.x  ./pcm-power.x  ./pcm-sensor-server.x  ./pcm-tsx.x</span><br><span class="line">./pcm-iio.x   ./pcm-lspci.x    ./pcm-mmio.x    ./pcm-numa.x  ./pcm-pcie.x    ./pcm-raw.x    ./pcm-sensor.x</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># ./pcm.x 20</span><br><span class="line"></span><br><span class="line"> Processor Counter Monitor  (2020-10-01 16:31:57 +0200 ID=f510546)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">IBRS and IBPB supported  : yes</span><br><span class="line">STIBP supported          : yes</span><br><span class="line">Spec arch caps supported : yes</span><br><span class="line">Number of physical cores: 32</span><br><span class="line">Number of logical cores: 64</span><br><span class="line">Number of online logical cores: 64</span><br><span class="line">Threads (logical cores) per physical core: 2</span><br><span class="line">Num sockets: 2</span><br><span class="line">Physical cores per socket: 16</span><br><span class="line">Core PMU (perfmon) version: 4</span><br><span class="line">Number of core PMU generic (programmable) counters: 4</span><br><span class="line">Width of generic (programmable) counters: 48 bits</span><br><span class="line">Number of core PMU fixed counters: 3</span><br><span class="line">Width of fixed counters: 48 bits</span><br><span class="line">Nominal core frequency: 2300000000 Hz</span><br><span class="line">IBRS enabled in the kernel   : no</span><br><span class="line">STIBP enabled in the kernel  : no</span><br><span class="line">The processor is not susceptible to Rogue Data Cache Load: yes</span><br><span class="line">The processor supports enhanced IBRS                     : yes</span><br><span class="line">Package thermal spec power: 125 Watt; Package minimum power: 68 Watt; Package maximum power: 307 Watt;</span><br><span class="line">Socket 0: 2 memory controllers detected with total number of 6 channels. 3 QPI ports detected. 2 M2M (mesh to memory) blocks detected. 0 Home Agents detected. 3 M3UPI blocks detected.</span><br><span class="line">Socket 1: 2 memory controllers detected with total number of 6 channels. 3 QPI ports detected. 2 M2M (mesh to memory) blocks detected. 0 Home Agents detected. 3 M3UPI blocks detected.</span><br><span class="line">Delay: 20</span><br><span class="line">Disabling NMI watchdog since it consumes one hw-PMU counter.</span><br><span class="line">Trying to use Linux perf events...</span><br><span class="line">Successfully programmed on-core PMU using Linux perf</span><br><span class="line">Link 3 is disabled</span><br><span class="line">Link 3 is disabled</span><br><span class="line">Socket 0</span><br><span class="line">Max QPI link 0 speed: 23.3 GBytes/second (10.4 GT/second)</span><br><span class="line">Max QPI link 1 speed: 23.3 GBytes/second (10.4 GT/second)</span><br><span class="line">Socket 1</span><br><span class="line">Max QPI link 0 speed: 23.3 GBytes/second (10.4 GT/second)</span><br><span class="line">Max QPI link 1 speed: 23.3 GBytes/second (10.4 GT/second)</span><br><span class="line"></span><br><span class="line">Detected Intel(R) Xeon(R) Gold 5218 CPU @ 2.30GHz &quot;Intel(r) microarchitecture codename Cascade Lake-SP&quot; stepping 7 microcode level 0x5002f01</span><br><span class="line"></span><br><span class="line"> EXEC  : instructions per nominal CPU cycle</span><br><span class="line"> IPC   : instructions per CPU cycle</span><br><span class="line"> FREQ  : relation to nominal CPU frequency=&#x27;unhalted clock ticks&#x27;/&#x27;invariant timer ticks&#x27; (includes Intel Turbo Boost)</span><br><span class="line"> AFREQ : relation to nominal CPU frequency while in active state (not in power-saving C state)=&#x27;unhalted clock ticks&#x27;/&#x27;invariant timer ticks while in C0-state&#x27;  (includes Intel Turbo Boost)</span><br><span class="line"> L3MISS: L3 (read) cache misses</span><br><span class="line"> L2MISS: L2 (read) cache misses (including other core&#x27;s L2 cache *hits*)</span><br><span class="line"> L3HIT : L3 (read) cache hit ratio (0.00-1.00)</span><br><span class="line"> L2HIT : L2 cache hit ratio (0.00-1.00)</span><br><span class="line"> L3MPI : number of L3 (read) cache misses per instruction</span><br><span class="line"> L2MPI : number of L2 (read) cache misses per instruction</span><br><span class="line"> READ  : bytes read from main memory controller (in GBytes)</span><br><span class="line"> WRITE : bytes written to main memory controller (in GBytes)</span><br><span class="line"> LOCAL : ratio of local memory requests to memory controller in %</span><br><span class="line">LLCRDMISSLAT: average latency of last level cache miss for reads and prefetches (in ns)</span><br><span class="line"> PMM RD : bytes read from PMM memory (in GBytes)</span><br><span class="line"> PMM WR : bytes written to PMM memory (in GBytes)</span><br><span class="line"> L3OCC : L3 occupancy (in KBytes)</span><br><span class="line"> TEMP  : Temperature reading in 1 degree Celsius relative to the TjMax temperature (thermal headroom): 0 corresponds to the max temperature</span><br><span class="line"> energy: Energy in Joules</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> Core (SKT) | EXEC | IPC  | FREQ  | AFREQ | L3MISS | L2MISS | L3HIT | L2HIT | L3MPI | L2MPI |   L3OCC | TEMP</span><br><span class="line"></span><br><span class="line">   0    0     0.02   0.50   0.03    1.26     926 K   9825 K    0.89    0.42    0.00    0.01      128     43</span><br><span class="line">   1    1     0.03   0.67   0.05    0.84    4930 K   6272 K    0.14    0.63    0.00    0.00      320     55</span><br><span class="line">   2    0     0.22   0.81   0.28    1.05    5539 K     12 M    0.53    0.79    0.00    0.00     1472     54</span><br><span class="line">   3    1     0.00   0.29   0.00    1.33      23 K     44 K    0.38    0.86    0.00    0.00        0     47</span><br><span class="line">   4    0     0.14   0.84   0.17    0.96    3001 K   7083 K    0.53    0.79    0.00    0.00      640     49</span><br><span class="line">   5    1     0.01   0.53   0.03    0.99     129 K   2453 K    0.93    0.61    0.00    0.00      256     61</span><br><span class="line">   6    0     0.21   0.85   0.25    1.04    5115 K     11 M    0.50    0.80    0.00    0.00      384     54</span><br><span class="line">   7    1     0.03   0.55   0.05    1.10     273 K   4573 K    0.93    0.60    0.00    0.00     1344     57</span><br><span class="line">   8    0     0.21   0.80   0.26    1.06    5361 K     11 M    0.49    0.80    0.00    0.00     1216     54</span><br><span class="line">   9    1     0.09   0.57   0.16    1.32     769 K     14 M    0.94    0.65    0.00    0.00     2048     57</span><br><span class="line">  10    0     0.21   0.74   0.29    1.26    7000 K     14 M    0.48    0.79    0.00    0.00      256     52</span><br><span class="line">  11    1     0.02   0.44   0.04    1.30    1072 K   2780 K    0.36    0.62    0.00    0.00        0     54</span><br><span class="line">  12    0     0.20   0.84   0.23    1.08    4916 K     11 M    0.50    0.78    0.00    0.00      640     53</span><br><span class="line">  13    1     0.01   0.55   0.03    1.06     158 K   2583 K    0.92    0.61    0.00    0.00      192     57</span><br><span class="line">  14    0     0.14   0.70   0.20    1.26    2654 K   7546 K    0.58    0.81    0.00    0.00     1664     52</span><br><span class="line">  15    1     0.00   0.52   0.01    0.78      54 K    897 K    0.78    0.57    0.00    0.00        0     54</span><br><span class="line">  16    0     0.11   0.74   0.14    0.96    2978 K   7413 K    0.54    0.78    0.00    0.00     3328     53</span><br><span class="line">  17    1     0.00   0.50   0.01    0.80      38 K    610 K    0.79    0.57    0.00    0.00        0     59</span><br><span class="line">  18    0     0.15   0.69   0.22    1.00    5981 K     12 M    0.45    0.78    0.00    0.00     2368     53</span><br><span class="line">  19    1     0.13   2.30   0.06    1.07     186 K    952 K    0.79    0.53    0.00    0.00      128     58</span><br><span class="line">  20    0     0.11   0.74   0.14    0.87    5408 K     10 M    0.43    0.74    0.00    0.00     4928     52</span><br><span class="line">  21    1     0.01   0.44   0.03    1.05    1742 K   2476 K    0.22    0.74    0.00    0.00      448     55</span><br><span class="line">  22    0     0.20   0.84   0.23    0.98    4198 K   9626 K    0.51    0.81    0.00    0.00      576     55</span><br><span class="line">  23    1     0.00   0.87   0.00    0.52     191 K    316 K    0.37    0.59    0.00    0.00      192     60</span><br><span class="line">  24    0     0.15   0.86   0.17    1.05    2357 K   6482 K    0.58    0.80    0.00    0.00      384     52</span><br><span class="line">  25    1     0.01   1.18   0.00    0.50     123 K    275 K    0.49    0.82    0.00    0.00        0     59</span><br><span class="line">  26    0     0.12   0.76   0.16    1.02    4988 K     10 M    0.43    0.77    0.00    0.00      704     52</span><br><span class="line">  27    1     0.01   1.06   0.01    0.69     125 K   1009 K    0.87    0.63    0.00    0.00        0     55</span><br><span class="line">  28    0     0.15   0.83   0.18    0.99    4284 K   9017 K    0.46    0.79    0.00    0.00     1792     53</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9mYXRtaW4uY29tLzIwMTYvMDYvMTAvbnVtYS1ub2RlLXRvLXBjaS1zbG90LW1hcHBpbmctaW4tcmVkLWhhdC1lbnRlcnBpc2UtbGludXgv">NUMA Node to PCI Slot Mapping in Red Hat Enterpise Linux<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9hY2Nlc3MucmVkaGF0LmNvbS9kb2N1bWVudGF0aW9uL3poLWNuL3JlZF9oYXRfZW50ZXJwcmlzZV9saW51eC83L2h0bWwtc2luZ2xlL3ZpcnR1YWxpemF0aW9uX3R1bmluZ19hbmRfb3B0aW1pemF0aW9uX2d1aWRlL2luZGV4I3NlY3QtVmlydHVhbGl6YXRpb25fVHVuaW5nX09wdGltaXphdGlvbl9HdWlkZS1OVU1BLUF1dG9fTlVNQV9CYWxhbmNpbmc=">虚拟化调试和优化指南<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0x1Y2FDYW5hbGkvTWlzY2VsbGFuZW91cy9ibG9iL21hc3Rlci9TcGFya19Ob3Rlcy9Ub29sc19MaW51eF9NZW1vcnlfUGVyZl9NZWFzdXJlLm1k">Notes and tools for measuring CPU-to-memory throughput in Linux<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9mcmFua2Rlbm5lbWFuLm5sLzIwMjAvMDEvMzAvbWFjaGluZS1sZWFybmluZy13b3JrbG9hZC1hbmQtZ3BncHUtbnVtYS1ub2RlLWxvY2FsaXR5Lw==">Machine Learning Workload and GPGPU NUMA Node Locality<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>Linux内核</category>
      </categories>
      <tags>
        <tag>numa</tag>
        <tag>pci</tag>
      </tags>
  </entry>
  <entry>
    <title>printk_ratelimit</title>
    <url>/post/59845.html</url>
    <content><![CDATA[<p>在Linux内核代码里当需要限制<code>printk</code>打印频率时会用到<code>__ratelimit</code>或<code>printk_ratelimit</code>（封装了__ratelimit）</p>
<span id="more"></span>

<p><code>printk_ratelimit</code>默认允许在<code>5s</code>内最多打印<code>10</code>条消息出来</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash"><span class="built_in">cat</span> /proc/sys/kernel/printk_ratelimit</span></span><br><span class="line">5</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash"><span class="built_in">cat</span> /proc/sys/kernel/printk_ratelimit_burst</span></span><br><span class="line">10</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (printk_ratelimit()) &#123;</span><br><span class="line">    dev_err(adev-&gt;dev, <span class="string">&quot;GPU fault detected: %d 0x%08x\n&quot;</span>,</span><br><span class="line">        entry-&gt;src_id, entry-&gt;src_data[<span class="number">0</span>]);</span><br><span class="line">    dev_err(adev-&gt;dev, <span class="string">&quot;  VM_CONTEXT1_PROTECTION_FAULT_ADDR   0x%08X\n&quot;</span>,</span><br><span class="line">        addr);</span><br><span class="line">    dev_err(adev-&gt;dev, <span class="string">&quot;  VM_CONTEXT1_PROTECTION_FAULT_STATUS 0x%08X\n&quot;</span>,</span><br><span class="line">        status);</span><br><span class="line">    gmc_v8_0_vm_decode_fault(adev, status, addr, mc_client);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xra2V5ODAvYXJ0aWNsZS9kZXRhaWxzLzQ1MTkwMDk1">限制printk打印频率函数printk_ratelimit<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>Linux内核</category>
      </categories>
      <tags>
        <tag>printk</tag>
      </tags>
  </entry>
  <entry>
    <title>printk打印输出级别—15</title>
    <url>/post/aabf231e.html</url>
    <content><![CDATA[<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># cat /proc/sys/kernel/printk</span><br><span class="line">15      4       1       7</span><br></pre></td></tr></table></figure>
<p>在正常的printk日志输出级别中只有<code>0～7</code>，为何会出现<code>15</code>？</p>
<blockquote>
<p>原因是内核lock的状态检测到异常后，在进行相关锁状态信息输出前，将console的level配置成<code>15</code></p>
</blockquote>
<span id="more"></span>

<h2 id="printk级别"><a href="#printk级别" class="headerlink" title="printk级别"></a>printk级别</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int console_printk[4] = &#123;</span><br><span class="line">    CONSOLE_LOGLEVEL_DEFAULT,   /* console_loglevel */</span><br><span class="line">    MESSAGE_LOGLEVEL_DEFAULT,   /* default_message_loglevel */</span><br><span class="line">    CONSOLE_LOGLEVEL_MIN,       /* minimum_console_loglevel */</span><br><span class="line">    CONSOLE_LOGLEVEL_DEFAULT,   /* default_console_loglevel */</span><br><span class="line">&#125;;</span><br><span class="line">EXPORT_SYMBOL_GPL(console_printk);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>kernel&#x2F;printk&#x2F;printk.c</p>
</blockquote>
<p>出现异常时调整的是<code>console_loglevel</code>，其默认值为:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define CONSOLE_LOGLEVEL_DEFAULT CONFIG_CONSOLE_LOGLEVEL_DEFAULT</span><br><span class="line"></span><br><span class="line">CONFIG_CONSOLE_LOGLEVEL_DEFAULT=7 //内核配置</span><br></pre></td></tr></table></figure>

<p>kernel日志等级：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* integer equivalents of KERN_&lt;LEVEL&gt; */</span><br><span class="line">#define LOGLEVEL_SCHED      -2  /* Deferred messages from sched code</span><br><span class="line">                     * are set to this special level */</span><br><span class="line">#define LOGLEVEL_DEFAULT    -1  /* default (or last) loglevel */</span><br><span class="line">#define LOGLEVEL_EMERG      0   /* system is unusable */</span><br><span class="line">#define LOGLEVEL_ALERT      1   /* action must be taken immediately */</span><br><span class="line">#define LOGLEVEL_CRIT       2   /* critical conditions */</span><br><span class="line">#define LOGLEVEL_ERR        3   /* error conditions */</span><br><span class="line">#define LOGLEVEL_WARNING    4   /* warning conditions */</span><br><span class="line">#define LOGLEVEL_NOTICE     5   /* normal but significant condition */</span><br><span class="line">#define LOGLEVEL_INFO       6   /* informational */</span><br><span class="line">#define LOGLEVEL_DEBUG      7   /* debug-level messages */</span><br></pre></td></tr></table></figure>
<blockquote>
<p>include&#x2F;linux&#x2F;kern_levels.h</p>
</blockquote>
<h2 id="console-loglevel"><a href="#console-loglevel" class="headerlink" title="console_loglevel"></a>console_loglevel</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define console_loglevel (console_printk[0])</span><br></pre></td></tr></table></figure>

<p>调整接口：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define CONSOLE_LOGLEVEL_MOTORMOUTH 15  /* You can&#x27;t shut this one up */</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static inline void console_verbose(void)</span><br><span class="line">&#123;</span><br><span class="line">    if (console_loglevel)</span><br><span class="line">        console_loglevel = CONSOLE_LOGLEVEL_MOTORMOUTH;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>include&#x2F;linux&#x2F;printk.h</p>
</blockquote>
<p>也就是通过<code>console_verbose</code>接口，将console等级调整为<code>15</code>.</p>
<h2 id="console-verbose的调用流程"><a href="#console-verbose的调用流程" class="headerlink" title="console_verbose的调用流程"></a>console_verbose的调用流程</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">print_unlock_imbalance_bug</span><br><span class="line">  \-&gt; debug_locks_off</span><br><span class="line">    \-&gt; console_verbose //打开console全部输出，级别15 lib/debug_locks.c</span><br><span class="line">  \-&gt; dump_stack</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux内核</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>printk</tag>
      </tags>
  </entry>
  <entry>
    <title>IPI通信（SMP）</title>
    <url>/post/60164.html</url>
    <content><![CDATA[<blockquote>
<p>IPI(Interrupt-Procecesorr Interrupt): 处理中间的中断</p>
</blockquote>
<p>主要应用是一个处理器让另一个处理器做特定的事情（function和sched）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">              +---------------------------+-+</span><br><span class="line">system boot   | request_percpu_irq（）      +</span><br><span class="line">              | mailbox irq handle          +</span><br><span class="line">              +--+-----------------------+--+</span><br><span class="line">                 |                       |</span><br><span class="line">                 |                       |</span><br><span class="line">              +--v--+                +---v-+</span><br><span class="line">              | CPU0|                &gt; CPU1|</span><br><span class="line">              +--+--+                +----++</span><br><span class="line">                 |                        |</span><br><span class="line">            +----+----+             +-----+-----+</span><br><span class="line">            |mailbox0 |          +--&gt;mailbox1   |</span><br><span class="line">            +---------+          |  +-----------+</span><br><span class="line">                                 |</span><br><span class="line">                 +---------------+        |</span><br><span class="line">system run    A send IPI CPU1             |</span><br><span class="line">              write mailbox1              |</span><br><span class="line">                 |                        |</span><br><span class="line">                 |                  +-----v-----------------+---+</span><br><span class="line">          +------+----+             | 1. 读取mailbox中的action  +</span><br><span class="line">          |  Task A   |             | 2. 通过action判断IPI类型  +</span><br><span class="line">          |           |             | 3. 进行function和sched处理+</span><br><span class="line">          +-----------+             |                           +</span><br><span class="line">                                    +---------------------------+</span><br></pre></td></tr></table></figure>

<p>在多核处理器中，每一个CPU核有一个<code>mailbox</code>(相当于邮箱)，如果需要进行IPI通信时，其主要通过IPI的中断实现。假设CPU0需要给CPU1发送一个<code>action</code>(<code>action</code>I的类型：<code>SMP_CALL_FUNCTION</code>,<code>SMP_RESCHEDULE_YOURSELF</code>等)时, 只需要CPU0向CPU1的<code>mailbox</code>中写于<code>action</code>的id（相当于信），此时CPU1将产生一个IPI中断（表明收到信），<code>mailbox</code>的中断处理程序将读取<code>mailbox</code>（相当于看信）中的<code>action</code>，判断<code>action</code>的类型进行相应的处理。</p>
<span id="more"></span>

<p>MIPS架构下的IPI通信</p>
<blockquote>
<ol>
<li>关闭中断后还会发送IPI</li>
</ol>
</blockquote>
<h2 id="MIPS接口"><a href="#MIPS接口" class="headerlink" title="MIPS接口"></a>MIPS接口</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">plat_smp_ops</span> &#123;</span></span><br><span class="line">	<span class="type">void</span> (*send_ipi_single)(<span class="type">int</span> cpu, <span class="type">unsigned</span> <span class="type">int</span> action);</span><br><span class="line">	<span class="type">void</span> (*send_ipi_mask)(<span class="type">const</span> <span class="keyword">struct</span> cpumask *mask, <span class="type">unsigned</span> <span class="type">int</span> action);</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>IPI通信就是多个处理器之间的<code>交流</code>。<br><code>send_ipi_single</code>： 一对一聊天<br><code>send_ipi_mask</code> : 群发，mask表示群发的成员（CPU）</p>
</blockquote>
<h2 id="action类型"><a href="#action类型" class="headerlink" title="action类型"></a>action类型</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SMP_RESCHEDULE_YOURSELF 0x1 <span class="comment">/* XXX braindead */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SMP_CALL_FUNCTION   0x2</span></span><br><span class="line"><span class="comment">/* Octeon - Tell another core to flush its icache */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SMP_ICACHE_FLUSH    0x4</span></span><br><span class="line"><span class="comment">/* Used by kexec crashdump to save all cpu&#x27;s state */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SMP_DUMP        0x8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SMP_IPI_TIMER       0xC</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>file: arch&#x2F;mips&#x2F;include&#x2F;asm&#x2F;smp.h</p>
</blockquote>
<ol>
<li>不同的action(活动)何时将产生？</li>
<li>各自都有什么作用？</li>
</ol>
<h3 id="SMP-RESCHEDULE-YOURSELF"><a href="#SMP-RESCHEDULE-YOURSELF" class="headerlink" title="SMP_RESCHEDULE_YOURSELF"></a>SMP_RESCHEDULE_YOURSELF</h3><blockquote>
<p><code>SMP_RESCHEDULE_YOURSELF</code>将直接调用<code>scheduler_ipi</code>.将任务插入目标CPU的运行队列。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * this function sends a &#x27;reschedule&#x27; IPI to another CPU.</span></span><br><span class="line"><span class="comment"> * it goes straight through and wastes no time serializing</span></span><br><span class="line"><span class="comment"> * anything. Worst case is that we lose a reschedule ...</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">smp_send_reschedule</span><span class="params">(<span class="type">int</span> cpu)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">plat_smp_ops</span> *<span class="title">mp_ops</span>;</span> <span class="comment">/* private */</span></span><br><span class="line"></span><br><span class="line">	mp_ops-&gt;send_ipi_single(cpu, SMP_RESCHEDULE_YOURSELF);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>file: arch&#x2F;mips&#x2F;include&#x2F;asm&#x2F;smp.h</p>
</blockquote>
<h3 id="SMP-CALL-FUNCTION"><a href="#SMP-CALL-FUNCTION" class="headerlink" title="SMP_CALL_FUNCTION"></a>SMP_CALL_FUNCTION</h3><blockquote>
<p><code>SMP_CALL_FUNCTION</code>:将特定的函数在目标CPU上运行</p>
</blockquote>
<ul>
<li>内核回调接口：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">arch_send_call_function_single_ipi</span><span class="params">(<span class="type">int</span> cpu)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">plat_smp_ops</span> *<span class="title">mp_ops</span>;</span> <span class="comment">/* private */</span></span><br><span class="line"></span><br><span class="line">	mp_ops-&gt;send_ipi_mask(&amp;cpumask_of_cpu(cpu), SMP_CALL_FUNCTION);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">arch_send_call_function_ipi_mask</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> cpumask *mask)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">plat_smp_ops</span> *<span class="title">mp_ops</span>;</span> <span class="comment">/* private */</span></span><br><span class="line"></span><br><span class="line">	mp_ops-&gt;send_ipi_mask(mask, SMP_CALL_FUNCTION);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>file: arch&#x2F;mips&#x2F;include&#x2F;asm&#x2F;smp.h</p>
</blockquote>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * smp_call_function_single - Run a function on a specific CPU</span></span><br><span class="line"><span class="comment"> * @func: The function to run. This must be fast and non-blocking.</span></span><br><span class="line"><span class="comment"> * @info: An arbitrary pointer to pass to the function.</span></span><br><span class="line"><span class="comment"> * @wait: If true, wait until function has completed on other CPUs.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Returns 0 on success, else a negative status code.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">smp_call_function_single</span><br><span class="line">	\-&gt;generic_exec_single</span><br><span class="line">		\-&gt;arch_send_call_function_single_ipi</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * smp_call_function_many(): Run a function on a set of other CPUs.</span></span><br><span class="line"><span class="comment"> * @mask: The set of cpus to run on (only runs on online subset).</span></span><br><span class="line"><span class="comment"> * @func: The function to run. This must be fast and non-blocking.</span></span><br><span class="line"><span class="comment"> * @info: An arbitrary pointer to pass to the function.</span></span><br><span class="line"><span class="comment"> * @wait: If true, wait (atomically) until function has completed</span></span><br><span class="line"><span class="comment"> *        on other CPUs.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If @wait is true, then returns once @func has returned.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * You must not call this function with disabled interrupts or from a</span></span><br><span class="line"><span class="comment"> * hardware interrupt handler or from a bottom half handler. Preemption</span></span><br><span class="line"><span class="comment"> * must be disabled when calling this function.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">smp_call_function_many</span><br><span class="line">	\-&gt;arch_send_call_function_ipi_mask</span><br></pre></td></tr></table></figure>
<blockquote>
<p>file: kernel&#x2F;smp.c</p>
</blockquote>
<h2 id="刷新TLB"><a href="#刷新TLB" class="headerlink" title="刷新TLB"></a>刷新TLB</h2><p>多核进行TLB的同步？</p>
]]></content>
      <categories>
        <category>Linux内核</category>
      </categories>
      <tags>
        <tag>ipi</tag>
        <tag>smp</tag>
      </tags>
  </entry>
  <entry>
    <title>Ticket spinlocks</title>
    <url>/post/50889.html</url>
    <content><![CDATA[<p><code>Ticket Spinlock</code>思路：类似银行办业务，先取一个号排队，然后等待叫号叫到自己</p>
<span id="more"></span>

<p>在x86架构中，在2.6.24内核中，自旋锁由整数值表示，其值为1表示锁是可用的。 <code>spin_lock()</code>代码通过递减值（以系统范围的原子方式），然后查看结果是否为0; 如果为0，表示锁已成功获得。 相反，如果递减的结果是负数，则<code>spin_lock()</code>知道该锁是由其他人拥有的。所以它忙着等待（“自旋”）进入一个循环，直到锁的值变为正数; 然后它回到开始并再次尝试。</p>
<p>代码一旦执行到关键部分，锁的所有者通过将其设置为1来释放锁。</p>
<blockquote>
<p>这种方法存在一个缺点：这是<code>不公平</code>。当自旋等待获取锁的对象增多，一旦释放锁，第一个能够减少锁定的处理器将成为新的所有者。 没有办法确保等待时间最长的处理器先获得锁定; 实际上，刚刚释放锁的CPU可以凭借拥有该缓存行而具有优势，快速重新获取锁。</p>
</blockquote>
<h2 id="ticket-spinlocks"><a href="#ticket-spinlocks" class="headerlink" title="ticket spinlocks"></a>ticket spinlocks</h2><blockquote>
<p>ARM平台为例，Linux4.4</p>
</blockquote>
<p>一个自旋锁变成了<code>32位</code>数，分成两个部分：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		u32 slock;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> __<span class="title">raw_tickets</span> &#123;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __ARMEB__</span></span><br><span class="line">			u16 next;</span><br><span class="line">			u16 owner;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">			u16 owner;</span><br><span class="line">			u16 next;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">		&#125; tickets;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125; <span class="type">arch_spinlock_t</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>file: arch&#x2F;arm&#x2F;include&#x2F;asm&#x2F;spinclok_types.h</p>
</blockquote>
<p><img data-src="/images/2019/04/spinlock_struct.png" alt="spinlock_struct"></p>
<p>每个半字可以被认为是一个票号。 如果你去过一家商店，客户拿纸票确保按照到货顺序送达，您可以将<code>next</code>字段视为分配器中下一张票的号码，而<code>owner</code>是在柜台上的<code>正在服务</code>显示中出现的号码。</p>
<p>因此，在新的方案中，锁的值被初始化（两个字段）为零。 spin_lock()开始记录锁的值，然后递增<code>next</code>字段(所有这些都在一个原子操作中)。 如果<code>next</code>（在增量之前）的值等于<code>owner</code>，则已获得锁并且可以继续工作。 否则处理器将自旋，等待<code>owner</code>增加到正确的值。 在这个方案中，释放锁是一个简单的增加<code>owner</code>的问题。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h3><table>
<thead>
<tr>
<th align="center">汇编指令</th>
<th align="left">解释</th>
<th align="left">示例</th>
</tr>
</thead>
<tbody><tr>
<td align="center">prfm</td>
<td align="left">Prefetch Memory (register)预取</td>
<td align="left"></td>
</tr>
<tr>
<td align="center">stxr</td>
<td align="left">赋值存储，并保存存储状态</td>
<td align="left">STXR <Ws>, <Wt>, [Xn{,#0}]，将Wt写入Xn中，并保存写入状态到Ws</td>
</tr>
<tr>
<td align="center">cbnz</td>
<td align="left">不等于0</td>
<td align="left"></td>
</tr>
<tr>
<td align="center">cbz</td>
<td align="left">等于0</td>
<td align="left"></td>
</tr>
<tr>
<td align="center">sevl</td>
<td align="left">Send Event Local是一个提示指令，它使事件在本地发出信号，而不需要将事件通知多处理器系统中的其他PE。 它可以启动一个以WFE指令开始的等待循环。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center">ldaxrh</td>
<td align="left">Load-Acquire Exclusive Register Halfword, 从存储器加载半字，对其进行零扩展并将其写入寄存器,</td>
<td align="left">LDAXRH <Wt>, [Xn{,#0}], 将Xn赋值给Wt</td>
</tr>
<tr>
<td align="center">staddlh</td>
<td align="left">Atomic add on halfword in memory</td>
<td align="left">STADDH <Ws>, [Xn]，Xn加Ws并保存到Xn</td>
</tr>
<tr>
<td align="center">ldadda</td>
<td align="left">Atomic add on word or doubleword in memory</td>
<td align="left"></td>
</tr>
</tbody></table>
<blockquote>
<ul>
<li>PE 指的是<code>Process Element</code>， 就是逻辑核心(logic core)，一个逻辑核心上可以跑一个线程</li>
<li>Load-Acquire&#x2F;Store-Release指令是ARMv8的特性，在执行load和store操作的时候顺便执行了memory barrier相关的操作, 如ldaxr，ldaxrh等指令</li>
</ul>
</blockquote>
<h3 id="spin-lock-init"><a href="#spin-lock-init" class="headerlink" title="spin_lock_init"></a>spin_lock_init</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> __ARCH_SPIN_LOCK_UNLOCKED	&#123; 0 , 0 &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> __raw_spin_lock_init(<span class="type">raw_spinlock_t</span> *lock, <span class="type">const</span> <span class="type">char</span> *name,</span><br><span class="line">			  <span class="keyword">struct</span> lock_class_key *key)</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEBUG_LOCK_ALLOC</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Make sure we are not reinitializing a held lock:</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	debug_check_no_locks_freed((<span class="type">void</span> *)lock, <span class="keyword">sizeof</span>(*lock));</span><br><span class="line">	lockdep_init_map(&amp;lock-&gt;dep_map, name, key, <span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="comment">//初始化，next=owner=0</span></span><br><span class="line">	lock-&gt;raw_lock = (<span class="type">arch_spinlock_t</span>)__ARCH_SPIN_LOCK_UNLOCKED;</span><br><span class="line">	lock-&gt;magic = SPINLOCK_MAGIC;</span><br><span class="line">	lock-&gt;owner = SPINLOCK_OWNER_INIT;</span><br><span class="line">	lock-&gt;owner_cpu = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EXPORT_SYMBOL(__raw_spin_lock_init);</span><br></pre></td></tr></table></figure>

<h3 id="spin-lock"><a href="#spin-lock" class="headerlink" title="spin_lock"></a>spin_lock</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">arch_spin_trylock</span><span class="params">(<span class="type">arch_spinlock_t</span> *lock)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> tmp;</span><br><span class="line">	<span class="type">arch_spinlock_t</span> lockval;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(ARM64_LSE_ATOMIC_INSN(</span></span><br><span class="line"><span class="params">	<span class="comment">/* LL/SC */</span></span></span><br><span class="line"><span class="params">  <span class="comment">//prfm: Prefetch Memory (register)预取</span></span></span><br><span class="line"><span class="params">  <span class="comment">//pstl1strm: 表示预取数据为一级Cache的流式存储</span></span></span><br><span class="line"><span class="params">  <span class="comment">//将lock结构存储到一级Cache，提高访问速度</span></span></span><br><span class="line"><span class="params">	<span class="string">&quot;	prfm	pstl1strm, %2\n&quot;</span></span></span><br><span class="line"><span class="params">  <span class="comment">//赋值，将lock赋值给lockval</span></span></span><br><span class="line"><span class="params">	<span class="string">&quot;1:	ldaxr	%w0, %2\n&quot;</span></span></span><br><span class="line"><span class="params">  <span class="comment">//eor:按位异或</span></span></span><br><span class="line"><span class="params">  <span class="comment">//ror:循环右移</span></span></span><br><span class="line"><span class="params">  <span class="comment">//相当于if(next == owner)</span></span></span><br><span class="line"><span class="params">	<span class="string">&quot;	eor	%w1, %w0, %w0, ror #16\n&quot;</span></span></span><br><span class="line"><span class="params">  <span class="comment">//比较如果tmp不是0，跳转标号2，next与owner不相等</span></span></span><br><span class="line"><span class="params">	<span class="string">&quot;	cbnz	%w1, 2f\n&quot;</span></span></span><br><span class="line"><span class="params">  <span class="comment">/* next == owner，该锁未被使用，no busy */</span></span></span><br><span class="line"><span class="params">  <span class="comment">//lockval中的next加1</span></span></span><br><span class="line"><span class="params">	<span class="string">&quot;	add	%w0, %w0, %3\n&quot;</span></span></span><br><span class="line"><span class="params">  <span class="comment">//将lockval写入lock，并保存赋值状态到tmp</span></span></span><br><span class="line"><span class="params">	<span class="string">&quot;	stxr	%w1, %w0, %2\n&quot;</span></span></span><br><span class="line"><span class="params">  <span class="comment">//如果tmp不等于0，则跳转标号1</span></span></span><br><span class="line"><span class="params">	<span class="string">&quot;	cbnz	%w1, 1b\n&quot;</span></span></span><br><span class="line"><span class="params">  <span class="comment">/* next != owner, 该锁已被使用，busy */</span></span></span><br><span class="line"><span class="params">	<span class="string">&quot;2:&quot;</span>,</span></span><br><span class="line"><span class="params">	<span class="comment">/* LSE atomics */</span></span></span><br><span class="line"><span class="params">  <span class="comment">//将lock赋值给lockval</span></span></span><br><span class="line"><span class="params">	<span class="string">&quot;	ldr	%w0, %2\n&quot;</span></span></span><br><span class="line"><span class="params">  <span class="comment">//判断next与owner是否相等</span></span></span><br><span class="line"><span class="params">	<span class="string">&quot;	eor	%w1, %w0, %w0, ror #16\n&quot;</span></span></span><br><span class="line"><span class="params">  <span class="comment">//如果tmp不等于0，跳转标号1</span></span></span><br><span class="line"><span class="params">	<span class="string">&quot;	cbnz	%w1, 1f\n&quot;</span></span></span><br><span class="line"><span class="params">  <span class="comment">//lockval中的next加1</span></span></span><br><span class="line"><span class="params">	<span class="string">&quot;	add	%w1, %w0, %3\n&quot;</span></span></span><br><span class="line"><span class="params">  <span class="comment">//casa:Compare and Swap</span></span></span><br><span class="line"><span class="params">  <span class="comment">//比较lockval与tmp，如果相等，将tmp写入lockval，否则跳转标号2(原子指令)</span></span></span><br><span class="line"><span class="params">	<span class="string">&quot;	casa	%w0, %w1, %2\n&quot;</span></span></span><br><span class="line"><span class="params">  <span class="comment">//將tmp中的next減去1</span></span></span><br><span class="line"><span class="params">	<span class="string">&quot;	sub	%w1, %w1, %3\n&quot;</span></span></span><br><span class="line"><span class="params">  <span class="comment">//判斷lockval与tmp是否相等</span></span></span><br><span class="line"><span class="params">	<span class="string">&quot;	eor	%w1, %w1, %w0\n&quot;</span></span></span><br><span class="line"><span class="params">  <span class="comment">/* lockval与tmp，相等：退出；不相等：跳转标号1，循环 */</span></span></span><br><span class="line"><span class="params">	<span class="string">&quot;1:&quot;</span>)</span></span><br><span class="line"><span class="params">	: <span class="string">&quot;=&amp;r&quot;</span> (lockval), <span class="string">&quot;=&amp;r&quot;</span> (tmp), <span class="string">&quot;+Q&quot;</span> (*lock)</span></span><br><span class="line"><span class="params">	: <span class="string">&quot;I&quot;</span> (<span class="number">1</span> &lt;&lt; TICKET_SHIFT)</span></span><br><span class="line"><span class="params">	: <span class="string">&quot;memory&quot;</span>)</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> !tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">arch_spin_lock</span><span class="params">(<span class="type">arch_spinlock_t</span> *lock)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> tmp;</span><br><span class="line">	<span class="type">arch_spinlock_t</span> lockval, newval;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(</span></span><br><span class="line"><span class="params">	<span class="comment">/* Atomically increment the next ticket. */</span></span></span><br><span class="line"><span class="params">	ARM64_LSE_ATOMIC_INSN(</span></span><br><span class="line"><span class="params">	<span class="comment">/* LL/SC */</span></span></span><br><span class="line"><span class="params"><span class="string">&quot;	prfm	pstl1strm, %3\n&quot;</span></span></span><br><span class="line"><span class="params"><span class="string">&quot;1:	ldaxr	%w0, %3\n&quot;</span></span></span><br><span class="line"><span class="params"><span class="string">&quot;	add	%w1, %w0, %w5\n&quot;</span></span></span><br><span class="line"><span class="params"><span class="string">&quot;	stxr	%w2, %w1, %3\n&quot;</span></span></span><br><span class="line"><span class="params"><span class="string">&quot;	cbnz	%w2, 1b\n&quot;</span>,</span></span><br><span class="line"><span class="params">	<span class="comment">/* LSE atomics */</span></span></span><br><span class="line"><span class="params"><span class="string">&quot;	mov	%w2, %w5\n&quot;</span></span></span><br><span class="line"><span class="params"><span class="comment">/* next加1 */</span></span></span><br><span class="line"><span class="params"><span class="string">&quot;	ldadda	%w2, %w0, %3\n&quot;</span></span></span><br><span class="line"><span class="params"><span class="string">&quot;	nop\n&quot;</span></span></span><br><span class="line"><span class="params"><span class="string">&quot;	nop\n&quot;</span></span></span><br><span class="line"><span class="params"><span class="string">&quot;	nop\n&quot;</span></span></span><br><span class="line"><span class="params">	)</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">	<span class="comment">/* Did we get the lock? */</span></span></span><br><span class="line"><span class="params"><span class="string">&quot;	eor	%w1, %w0, %w0, ror #16\n&quot;</span></span></span><br><span class="line"><span class="params"><span class="string">&quot;	cbz	%w1, 3f\n&quot;</span></span></span><br><span class="line"><span class="params">	<span class="comment">/*</span></span></span><br><span class="line"><span class="comment"><span class="params">	 * No: spin on the owner. Send a local event to avoid missing an</span></span></span><br><span class="line"><span class="comment"><span class="params">	 * unlock before the exclusive load.</span></span></span><br><span class="line"><span class="comment"><span class="params">	 */</span></span></span><br><span class="line"><span class="params"><span class="comment">/* 使CPU进入低功耗模式， 等待自旋 */</span></span></span><br><span class="line"><span class="params"><span class="string">&quot;	sevl\n&quot;</span></span></span><br><span class="line"><span class="params"><span class="string">&quot;2:	wfe\n&quot;</span></span></span><br><span class="line"><span class="params"><span class="comment">//==&gt; 其他cpu唤醒本cpu，获取当前owner值</span></span></span><br><span class="line"><span class="params"><span class="string">&quot;	ldaxrh	%w2, %4\n&quot;</span></span></span><br><span class="line"><span class="params"><span class="string">&quot;	eor	%w1, %w2, %w0, lsr #16\n&quot;</span></span></span><br><span class="line"><span class="params"><span class="string">&quot;	cbnz	%w1, 2b\n&quot;</span></span></span><br><span class="line"><span class="params">	<span class="comment">/* We got the lock. Critical section starts here. */</span></span></span><br><span class="line"><span class="params"><span class="string">&quot;3:&quot;</span></span></span><br><span class="line"><span class="params">	: <span class="string">&quot;=&amp;r&quot;</span> (lockval), <span class="string">&quot;=&amp;r&quot;</span> (newval), <span class="string">&quot;=&amp;r&quot;</span> (tmp), <span class="string">&quot;+Q&quot;</span> (*lock)</span></span><br><span class="line"><span class="params">	: <span class="string">&quot;Q&quot;</span> (lock-&gt;owner), <span class="string">&quot;I&quot;</span> (<span class="number">1</span> &lt;&lt; TICKET_SHIFT)</span></span><br><span class="line"><span class="params">	: <span class="string">&quot;memory&quot;</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Wait For Event is a hint instruction that indicates that the PE can enter a low-power state and remain there until a wakeup event occurs. Wakeup events include the event signaled as a result of executing the <code>SEV</code> instruction on any PE in the multiprocessor system. For more information, see Wait for Event mechanism and Send event on page D1-2255.</p>
</blockquote>
<h3 id="spin-unlock"><a href="#spin-unlock" class="headerlink" title="spin_unlock"></a>spin_unlock</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">arch_spin_unlock</span><span class="params">(<span class="type">arch_spinlock_t</span> *lock)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> tmp;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(ARM64_LSE_ATOMIC_INSN(</span></span><br><span class="line"><span class="params">	<span class="comment">/* LL/SC */</span></span></span><br><span class="line"><span class="params">	<span class="string">&quot;	ldrh	%w1, %0\n&quot;</span></span></span><br><span class="line"><span class="params">	<span class="string">&quot;	add	%w1, %w1, #1\n&quot;</span></span></span><br><span class="line"><span class="params">	<span class="string">&quot;	stlrh	%w1, %0&quot;</span>,</span></span><br><span class="line"><span class="params">	<span class="comment">/* LSE atomics */</span></span></span><br><span class="line"><span class="params">	<span class="string">&quot;	mov	%w1, #1\n&quot;</span></span></span><br><span class="line"><span class="params">	<span class="string">&quot;	nop\n&quot;</span></span></span><br><span class="line"><span class="params">  <span class="comment">/* owner加1 */</span></span></span><br><span class="line"><span class="params">	<span class="string">&quot;	staddlh	%w1, %0&quot;</span>)</span></span><br><span class="line"><span class="params">	: <span class="string">&quot;=Q&quot;</span> (lock-&gt;owner), <span class="string">&quot;=&amp;r&quot;</span> (tmp)</span></span><br><span class="line"><span class="params">	:</span></span><br><span class="line"><span class="params">	: <span class="string">&quot;memory&quot;</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>没有sev指令，如何唤醒进入低功耗模式（wfe）的CPU core？？</li>
</ul>
<blockquote>
<p>ARMv8 provides Wait For Event, Send Event, and Send Event Local instructions, WFE, SEV, and SEVL, that can assist with reducing power consumption and bus contention caused by PEs repeatedly attempting to obtain a spin-lock. These instructions can be used at the application level, but a complete understanding of what they do depends on a system level understanding of exceptions. They are described in Wait for Event mechanism and Send event on page D1-2255. However, in ARMv8, when the global monitor for a PE changes from <code>Exclusive Access</code> state to Open Access state, an event is generated.</p>
</blockquote>
<p><strong><code>stlrh</code>和<code>staddlh</code>指令存在Exclusive操作，当PE（n）对x地址发起了exclusive操作的时候，PE（n）的global monitor从open access迁移到exclusive access状态，来自其他PE上针对x（该地址已经被mark for PE（n））的store操作会导致PE（n）的global monitor从exclusive access迁移到open access状态，这时候，PE（n）的Event register会被写入event，就好象生成一个event，将该PE唤醒，从而可以省略一个SEV的指令</strong></p>
<p><img data-src="/images/2019/04/spin_lock_pe_n.png" alt="spin_lock_pe_n"></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9sd24ubmV0L0FydGljbGVzLzI2Nzk2OC8=">Ticket spinlocks<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9kZXYudGVuY2VudC5jb20vdS9XaW5kZG9pbmcvcC9ibG9nX2RvY3MvZ2l0L3Jhdy9tYXN0ZXIvRERJMDQ4N0RfYV9hcm12OF9hcm0ucGRm">ARMv8®体系结构参考手册<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL3d3dy53b3dvdGVjaC5uZXQvYXJtdjhhX2FyY2gvd2ZlX3dmaS5odG1s">ARM WFI和WFE指令<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>Linux内核</category>
      </categories>
      <tags>
        <tag>sync</tag>
        <tag>spinlock</tag>
      </tags>
  </entry>
  <entry>
    <title>vanilla kernel</title>
    <url>/post/b4e9a1bb.html</url>
    <content><![CDATA[<blockquote>
<p>The kernels at <span class="exturl" data-url="aHR0cHM6Ly93d3cua2VybmVsLm9yZy8=">www.kernel.org<i class="fa fa-external-link-alt"></i></span> are vanilla kernels.</p>
</blockquote>
<p><code>vanilla</code>: 表示原始的，最基本的结构或框架</p>
<span id="more"></span>

<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cubGludXhxdWVzdGlvbnMub3JnL3F1ZXN0aW9ucy9saW51eC1nZW5lcmFsLTEvd2hhdC1pcy12YW5pbGxhLWtlcm5lbC03OTM4OC8=">What is Vanilla kernel ? <i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>Linux内核</category>
      </categories>
      <tags>
        <tag>kernel</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>内存屏障——arm64</title>
    <url>/post/9a485b42.html</url>
    <content><![CDATA[<p><code>内存屏障</code>，也称内存栅栏，内存栅障，屏障指令等， 是一类同步屏障指令，是<code>CPU或编译器在对内存随机访问的操作中的一个同步点</code>，使得此点之前的所有读写操作都执行后才可以开始执行此点之后的操作</p>
<span id="more"></span>

<p>内存屏障的主要目的是为了防止指令重排引起的错误。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1JvbGFuZF9TdW4vYXJ0aWNsZS9kZXRhaWxzLzEwNzQ2ODA1NQ==">Arm64内存屏障<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3M/X19iaXo9TXpVNU1UZzJPVGMzTmc9PSZtaWQ9MjI0NzQ4MzcxNyZpZHg9MSZzbj00MWYxMGU0MjhlYjZlZTY4M2YzYjRkZDlkZDAyNTc0MiZjaGtzbT1mZTI5MjM3YWM5NWVhYTZjOTQ5MmRlZDMyNThhOTBkZTRmMDIzNDNhMmVlNTY4MzlkNGNkYWE1OGY0NDI3Zjg0YTYyMmJhNzU3NzBiJnRva2VuPTE2MDE4NDUxMzEmbGFuZz16aF9DTiNyZA==">带你了解缓存一致性协议 MESI<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8xMjU3Mzc4NjQ=">内存屏障（Memory Barrier）究竟是个什么鬼？<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>Linux内核</category>
      </categories>
      <tags>
        <tag>arm64</tag>
        <tag>内存</tag>
        <tag>arm</tag>
        <tag>smb</tag>
      </tags>
  </entry>
  <entry>
    <title>内存布局与映射关系</title>
    <url>/post/d852017a.html</url>
    <content><![CDATA[<p>虚拟内存的布局划分与其对应的物理内存之间的映射关系</p>
<span id="more"></span>

<h2 id="32位系统"><a href="#32位系统" class="headerlink" title="32位系统"></a>32位系统</h2><p>32位系统最大可以访问内存地址范围为<code>0 ~ 4G</code>，这4G内存的被分为<code>用户空间内存</code>和<code>内核空间内存</code></p>
<ul>
<li>用户空间：<code>0x0000_0000 ~ 0xBFFF_FFFF</code> (0G ~ 3G)</li>
<li>内核空间：<code>0xC000_0000 ~ 0xFFFF_FFFF</code> (3G ~ 4G)</li>
</ul>
<h3 id="虚拟地址划分"><a href="#虚拟地址划分" class="headerlink" title="虚拟地址划分"></a>虚拟地址划分</h3><p>Linux下32位寻址空间的大致分布（虚拟内存）：</p>
<p><img data-src="/images/2022/07/32bit%E5%86%85%E5%AD%98%E5%88%92%E5%88%86.png" alt="32bit内存划分"></p>
<h3 id="虚拟地址与物理地址之间的关系"><a href="#虚拟地址与物理地址之间的关系" class="headerlink" title="虚拟地址与物理地址之间的关系"></a>虚拟地址与物理地址之间的关系</h3><p><img data-src="/images/2022/07/32bit%E5%86%85%E5%AD%98%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E4%B8%8E%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB.png" alt="32bit内存虚拟地址与物理地址之间的关系"></p>
<p>虚拟内存和物理内存的转换通过<code>MMU</code>硬件来实现</p>
<p>32位CPU可以访问的寻址范围只有4G，因此如果物理内存大于4G时，应该如何处理？</p>
<p>目前在linux系统中可以通过PAE可以支持物理内存超过4G的访问，但是此时CPU也必须支持PAE功能，这部分后面有机会研究了详细说明。</p>
<p>在之前一直以为物理内存超过4G与高端内存有关，而实际上高端内存的产生至于虚拟内存地址范围有关，与物理内存无关。</p>
<h3 id="高端内存"><a href="#高端内存" class="headerlink" title="高端内存"></a>高端内存</h3><p>High Memory: 解决的问题是<code>在32位CPU下虚拟机地址空间不足</code>带来的问题。</p>
<p>原因：</p>
<p>在内核中我们要进行频繁的虚拟地址（VA）和物理地址（PA）操作，在这种情况下，如何高效的进行VA to PA的转换就很重要。可是如果按照多级页表路径查找，内存访问开销就比较大，因此采用了另一种简单的”fix-mapping”思路，将<code>0xc000 0000~0xffff ffff</code>虚拟地址直接映射到<code>0x0000 0000~0x3fff ffff</code>,也就是将虚拟地址空间最高1G全部映射到物理地址空间最低的1G上，这样VA与PA之间就存在3G的固定偏移，这样PA&#x3D;VA-3G。</p>
<p>这样使用简单高效，但是也存在局限性，就是在内核空间只能使用1G的物理内存。但是随着技术的发展1G大小的内核空间已经无法满足内核的使用，因此需要将内核空间增大，有人提议重新划分用户空间和内核空间的比例，比如不按照3：1,使用2.5：1.5等，但由于一些特殊场景（比如用户空间使用的内存非常多）会使得用户态运行效率降低，同时带来一些非对其问题，因此也不是一个很好的办法。</p>
<p>最后就引入了<code>高端内存</code>，将内核空间的1G地址，分为两部分，一部分同样采用<code>fix-mapping</code>，另一部分用来<code>dynamic mapping</code>,以X86为例，实际中的做法是，<code>0xC000 0000-0xF7FF FFFF</code>的896MB用作<code>fix-mapping</code>，<code>0xF800 0000-0xFFFF FFFF</code>的128MB用作<code>dynamic-mapping</code>，前者仍然对应于物理地址的<code>0x0000 0000-0x37FF FFFF</code>（只不过部分要优先分配给DMA）；后者就是所谓的<code>high memory</code>。</p>
<p>实际上<code>high memory</code>还被划分为了3个区域，一部分用于vmalloc分配虚拟地址上连续的内存，一部分用于较长期的动态映射（persistent kernel mappings），还有一部分用于编译时可以直接分配物理地址的高端固定映射（fixmaps）<br><img data-src="/images/2022/07/%E5%86%85%E6%A0%B8%E7%A9%BA%E9%97%B4%E5%88%92%E5%88%86.png" alt="内核空间划分"></p>
<ul>
<li>虚拟内存中连续、但物理内存中不连续的内存区,可以在<code>vmalloc区域</code>分配。该机制通常用于用户过程,内核自身会试图尽力避免非连续的物理地址。内核通常会成功,因为大部分大的内存块都在启动时分配给内核,那时内存的碎片尚不严重。但在已经运行了很长时间的系统上,在内核需要物理内存时,就可能出现可用空间不连续的情况。此类情况,主要出现在动态加载模块时。</li>
<li><code>持久映射</code>用于将高端内存域中的非持久页映射到内核中</li>
<li><code>固定映射</code>是与物理地址空间中的固定页关联的虚拟地址空间项,但具体关联的页帧可以自由选择。它与通过固定公式与物理内存关联的直接映射页相反,虚拟固定映射地址与物理内存位置之间的关联可以自行定义,关联建立后内核总是会注意到的。</li>
</ul>
<p>在linux中高端内存的大小，可以通过启动参数进行指定：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">highmem=nn[KMG] [KNL,BOOT] forces the highmem zone to have an exact</span><br><span class="line">        size of &lt;nn&gt;. This works even on boxes that have no</span><br><span class="line">        highmem otherwise. This also works to reduce highmem</span><br><span class="line">        size on bigger boxes.</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Documentation&#x2F;admin-guide&#x2F;kernel-parameters.txt</p>
</blockquote>
<p>在64位系统中，不存在这个问题，因此64位系统的内存划分不存在<code>高端内存</code>（High Memory）</p>
<h3 id="PAE"><a href="#PAE" class="headerlink" title="PAE"></a>PAE</h3><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ppbmtpbmcwMS9hcnRpY2xlL2RldGFpbHMvMTA1ODM0ODAx">linux内存管理之PAE（物理地址扩展）解决内存大于4G的问题<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<h3 id="虚拟内存空间与进程地址空间"><a href="#虚拟内存空间与进程地址空间" class="headerlink" title="虚拟内存空间与进程地址空间"></a>虚拟内存空间与进程地址空间</h3><p><img data-src="/images/2022/07/32bit_ram_layer.png" alt="32bit_RAM_layer_"></p>
<h2 id="64位系统"><a href="#64位系统" class="headerlink" title="64位系统"></a>64位系统</h2><p>环境：arm64CPU，linux系统</p>
<p>64bit内存地址可用空间为<code>0x0000 0000 0000 0000 ~ 0xFFFF FFFF FFFF FFFF</code></p>
<p>64位CPU的寻址分三种:</p>
<p><img data-src="/images/2022/07/64%E4%BD%8D%E5%AF%BB%E5%9D%80%E5%8C%BA%E5%9F%9F%E5%88%92%E5%88%86.png" alt="64位寻址区域划分"></p>
<p>ARM64架构的处理器采用的是<code>48位</code>的物理寻址方式。用户空间和内核空间最大支持256TB的地址空间。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">config ARM64_PA_BITS_48</span><br><span class="line">    bool &quot;48-bit&quot;</span><br></pre></td></tr></table></figure>
<ul>
<li>内核空间 ：0xFFFF 0000 0000 0000 ~ 0xFFFF FFFF FFFF FFFF (256TB)</li>
<li>非规范区 ：0x0000 FFFF FFFF FFFF ~ 0xFFFF 0000 0000 0000 (未使用）</li>
<li>用户空间 ：0x0000 0000 0000 0000 ~ 0x0000 FFFF FFFF FFFF (256TB)</li>
</ul>
<h3 id="48位寻址划分"><a href="#48位寻址划分" class="headerlink" title="48位寻址划分"></a>48位寻址划分</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AArch64 Linux memory layout with 4KB pages + 4 levels (48-bit)::</span><br><span class="line"></span><br><span class="line">  Start         End         Size        Use</span><br><span class="line">  -----------------------------------------------------------------------</span><br><span class="line">  0000000000000000  0000ffffffffffff     256TB      user</span><br><span class="line">  ffff000000000000  ffff7fffffffffff     128TB      kernel logical memory map</span><br><span class="line">  ffff800000000000  ffff9fffffffffff      32TB      kasan shadow region</span><br><span class="line">  ffffa00000000000  ffffa00007ffffff     128MB      bpf jit region</span><br><span class="line">  ffffa00008000000  ffffa0000fffffff     128MB      modules</span><br><span class="line">  ffffa00010000000  fffffdffbffeffff     ~93TB      vmalloc</span><br><span class="line">  fffffdffbfff0000  fffffdfffe5f8fff    ~998MB      [guard region]</span><br><span class="line">  fffffdfffe5f9000  fffffdfffe9fffff    4124KB      fixed mappings</span><br><span class="line">  fffffdfffea00000  fffffdfffebfffff       2MB      [guard region]</span><br><span class="line">  fffffdfffec00000  fffffdffffbfffff      16MB      PCI I/O space</span><br><span class="line">  fffffdffffc00000  fffffdffffdfffff       2MB      [guard region]</span><br><span class="line">  fffffdffffe00000  ffffffffffdfffff       2TB      vmemmap</span><br><span class="line">  ffffffffffe00000  ffffffffffffffff       2MB      [guard region]</span><br></pre></td></tr></table></figure>

<p><img data-src="/images/2022/07/48%E4%BD%8D%E5%AF%BB%E5%9D%80%E5%88%92%E5%88%86.png" alt="48位寻址划分"></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzI4MDUyNjA0Mg==">linux的高端内存是什么？<i class="fa fa-external-link-alt"></i></span></li>
<li>Documentation&#x2F;arm64&#x2F;memory.rst</li>
<li>Documentation&#x2F;x86&#x2F;x86_64&#x2F;mm.rst</li>
</ul>
]]></content>
      <categories>
        <category>Linux内核</category>
      </categories>
      <tags>
        <tag>内存</tag>
        <tag>mmu</tag>
      </tags>
  </entry>
  <entry>
    <title>内存管理之NUMA与CPU</title>
    <url>/post/36923.html</url>
    <content><![CDATA[<p>NUMA与CPU之间的关系,如系统中有2个CPU（可以超过2个CPU）时， NUMA内存访问模型</p>
<p><img data-src="/images/2019/06/mmu_numa_cpu.png" alt="mmu_numa_cpu"></p>
<blockquote>
<p>平台：arm64<br>kernel：linux4.4</p>
</blockquote>
<span id="more"></span>

<h2 id="NUMA-Non-Uniform-Memory-Access"><a href="#NUMA-Non-Uniform-Memory-Access" class="headerlink" title="NUMA(Non Uniform Memory Access)"></a>NUMA(Non Uniform Memory Access)</h2><p>NUMA和SMP是两种CPU相关的硬件架构。在SMP架构里面，所有的CPU争用一个总线来访问所有内存，优点是资源共享，而缺点是总线争用激烈。随着PC服务器上的CPU数量变多（不仅仅是CPU核数），总线争用的弊端慢慢越来越明显，于是Intel在Nehalem CPU上推出了NUMA架构，而AMD也推出了基于相同架构的Opteron CPU。</p>
<p>NUMA最大的特点是引入了node和distance的概念。对于CPU和内存这两种最宝贵的硬件资源，NUMA用近乎严格的方式划分了所属的资源组（node），而每个资源组内的CPU和内存是几乎相等。资源组的数量取决于物理CPU的个数（现有的PC server大多数有两个物理CPU，每个CPU有4个核）；distance这个概念是用来定义各个node之间调用资源的开销，为资源调度优化算法提供数据支持。</p>
<p><img data-src="/images/2019/06/mmu_numa_intel_access.png" alt="mmu_numa_intel_access"></p>
<ul>
<li>查看NUMA相关情况<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#numactl  --show</span><br></pre></td></tr></table></figure>
<h2 id="ARM64内存在管理相当于单个node"><a href="#ARM64内存在管理相当于单个node" class="headerlink" title="ARM64内存在管理相当于单个node"></a>ARM64内存在管理相当于单个node</h2></li>
</ul>
<p><img data-src="/images/2019/06/mmu_one_node.png" alt="mmu_one_node"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">On node 0 totalpages: 524288</span><br><span class="line">  DMA zone: 8192 pages used for memmap</span><br><span class="line">  DMA zone: 0 pages reserved</span><br><span class="line">  DMA zone: 524288 pages, LIFO batch:31</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<blockquote>
<p>内核启动部分打印</p>
</blockquote>
<h3 id="node的初始化"><a href="#node的初始化" class="headerlink" title="node的初始化"></a>node的初始化</h3><p>在内核启动时进行初始化：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">start_kernel</span><br><span class="line">  \-&gt;setup_arch //不同的CPU对node的使用不同</span><br><span class="line">      \-&gt;paging_init</span><br><span class="line">          \-&gt;bootmem_init</span><br><span class="line">              \-&gt;zone_sizes_init(arch/arm64/mm/minit.c)</span><br><span class="line">                  \-&gt;free_area_init_node(nid=0, ...)</span><br><span class="line">                    &#123;</span><br><span class="line">                       pg_data_t *pgdat = NODE_DATA(nid);</span><br><span class="line"></span><br><span class="line">                       calculate_node_totalpages(pgdat, start_pfn, end_pfn,</span><br><span class="line">                         zones_size, zholes_size);</span><br><span class="line">                       alloc_node_mem_map(pgdat);</span><br><span class="line">                    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="物理内存与node之间的关系"><a href="#物理内存与node之间的关系" class="headerlink" title="物理内存与node之间的关系"></a>物理内存与node之间的关系</h2><h2 id="numa编码"><a href="#numa编码" class="headerlink" title="numa编码"></a>numa编码</h2><p>将当前进程绑定到node0或node1,及在当前node上的CPU运行与申请内存</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">set_numa_node</span><span class="params">(<span class="type">int</span> node)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bitmask</span> *<span class="title">bit</span>;</span></span><br><span class="line"></span><br><span class="line">    bit = numa_bitmask_alloc(<span class="number">1</span>);</span><br><span class="line">    numa_bitmask_clearall(bit);</span><br><span class="line">    numa_bitmask_setbit(bit, node);</span><br><span class="line">    numa_bind(bit); <span class="comment">//将当前任务及其子任务绑定到nodemask中指定的节点。它们只会在指定节点的CPU上运行，并且只能从它们分配内存。</span></span><br><span class="line">    numa_bitmask_free(bit);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>numa_bind()</code> binds the current task and its children to the nodes specified in nodemask. They will only run on the CPUs of the specified nodes and only be able to allocate memory from them. This function is equivalent to calling numa_run_on_node_mask(nodemask) followed by numa_set_membind(nodemask). If tasks should be bound to individual CPUs inside nodes consider using numa_node_to_cpus and the sched_setaffinity(2) syscall.</p>
</blockquote>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20veHVlcWl1cWl1L2FydGljbGVzLzkyODI5MDMuaHRtbA==">NUMA的取舍与优化设置<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>Linux内核</category>
      </categories>
      <tags>
        <tag>内存</tag>
      </tags>
  </entry>
  <entry>
    <title>内核宏—IRQCHIP_DECLARE</title>
    <url>/post/c27adb68.html</url>
    <content><![CDATA[<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">IRQCHIP_DECLARE(gic_400, <span class="string">&quot;arm,gic-400&quot;</span>, gic_of_init);</span><br></pre></td></tr></table></figure>
<p>声明irqchip与初始化函数的关联，兼容GIC-V2的GIC实现有很多，不过其初始化函数都是一个。在linux kernel编译的时候，你可以配置多个irq chip进入内核，编译系统会把所有的IRQCHIP_DECLARE宏定义的数据放入到一个特殊的section中（section name是<code>__irqchip_of_table</code>），我们称这个特殊的section叫做<code>irq chip table</code>。这个table也就保存了kernel支持的所有的中断控制器的ID信息（最重要的是驱动代码初始化函数和DT compatible string）</p>
<span id="more"></span>


<h2 id="IRQCHIP-DECLARE宏定义"><a href="#IRQCHIP-DECLARE宏定义" class="headerlink" title="IRQCHIP_DECLARE宏定义"></a>IRQCHIP_DECLARE宏定义</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* include/linux/irqchip.h */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRQCHIP_DECLARE(name, compat, fn) OF_DECLARE_2(irqchip, name, compat, fn)</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* include/linux/of.h */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _OF_DECLARE(table, name, compat, fn, fn_type)           \</span></span><br><span class="line"><span class="meta">    static const struct of_device_id __of_table_##name      \</span></span><br><span class="line"><span class="meta">        __used __section(__##table##_of_table)          \</span></span><br><span class="line"><span class="meta">        __aligned(__alignof__(struct of_device_id))     \</span></span><br><span class="line"><span class="meta">         = &#123; .compatible = compat,              \</span></span><br><span class="line"><span class="meta">             .data = (fn == (fn_type)NULL) ? fn : fn  &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">int</span> <span class="params">(*of_init_fn_2)</span><span class="params">(<span class="keyword">struct</span> device_node *, <span class="keyword">struct</span> device_node *)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OF_DECLARE_2(table, name, compat, fn) \</span></span><br><span class="line"><span class="meta">        _OF_DECLARE(table, name, compat, fn, of_init_fn_2)</span></span><br></pre></td></tr></table></figure>

<p><code>IRQCHIP_DECLARE</code>宏展开后</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> __<span class="title">of_table_gic_400</span></span></span><br><span class="line"><span class="class">    __<span class="title">used</span> __<span class="title">section</span>(__<span class="title">irqchip_of_table</span>)  //编译时将定义的<span class="title">of_device_id</span>结构体添加到<span class="title">irqchip_of_table</span> <span class="title">section</span>中</span></span><br><span class="line"><span class="class">    __<span class="title">aligned</span>(__<span class="title">alignof__</span>(<span class="keyword">struct</span> <span class="title">of_device_id</span>))</span></span><br><span class="line"><span class="class">    =</span> &#123;</span><br><span class="line">      .compatible = <span class="string">&quot;arm,gic-400&quot;</span>,</span><br><span class="line">      .data = gic_of_init</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>将初始化的<code>of_device_id</code>结构体插入到<code>irqchip_of_table</code> section中</p>
</blockquote>
<h2 id="irqchip-of-table段的定义"><a href="#irqchip-of-table段的定义" class="headerlink" title="irqchip_of_table段的定义"></a>irqchip_of_table段的定义</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* arch/arm64/kernel/vmlinux.lds.S */</span><br><span class="line">.init.data : &#123;</span><br><span class="line">    INIT_DATA       //添加init section</span><br><span class="line">    INIT_SETUP(16)</span><br><span class="line">    INIT_CALLS</span><br><span class="line">    CON_INITCALL</span><br><span class="line">    INIT_RAM_FS</span><br><span class="line">    *(.init.rodata.* .init.bss) /* from the EFI stub */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* include/asm-generic/vmlinux.lds.h */</span></span><br><span class="line"><span class="comment">/* init and exit section handling */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INIT_DATA                           \</span></span><br><span class="line"><span class="meta">    ...</span></span><br><span class="line">    IRQCHIP_OF_MATCH_TABLE()                    \</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ___OF_TABLE(cfg, name)  _OF_TABLE_##cfg(name)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __OF_TABLE(cfg, name)   ___OF_TABLE(cfg, name)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OF_TABLE(cfg, name) __OF_TABLE(IS_ENABLED(cfg), name)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _OF_TABLE_0(name)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _OF_TABLE_1(name)                       \</span></span><br><span class="line"><span class="meta">    . = ALIGN(8);                           \</span></span><br><span class="line"><span class="meta">    __##name##_of_table = .;                    \</span></span><br><span class="line"><span class="meta">    KEEP(*(__##name##_of_table))                    \</span></span><br><span class="line"><span class="meta">    KEEP(*(__##name##_of_table_end))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRQCHIP_OF_MATCH_TABLE() OF_TABLE(CONFIG_IRQCHIP, irqchip)  <span class="comment">//CONFIG_IRQCHIP=y</span></span></span><br></pre></td></tr></table></figure>

<p><code>IRQCHIP_OF_MATCH_TABLE</code>宏展开</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">. = ALIGN(<span class="number">8</span>);     <span class="comment">//表示从该地址开始后面的存储进行8字节对齐</span></span><br><span class="line">__irqchip_of_table = .;   <span class="comment">//定义当前section名字为irqchip_of_table</span></span><br><span class="line">KEEP(*(irqchip_of_table))</span><br><span class="line">KEEP(*(irqchip_of_table_end))</span><br></pre></td></tr></table></figure>
<ul>
<li><code>KEEP</code>: 链接器关键字，防止被优化</li>
<li><code>ALIGN</code>： 表示字节对其</li>
</ul>
<blockquote>
<p><code>IRQCHIP_DECLARE</code>宏定义的的数据结构将直接插入到<code>.init.data</code>段中的<code>irqchip_of_table</code></p>
</blockquote>
<h2 id="解析irqchip-of-table段"><a href="#解析irqchip-of-table段" class="headerlink" title="解析irqchip_of_table段"></a>解析irqchip_of_table段</h2><p>定义并初始化完后，何时如何被解析使用。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">start_kernel</span><br><span class="line">  \-&gt; init_IRQ  <span class="comment">//arch/arm64/kernel/irq.c</span></span><br><span class="line">    \-&gt; irqchip_init</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* drivers/irqchip/irqchip.c */</span></span><br><span class="line"><span class="type">void</span> __init <span class="title function_">irqchip_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    of_irq_init(__irqchip_of_table);</span><br><span class="line">    acpi_probe_device_table(irqchip);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* drivers/of/irq.c */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* of_irq_init - Scan and init matching interrupt controllers in DT */</span></span><br><span class="line"><span class="type">void</span> __init <span class="title function_">of_irq_init</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> of_device_id *matches)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 扫描并初始化of_intc_desc结构体 */</span></span><br><span class="line">  for_each_matching_node_and_match(np, matches, &amp;match) &#123;</span><br><span class="line">    ...</span><br><span class="line">    desc-&gt;irq_init_cb = match-&gt;data;</span><br><span class="line">    desc-&gt;dev = of_node_get(np);</span><br><span class="line">    desc-&gt;interrupt_parent = of_irq_find_parent(np);</span><br><span class="line">    <span class="keyword">if</span> (desc-&gt;interrupt_parent == np)</span><br><span class="line">        desc-&gt;interrupt_parent = <span class="literal">NULL</span>;</span><br><span class="line">    list_add_tail(&amp;desc-&gt;<span class="built_in">list</span>, &amp;intc_desc_list);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 回调初始化接口，data成员的定义 */</span></span><br><span class="line">  <span class="keyword">while</span> (!list_empty(&amp;intc_desc_list)) &#123;</span><br><span class="line">    list_for_each_entry_safe(desc, temp_desc, &amp;intc_desc_list, <span class="built_in">list</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line">        ret = desc-&gt;irq_init_cb(desc-&gt;dev,</span><br><span class="line">                    desc-&gt;interrupt_parent);</span><br><span class="line">        ...</span><br><span class="line">        list_add_tail(&amp;desc-&gt;<span class="built_in">list</span>, &amp;intc_parent_list);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux内核</category>
      </categories>
      <tags>
        <tag>kernel</tag>
        <tag>linux</tag>
        <tag>irqchip</tag>
      </tags>
  </entry>
  <entry>
    <title>内核版本升级——ubuntu18.04</title>
    <url>/post/15332.html</url>
    <content><![CDATA[<p>linux内核升级笔记：</p>
<span id="more"></span>

<h2 id="内核升级"><a href="#内核升级" class="headerlink" title="内核升级"></a>内核升级</h2><ul>
<li>HWE<blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cuc3lzZ2Vlay5jbi91YnVudHUtMTgwNC1pbnN0YWxsLWxpbnV4LWtlcm5lbC01MC8=">https://www.sysgeek.cn/ubuntu-1804-install-linux-kernel-50/<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
</li>
</ul>
<p>Ubuntu 18.04.2 版本包含一个新的「硬件启用堆栈」，即 HWE，该堆栈由较新的Linux Kernel、X.org 图形服务器和图形驱动程序等组成。然而毕竟 LTS 长期支持版本主打的是稳定性，用户不一定希望经常有新内核更新，所以 HWE 不会自动安装到现有系统上，以确保不会破坏任何内容。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install --install-recommends linux-generic-hwe-18.04 xserver-xorg-hwe-18.04</span><br></pre></td></tr></table></figure>

<ul>
<li>手动升级</li>
</ul>
<blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9rZXJuZWwudWJ1bnR1LmNvbS9+a2VybmVsLXBwYS9tYWlubGluZS8=">https://kernel.ubuntu.com/~kernel-ppa/mainline/<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<p>升级脚本：<span class="exturl" data-url="aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL1dpbmRkb2luZy93b3JrX2Vudi9tYXN0ZXIvdG9vbHMvYXV0by1pbnN0YWxsL3VwZ3JhZGVfbGF0ZXN0X2tlcm5lbC5zaA==">https://raw.githubusercontent.com/Winddoing/work_env/master/tools/auto-install/upgrade_latest_kernel.sh<i class="fa fa-external-link-alt"></i></span></p>
<ul>
<li>ubuntu HWE 支持</li>
</ul>
<blockquote>
<ol>
<li>获取5.3.0内核版本 sudo apt list | grep linux-generic*</li>
<li>能够获取到5.3.0版本之后直接安装 sudo apt install linux-generic-hwe-18.04-edge</li>
</ol>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">sudo apt list | grep linux-generic*</span></span><br><span class="line"></span><br><span class="line">WARNING: apt does not have a stable CLI interface. Use with caution in scripts.</span><br><span class="line"></span><br><span class="line">linux-generic/bionic-updates,bionic-security,now 4.15.0.70.72 amd64 [installed]</span><br><span class="line">linux-generic-hwe-16.04/bionic-updates,bionic-security 4.15.0.70.72 amd64</span><br><span class="line">linux-generic-hwe-16.04-edge/bionic-updates,bionic-security 4.15.0.70.72 amd64</span><br><span class="line">linux-generic-hwe-18.04/bionic-updates,bionic-security 5.0.0.36.94 amd64</span><br><span class="line">linux-generic-hwe-18.04-edge/bionic-updates,bionic-security,now 5.3.0.23.90 amd64 [installed]</span><br><span class="line"></span><br><span class="line">sudo apt install linux-generic-hwe-18.04-edge</span><br></pre></td></tr></table></figure>

<p>更新grub启动配置文件：<code>/boot/grub/grub.cfg</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo update-grub</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果系统没有该命令通过<code>sudo apt install grub-efi-amd64 grub-efi-amd64-bin</code>安装</p>
</blockquote>
<ul>
<li>下载当前内核源码</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get source linux-image-$(uname -r)</span><br></pre></td></tr></table></figure>

<h2 id="启动模式"><a href="#启动模式" class="headerlink" title="启动模式"></a>启动模式</h2><ul>
<li><p>文本模式</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl set-default multi-user.target</span><br></pre></td></tr></table></figure>
</li>
<li><p>图形模式</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl set-default graphical.target</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="源码编译升级"><a href="#源码编译升级" class="headerlink" title="源码编译升级"></a>源码编译升级</h2><blockquote>
<p>系统：ubuntu18.04</p>
</blockquote>
<ul>
<li><p>依赖软件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install libssl-dev</span><br></pre></td></tr></table></figure>
</li>
<li><p>编译升级</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp -v /boot/config-$(uname -r) .config</span><br><span class="line">sh -c &#x27;yes &quot;&quot; | make oldconfig&#x27;</span><br><span class="line">make -j4</span><br><span class="line">sudo make modules_install</span><br><span class="line">sudo make install</span><br><span class="line">reboot</span><br></pre></td></tr></table></figure>
<blockquote>
<p>重启时选择最新安装内核启动，通过<code>uname -a</code>确定内核升级是否成功</p>
</blockquote>
</li>
</ul>
<h2 id="列出系统中的所有已安装内核"><a href="#列出系统中的所有已安装内核" class="headerlink" title="列出系统中的所有已安装内核"></a>列出系统中的所有已安装内核</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo dpkg --get-selections|grep linux</span><br><span class="line">sudo dpkg --list | grep linux-image</span><br><span class="line">sudo dpkg --list | grep linux-headers</span><br></pre></td></tr></table></figure>

<h2 id="删除不要的内核镜像"><a href="#删除不要的内核镜像" class="headerlink" title="删除不要的内核镜像"></a>删除不要的内核镜像</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get purge linux-headers-3.13.0-24-generic</span><br><span class="line">sudo apt-get purge linux-image-3.13.0-24-generic</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux内核</category>
      </categories>
      <tags>
        <tag>内核</tag>
      </tags>
  </entry>
  <entry>
    <title>[译]MCS locks and qspinlocks</title>
    <url>/post/12400.html</url>
    <content><![CDATA[<p>原文： <span class="exturl" data-url="aHR0cHM6Ly9sd24ubmV0L0FydGljbGVzLzU5MDI0My8=">https://lwn.net/Articles/590243/<i class="fa fa-external-link-alt"></i></span></p>
<p>从概念上讲，自旋锁是一种简单的机制。 锁可以小到一位; 如果该位清零，则锁定可用。 想要获取锁的线程将尝试使用<code>原子比较交换指令</code>(atomic compare-and-swap instruction)设置该位，如果当时锁不可用则反复“旋转”。 多年来，自旋锁变得更加复杂; 排队自旋锁（<span class="exturl" data-url="aHR0cHM6Ly9sd24ubmV0L0FydGljbGVzLzI2Nzk2OC8=">Ticket spinlocks<i class="fa fa-external-link-alt"></i></span>）在2008年增加了对该机制的公平性，并且2013年增加了更好的半虚拟化支持。</p>
<span id="more"></span>

<p>尽管每次尝试获取锁定都需要将包含该锁定的高速缓存行移动到本地CPU，但自旋锁仍然存在一个根本问题，除了简单的旋转锁定是痛苦的。 对于竞争锁，此<code>缓存弹跳</code>(cache-line bouncing)可能会显着损害性能。 因此，开发人员一直在努力减少自旋锁的缓存争用并不奇怪; 例如，尝试在2013年初为自旋锁添加自动退避(<span class="exturl" data-url="aHR0cHM6Ly9sd24ubmV0L0FydGljbGVzLzUzMTI1NC8=">an attempt to add automatic backoff<i class="fa fa-external-link-alt"></i></span>)是为了实现这一目标，但这项工作从未合并过。</p>
<h2 id="MCS-locks"><a href="#MCS-locks" class="headerlink" title="MCS locks"></a>MCS locks</h2><p>最近，Tim Chen根据一个名为“MCS锁”的原语组合了一种不同的方法。 通过将自旋锁扩展为每个CPU结构，MCS锁可以消除更简单锁所经历的大部分缓存弹跳，尤其是在竞争情况下。</p>
<p>MCS锁定由此结构的实例定义：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct mcs_spinlock &#123;</span><br><span class="line">  struct mcs_spinlock *next;</span><br><span class="line">	int locked; /* 1 if lock acquired */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img data-src="/images/2019/04/msc_lock_struct.png" alt="msc_lock_struct"></p>
<p>当CPU出现获取此锁的愿望时，它将提供自己的<code>mcs_spinlock</code>结构。 使用无条件原子交换操作，它将自己的结构的地址存储在锁的<code>next</code>字段中，并将<code>locked</code>置为1，标记为以拿到，产生如下情况：<br><img data-src="/images/2019/04/msc_lock_taken.png" alt="msc_lock_taken"></p>
<p>原子交换将返回<code>next</code>指针的前面值。 由于该指针为空，因此获取CPU知道它已成功获取锁。 一旦完成，锁将是忙，但没有争用。 如果第二个CPU出现并尝试获取锁，它将以相同的方式启动，在主锁的<code>next</code>指针中存储指向其<code>mcs_spinlock</code>结构的指针：<br><img data-src="/images/2019/04/msc_lock_2.png" alt="msc_lock_2"></p>
<p>当第二个CPU在主锁上执行此原子交换时，它也将返回<code>next</code>字段的先前值(指向第一个CPU的mcs_spinlock结构的指针)。非NULL值则告诉第二个CPU锁是不可用，而特定指针的值表示谁在锁的前面。 第二个CPU将通过在CPU1的结构的<code>next</code>字段中存储指向其mcs_spinlock结构的指针来响应这种情况：<br><img data-src="/images/2019/04/msc_lock_3.png" alt="msc_lock_3"></p>
<p>请注意，在主锁上使用原子交换操作意味着只有CPU2可以具有指向CPU1的mcs_spinlock结构的指针。因此，在对该结构进行更改时不需要原子操作，但仍需要进行一些仔细的编程，以确保在正确的时间CPU1可以看到更改。</p>
<p>完成此分配后，CPU2将在其自己的mcs_spinlock结构中旋转锁定值，而不是主锁中的值。因此，它的旋转完全是CPU本地的，根本不会触及主锁。 随着对锁的争用增加，这个过程可以无限期地继续进行，每个CPU将自己置于已经存在的那些后面，并且每个CPU在其自己的锁副本上旋转。 因此，“主”锁中的指针始终指示等待CPU队列的尾部。</p>
<p>当CPU 1最终完成锁定时，它将对主锁执行比较和交换操作，尝试将下一个指针设置为NULL，假设此指针仍指向其自己的结构。 如果该操作成功，则永远不会争用锁定并完成作业。但是，如果某个其他CPU已经更改了该指针，如上所示，则compare-and-swap将失败。 在这种情况下，CPU1根本不会改变主锁; 相反，它将更改CPU2结构中的锁定值并从以下情况中移除自身：<br><img data-src="/images/2019/04/msc_lock_4.png" alt="msc_lock_4"></p>
<p>一旦锁的副本被更改，CPU2将脱离其旋转并成为锁的新所有者。</p>
<p>因此，MCS锁比常规自旋锁稍微复杂一些。但是，增加的复杂性消除了许多缓存行从竞争情况中反弹; 它也完全公平，按照CPU到达的顺序将锁传递给每个CPU。</p>
<h2 id="Qspinlocks"><a href="#Qspinlocks" class="headerlink" title="Qspinlocks"></a>Qspinlocks</h2><p>MCS锁用于实现互斥锁，但它们不会替换现有的排队自旋锁（ticket spinlocks）实现。 其中一个原因是占用内存大小：排队自旋锁适合单个32位字，而MCS锁不适合。 事实证明这很重要：自旋锁被嵌入到许多内核结构中，其中一些（特别是结构页面）不能容忍大小的增加。 如果要在整个内核中使用MCS锁定技术，则需要一些其他方法。</p>
<p>可能合并的那种方法的版本可以在Peter Zijlstra的<span class="exturl" data-url="aHR0cHM6Ly9sd24ubmV0L0FydGljbGVzLzU5MDE4OS8=">“qspinlock”补丁<i class="fa fa-external-link-alt"></i></span>系列中看到，而后者则基于Waiman Long的<span class="exturl" data-url="aHR0cHM6Ly9sd24ubmV0L0FydGljbGVzLzU4ODQyNi8=">实施<i class="fa fa-external-link-alt"></i></span>。 在此补丁集中，每个CPU在众所周知的位置获取四个<code>mcs_spinlock</code>结构的数组。 需要四种结构，因为CPU可能一次尝试获取多个自旋锁：想象如果在线程在锁上旋转时硬件中断进入会发生什么，并且中断处理程序试图锁定它自己的锁 ， 例如。 结构数组允许来自正常，软件中断，硬件中断和不可屏蔽中断上下文的锁定获取尝试保持分开。</p>
<p>32位<code>qspinlock</code>字段：</p>
<ul>
<li>函数的整数计数器，如上所述的<code>locked</code>字段</li>
<li>一个两位<code>index</code>字段，表示每个CPU<code>mcs_spinlock</code>数组中的哪个条目由列表尾部被使用</li>
<li>一个<code>pending</code>位</li>
<li>一个整数字段，用于保存指示队列尾部的CPU编号</li>
</ul>
<p>一个与每个CPU用于自转的值有关。 当下一个CPU获得锁时，它将自动上锁，而不是在每个CPU结构上自旋。 这样，当释放锁时，不需要操作每CPU结构的高速缓存行，从<del>等式</del>中移除一个高速缓存行未命中。 任何后续的CPU都会在它们自己的结构上自旋，直到它们到达队列的头部。</p>
<p><code>pending</code>位将该策略进一步扩展。如果CPU发现锁正忙但没有其他CPU正在等待，它将简单地设置挂起位而不打扰其自己的mcs_spinlock结构。第二个出现的CPU将看到挂起的位，开始构建队列的过程，并像往常一样旋转其锁定字段的本地副本。 服务员之间的缓存行反弹仍然被消除，但第一个服务员也能够避免与访问其自己的mcs_spinlock数组相关的缓存未命中代价。</p>
<h2 id="Other"><a href="#Other" class="headerlink" title="Other"></a>Other</h2><ul>
<li><a href="/downloads/kernel/spinlock/mcs.pdf">spin lock(Ticket lock: A fair lock)</a></li>
</ul>
]]></content>
      <categories>
        <category>Linux内核</category>
      </categories>
      <tags>
        <tag>sync</tag>
        <tag>spinlock</tag>
      </tags>
  </entry>
  <entry>
    <title>Makefile基础语法</title>
    <url>/post/21058.html</url>
    <content><![CDATA[<p>Makefile语法</p>
<span id="more"></span>

<h2 id="x3D-x3D-x3D-x3D"><a href="#x3D-x3D-x3D-x3D" class="headerlink" title="&#x3D; :&#x3D; ?&#x3D; +&#x3D;"></a>&#x3D; :&#x3D; ?&#x3D; +&#x3D;</h2><ol>
<li><code>=</code> 是最基本的赋值</li>
<li><code>:=</code> 是覆盖之前的值</li>
<li><code>?=</code> 是如果没有被赋值过就赋予等号后面的值</li>
<li><code>+=</code> 是添加等号后面的值</li>
</ol>
<h3 id=""><a href="#" class="headerlink" title="="></a><code>=</code></h3><p>make会将整个makefile展开后，再决定变量的值。也就是说，变量的值将会是整个makefile中最后被指定的值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x = foo</span><br><span class="line">y = $(x) bar</span><br><span class="line">x = xyz</span><br><span class="line"></span><br><span class="line">all:</span><br><span class="line">    echo &quot;==: $y&quot;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>结果&#x3D;&#x3D;: xyz bar</p>
</blockquote>
<h3 id="-1"><a href="#-1" class="headerlink" title=":="></a><code>:=</code></h3><p>表示变量的值决定于它在makefile中的位置，而不是整个makefile展开后的最终值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x := foo</span><br><span class="line">y := $(x) bar</span><br><span class="line">x := xyz</span><br><span class="line"></span><br><span class="line">all:</span><br><span class="line">    echo &quot;==: $y&quot;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>结果&#x3D;&#x3D;: foo bar</p>
</blockquote>
<h2 id="解析版本号"><a href="#解析版本号" class="headerlink" title="解析版本号"></a>解析版本号</h2><p>Makefile文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SRC_PATH := $(dir $(lastword $(MAKEFILE_LIST)))</span><br><span class="line">PWD := $(shell pwd)</span><br><span class="line"></span><br><span class="line"># version decode: client.major.minor.release</span><br><span class="line">#	client: the proposed client ID</span><br><span class="line">#       major: increase the major number every year</span><br><span class="line">#       		2020=&gt;K.2.2.0 2021=&gt;K.3.2.0 2022=&gt;K.4.2.0</span><br><span class="line">#       minor: increase the minor number every promotion</span><br><span class="line">#       		K.2.1.0=&gt;K.2.2.0=&gt;K.2.3.0=&gt;...=&gt;K.2.255.0</span><br><span class="line">#       release: change the release number with each release</span><br><span class="line">VERSION_FILE = $(SRC_PATH)/VERSION</span><br><span class="line">GCC_VER_GE9 = $(shell echo `gcc -dumpversion | cut -f1-2 -d.`\&gt;=9 | bc)</span><br><span class="line">GCC_VER_GE6 = $(shell echo `gcc -dumpversion | cut -f1-2 -d.`\&gt;=6 | bc)</span><br><span class="line"></span><br><span class="line">getver = $(shell grep $1 $(VERSION_FILE) | awk -F&#x27;=&#x27; &#x27;&#123;print $$2&#125;&#x27;)</span><br><span class="line">ifneq (&quot;&quot;, &quot;$(wildcard $(VERSION_FILE))&quot;)</span><br><span class="line">  TST_VERSION = $(call getver,client).$(call getver,major).$(call getver,minor).$(call getver,release)</span><br><span class="line">else</span><br><span class="line">  TST_VERSION = staging</span><br><span class="line">endif</span><br><span class="line"></span><br><span class="line">$(info $(GCC_VER_GE9))</span><br><span class="line">$(info $(GCC_VER_GE6))</span><br><span class="line">$(info $(TST_VERSION))</span><br><span class="line"></span><br><span class="line">ifeq ($(GCC_VER_GE9),1)</span><br><span class="line">	subdir-ccflags-y += -fcf-protection=none</span><br><span class="line">endif</span><br><span class="line"></span><br><span class="line">ifeq ($(GCC_VER_GE6),1)</span><br><span class="line">	subdir-ccflags-y += -Wshift-negative-value</span><br><span class="line">endif</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">all:</span><br><span class="line">	echo &quot;Test&quot;</span><br></pre></td></tr></table></figure>

<p>VERSION文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$cat VERSION</span><br><span class="line">client=R</span><br><span class="line">major=3</span><br><span class="line">minor=88</span><br><span class="line">release=1</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Makefile</category>
      </categories>
      <tags>
        <tag>makefile</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux下Anaconda环境搭建</title>
    <url>/post/65273.html</url>
    <content><![CDATA[<p><code>Anaconda</code>是Python的包管理器和环境管理器</p>
<p>优点:</p>
<ul>
<li>Anaconda附带了一大批常用数据科学包，它附带了conda、Python和 150 多个科学包及其依赖项</li>
<li>管理包. Anaconda 是在 conda（一个包管理器和环境管理器）上发展出来的, 包括安装、卸载和更新包</li>
<li>管理环境. 方便创建和使用不同python版本的虚拟环境</li>
</ul>
<span id="more"></span>

<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p>官网:<span class="exturl" data-url="aHR0cHM6Ly93d3cuYW5hY29uZGEuY29tL2Rvd25sb2FkLyNsaW51eA==">https://www.anaconda.com/download/#linux<i class="fa fa-external-link-alt"></i></span></p>
<h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bash Anaconda3-5.3.0-Linux-x86_64.sh</span><br></pre></td></tr></table></figure>
<p>在安装的过程中，会问你安装路径(home目录下)，直接回车选择默认。有个地方问你是否将anaconda安装路径加入到环境变量（.bashrc)中，输入yes，默认的是no</p>
<p>如果选择了默认需要手动将anaconda的路径添加到环境变量</p>
<ul>
<li>打开vi ~&#x2F;.bashrc</li>
<li>添加anaconda的路径下的bin路径到<code>PATH</code><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export PATH=$PATH:$HOME/.tools/x86:$HOME/anaconda3/bin/</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>安装完成后,需要重启终端或者<code>source ~/.bashrc</code></strong></p>
<h3 id="检查安装是否成功"><a href="#检查安装是否成功" class="headerlink" title="检查安装是否成功"></a>检查安装是否成功</h3><p>which conda或conda –version</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$conda --version</span><br><span class="line">conda 4.5.11</span><br></pre></td></tr></table></figure>

<h2 id="使用命令–conda"><a href="#使用命令–conda" class="headerlink" title="使用命令–conda"></a>使用命令–conda</h2><h3 id="帮助"><a href="#帮助" class="headerlink" title="帮助"></a>帮助</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$conda -h</span><br><span class="line">usage: conda [-h] [-V] command ...</span><br><span class="line"></span><br><span class="line">conda is a tool for managing and deploying applications, environments and packages.</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line"></span><br><span class="line">positional arguments:</span><br><span class="line">  command</span><br><span class="line">    clean        Remove unused packages and caches.</span><br><span class="line">    config       Modify configuration values in .condarc. This is modeled</span><br><span class="line">                 after the git config command. Writes to the user .condarc</span><br><span class="line">                 file (/home/xxx/.condarc) by default.</span><br><span class="line">    create       Create a new conda environment from a list of specified</span><br><span class="line">                 packages.</span><br><span class="line">    help         Displays a list of available conda commands and their help</span><br><span class="line">                 strings.</span><br><span class="line">    info         Display information about current conda install.</span><br><span class="line">    install      Installs a list of packages into a specified conda</span><br><span class="line">                 environment.</span><br><span class="line">    list         List linked packages in a conda environment.</span><br><span class="line">    package      Low-level conda package utility. (EXPERIMENTAL)</span><br><span class="line">    remove       Remove a list of packages from a specified conda environment.</span><br><span class="line">    uninstall    Alias for conda remove. See conda remove --help.</span><br><span class="line">    search       Search for packages and display associated information. The</span><br><span class="line">                 input is a MatchSpec, a query language for conda packages.</span><br><span class="line">                 See examples below.</span><br><span class="line">    update       Updates conda packages to the latest compatible version. This</span><br><span class="line">                 command accepts a list of package names and updates them to</span><br><span class="line">                 the latest versions that are compatible with all other</span><br><span class="line">                 packages in the environment. Conda attempts to install the</span><br><span class="line">                 newest versions of the requested packages. To accomplish</span><br><span class="line">                 this, it may update some packages that are already installed,</span><br><span class="line">                 or install additional packages. To prevent existing packages</span><br><span class="line">                 from updating, use the --no-update-deps option. This may</span><br><span class="line">                 force conda to install older versions of the requested</span><br><span class="line">                 packages, and it does not prevent additional dependency</span><br><span class="line">                 packages from being installed. If you wish to skip dependency</span><br><span class="line">                 checking altogether, use the &#x27;--force&#x27; option. This may</span><br><span class="line">                 result in an environment with incompatible packages, so this</span><br><span class="line">                 option must be used with great caution.</span><br><span class="line">    upgrade      Alias for conda update. See conda update --help.</span><br><span class="line"></span><br><span class="line">optional arguments:</span><br><span class="line">  -h, --help     Show this help message and exit.</span><br><span class="line">  -V, --version  Show the conda version number and exit.</span><br><span class="line"></span><br><span class="line">conda commands available from other packages:</span><br><span class="line">  build</span><br><span class="line">  convert</span><br><span class="line">  develop</span><br><span class="line">  env</span><br><span class="line">  index</span><br><span class="line">  inspect</span><br><span class="line">  metapackage</span><br><span class="line">  render</span><br><span class="line">  server</span><br><span class="line">  skeleton</span><br></pre></td></tr></table></figure>

<h3 id="查看已安装的库"><a href="#查看已安装的库" class="headerlink" title="查看已安装的库"></a>查看已安装的库</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$conda list</span><br></pre></td></tr></table></figure>

<h3 id="安装库"><a href="#安装库" class="headerlink" title="安装库"></a>安装库</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$conda install numpy</span><br></pre></td></tr></table></figure>

<h3 id="更新库"><a href="#更新库" class="headerlink" title="更新库"></a>更新库</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$conda update numpy</span><br></pre></td></tr></table></figure>

<h3 id="验证是否安装成功"><a href="#验证是否安装成功" class="headerlink" title="验证是否安装成功"></a>验证是否安装成功</h3><p>进入python环境使用<code>import numpy</code>进行验证,不报任何错误表示安装成功</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$python3.7</span><br><span class="line">Python 3.7.0 (default, Jun 28 2018, 13:15:42)</span><br><span class="line">[GCC 7.2.0] :: Anaconda, Inc. on linux</span><br><span class="line">Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">&gt;&gt;&gt; import numpy</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<h2 id="Conda的环境管理"><a href="#Conda的环境管理" class="headerlink" title="Conda的环境管理"></a>Conda的环境管理</h2><h3 id="虚拟环境"><a href="#虚拟环境" class="headerlink" title="虚拟环境"></a>虚拟环境</h3><p>Conda的环境管理功能允许我们同时安装若干不同版本的Python，并能自由切换。<br>若需要安装Python3.6，此时，我们需要做的操作如下：</p>
<ol>
<li>创建Python虚拟环境test，指定Python版本是3.6（不用管是3.6.x，conda会为我们自动寻找3.6.x中的最新版本）<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">conda create -n test python=3.6</span><br></pre></td></tr></table></figure></li>
<li>激活虚拟环境<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">source activate test</span><br></pre></td></tr></table></figure></li>
<li>关闭虚拟环境<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">source deactivate zeronet</span><br></pre></td></tr></table></figure></li>
<li>删除虚拟环境<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">conda remove -n test --all</span><br></pre></td></tr></table></figure></li>
<li>虚拟环境中安装额外的包<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">conda install -n test [package]</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><span class="exturl" data-url="aHR0cDovL3d3dy5jbmJsb2dzLmNvbS9saWFvaHVpcWlhbmcvcC85MzgwNDE3Lmh0bWw=">conda环境管理<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3o1ODM2MzY3NjIvYXJ0aWNsZS9kZXRhaWxzLzc5MTY2Mzcz">conda命令：管理包、管理环境<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>【转】python练习项目</title>
    <url>/post/9636.html</url>
    <content><![CDATA[<p>转载再次，自己实现练习python<br>本书链接 <span class="exturl" data-url="aHR0cDovL2Fvc2Fib29rLm9yZy9ibG9nLw==">http://aosabook.org/blog/<i class="fa fa-external-link-alt"></i></span><br>目录页：<span class="exturl" data-url="aHR0cDovL2Fvc2Fib29rLm9yZy9ibG9nLw==">http://aosabook.org/blog/<i class="fa fa-external-link-alt"></i></span><br>以下是章节目录，每一章都让你热血澎湃，看完介绍你就向往下读。</p>
<ol>
<li>A Template Engine （<span class="exturl" data-url="aHR0cDovL2Fvc2Fib29rLm9yZy9lbi81MDBML2EtdGVtcGxhdGUtZW5naW5lLmh0bWwlRUYlQkMlODk=">http://aosabook.org/en/500L/a-template-engine.html）<i class="fa fa-external-link-alt"></i></span><br>MVC模型中的view层如何解析html中的静态变量和简单的语句，如下：</li>
</ol>
<p>Welcome, {name}!</p>
<p>Products:</p>
<ul>
{products}
</ul>
<!---more--->

<p>web中的view层不只是html代码，还有支持其他的代码。比如 {products}是一个变量。 同时view层还支持{if} , {for}, {foreach}等等。django，velocity等是如何解析他们的？<br>大牛用不到500行代码告诉你，是如何实现的？ （不是替换，替换需要每次请求都需要解析）</p>
<ol start="2">
<li><p>Web Spreadsheet （<span class="exturl" data-url="aHR0cDovL2Fvc2Fib29rLm9yZy9lbi81MDBML3dlYi1zcHJlYWRzaGVldC5odG1sJUVGJUJDJTg5">http://aosabook.org/en/500L/web-spreadsheet.html）<i class="fa fa-external-link-alt"></i></span><br>web的电子表格如何实现的？ 好像比较简单，但是介绍了 web storage 和 web worker，还是很值得一看的</p>
</li>
<li><p>A Web Crawler <span class="exturl" data-url="aHR0cDovL2Fvc2Fib29rLm9yZy9lbi81MDBML2Etd2ViLWNyYXdsZXItd2l0aC1hc3luY2lvLWNvcm91dGluZXMuaHRtbA==">http://aosabook.org/en/500L/a-web-crawler-with-asyncio-coroutines.html<i class="fa fa-external-link-alt"></i></span><br>不多说，几百行代码实现高效的网络爬虫， 高效！</p>
</li>
<li><p>Static Analysis <span class="exturl" data-url="aHR0cDovL2Fvc2Fib29rLm9yZy9lbi81MDBML3N0YXRpYy1hbmFseXNpcy5odG1s">http://aosabook.org/en/500L/static-analysis.html<i class="fa fa-external-link-alt"></i></span><br>成熟的IDE都有代码检查和代码提示，怎么做的？ 看这章</p>
</li>
<li><p>Clustering by Consensus <span class="exturl" data-url="aHR0cDovL2Fvc2Fib29rLm9yZy9lbi81MDBML2NsdXN0ZXJpbmctYnktY29uc2Vuc3VzLmh0bWw=">http://aosabook.org/en/500L/clustering-by-consensus.html<i class="fa fa-external-link-alt"></i></span><br>分布式系统 paxos原理与实现。不知道paxos说明你没接触过分布式体统，接触过分布式还不懂，说明你只会用分布式系统</p>
</li>
<li><p>A Simple Object Modle <span class="exturl" data-url="aHR0cDovL2Fvc2Fib29rLm9yZy9lbi81MDBML2Etc2ltcGxlLW9iamVjdC1tb2RlbC5odG1s">http://aosabook.org/en/500L/a-simple-object-model.html<i class="fa fa-external-link-alt"></i></span><br>Python是面向对象语言，对象，继承，多态，怎么用代码实现的，不到500行代码，实际不到400 行， 666.。。</p>
</li>
<li><p>An Archaeology-Inspired Database <span class="exturl" data-url="aHR0cDovL2Fvc2Fib29rLm9yZy9lbi81MDBML2FuLWFyY2hhZW9sb2d5LWluc3BpcmVkLWRhdGFiYXNlLmh0bWw=">http://aosabook.org/en/500L/an-archaeology-inspired-database.html<i class="fa fa-external-link-alt"></i></span><br>如何用python实现一个数据库，支持 query，index, transaction， 2，3百行代码和对每个函数的讲解。看完你就知道知道数据库原理，太值了</p>
</li>
<li><p>Dog Bed Database <span class="exturl" data-url="aHR0cDovL2Fvc2Fib29rLm9yZy9lbi81MDBML2RiZGItZG9nLWJlZC1kYXRhYmFzZS5odG1s">http://aosabook.org/en/500L/dbdb-dog-bed-database.html<i class="fa fa-external-link-alt"></i></span><br>类似上一章，不过这次实现的是key-value的非关系型数据库，详细的讲解和2，3百行代码</p>
</li>
<li><p>A 3D Modeller <span class="exturl" data-url="aHR0cDovL2Fvc2Fib29rLm9yZy9lbi81MDBML2EtM2QtbW9kZWxsZXIuaHRtbA==">http://aosabook.org/en/500L/a-3d-modeller.html<i class="fa fa-external-link-alt"></i></span><br>用python实现一个3D设计，显示到屏幕，可以交互。不是很懂，但不明觉厉</p>
</li>
<li><p>A Python Interpreter Written in Python <span class="exturl" data-url="aHR0cDovL2Fvc2Fib29rLm9yZy9lbi81MDBML2EtcHl0aG9uLWludGVycHJldGVyLXdyaXR0ZW4taW4tcHl0aG9uLmh0bWw=">http://aosabook.org/en/500L/a-python-interpreter-written-in-python.html<i class="fa fa-external-link-alt"></i></span><br>手把手教你如何实现python解析器。</p>
</li>
<li><p>A Pedometer in the Real World <span class="exturl" data-url="aHR0cDovL2Fvc2Fib29rLm9yZy9lbi81MDBML2EtcGVkb21ldGVyLWluLXRoZS1yZWFsLXdvcmxkLmh0bWw=">http://aosabook.org/en/500L/a-pedometer-in-the-real-world.html<i class="fa fa-external-link-alt"></i></span><br>你用过手机应用记录你每天走的步数，然后发送到朋友圈吗？ （没有？ 没关系。）这章告诉你如何实现步数记录，怎么算走一步。手机中有加速记，很容易获得你某一时刻在x,y,z三个方向的加速度，用这些参数，如何计算你走了多少步？ 知道吗？ 不知道，看这章，讲解加实现</p>
</li>
<li><p>A Continuous Intergration System <span class="exturl" data-url="aHR0cDovL2Fvc2Fib29rLm9yZy9lbi81MDBML2EtY29udGludW91cy1pbnRlZ3JhdGlvbi1zeXN0ZW0uaHRtbA==">http://aosabook.org/en/500L/a-continuous-integration-system.html<i class="fa fa-external-link-alt"></i></span><br>CI System是一个专门用来测试新代码的系统，根据代码提交记录，拿到新的代码，测试，生成报告。这不是关键，关键是 如果test失败，它还会 恢复，然后从失败的那个点在跑，相当于把出错环境重现了。。。</p>
</li>
</ol>
<p>13 A Rejection Sampler <span class="exturl" data-url="aHR0cDovL2Fvc2Fib29rLm9yZy9lbi81MDBML2EtcmVqZWN0aW9uLXNhbXBsZXIuaHRtbA==">http://aosabook.org/en/500L/a-rejection-sampler.html<i class="fa fa-external-link-alt"></i></span><br>不是很懂，和机器学习相关，如何 计算你赢得象棋比赛的概率，天气对飞机的影响等类似的问题</p>
<p>14 A visual programming toolkit <span class="exturl" data-url="aHR0cDovL2Fvc2Fib29rLm9yZy9lbi81MDBML2Jsb2NrY29kZS1hLXZpc3VhbC1wcm9ncmFtbWluZy10b29sa2l0Lmh0bWw=">http://aosabook.org/en/500L/blockcode-a-visual-programming-toolkit.html<i class="fa fa-external-link-alt"></i></span><br>不太明白</p>
<ol start="15">
<li>A Flow Shop Scheduler <span class="exturl" data-url="aHR0cDovL2Fvc2Fib29rLm9yZy9lbi81MDBML2EtZmxvdy1zaG9wLXNjaGVkdWxlci5odG1s">http://aosabook.org/en/500L/a-flow-shop-scheduler.html<i class="fa fa-external-link-alt"></i></span><br>flowshop调度问题，好像很出名的样子，最优化问题，如何从局部最优解找全局最优解</li>
</ol>
<p>16 Optical Character Recognition<br>几百行代码使用人工神经网络实现识别手写字母。。。</p>
<p>github源码：500lines&#x2F;README.md at master · aosabook&#x2F;500lines · GitHub</p>
<p>作者：小小搬运工<br>链接：<span class="exturl" data-url="aHR0cDovL3d3dy56aGlodS5jb20vcXVlc3Rpb24vMjkzNzI1NzQvYW5zd2VyLzg4NjI0NTA3">http://www.zhihu.com/question/29372574/answer/88624507<i class="fa fa-external-link-alt"></i></span><br>来源：知乎<br>著作权归作者所有，转载请联系作者获得授权。</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python数据处理</title>
    <url>/post/60233.html</url>
    <content><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9zdXBlcmdpcy5naXRib29rcy5pby9naXRfbm90ZWJvb2svY29udGVudC9kb2Mvb3BlbmRhdGFzb3VyY2UuaHRtbA==">https://supergis.gitbooks.io/git_notebook/content/doc/opendatasource.html<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux下GBK文件编码批量转换UTF-8</title>
    <url>/post/38869.html</url>
    <content><![CDATA[<p>Windows默认是<code>GBK</code>编码格式，Linux默认是<code>UTF-8</code>的格式，不同格式之间的乱码处理。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">enca -L zh_CN -x UTF-8 *.c</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="enca-–-文件编码"><a href="#enca-–-文件编码" class="headerlink" title="enca – 文件编码"></a>enca – 文件编码</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">enca -h</span></span><br><span class="line">Usage:  enca [-L LANGUAGE] [OPTION]... [FILE]...</span><br><span class="line">        enconv [-L LANGUAGE] [OPTION]... [FILE]...</span><br></pre></td></tr></table></figure>

<p>用法：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">enca -L zh_CN file      检查文件的编码</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">enca -L zh_CN -x UTF-8 file 将文件编码转换为<span class="string">&quot;UTF-8&quot;</span>编码</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">enca -L zh_CN -x UTF-8 file1 file2 如果不想覆盖原文件可以这样</span></span><br></pre></td></tr></table></figure>

<h2 id="convmv-–-文件名编码"><a href="#convmv-–-文件名编码" class="headerlink" title="convmv – 文件名编码"></a>convmv – 文件名编码</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">convmv -f 源编码 -t 新编码 [选项] 文件名</span></span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>-r 递归处理子文件夹</li>
<li>–notest 真正进行操作，请注意在默认情况下是不对文件进行真实操作的，而只是试验。</li>
<li>–list 显示所有支持的编码</li>
<li>–unescap 可以做一下转义，比如把%20变成空格</li>
</ul>
</blockquote>
<p>示例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">convmv -f GBK -t UTF-8 --notest utf8 filename</span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">find default -<span class="built_in">type</span> f -<span class="built_in">exec</span> convmv -f GBK -t UTF-8 --notest utf8 &#123;&#125; -o utf/&#123;&#125; \;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>批量处理</p>
</blockquote>
]]></content>
      <categories>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>linux下shell基础--获取脚本路径</title>
    <url>/post/12156.html</url>
    <content><![CDATA[<p>在执行脚本时我们或多或少的都要知道当前所在的路径,或者脚本存放的路径,记录几个常用的获取<code>路径</code>的方法</p>
<span id="more"></span>

<h2 id="脚本路径"><a href="#脚本路径" class="headerlink" title="脚本路径"></a>脚本路径</h2><h3 id="cd-dirname-0-pwd"><a href="#cd-dirname-0-pwd" class="headerlink" title="$(cd dirname $0;pwd)"></a>$(cd <code>dirname $0</code>;pwd)</h3><blockquote>
<p>获取当前<code>脚本</code>所在的<code>绝对路径</code></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">basepath=$(cd `dirname $0`; pwd)</span><br></pre></td></tr></table></figure>
<ul>
<li><code>dirname $0</code> :取得当前执行脚本文件的父目录</li>
</ul>
<h3 id="pwd"><a href="#pwd" class="headerlink" title="pwd"></a>pwd</h3><blockquote>
<p>获取当前<code>执行脚本</code>的所在的<code>绝对路径</code></p>
</blockquote>
<h3 id="readlink-f-dirname-0"><a href="#readlink-f-dirname-0" class="headerlink" title="$(readlink -f $(dirname $0))"></a>$(readlink -f $(dirname $0))</h3><blockquote>
<p>获取当前<code>脚本</code>所在的&#96;相对路径&#96;&#96;</p>
</blockquote>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><blockquote>
<p>xxx:主机名</p>
</blockquote>
<ul>
<li>测试脚本</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">basepath1=`pwd`</span><br><span class="line">basepath2=$(cd `dirname $0`; pwd)</span><br><span class="line">basepath3=$(readlink -f $(dirname $0))</span><br><span class="line">basepath4=$(dirname $0)</span><br><span class="line">basepath5=$(dirname $(readlink -f $0))</span><br><span class="line"></span><br><span class="line">echo &quot;basepath1= $basepath1&quot;</span><br><span class="line">echo &quot;basepath2= $basepath2&quot;</span><br><span class="line">echo &quot;basepath3= $basepath3&quot;</span><br><span class="line">echo &quot;basepath4= $basepath4&quot;</span><br><span class="line">echo &quot;basepath5= $basepath5&quot;</span><br></pre></td></tr></table></figure>
<ul>
<li>测试环境</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">14:47 [xxx@xxx-pc]~/test</span><br><span class="line">=====&gt;$ls -l a.sh</span><br><span class="line">lrwxrwxrwx 1 xxx xxx 13 11月 24 14:42 a.sh -&gt; aa/bb/cc/a.sh</span><br></pre></td></tr></table></figure>
<ul>
<li>执行脚本</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">14:48 [xxx@xxx-pc]~</span><br><span class="line">=====&gt;$./test/a.sh</span><br><span class="line">basepath1= /home/xxx</span><br><span class="line">basepath2= /home/xxx/test</span><br><span class="line">basepath3= /home/xxx/test</span><br><span class="line">basepath4= ./test</span><br><span class="line">basepath5= /home/xxx/test/aa/bb/cc</span><br></pre></td></tr></table></figure>

<h2 id="readlink"><a href="#readlink" class="headerlink" title="readlink"></a>readlink</h2><blockquote>
<p>用来找出符号链接所指向的位置</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$readlink .vimrc</span><br><span class="line">/home/xxx/.work_env/vim/vimrc</span><br></pre></td></tr></table></figure>
<ul>
<li><code>-f</code>: 递归跟随给出文件名的所有符号链接以标准化，除最后一个外所有组件必须存在。</li>
</ul>
]]></content>
      <categories>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>linux下shell基础--软连接处理</title>
    <url>/post/55887.html</url>
    <content><![CDATA[<p>软连接的截取和定位</p>
<p>场景: 当前所执行的脚本是连接,获取其实际的路径(位置)</p>
<span id="more"></span>

<h2 id="判断软连接"><a href="#判断软连接" class="headerlink" title="判断软连接"></a>判断软连接</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">if [ -h &quot;a.sh&quot; ]; then</span><br><span class="line">    echo &quot;It&#x27;s a soft connection&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>-h</code>: 软连接</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">PRG=$0</span><br><span class="line">ls=`ls -ld &quot;$PRG&quot;`</span><br><span class="line">link=`expr &quot;$ls&quot; : &#x27;.*-&gt; \(.*\)$&#x27;`</span><br><span class="line"></span><br><span class="line">echo &quot;Current script PRG: $PRG&quot;</span><br><span class="line">echo &quot;Soft connection path link: $link&quot;</span><br><span class="line"></span><br><span class="line">echo &quot;Get the current path: `dirname &quot;$PRG&quot;`&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">判断软连接是否在当前目录下</span></span><br><span class="line">if expr &quot;$link&quot; : &#x27;/.*&#x27; &gt; /dev/null; then</span><br><span class="line">    PRG=&quot;$link&quot;</span><br><span class="line">else</span><br><span class="line">    PRG=&quot;`dirname &quot;$PRG&quot;`/$link&quot;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">echo &quot;Soft connection path link: $link&quot;</span><br><span class="line">echo &quot;Actual script path PRG: $PRG&quot;</span><br></pre></td></tr></table></figure>

<p>测试环境: 保存脚本到xx.sh</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$mkdir -p aa/bb/cc</span><br><span class="line">$mv xx.sh aa/bb/cc</span><br><span class="line">$ln -s aa/bb/cc/xx.sh xx.sh</span><br><span class="line">$ls -ld xx.sh</span><br><span class="line">lrwxrwxrwx 1 xxx xxx 14 12月 21 16:57 xx.sh -&gt; aa/bb/cc/xx.sh</span><br><span class="line">$./xx.sh</span><br></pre></td></tr></table></figure>

<p>执行脚本:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$./xx.sh</span><br><span class="line">Current script PRG: ./xx.sh</span><br><span class="line">Soft connection path link: aa/bb/cc/xx.sh</span><br><span class="line">Get the current path: .</span><br><span class="line">Soft connection path link: aa/bb/cc/xx.sh</span><br><span class="line">Actual script path PRG: ./aa/bb/cc/xx.sh</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title> linux下shell基础——创建可执行文件</title>
    <url>/post/5b5dea38.html</url>
    <content><![CDATA[<p>在平时通过shell脚本部署一个服务和应用时，除了自身的脚本外可能还依赖一些二进制文件，如何将二者一起打包发布，使其变为一个可执行文件，方便后期维护和使用</p>
<p>为实现以上目标可以使用<code>sed</code>实现，具体流程如下：</p>
<ul>
<li>前期使用<code>cat</code>将两个文件合并为一个文件</li>
<li>后期运行是通过<code>sed</code>将两个文件分开，后在具体操作</li>
</ul>
<span id="more"></span>

<h2 id="测试脚本"><a href="#测试脚本" class="headerlink" title="测试脚本"></a>测试脚本</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">echo &quot;This is test shell&quot;</span><br></pre></td></tr></table></figure>

<h2 id="打包测试脚本（如同二进制文件）"><a href="#打包测试脚本（如同二进制文件）" class="headerlink" title="打包测试脚本（如同二进制文件）"></a>打包测试脚本（如同二进制文件）</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar zcvf test.tar.gz test.sh</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在实际应用中可以根据实际需要使用其他二进制文件</p>
</blockquote>
<h2 id="运行测试脚本-run-sh"><a href="#运行测试脚本-run-sh" class="headerlink" title="运行测试脚本(run.sh)"></a>运行测试脚本(run.sh)</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">set -x</span><br><span class="line"></span><br><span class="line">echo &quot;Test shell+bin&quot;</span><br><span class="line">mkdir tmp</span><br><span class="line"></span><br><span class="line">sed -n &#x27;1,/^exit 0$/!p&#x27; $0 &gt; ./tmp/test.tar.gz</span><br><span class="line"></span><br><span class="line">cd tmp</span><br><span class="line">tar zxvf test.tar.gz</span><br><span class="line">bash ./test.sh</span><br><span class="line">cd -</span><br><span class="line"></span><br><span class="line">exit 0</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>sed -n &#39;1,/^exit 0$/!p&#39; $0 &gt; ./tmp/test.tar.gz</code>命令用于将后面<code>cat</code>合并两个文件重新分开，并执行</p>
<ul>
<li>当前文件中除了<code>第一行</code>和<code>exit 0</code>所在行中间的部分，也就是<code>exit 0</code>后面的内容，输出到<code>./tmp/test.tar.gz</code>。<code>$0</code>是当前脚本的名，也就是<code>run.sh</code></li>
<li><code>exit 0</code>在这里可以看作一个分割标志，可以使用其他字符串代替</li>
</ul>
</blockquote>
<h2 id="合并可执行文件"><a href="#合并可执行文件" class="headerlink" title="合并可执行文件"></a>合并可执行文件</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat run.sh test.tar.gz &gt; run-tst.sh</span><br></pre></td></tr></table></figure>

<p>重新生成的运行脚本：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">set -x</span><br><span class="line"></span><br><span class="line">echo &quot;Test shell+bin&quot;</span><br><span class="line">mkdir tmp</span><br><span class="line"></span><br><span class="line">sed -n &#x27;1,/^exit 0$/!p&#x27; $0 &gt; ./tmp/test.tar.gz</span><br><span class="line"></span><br><span class="line">cd tmp</span><br><span class="line">tar zxvf test.tar.gz</span><br><span class="line">bash ./test.sh</span><br><span class="line">cd -</span><br><span class="line"></span><br><span class="line">exit 0</span><br><span class="line">^_?^H^@^@^@^@^@^@^C??AK?0^T^G?^?O?\?[??^M?&amp;?GO?^B?^ZL???d?^S(;&#123;???N?ɛ^H~?֯a?^^??@^YC??^H&lt;??=x?8e???`??????r?????DȀ???I?d&quot;^Cƅ^_^H??u?/^K???(X^[????????????T?Ynu^T?Z^Tә)^U???*^L3r?????^K???ϖ?*??T^W&gt;=iT?</span><br><span class="line">TAS??3^RL?????n?^Ri?~??~?m???^S??[?p֮n?????^O?*;o̕3u^Uf^?Y:Rs]?`??%^????jU?????^B^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@??;??z^]^@(^@^@</span><br></pre></td></tr></table></figure>

<h2 id="shell加密——shc"><a href="#shell加密——shc" class="headerlink" title="shell加密——shc"></a>shell加密——shc</h2><p>将shell脚本转换为一个可执行的二进制文件，可以保护shell脚本中的一些敏感信息和具体的执行步骤。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install shc</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">shc -v -f run-tst.sh</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>linux下批量文件处理-字符串替换</title>
    <url>/post/63603.html</url>
    <content><![CDATA[<p><code>sed</code>进行处理多文件中的字符串替换,可以快速的修改函数名或者变量名.</p>
<span id="more"></span>

<h2 id="sed"><a href="#sed" class="headerlink" title="sed"></a>sed</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sed [-nefri] [动作]</span><br></pre></td></tr></table></figure>
<ul>
<li><code>-n</code> ：使用安静(silent)模式。在一般 sed 的用法中，所有来自 STDIN 的数据一般都会被列出到终端上。但如果加上 -n 参数后，则只有经过sed 特殊处理的那一行(或者动作)才会被列出来。</li>
<li><code>-e</code> ：直接在命令列模式上进行 sed 的动作编辑；</li>
<li><code>-f</code> ：直接将 sed 的动作写在一个文件内， -f filename 则可以运行 filename 内的 sed 动作；</li>
<li><code>-r</code> ：sed 的动作支持的是延伸型正规表示法的语法。(默认是基础正规表示法语法)</li>
<li><code>-i</code> ：直接修改读取的文件内容，而不是输出到终端。</li>
</ul>
<h2 id="单文件替换"><a href="#单文件替换" class="headerlink" title="单文件替换"></a>单文件替换</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sed -i &#x27;s/sockhandle/sock/g&#x27; aa.c</span><br></pre></td></tr></table></figure>

<h2 id="多文件替换"><a href="#多文件替换" class="headerlink" title="多文件替换"></a>多文件替换</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">grep &quot;sockhandle&quot; . -rl | xargs sed -i &#x27;s/sockhandle/sock/g&#x27;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>-rl</code>: 列出文件内容符合指定的范本样式的文件名称</p>
<p><code>-rn</code>: 在显示符合范本样式的那一列之前，标示出该列的列数编号</p>
</blockquote>
]]></content>
      <categories>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>linux shell</tag>
      </tags>
  </entry>
  <entry>
    <title>Shell字符串处理——配置文件获取版本号</title>
    <url>/post/35545.html</url>
    <content><![CDATA[<p>字符串的截取和最后一个字符的删除</p>
<span id="more"></span>

<p>配置文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">software_version  = xxxxxxx-V1.0.2</span><br><span class="line">hdmi_info=1920*1080p@60@48000</span><br><span class="line">wlan_ip=  0.0.0.0</span><br><span class="line">mac_address=  00:00:00:00:00:00</span><br><span class="line">encode_rate  =8192</span><br><span class="line">wfd_mode_tcp  =true</span><br></pre></td></tr></table></figure>

<p>过滤脚本：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">CFGD_CONF=&quot;$&#123;OSDRV_DIR&#125;/conf/db/cfgd.conf&quot;</span><br><span class="line">software_version=`grep &quot;software_version&quot; $&#123;CFGD_CONF&#125; | awk &#x27;&#123;sub(/.$/,&quot;&quot;)&#125;1&#x27; | awk &#x27;&#123;print $3&#125;&#x27;`</span><br><span class="line"></span><br><span class="line">echo &quot;current software_version: [$&#123;software_version&#125;]&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>awk &#39;&#123;sub(/.$/,&quot;&quot;)&#125;1&#39;</code>: 去掉最后一个字符</li>
<li><code>awk &#39;&#123;print $3&#125;&#39;</code>：输出版本号</li>
</ul>
<blockquote>
<p>直接使用grep得到的<code>software_version</code>这行最后一个字符是<code>？</code>，影响输出结果因此要去掉</p>
</blockquote>
]]></content>
      <categories>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>shell常用代码</title>
    <url>/post/3776.html</url>
    <content><![CDATA[<div class="note info"><p>shell常用代码： </p>
</div>

<span id="more"></span>

<h2 id="当前执行所有信息写入文件"><a href="#当前执行所有信息写入文件" class="headerlink" title="当前执行所有信息写入文件"></a>当前执行所有信息写入文件</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">！/bin/bash</span></span><br><span class="line">exec 1&gt;mylog 2&gt;&amp;1</span><br><span class="line">set -xv</span><br><span class="line">free</span><br><span class="line">df -h</span><br><span class="line">pwd</span><br></pre></td></tr></table></figure>

<ul>
<li><p>第二行exec命令用于调用并执行指令的命令。</p>
<ul>
<li>exec命令通常用在shell脚本程序中，可以调用其他的命令</li>
<li>1&gt; mylog  是将标准输出重定向到mylog文件中</li>
<li>2&gt;&amp;1 是将标准错误定向到标准输入，一起定向到mylog中，也就是说，标准输入和标准输出都会到mylog文件中</li>
</ul>
</li>
<li><p>第三行是打开模式开关 -v：显示shell所读取的输入值。-x：执行指令后，会先显示该指令及所下的参数</p>
</li>
</ul>
<h2 id="文件匹配行前-x2F-后插入新行"><a href="#文件匹配行前-x2F-后插入新行" class="headerlink" title="文件匹配行前&#x2F;后插入新行"></a>文件匹配行前&#x2F;后插入新行</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">匹配行前加</span></span><br><span class="line">sed -i &#x27;/searchtext/iNew Line&#x27; file.txt</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">匹配行前后</span></span><br><span class="line">sed -i &#x27;/searchtext/aNew Line&#x27; file.txt</span><br></pre></td></tr></table></figure>


<h2 id="记录所有登录用户操作命令"><a href="#记录所有登录用户操作命令" class="headerlink" title="记录所有登录用户操作命令"></a>记录所有登录用户操作命令</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">PS1=&quot;`whoami`@`hostname`:&quot;&#x27;[$PWD]&#x27;</span><br><span class="line"></span><br><span class="line">history</span><br><span class="line"></span><br><span class="line">USER_IP=`who -u am i 2&gt;/dev/null| awk &#x27;&#123;print $NF&#125;&#x27;|sed -e &#x27;s/[()]//g&#x27;`</span><br><span class="line">if [ &quot;$USER_IP&quot; = &quot;&quot; ]; then</span><br><span class="line">    USER_IP=`hostname`</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">if [ ! -d /tmp/dbasky ]; then</span><br><span class="line">    mkdir /tmp/dbasky</span><br><span class="line">    chmod 777 /tmp/dbasky</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">if [ ! -d /tmp/dbasky/$&#123;LOGNAME&#125; ]; then</span><br><span class="line">    mkdir /tmp/dbasky/$&#123;LOGNAME&#125;</span><br><span class="line">    chmod 300 /tmp/dbasky/$&#123;LOGNAME&#125;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">export HISTSIZE=4096</span><br><span class="line"></span><br><span class="line">DT=`date &quot;+%Y-%m-%d_%H:%M:%S&quot;`</span><br><span class="line"></span><br><span class="line">export HISTFILE=&quot;/tmp/dbasky/$&#123;LOGNAME&#125;/$&#123;USER_IP&#125; dbasky.$DT&quot;</span><br><span class="line"></span><br><span class="line">chmod 600 /tmp/dbasky/$&#123;LOGNAME&#125;/*dbasky* 2&gt;/dev/null</span><br></pre></td></tr></table></figure>
<p>将以上代码添加到<code>/etc/profile</code>中，在系统的&#x2F;tmp新建个dbasky目录，记录所有登陆过系统的用户和IP地址（文件名），每当用户登录&#x2F;退出会创建相应的文件，该文件保存这段用户登录时期内操作历史。</p>
<h2 id="去掉字符串中双引号"><a href="#去掉字符串中双引号" class="headerlink" title="去掉字符串中双引号"></a>去掉字符串中双引号</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo \&quot;hello\&quot; | sed &#x27;s/\&quot;//g&#x27;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">or</span></span><br><span class="line">echo \&quot;hello\&quot; | sed &#x27;s:\&quot;::g&#x27;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">or</span></span><br><span class="line">echo \&quot;hello\&quot; | sed &#x27;s:&quot;::g&#x27;</span><br></pre></td></tr></table></figure>

<h2 id="for循环拼接字符串"><a href="#for循环拼接字符串" class="headerlink" title="for循环拼接字符串"></a>for循环拼接字符串</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在当前目录下创建文本文件temp，如果文件存在则清空文件</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">(&gt; temp)</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="keyword">for</span> 循环将参数追加到当前目录的temp文件，逗号分隔，<span class="built_in">echo</span> -n 不换行</span></span><br><span class="line">for i in $*;do</span><br><span class="line">	((n++))</span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">从第四个开始拼接</span></span><br><span class="line">	if [[ n -gt 3 ]];then</span><br><span class="line">		echo -n $&#123;i&#125;, &gt;&gt; temp</span><br><span class="line">	fi</span><br><span class="line">done</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">h2取tempfile文本里的字符串</span></span><br><span class="line">h2=$(cat temp)</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将字符串最后的一个逗号去掉</span></span><br><span class="line">h2=$&#123;h2%*,&#125;</span><br><span class="line">echo $h2</span><br></pre></td></tr></table></figure>

<h2 id="参数组合执行"><a href="#参数组合执行" class="headerlink" title="参数组合执行"></a>参数组合执行</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">set -- $(getopt -q dbc &quot;$@&quot;)</span><br><span class="line">while [ -n &quot;$1&quot; ]</span><br><span class="line">do</span><br><span class="line">        case &quot;$1&quot; in</span><br><span class="line">            -d) echo &quot;Deploy ...&quot;</span><br><span class="line"></span><br><span class="line">                shift ;;</span><br><span class="line">            -b) echo &quot;Build  ...&quot;</span><br><span class="line"></span><br><span class="line">                shift ;;</span><br><span class="line">            -c) echo &quot;Clean  ...&quot;</span><br><span class="line"></span><br><span class="line">                shift ;;</span><br><span class="line">            --) shift</span><br><span class="line">                break ;;</span><br><span class="line">            -*) echo &quot;Nothing to do&quot;;;</span><br><span class="line">        esac</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<p>以上参数可以单独传递执行，也可以组合一起执行。<br>例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">./m.sh -d</span></span><br><span class="line">Deploy ...</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">./m.sh -c</span></span><br><span class="line">Clean  ...</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">./m.sh -db</span></span><br><span class="line">Deploy ...</span><br><span class="line">Build  ...</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">./m.sh -d -b</span></span><br><span class="line">Deploy ...</span><br><span class="line">Build  ...</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">./m.sh -dbc</span></span><br><span class="line">Deploy ...</span><br><span class="line">Build  ...</span><br><span class="line">Clean  ...</span><br></pre></td></tr></table></figure>


<h2 id="调试技巧"><a href="#调试技巧" class="headerlink" title="调试技巧"></a>调试技巧</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">set -euo pipefail</span><br><span class="line">IFS=$&#x27;\n\t&#x27;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>-e</code>: 如果任何命令返回为非零，则bash 立即退出。如果没有这条命令，那么当前命令失败后，后面的指令还是会执行，这会带来意想不到的bug。</li>
<li><code>-u</code>: 设置后对未定义的任何变量的使用（除了 $* 和 $@）都会报错，程序立即退出。</li>
<li><code>-o</code>: 如果管道中的任何命令失败，该返回代码将用作整个管道的返回代码</li>
<li><code>IFS</code>: bash的默认分隔符是<code>空格</code>、<code>换行</code>、<code>Tab</code>，遍历含有空格的字符串时，会以空格为分隔符，单着常常不是我们想要的。IFS&#x3D;$’\n\t’的作用就是只设置<code>换行</code>和<code>Tab</code>作为分隔符。</li>
</ul>
<h2 id="获取随机MAC地址"><a href="#获取随机MAC地址" class="headerlink" title="获取随机MAC地址"></a>获取随机MAC地址</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo -n 00-60-2F; dd bs=1 count=3 if=/dev/urandom 2&gt;/dev/null |hexdump -v -e &#x27;/1 &quot;-%02X&quot;&#x27;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">or</span></span><br><span class="line"></span><br><span class="line">echo -n 00-60-2F; head -c 3 /dev/urandom | hexdump -v -e &#x27;/1 &quot;-%02X&quot;&#x27;</span><br></pre></td></tr></table></figure>


<h2 id="shell单例模式"><a href="#shell单例模式" class="headerlink" title="shell单例模式"></a>shell单例模式</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">此函数用于获取不到锁时主动退出</span></span><br><span class="line">activate_exit()&#123;</span><br><span class="line">    echo &quot;`date +&#x27;%Y-%m-%d %H:%M:%S&#x27;`--error. get lock fail. there is other instance running. will be exit.&quot;</span><br><span class="line">    exit 1</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">此函数用于申请锁</span></span><br><span class="line">get_lock()&#123;</span><br><span class="line">    lock_file_name=&quot;/tmp/`basename $0`.pid&quot;</span><br><span class="line">    # exec 6&lt;&gt;$&#123;lock_file_name&#125;，即以6作为lock_file_name的文件描述符（file descriptor number）</span><br><span class="line">    # 6是随便取的一个数值，但不要是0/1/2，也不要太大（不要太太包含不能使用$$，$$值可能会比较大）</span><br><span class="line">    # 不用担心如test.sh和test1.sh都使用</span><br><span class="line">    exec 6&lt;&gt;$&#123;lock_file_name&#125;</span><br><span class="line">    # 如果获取不到锁，flock语句就为假，就会执行||后的activate_exit</span><br><span class="line">    # 引入一个activate_exit函数的原因是||后不知道怎么写多个命令</span><br><span class="line">    flock -n 6 || activate_exit</span><br><span class="line">    # 如果没有执行activate_exit，那么程序就可以继续执行</span><br><span class="line">    echo &quot;`date +&#x27;%Y-%m-%d %H:%M:%S&#x27;`--ok. get lock success. there is not any other instance running.&quot;</span><br><span class="line">    # 将当前获取锁的进程id写入文件</span><br><span class="line">    echo &quot;$$&quot;&gt;&amp;6</span><br><span class="line"></span><br><span class="line">    # 设置监听信号</span><br><span class="line">    # 当进程因这些信号致使进程中断时，最后仍要释放锁。类似java等中的final</span><br><span class="line">    # 这个其实不需要，因为进程结束时fd会自动关闭</span><br><span class="line">    # trap &#x27;release_lock &amp;&amp; activate_exit &quot;1002&quot; &quot;break by some signal.&quot;&#x27; 1 2 3 9 15</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">程序主要逻辑</span></span><br><span class="line">exec_main_logic()&#123;</span><br><span class="line">  echo &quot;you can code your main logic in this function.&quot;</span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">这个<span class="built_in">sleep</span>只是为了用于演示，替换成自己的代码即可</span></span><br><span class="line">  sleep 30</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">程序主体逻辑</span></span><br><span class="line">main()&#123;</span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">获取锁</span></span><br><span class="line">  get_lock $@</span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">程序主要逻辑</span></span><br><span class="line">  exec_main_logic</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main $@</span><br></pre></td></tr></table></figure>


<h2 id="wait"><a href="#wait" class="headerlink" title="wait"></a>wait</h2><p><code>wait</code>是用来阻塞当前进程的执行，直至指定的子进程执行结束后，才继续执行。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">tst()</span><br><span class="line">&#123;</span><br><span class="line">  while [ 1 ]</span><br><span class="line">	do</span><br><span class="line">		sleep 1</span><br><span class="line">		echo &quot;Test wait ...&quot;</span><br><span class="line">	done</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tst &amp;</span><br><span class="line"></span><br><span class="line">wait</span><br></pre></td></tr></table></figure>


<h2 id="sh下获取一个随机数"><a href="#sh下获取一个随机数" class="headerlink" title="sh下获取一个随机数"></a>sh下获取一个随机数</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line"></span><br><span class="line">rand()</span><br><span class="line">&#123;</span><br><span class="line">	min=$1</span><br><span class="line">	max=$(($2-$min+1))</span><br><span class="line">	num=$(cat /dev/urandom | head -n 10 | cksum | awk -F &#x27; &#x27; &#x27;&#123;print $1&#125;&#x27;)</span><br><span class="line">	echo $(($num % $max + $min))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rnd=$(rand 100 500)</span><br><span class="line">echo $rnd</span><br></pre></td></tr></table></figure>

<p>获取随机字符串:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">head -c 4 /dev/urandom | od -A n -t x | tr -d &#x27; &#x27;</span><br></pre></td></tr></table></figure>


<h2 id="bash调试命令"><a href="#bash调试命令" class="headerlink" title="bash调试命令"></a>bash调试命令</h2><p>Shell本身提供一些调试方法选项：</p>
<ul>
<li><code>-n</code>: 读一遍脚本中的命令但不执行，用于检查脚本中的语法错误。</li>
<li><code>-v</code>: 一边执行脚本，一边将执行过的脚本命令打印到标准输出。</li>
<li><code>-x</code>: 提供跟踪执行信息，将执行的每一条命令和结果依次打印出来。</li>
</ul>
<p>基本写法： <code>sh [-nxv] 脚本名字</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">bash -x  aa.sh</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">or</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash -x</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="获取centos发行版本"><a href="#获取centos发行版本" class="headerlink" title="获取centos发行版本"></a>获取centos发行版本</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rpm --query centos-release</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">或</span></span><br><span class="line">rpm -q centos-release --qf &#x27;centos %&#123;v&#125;-%&#123;r&#125;\n&#x27;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly91bml4LnN0YWNrZXhjaGFuZ2UuY29tL3F1ZXN0aW9ucy80MTc2NTYvYmFzaC1jb21tYW5kLXRvLWdldC1kaXN0cmlidXRpb24tYW5kLXZlcnNpb24tb25seQ==">https://unix.stackexchange.com/questions/417656/bash-command-to-get-distribution-and-version-only<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">OS_VERSION_ID=$(grep &quot;VERSION_ID=&quot; /etc/*-release | awk -F &quot;=&quot; &#x27;&#123;print $2&#125;&#x27;)</span><br><span class="line">OS_VERSION_ID=$(echo $OS_VERSION_ID | sed &#x27;s/\&quot;//g&#x27;)</span><br><span class="line"></span><br><span class="line">echo &quot;Current OS CentOS $OS_VERSION_ID&quot;</span><br></pre></td></tr></table></figure>

<h2 id="检测IP地址格式是否有效"><a href="#检测IP地址格式是否有效" class="headerlink" title="检测IP地址格式是否有效"></a>检测IP地址格式是否有效</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">function check_ip()</span><br><span class="line">&#123;</span><br><span class="line">    local ip=$1</span><br><span class="line">    info &quot;Check ip: $ip&quot;</span><br><span class="line">    local valid_check=$(echo $ip | awk -F. &#x27;$1&lt;=255&amp;&amp;$2&lt;=255&amp;&amp;$3&lt;=255&amp;&amp;$4&lt;=255&#123;print &quot;yes&quot;&#125;&#x27;)</span><br><span class="line">    if echo $ip | grep -E &quot;^[0-9]&#123;1,3&#125;\.[0-9]&#123;1,3&#125;\.[0-9]&#123;1,3&#125;\.[0-9]&#123;1,3&#125;$&quot;&gt;/dev/null; then</span><br><span class="line">        if [ $&#123;valid_check:-no&#125; == &quot;yes&quot; ]; then</span><br><span class="line">            echo &quot;IP $ip available.&quot;</span><br><span class="line">        else</span><br><span class="line">            error &quot;IP $ip not available!&quot;</span><br><span class="line">            return 311</span><br><span class="line">        fi</span><br><span class="line">    else</span><br><span class="line">        error &quot;IP format error!&quot;</span><br><span class="line">        return 312</span><br><span class="line">    fi</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="if条件中使用正则表达式"><a href="#if条件中使用正则表达式" class="headerlink" title="if条件中使用正则表达式"></a>if条件中使用正则表达式</h2><blockquote>
<p>The &#x3D;~ Regular Expression match operator no longer requires quoting of the pattern within [[ … ]].</p>
</blockquote>
<p>示例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">newip=&quot;192.168.1.1&quot;</span><br><span class="line">if [[ &quot;$newip&quot; =~ ^([0-9]&#123;1,3&#125;.)&#123;3&#125;[0-9]&#123;1,3&#125;$ ]];then</span><br><span class="line">    echo &quot;找到了ip地址&quot;</span><br><span class="line">fi</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">or</span></span><br><span class="line"></span><br><span class="line">if [[ &quot;$tag_version&quot; =~ ^v[0-9].[0-9].[0-9] ]]; then</span><br><span class="line">    echo &quot;$tag_version format is valid.&quot;</span><br><span class="line">else</span><br><span class="line">    echo &quot;$tag_version format error. example: v0.0.1 or v0.0.1a&quot;</span><br><span class="line">    exit 1</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<p><strong>注</strong>： 正则表达式正在[[…]]中不能使用双引号</p>
<h2 id="sed修改配置文件"><a href="#sed修改配置文件" class="headerlink" title="sed修改配置文件"></a>sed修改配置文件</h2><p><code>&quot;/^BOOTPROTO/c BOOTPROTO=static&quot;</code>： 查找出首字符是<code>BOOTPROTO</code>的行，并将其替换为<code>BOOTPROTO=static</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sed -i &quot;/^BOOTPROTO/c BOOTPROTO=static&quot; /etc/sysconfig/network-scripts/ifcfg-eno1</span><br><span class="line">sed -i &quot;/^ONBOOT/c ONBOOT=yes&quot; /etc/sysconfig/network-scripts/ifcfg-eno1</span><br><span class="line">sed -i &quot;/^IPADDR/c IPADDR=192.168.1.11&quot; /etc/sysconfig/network-scripts/ifcfg-eno1</span><br><span class="line">sed -i &#x27;$a NETMASK=255.255.255.0&#x27; /etc/sysconfig/network-scripts/ifcfg-eno1</span><br></pre></td></tr></table></figure>
<blockquote>
<p>配置IP地址</p>
</blockquote>
<h2 id="递归便利整个目录及子目录"><a href="#递归便利整个目录及子目录" class="headerlink" title="递归便利整个目录及子目录"></a>递归便利整个目录及子目录</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">function getdir()&#123;</span><br><span class="line">    echo $1</span><br><span class="line">    for file in $1/*</span><br><span class="line">    do</span><br><span class="line">        if test -f $file</span><br><span class="line">        then</span><br><span class="line">            echo $file</span><br><span class="line">            arr=($&#123;arr[*]&#125; $file)</span><br><span class="line">        else</span><br><span class="line">            getdir $file</span><br><span class="line">        fi</span><br><span class="line">    done</span><br><span class="line">&#125;</span><br><span class="line">getdir ./src</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="built_in">echo</span> <span class="variable">$&#123;arr[@]&#125;</span></span></span><br></pre></td></tr></table></figure>

<h2 id="打开多个窗口并登录ssh执行命令"><a href="#打开多个窗口并登录ssh执行命令" class="headerlink" title="打开多个窗口并登录ssh执行命令"></a>打开多个窗口并登录ssh执行命令</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">run_cmd_shell=$(tempfile)</span><br><span class="line">cat &gt; $run_cmd_shell &lt;&lt; EOF</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">ssh root@192.168.101.55 &#x27;pwd; ls; sleep 10&#x27;</span><br><span class="line">EOF</span><br><span class="line">echo &quot;Run cmd shell: $run_cmd_shell&quot;</span><br><span class="line"></span><br><span class="line">for win in &#123;1..5&#125;</span><br><span class="line">do</span><br><span class="line">    gnome-terminal -t &quot;win-$win&quot; --window -e \</span><br><span class="line">        &quot;bash $&#123;run_cmd_shell&#125;&quot;</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<h2 id="判断是否使用sudo"><a href="#判断是否使用sudo" class="headerlink" title="判断是否使用sudo"></a>判断是否使用sudo</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">root or not</span></span><br><span class="line">if [[ $EUID -ne 0 ]]; then</span><br><span class="line">  SUDO=&#x27;sudo -H&#x27;</span><br><span class="line">else</span><br><span class="line">  SUDO=&#x27;&#x27;</span><br><span class="line">fi</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">SUD0 apt update -y</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>EUID</code>: 在shell启动时被初始化的当前用户的有效ID,如果是root用户<code>EUID=0</code></p>
<blockquote>
<p>shell命令<code>id -u</code>作用相同</p>
</blockquote>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(( EUID != 0 )) &amp;&amp; exec sudo -E -- &quot;$0&quot; &quot;$@&quot;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[ $&#123;UID&#125; -ne 0 ] &amp;&amp; echo &quot;Please run with sudo&quot; &amp;&amp; exit -1</span><br></pre></td></tr></table></figure>

<h2 id="变量的默认值"><a href="#变量的默认值" class="headerlink" title="${:-}变量的默认值"></a>${:-}变量的默认值</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">NUM_THREADS=$&#123;NUM_THREADS:-4&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果NUM_THREADS变量没有被定义，NUM_THREADS值将是<code>：-</code>后得默认值；如果NUM_THREADS变量被定义，NUM_THREADS值将定义值</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">=====&gt;$bash -v aa.sh</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">NUM_THREADS=$&#123;NUM_THREADS:-4&#125;</span><br><span class="line">echo &quot;num-thread=$NUM_THREADS&quot;</span><br><span class="line">num-thread=4</span><br><span class="line"></span><br><span class="line">=====&gt;$bash -v aa.sh</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">NUM_THREADS=8</span><br><span class="line">NUM_THREADS=$&#123;NUM_THREADS:-4&#125;</span><br><span class="line">echo &quot;num-thread=$NUM_THREADS&quot;</span><br><span class="line">num-thread=8</span><br></pre></td></tr></table></figure>

<h2 id="将逗号分隔的字符串转成换行"><a href="#将逗号分隔的字符串转成换行" class="headerlink" title="将逗号分隔的字符串转成换行"></a>将逗号分隔的字符串转成换行</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">OLD_IFS=&quot;$IFS&quot;</span><br><span class="line">IFS=&quot;,&quot;</span><br><span class="line">arr=(`cat 1.txt`)</span><br><span class="line">IFS=&quot;$OLD_IFS&quot;</span><br><span class="line">for s in $&#123;arr[@]&#125;</span><br><span class="line">do</span><br><span class="line">    echo $s | tr -d &#x27;&quot;&#x27;</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line"></span><br><span class="line">cpu_tmp=0</span><br><span class="line">cpu=&quot;&quot;</span><br><span class="line">pmon=&quot;&quot;</span><br><span class="line">cycles=0</span><br><span class="line">data_dir=&quot;test_rpt.$$&quot;</span><br><span class="line"></span><br><span class="line">while read LINE</span><br><span class="line">do</span><br><span class="line">	if echo $LINE|grep &#x27;cpu_tmp&#x27;</span><br><span class="line">	then</span><br><span class="line">		cpu_tmp=$&#123;LINE#*:&#125;</span><br><span class="line">	fi</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	if echo $LINE|grep &#x27;cycles&#x27;</span><br><span class="line">	then</span><br><span class="line">		cycles=$&#123;LINE#*:&#125;</span><br><span class="line">	fi</span><br><span class="line"></span><br><span class="line">done &lt; run.cfg</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">多线程：</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">init fifo file</span></span><br><span class="line">THREAD1DIR=3 &amp;&amp; FIFONR=4 &amp;&amp; FIFONAME=&quot;$$.ff&quot; &amp;&amp; mkfifo $FIFONAME &amp;&amp; str=&quot;exec $FIFONR&lt;&gt; $FIFONAME&quot; &amp;&amp; eval $str &amp;&amp; rm $FIFONAME -f</span><br><span class="line">i=0</span><br><span class="line">while [ $i -lt $THREAD1DIR ]; do</span><br><span class="line">	i=$((i+1))</span><br><span class="line">	echo</span><br><span class="line">done &gt;&amp; $FIFONR</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="keyword">for</span> (( i=0; i&lt;<span class="variable">$THREAD1DIR</span>; i++ )); <span class="keyword">do</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">start <span class="built_in">test</span> 1st level <span class="built_in">dir</span></span></span><br><span class="line">all=`find . -maxdepth 1 -name &quot;?????\.*&quot;`</span><br><span class="line">for i in $all</span><br><span class="line">do</span><br><span class="line">	if [ -d $i ]</span><br><span class="line">	then</span><br><span class="line">		read</span><br><span class="line">		( echo $i&quot; 1runing&quot; &amp;&amp; cd $i/ &amp;&amp; ./$i&#x27;.run&#x27;.sh $cycles &amp;&amp; cd - &amp;&amp; echo &gt;&amp; $FIFONR ) &amp;</span><br><span class="line">	fi</span><br><span class="line">done &lt;&amp; $FIFONR</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">rm</span> fifo file</span></span><br><span class="line">wait &amp;&amp; str=&quot;exec $FIFONR&gt;&amp;-&quot; &amp;&amp; eval $str</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">get <span class="built_in">log</span></span></span><br><span class="line">[ -d $data_dir ] &amp;&amp; rm -rf $data_dir || mkdir $data_dir &amp;&amp; cp run.cfg $data_dir -f</span><br><span class="line"></span><br><span class="line">for i in $all</span><br><span class="line">do</span><br><span class="line">	if [ -d $i ]</span><br><span class="line">	then</span><br><span class="line">		des_dir=$data_dir&#x27;/&#x27;$i&#x27;/&#x27;</span><br><span class="line">		mkdir $des_dir</span><br><span class="line">		src_dir=&#x27;./&#x27;$i&#x27;/&#x27;</span><br><span class="line">		file_path=`find $src_dir/ -name *_*.log`</span><br><span class="line">		echo $file_path</span><br><span class="line">		mv $file_path $des_dir</span><br><span class="line">	fi</span><br><span class="line">done</span><br><span class="line">chmod 777 &#x27;./&#x27;$data_dir -R</span><br><span class="line">rm *.ff -f</span><br></pre></td></tr></table></figure>

<h2 id="修改文件名后缀"><a href="#修改文件名后缀" class="headerlink" title="修改文件名后缀"></a>修改文件名后缀</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">for file in `find . -name &quot;*.f90&quot;`</span><br><span class="line">do</span><br><span class="line">	newfile=$&#123;file%.*&#125;.f77</span><br><span class="line"><span class="meta prompt_">	#</span><span class="language-bash"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$newfile</span>&quot;</span></span></span><br><span class="line">	mv $file $newfile</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xvbmd4aWJlbmRpL2FydGljbGUvZGV0YWlscy82Mzg3NzMy">Linux批量更改文件后缀名<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<h2 id="检查网段IP占用情况"><a href="#检查网段IP占用情况" class="headerlink" title="检查网段IP占用情况"></a>检查网段IP占用情况</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">up=0</span><br><span class="line">down=0</span><br><span class="line"></span><br><span class="line">for siteip in $(seq 1 255)</span><br><span class="line">do</span><br><span class="line"><span class="meta prompt_">	#</span><span class="language-bash">site=<span class="string">&quot;192.168.2.<span class="variable">$&#123;siteip&#125;</span>&quot;</span></span></span><br><span class="line">	site=&quot;172.16.189.$&#123;siteip&#125;&quot;</span><br><span class="line">	ping -c1 -W1 $&#123;site&#125; &amp;&gt; /dev/null</span><br><span class="line">	if [ &quot;$?&quot; == &quot;0&quot; ]; then</span><br><span class="line">		up=$[$up+1]</span><br><span class="line">		echo &quot;$site is UP, cnt=$up&quot;</span><br><span class="line">	else</span><br><span class="line">		down=$[$down+1]</span><br><span class="line">		echo &quot;$site is DOWN, cnt=$down&quot;</span><br><span class="line">	fi</span><br><span class="line">done</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">除法</span></span><br><span class="line">alive=`awk &#x27;BEGIN&#123;printf &quot;%.2f\n&quot;,(&#x27;$up&#x27;/&#x27;$(($up + $down))&#x27;)&#125;&#x27;`</span><br><span class="line"></span><br><span class="line">echo &quot;up:$up, down:$down, alive:$alive&quot;</span><br></pre></td></tr></table></figure>

<h2 id="提取本地IP"><a href="#提取本地IP" class="headerlink" title="提取本地IP"></a>提取本地IP</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ip=`ifconfig | grep &quot;inet &quot; | grep -v &quot;127.0.0.1&quot;| awk &#x27;&#123;print $2&#125;&#x27;`</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>-v</code>: 排除</p>
</blockquote>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li>[shell中各种括号的作用()、(())、[]、[[]]、{}](<span class="exturl" data-url="aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdGFpeWFuZzE5ODc5MTIvYXJ0aWNsZS9kZXRhaWxzLzM5NTUxMzg1">http://blog.csdn.net/taiyang1987912/article/details/39551385<i class="fa fa-external-link-alt"></i></span>)</li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vYmFycnljaGlhby9hcmNoaXZlLzIwMTIvMTAvMjIvMjczMzIxMC5odG1s">shell变量详解<i class="fa fa-external-link-alt"></i></span></li>
</ol>
]]></content>
      <categories>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>shell脚本调试——bash</title>
    <url>/post/18379.html</url>
    <content><![CDATA[<p>shell脚本调试：</p>
<span id="more"></span>

<h2 id="Bash"><a href="#Bash" class="headerlink" title="Bash"></a>Bash</h2><p>帮助信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$bash -c &quot;help set&quot;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set: set [-abefhkmnptuvxBCHP] [-o option-name] [--] [arg ...]</span><br><span class="line">    Set or unset values of shell options and positional parameters.</span><br><span class="line"></span><br><span class="line">    Change the value of shell attributes and positional parameters, or</span><br><span class="line">    display the names and values of shell variables.</span><br><span class="line"></span><br><span class="line">    Options:</span><br><span class="line">      -a  Mark variables which are modified or created for export.</span><br><span class="line">      -b  Notify of job termination immediately.</span><br><span class="line">      -e  Exit immediately if a command exits with a non-zero status.</span><br><span class="line">      -f  Disable file name generation (globbing).</span><br><span class="line">      -h  Remember the location of commands as they are looked up.</span><br><span class="line">      -k  All assignment arguments are placed in the environment for a</span><br><span class="line">          command, not just those that precede the command name.</span><br><span class="line">      -m  Job control is enabled.</span><br><span class="line">      -n  Read commands but do not execute them.</span><br><span class="line">      -o option-name</span><br><span class="line">          Set the variable corresponding to option-name:</span><br><span class="line">              allexport    same as -a</span><br><span class="line">              braceexpand  same as -B</span><br><span class="line">              emacs        use an emacs-style line editing interface</span><br><span class="line">              errexit      same as -e</span><br><span class="line">              errtrace     same as -E</span><br><span class="line">              functrace    same as -T</span><br><span class="line">              hashall      same as -h</span><br><span class="line">              histexpand   same as -H</span><br><span class="line">              history      enable command history</span><br><span class="line">              ignoreeof    the shell will not exit upon reading EOF</span><br><span class="line">              interactive-comments</span><br><span class="line">                           allow comments to appear in interactive commands</span><br><span class="line">              keyword      same as -k</span><br><span class="line">              monitor      same as -m</span><br><span class="line">              noclobber    same as -C</span><br><span class="line">              noexec       same as -n</span><br><span class="line">              noglob       same as -f</span><br><span class="line">              nolog        currently accepted but ignored</span><br><span class="line">              notify       same as -b</span><br><span class="line">              nounset      same as -u</span><br><span class="line">              onecmd       same as -t</span><br><span class="line">              physical     same as -P</span><br><span class="line">              pipefail     the return value of a pipeline is the status of</span><br><span class="line">                           the last command to exit with a non-zero status,</span><br><span class="line">                           or zero if no command exited with a non-zero status</span><br><span class="line">              posix        change the behavior of bash where the default</span><br><span class="line">                           operation differs from the Posix standard to</span><br><span class="line">                           match the standard</span><br><span class="line">              privileged   same as -p</span><br><span class="line">              verbose      same as -v</span><br><span class="line">              vi           use a vi-style line editing interface</span><br><span class="line">              xtrace       same as -x</span><br><span class="line">      -p  Turned on whenever the real and effective user ids do not match.</span><br><span class="line">          Disables processing of the $ENV file and importing of shell</span><br><span class="line">          functions.  Turning this option off causes the effective uid and</span><br><span class="line">          gid to be set to the real uid and gid.</span><br><span class="line">      -t  Exit after reading and executing one command.</span><br><span class="line">      -u  Treat unset variables as an error when substituting.</span><br><span class="line">      -v  Print shell input lines as they are read.</span><br><span class="line">      -x  Print commands and their arguments as they are executed.</span><br><span class="line">      -B  the shell will perform brace expansion</span><br><span class="line">      -C  If set, disallow existing regular files to be overwritten</span><br><span class="line">          by redirection of output.</span><br><span class="line">      -E  If set, the ERR trap is inherited by shell functions.</span><br><span class="line">      -H  Enable ! style history substitution.  This flag is on</span><br><span class="line">          by default when the shell is interactive.</span><br><span class="line">      -P  If set, do not resolve symbolic links when executing commands</span><br><span class="line">          such as cd which change the current directory.</span><br><span class="line">      -T  If set, the DEBUG trap is inherited by shell functions.</span><br><span class="line">      --  Assign any remaining arguments to the positional parameters.</span><br><span class="line">          If there are no remaining arguments, the positional parameters</span><br><span class="line">          are unset.</span><br><span class="line">      -   Assign any remaining arguments to the positional parameters.</span><br><span class="line">          The -x and -v options are turned off.</span><br><span class="line"></span><br><span class="line">    Using + rather than - causes these flags to be turned off.  The</span><br><span class="line">    flags can also be used upon invocation of the shell.  The current</span><br><span class="line">    set of flags may be found in $-.  The remaining n ARGs are positional</span><br><span class="line">    parameters and are assigned, in order, to $1, $2, .. $n.  If no</span><br><span class="line">    ARGs are given, all shell variables are printed.</span><br><span class="line"></span><br><span class="line">    Exit Status:</span><br><span class="line">    Returns success unless an invalid option is given.</span><br></pre></td></tr></table></figure>

<ul>
<li><code>-x</code>: 执行过程中打印出执行的命令。</li>
<li><code>-v</code>: 执行时打印脚本中的所有信息。</li>
</ul>
<h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">bash -x a.sh</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>Shell获取git信息和编译时间</title>
    <url>/post/56769.html</url>
    <content><![CDATA[<p>记录软件版本每一个编译的时间和log信息：</p>
<span id="more"></span>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line">GIT_SHA1=`(git show-ref --head --hash=8 2&gt; /dev/null || echo 00000000) | head -n1`</span><br><span class="line">GIT_DIRTY=`git diff --no-ext-diff 2&gt; /dev/null | wc -l`</span><br><span class="line">BUILD_ID=`uname -n`&quot;-&quot;`date +%Y%m%d%H%M%S`</span><br><span class="line">test -f release.h || touch release.h</span><br><span class="line">(cat release.h | grep SHA1 | grep $GIT_SHA1) &amp;&amp; \</span><br><span class="line">(cat release.h | grep DIRTY | grep $GIT_DIRTY) &amp;&amp; exit 0 # Already up-to-date</span><br><span class="line">echo &quot;#define REDIS_GIT_SHA1 \&quot;$GIT_SHA1\&quot;&quot; &gt; release.h</span><br><span class="line">echo &quot;#define REDIS_GIT_DIRTY \&quot;$GIT_DIRTY\&quot;&quot; &gt;&gt; release.h</span><br><span class="line">echo &quot;#define REDIS_BUILD_ID \&quot;$BUILD_ID\&quot;&quot; &gt;&gt; release.h</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="built_in">touch</span> release.c <span class="comment"># Force recompile of release.c</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>结果：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define REDIS_GIT_SHA1 &quot;ed5b0648&quot;</span><br><span class="line">#define REDIS_GIT_DIRTY &quot;13&quot;</span><br><span class="line">#define REDIS_BUILD_ID &quot;xxxx-pc-20180918152335&quot;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>release.h</p>
</blockquote>
</li>
</ul>
]]></content>
      <categories>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>正则表达式(regular expression) [^,*]与[^,]*区别</title>
    <url>/post/10189.html</url>
    <content><![CDATA[<h3 id="正则表达式-Regular-Expression-与-区别："><a href="#正则表达式-Regular-Expression-与-区别：" class="headerlink" title="正则表达式(Regular Expression) [^,*]与[^,]*区别："></a>正则表达式(Regular Expression) [^,*]与[^,]*区别：</h3><ol>
<li>$ sed ‘s&#x2F;[^,]*&#x2F;{&amp;}&#x2F;‘ example.txt</li>
</ol>
<p>  <img data-src="/assets/img/article-image/2014-03-06/01.png" alt="01"><br>  2. $ sed ‘s&#x2F;[^,*]&#x2F;{&amp;}&#x2F;‘ example.txt</p>
<p>  <img data-src="/assets/img/article-image/2014-03-06/02.png" alt="02"></p>
<h4 id="使用此特殊字符匹配任意字符或字符串的重复多次表达式。例如：compu-t将匹配字符u一次或多次。"><a href="#使用此特殊字符匹配任意字符或字符串的重复多次表达式。例如：compu-t将匹配字符u一次或多次。" class="headerlink" title="使用此特殊字符匹配任意字符或字符串的重复多次表达式。例如：compu*t将匹配字符u一次或多次。"></a>使用此特殊字符匹配任意字符或字符串的重复多次表达式。例如：compu*t将匹配字符u一次或多次。</h4><p>  <img data-src="/assets/img/article-image/2014-03-06/03.png" alt="03"></p>
<ul>
<li>只匹配[ ] 内字符。可以是一个单字符，也可以是字符序列</li>
<li>[]在指定模式匹配的范围或限制方面很有用。结合使用*与[ ]更是有益，</li>
<li>例如:[ A - Z a - Z ] *将匹配所有单词<br> <em>注意</em> :^符号的使用，当直接用在第一个括号里，意指否定或不匹配括号里内容。</li>
</ul>
<h4 id="如-a-zA-Z-匹配任一非字母型字符，而-0-9-匹配任一非数字型字符。"><a href="#如-a-zA-Z-匹配任一非字母型字符，而-0-9-匹配任一非数字型字符。" class="headerlink" title="如:[^a-zA-Z]匹配任一非字母型字符，而[ ^ 0 - 9 ]匹配任一非数字型字符。"></a>如:[^a-zA-Z]匹配任一非字母型字符，而[ ^ 0 - 9 ]匹配任一非数字型字符。</h4><ul>
<li>$ sed ‘s&#x2F;[^,*]&#x2F;{&amp;}&#x2F;‘ example.txt</li>
<li>表示把开头不是一个或多个“，”时的第一个字符加上{}</li>
</ul>
<p>  <img data-src="/assets/img/article-image/2014-03-06/04.png" alt="04"></p>
<p>只对第一个字符“1”加上了{}，主要原因是[ ]内的字符一次只匹配一个。</p>
<ul>
<li><p>表示把不是“，”之前的所有字符串，加上{}</p>
<p><img data-src="/assets/img/article-image/2014-03-06/05.png" alt="05"></p>
</li>
</ul>
<h3 id="截取字符串"><a href="#截取字符串" class="headerlink" title="截取字符串"></a>截取字符串</h3><ul>
<li>原文本文件 example.txt<br>102,John Smith,IT Manager<br>103,Raj Reddy,Sysadmin<br>104,Anand Ram,Developer<br>105,Jane Miller,Sales Manager<br>,123<br>,lin,feng<br>,,,sss</li>
</ul>
<h4 id="截取非数字的所有字符-–失败"><a href="#截取非数字的所有字符-–失败" class="headerlink" title="截取非数字的所有字符  –失败"></a>截取非数字的所有字符  –失败</h4><ul>
<li><p>$ sed ‘s&#x2F;[^0-9]*&#x2F; &#x2F;‘ example.txt</p>
<p><img data-src="/assets/img/article-image/2014-03-06/06.png" alt="06"></p>
</li>
</ul>
<ul>
<li>失败原因：[^0-9]表示匹配一非数字型字符，而[^0-9]*表示一或多个非数字型字符，但只要有一个字符匹配成立，就进行替换。</li>
</ul>
<h4 id="截取非数字的所有字符-–成功"><a href="#截取非数字的所有字符-–成功" class="headerlink" title="截取非数字的所有字符  –成功"></a>截取非数字的所有字符  –成功</h4><ul>
<li><p>$ sed ‘s&#x2F;[^0-9].*&#x2F; &#x2F;‘ example.txt</p>
<p><img data-src="/assets/img/article-image/2014-03-06/07.png" alt="07"></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>linux系统下修改uboot环境变量</title>
    <url>/post/c90e9769.html</url>
    <content><![CDATA[<p>在linux系统下修改uboot环境变量，uboot自带工具<code>fw_printenv</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ls tools/env</span><br><span class="line">crc32.c  ctype.c  env_attr.c  env_flags.c  fw_env.c  fw_env.config  fw_env.h  fw_env_main.c  fw_env_private.h  linux_string.c  Makefile  README</span><br></pre></td></tr></table></figure>

<span id="more"></span>


<ul>
<li>编译</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">make CROSS_COMPILE=aarch64-none-linux-gnu- envtools</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>uboot</category>
      </categories>
      <tags>
        <tag>uboot</tag>
      </tags>
  </entry>
  <entry>
    <title>[转]An introduction to Mesa’s GLSL compiler (I)[翻译]</title>
    <url>/post/af8dbdc1.html</url>
    <content><![CDATA[<p>原文：<span class="exturl" data-url="aHR0cHM6Ly9ibG9ncy5pZ2FsaWEuY29tL2l0b3JhbC8yMDE1LzAzLzAzL2FuLWludHJvZHVjdGlvbi10by1tZXNhcy1nbHNsLWNvbXBpbGVyLWkv">https://blogs.igalia.com/itoral/2015/03/03/an-introduction-to-mesas-glsl-compiler-i/<i class="fa fa-external-link-alt"></i></span></p>
<span id="more"></span>

<h2 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2><p>在我的上一篇文章中，我解释了现代 3D 管道是可编程的，以及这如何影响图形驱动程序。在接下来的文章中，我们将通过查看 Mesa GLSL 编译器的不同部分来更深入地研究这个方面。具体来说，这篇文章将涵盖 GLSL 解析器、Mesa IR 以及内置变量和函数。</p>
<h2 id="GLSL解析器"><a href="#GLSL解析器" class="headerlink" title="GLSL解析器"></a>GLSL解析器</h2><p>解析器的工作是处理通过glShaderSource提供的shader源代码字符串，并将其转换为存储在RAM中的合适的二进制表示，并可以在后期由编译器的其他部分有效处理。</p>
<p>解析器由一组Lex&#x2F;Yacc规则组成，用于处理传入的shader source。词法分析器 ( glsl_parser.ll ) 负责对源代码进行标记，解析器 ( glsl_parser.yy ) 为词法分析器阶段识别的标记流添加含义。</p>
<p>类似地，就像在C或c++中一样，GLSL包含了一个预处理程序，在主解析器启动之前，它将遍历着色器源代码。Mesa的GLSL预处理程序的实现存在于src&#x2F;glsl&#x2F;glcpp中，也基于Lex&#x2F;Yacc规则。</p>
<p>解析器的输出是一个驻留在RAM内存中的抽象语法树 (AST)，它是着色器源代码的二进制表示。生成这棵树的节点在src&#x2F;glsl&#x2F;ast.h中定义。</p>
<p>对于熟悉所有Lex&#x2F;Yacc内容的人来说，Mesa 中的解析器实现应该足够熟悉了。</p>
<p>下一步是将AST转换为更适合驱动程序处理的那种操作,这种新的表示，称为IR（中间表示），在 Mesa 中通常被称为Mesa IR、GLSL IR或简称HIR。</p>
<p>在AST到Mesa IR转化是通过在代码src&#x2F;glsl&#x2F;ast_to_hir.cpp。</p>
<h2 id="Mesa-IR"><a href="#Mesa-IR" class="headerlink" title="Mesa IR"></a>Mesa IR</h2><p>Mesa IR是在编译器中使用的主要数据结构。编译器所做的大部分工作可以总结为：</p>
<ul>
<li>IR 中的优化</li>
<li>修改 IR 以更好地&#x2F;更容易地与GPU硬件集成</li>
<li>将多个着色器（多个 IR 实例）链接到一个程序中。</li>
<li>从 IR 为目标 GPU 生成本机汇编代码</li>
</ul>
<p>正如我们所见，Mesa IR 是编译器必须完成的所有工作的核心，因此了解它是如何设置的对于在 Mesa 的这一部分工作是必要的。</p>
<p>Mesa IR 树中的节点在src&#x2F;glsl&#x2F;ir.h中定义。让我们来看看最重要的：</p>
<p>在 IR 节点的类层次结构的顶部，我们有exec_node，这是 Mesa 将独立指令链接到列表中以制作程序的方式。这意味着每条指令都有上一个和下一个指针，分别指向它之前和之后的指令。所以，我们有ir_instruction，树中所有节点的基类，继承自exec_node。</p>
<p>另一个重要节点是ir_rvalue，它是用于表示表达式的基类。通常，任何可以放在赋值右侧的东西都是ir_rvalue。ir_rvalue 的子类包括ir_expression，用于表示各种一元、二元或三元运算（支持的运算符在ir_expression_operation枚举中定义），ir_texture，用于表示纹理查找等纹理操作，ir_swizzle，用于swizzling向量中的值，所有ir_dereference 节点，用于访问存储在变量、数组、结构等中的值和ir_constant, 用于表示所有基本类型（bool、float、integer 等）的常量。</p>
<p>我们还有ir_variable，它代表着色器代码中的变量。请注意，ir_variable的定义非常大……事实上，在大型游戏&#x2F;应用程序中编译着色器时，这是对编译器内存占用影响最大的节点。另请注意，IR 区分变量和变量取消引用（查看变量值的事实），它们表示为ir_rvalue。</p>
<p>同样，IR 也为其他语言结构定义了节点，如ir_loop、ir_if、ir_assignment等。</p>
<p>调试 IR 并不容易，因为在 IR 节点中表示着色器程序可能非常复杂，无法使用调试器进行遍历和检查。为了帮助解决这个问题，Mesa 提供了将 IR 打印为人类可读文本格式的方法。我们可以通过使用环境变量MESA_GLSL&#x3D;dump来启用它。这将指示 Mesa 打印原始着色器源代码及其 IR 表示。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">$ MESA_GLSL=dump ./test_program</span><br><span class="line"></span><br><span class="line">GLSL source for vertex shader 1:</span><br><span class="line">#version 140</span><br><span class="line">#extension GL_ARB_explicit_attrib_location : enable</span><br><span class="line"></span><br><span class="line">layout(location = 0) in vec3 inVertexPosition;</span><br><span class="line">layout(location = 1) in vec3 inVertexColor;</span><br><span class="line"></span><br><span class="line">uniform mat4 MVP;</span><br><span class="line">smooth out vec3 out0;</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">  gl_Position = MVP * vec4(inVertexPosition, 1);</span><br><span class="line">  out0 = inVertexColor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GLSL IR for shader 1:</span><br><span class="line">(</span><br><span class="line">(declare (sys ) int gl_InstanceID)</span><br><span class="line">(declare (sys ) int gl_VertexID)</span><br><span class="line">(declare (shader_out ) (array float 0) gl_ClipDistance)</span><br><span class="line">(declare (shader_out ) float gl_PointSize)</span><br><span class="line">(declare (shader_out ) vec4 gl_Position)</span><br><span class="line">(declare (uniform ) (array vec4 56) gl_CurrentAttribFragMESA)</span><br><span class="line">(declare (uniform ) (array vec4 33) gl_CurrentAttribVertMESA)</span><br><span class="line">(declare (uniform ) gl_DepthRangeParameters gl_DepthRange)</span><br><span class="line">(declare (uniform ) int gl_NumSamples)</span><br><span class="line">(declare () int gl_MaxVaryingComponents)</span><br><span class="line">(declare () int gl_MaxClipDistances)</span><br><span class="line">(declare () int gl_MaxFragmentUniformComponents)</span><br><span class="line">(declare () int gl_MaxVaryingFloats)</span><br><span class="line">(declare () int gl_MaxVertexUniformComponents)</span><br><span class="line">(declare () int gl_MaxDrawBuffers)</span><br><span class="line">(declare () int gl_MaxTextureImageUnits)</span><br><span class="line">(declare () int gl_MaxCombinedTextureImageUnits)</span><br><span class="line">(declare () int gl_MaxVertexTextureImageUnits)</span><br><span class="line">(declare () int gl_MaxVertexAttribs)</span><br><span class="line">(declare (shader_in ) vec3 inVertexPosition)</span><br><span class="line">(declare (shader_in ) vec3 inVertexColor)</span><br><span class="line">(declare (uniform ) mat4 MVP)</span><br><span class="line">(declare (shader_out smooth) vec3 out0)</span><br><span class="line">(function main</span><br><span class="line">  (signature void</span><br><span class="line">    (parameters</span><br><span class="line">    )</span><br><span class="line">    (</span><br><span class="line">      (declare (temporary ) vec4 vec_ctor)</span><br><span class="line">      (assign  (w) (var_ref vec_ctor)  (constant float (1.000000)) )</span><br><span class="line">      (assign  (xyz) (var_ref vec_ctor)  (var_ref inVertexPosition) )</span><br><span class="line">      (assign  (xyzw) (var_ref gl_Position)</span><br><span class="line">            (expression vec4 * (var_ref MVP) (var_ref vec_ctor) ) )</span><br><span class="line">      (assign  (xyz) (var_ref out0)  (var_ref inVertexColor) )</span><br><span class="line">    ))</span><br><span class="line">)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>但是请注意，我们得到的 IR 表示不是解析器生成的。正如我们稍后将看到的，Mesa 将通过多种方式修改初始 IR，例如通过添加不同类型的优化，因此我们看到的 IR 是所有这些处理通过原始 IR 后的结果。Mesa 将这个经过后处理的 IR 版本称为LIR（低级 IR），并将解析器生成的 IR 的初始版本称为HIR（高级 IR）。如果我们想打印HIR（或 IR 转换为最终LIR 的任何中间版本），我们可以编辑编译器并根据需要添加对 _mesa_print_ir 的调用。</p>
<h2 id="穿越-Mesa-IR"><a href="#穿越-Mesa-IR" class="headerlink" title="穿越 Mesa IR"></a>穿越 Mesa IR</h2><p>我们之前提到过编译器的一些工作（实际上是很大一部分）与 IR 的优化和修改有关。这意味着编译器需要遍历 IR 树并识别与此类操作相关的子树。为了实现这一点，Mesa 使用了访问者设计模式。</p>
<p>基本上，这个想法是我们有一个可以遍历 IR 树的访问者对象，我们可以定义当它找到特定节点时我们想要执行的行为。</p>
<p>例如，在src&#x2F;glsl&#x2F;linker.cpp 中有一个非常简单的例子：find_deref_visitor，它检测变量是否被读取。这涉及遍历 IR，识别ir_dereference_variable节点（访问变量值的节点）并检查该变量的名称是否与我们要查找的名称匹配。这是访问者类定义：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Visitor that determines whether or not a variable is ever read.</span><br><span class="line"> */</span><br><span class="line">class find_deref_visitor : public ir_hierarchical_visitor &#123;</span><br><span class="line">public:</span><br><span class="line">   find_deref_visitor(const char *name)</span><br><span class="line">      : name(name), found(false)</span><br><span class="line">   &#123;</span><br><span class="line">      /* empty */</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   virtual ir_visitor_status visit(ir_dereference_variable *ir)</span><br><span class="line">   &#123;</span><br><span class="line">      if (strcmp(this-&gt;name, ir-&gt;var-&gt;name) == 0) &#123;</span><br><span class="line">         this-&gt;found = true;</span><br><span class="line">         return visit_stop;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      return visit_continue;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   bool variable_found() const</span><br><span class="line">   &#123;</span><br><span class="line">      return this-&gt;found;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">   const char *name;       /**&lt; Find writes to a variable with this name. */</span><br><span class="line">   bool found;             /**&lt; Was a write to the variable found? */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这就是我们如何使用它，例如检查着色器代码是否曾经读取gl_Vertex：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find_deref_visitor find(&quot;gl_Vertex&quot;);</span><br><span class="line">find.run(sh-&gt;ir);</span><br><span class="line">if (find.variable_found()) &#123;</span><br><span class="line">  (...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Mesa 中的大多数优化和降低通道都是作为访问者实现的，并遵循类似的想法。我们将在后面的文章中查看这些示例</p>
<h2 id="内置变量和函数"><a href="#内置变量和函数" class="headerlink" title="内置变量和函数"></a>内置变量和函数</h2><p>GLSL 为 Mesa 自动注入着色器代码的每个着色器阶段定义了一组内置变量（带有“gl_”前缀）。如果您查看我们使用<code>MESA_GLSL=dump</code>获取生成的Mesa IR的示例，您可以看到其中一些变量。</p>
<p>Mesa 在_mesa_glsl_initialize_variables() 中实现了对内置变量的支持，定义在src&#x2F;glsl&#x2F;builtin_variables.cpp 中。</p>
<p>请注意，其中一些变量对所有着色器阶段都是通用的，而有些变量特定于特定阶段或仅在特定版本的 GLSL 中可用。</p>
<p>根据变量的类型，Mesa 或硬件驱动程序可能能够立即提供值（例如，对于保存常量值的变量，如gl_MaxVertexAttribs或gl_MaxDrawBuffers）。否则，驱动程序可能必须在程序运行时通过生成添加到用户程序的本机代码从硬件中获取（或生成）变量的值。例如，使用gl_PrimitiveID的几何着色器将需要为绘制调用中几何着色器单元处理的每个图元更新该变量。为了实现这一点，驱动程序可能必须生成本机代码，从硬件获取当前原始 ID 值并将其存储在寄存器中，该寄存器为执行用户代码之前的gl_PrimitveID变量。</p>
<p>GLSL 语言还定义了许多必须由实现者提供的可用内置函数，例如texture()、mix() 或 dot() 等，仅举几例。Mesa 的 GLSL 编译器中内置函数的入口点是src&#x2F;glsl&#x2F;builtin_functions.cpp。</p>
<p>方法builtin_builder::create_builtins()负责注册内置函数，就像内置变量一样，并非所有函数都始终可用：某些函数可能仅在某些着色单元中可用，而其他函数可能仅在某些 GLSL 版本等。为此，每个内置函数都注册了一个谓词，该谓词可用于测试该函数在特定场景中是否完全可用。</p>
<p>内置函数通过调用add_function()方法注册，该方法注册特定函数的所有版本。例如，用于 float、vec2、vec3、vec4 等的mix()这些版本中的每一个都有自己的可用性谓词。例如，mix()始终可用于浮点参数，但将其与整数一起使用需要GLSL 1.30和EXT_shader_integer_mix扩展。</p>
<p>除了可用性谓词之外，add_function()还接受一个ir_function_signature，它告诉 Mesa 正在注册的函数的特定签名。请注意，当 Mesa 为函数创建签名时，它还定义了函数体。例如，以下代码片段定义了modf()的签名：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ir_function_signature *</span><br><span class="line">builtin_builder::_modf(builtin_available_predicate avail,</span><br><span class="line">                       const glsl_type *type)</span><br><span class="line">&#123;</span><br><span class="line">   ir_variable *x = in_var(type, &quot;x&quot;);</span><br><span class="line">   ir_variable *i = out_var(type, &quot;i&quot;);</span><br><span class="line">   MAKE_SIG(type, avail, 2, x, i);</span><br><span class="line"></span><br><span class="line">   ir_variable *t = body.make_temp(type, &quot;t&quot;);</span><br><span class="line">   body.emit(assign(t, expr(ir_unop_trunc, x)));</span><br><span class="line">   body.emit(assign(i, t));</span><br><span class="line">   body.emit(ret(sub(x, t)));</span><br><span class="line"></span><br><span class="line">   return sig;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>GLSL 的modf()将数字拆分为整数和小数部分。它将整数部分分配给输出参数，函数返回值是小数部分。</p>
<p>我们在上面看到的这个签名定义了类型为“type”的输入参数“x”（我们想要分割的数字）、一个相同类型的输出参数“i”（它将保存“x”的整数部分）和一个返回值输入“类型”。</p>
<p>函数实现基于一元运算符ir_unop_trunc的存在，它可以取一个数字并提取其整数部分。然后它通过从原始数字中减去小数部分来计算小数部分。</p>
<p>当使用modf()内置函数时，调用将被扩展以包含此 IR 代码，稍后将通过相应的硬件驱动程序将其转换为 GPU 的本机代码。在这种情况下，这意味着硬件驱动预计将提供所述的实现ir_unop_trunc操作者，例如，其在Intel i965的驱动器的情况下，作为一个单一的硬件指令被实现（见brw_vec4_visitor.cpp或brw_fs_visitor.cpp,在src&#x2F;mesa&#x2F;drivers&#x2F;dri&#x2F;i965）。</p>
<p>在某些情况下，无法在 IR 级别定义内置函数的实现。在这种情况下，实现只是发出一个临时 IR 节点，驱动程序可以适当地识别和扩展。一个例子是几何着色器中的EmitVertex()。这并不是传统意义上的真正函数调用，而是一种向驱动程序发出信号的方式，即我们已经定义了一个顶点的所有属性，是时候将该顶点“推”到当前图元中了。“推动顶点”的含义无法在 IR 级别定义，因为每个驱动程序&#x2F;硬件都会有所不同。因此，内置函数只需注入一个 IR 节点ir_emit_vertex驾驶员可以在时机成熟时识别并正确实施。在英特尔代码的情况下，推送顶点涉及许多与硬件非常交织的步骤，但它基本上相当于生成实现硬件期望发生的行为的本机代码。如果您很好奇，可以在brw_vec4_gs_visitor.cpp中的 i965 驱动程序代码中找到它的实现，该方法在将ir_emit_vertex IR 节点作为参数的visit()方法中。</p>
<h2 id="接下来的事"><a href="#接下来的事" class="headerlink" title="接下来的事"></a>接下来的事</h2><p>在这篇文章中，我们讨论了解析器，它是编译器的入口点，并介绍了主要数据结构Mesa IR。在接下来的文章中，我们将深入研究 GLSL 编译器的实现。具体来说，我们将研究降低和优化过程以及链接过程和处理本机代码生成的硬件驱动程序的钩子。</p>
]]></content>
      <categories>
        <category>多媒体</category>
      </categories>
      <tags>
        <tag>mesa</tag>
        <tag>glsl</tag>
        <tag>opengl</tag>
      </tags>
  </entry>
  <entry>
    <title>[转]An introduction to Mesa’s GLSL compiler (II)[翻译]</title>
    <url>/post/1e9ef115.html</url>
    <content><![CDATA[<p>原文： <span class="exturl" data-url="aHR0cHM6Ly9ibG9ncy5pZ2FsaWEuY29tL2l0b3JhbC8yMDE1LzAzLzA2L2FuLWludHJvZHVjdGlvbi10by1tZXNhcy1nbHNsLWNvbXBpbGVyLWlpLw==">https://blogs.igalia.com/itoral/2015/03/06/an-introduction-to-mesas-glsl-compiler-ii/<i class="fa fa-external-link-alt"></i></span></p>
<span id="more"></span>

<h2 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2><p>我之前的文章是对 Mesa 的 GLSL 编译器的初步了解，我们在其中讨论了 Mesa IR，它是编译器的一个核心方面。在这篇文章中，我将介绍另一个相关方面：IR lowering​​​​​​​。</p>
<h2 id="IR-lowering"><a href="#IR-lowering" class="headerlink" title="IR lowering"></a>IR lowering</h2><p>Mesa 中实现了多个降低通道（查看src&#x2F;glsl&#x2F;lower_*.cpp以获取完整列表），但它们都有一个共同点：它们的目的是重写 IR 中的某些构造，以便它们更适合底层 GPU硬件。</p>
<p>在这篇文章中，我们将研究lower_instructions.cpp降低传递，它重写了具有不同实现的GPU硬件可能不直接支持的表达式操作。</p>
<p>降低过程涉及遍历 IR，识别我们想要降低的指令并相应地修改 IR，这非常适合我在上一篇文章中讨论的访问者模式策略。在这种情况下，表达式降低由lower_instructions_visitor类处理，该类在visit_leave()方法中为ir_expression 节点实现降低传递。</p>
<p>分层访问者类，作为 Mesa 中大多数访问者的基类，为IR 树中的叶节点定义了visit()方法，为非叶节点定义了visit_leave()&#x2F;visit_enter()方法。这样，当遍历 IR 中的中间节点时，我们可以决定在进入它们或即将离开它们时立即采取行动。</p>
<p>在我们的lower_instructions_visitor类的情况下，visit_leave()方法实现是一个大的switch()语句，其中包含它可以降低的所有运算符。</p>
<p>此文件中的代码降低了预计对大多数 GPU 驱动程序有用的常见场景，但个别驱动程序仍然可以选择他们想要使用这些降低通道中的哪一个。为此，硬件驱动程序创建了lower_instructions类的实例，传递了要启用的降低通道列表。例如，Intel i965 驱动程序执行以下操作：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">onst int bitfield_insert = brw-&gt;gen &gt;= 7</span><br><span class="line">                            ? BITFIELD_INSERT_TO_BFM_BFI</span><br><span class="line">                            : 0;</span><br><span class="line">lower_instructions(shader-&gt;base.ir,</span><br><span class="line">                   MOD_TO_FLOOR |</span><br><span class="line">                   DIV_TO_MUL_RCP |</span><br><span class="line">                   SUB_TO_ADD_NEG |</span><br><span class="line">                   EXP_TO_EXP2 |</span><br><span class="line">                   LOG_TO_LOG2 |</span><br><span class="line">                   bitfield_insert |</span><br><span class="line">                   LDEXP_TO_ARITH);</span><br></pre></td></tr></table></figure>

<p>请注意，在英特尔 GPU 的情况下，如何根据所涉及的硬件有条件地选择降低通道之一。在这种情况下，brw-&gt;gen &gt;&#x3D; 7选择自IvyBridge以来的 GPU 代。</p>
<p>让我们来看看其中一些降低通道的实现。例如，SUB_TO_ADD_NEG是一个非常简单的将减法转换为负加法的方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">void</span><br><span class="line">lower_instructions_visitor::sub_to_add_neg(ir_expression *ir)</span><br><span class="line">&#123;</span><br><span class="line">   ir-&gt;operation = ir_binop_add;</span><br><span class="line">   ir-&gt;operands[1] =</span><br><span class="line">      new(ir) ir_expression(ir_unop_neg, ir-&gt;operands[1]-&gt;type,</span><br><span class="line">                            ir-&gt;operands[1], NULL);</span><br><span class="line">   this-&gt;progress = true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如我们所见，降低传递简单地改变了ir_expression节点使用的运算符，并使用一元取反运算符 (ir_unop_neg) 取反第二个操作数，从而将原始a &#x3D; b – c转换为a &#x3D; b + (-c )。</p>
<p>当然，如果驱动程序没有对减法操作的本机支持，它在处理 IR 以生成本机代码时仍然可以这样做，但这样 Mesa 节省了驱动程序开发人员的工作。此外，一些降低通道可能会在降低驱动程序可能会错过的降低之后启用优化通道。</p>
<p>让我们看一个更复杂的例子：MOD_TO_FLOOR。在这种情况下，降低传递为没有本地模运算的 GPU提供了ir_binop_mod（模）的实现。</p>
<p>模运算采用两个操作数 (op0, op1) 并实现“ op0 % op1 ”的 C 等效项，即它计算 op0 除以 op1 的余数。为了实现这一点，降低传递将模运算分解为mod(op0, op1) &#x3D; op0 – op1 * floor(op0 &#x2F; op1)，它只需要乘法、除法和减法。这是实现：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">ir_variable *x = new(ir) ir_variable(ir-&gt;operands[0]-&gt;type, &quot;mod_x&quot;,</span><br><span class="line">                                     ir_var_temporary);</span><br><span class="line">ir_variable *y = new(ir) ir_variable(ir-&gt;operands[1]-&gt;type, &quot;mod_y&quot;,</span><br><span class="line">                                     ir_var_temporary);</span><br><span class="line">this-&gt;base_ir-&gt;insert_before(x);</span><br><span class="line">this-&gt;base_ir-&gt;insert_before(y);</span><br><span class="line"></span><br><span class="line">ir_assignment *const assign_x =</span><br><span class="line">   new(ir) ir_assignment(new(ir) ir_dereference_variable(x),</span><br><span class="line">                         ir-&gt;operands[0], NULL);</span><br><span class="line">ir_assignment *const assign_y =</span><br><span class="line">   new(ir) ir_assignment(new(ir) ir_dereference_variable(y),</span><br><span class="line">                         ir-&gt;operands[1], NULL);</span><br><span class="line"></span><br><span class="line">this-&gt;base_ir-&gt;insert_before(assign_x);</span><br><span class="line">this-&gt;base_ir-&gt;insert_before(assign_y);</span><br><span class="line"></span><br><span class="line">ir_expression *const div_expr =</span><br><span class="line">   new(ir) ir_expression(ir_binop_div, x-&gt;type,</span><br><span class="line">                         new(ir) ir_dereference_variable(x),</span><br><span class="line">                         new(ir) ir_dereference_variable(y));</span><br><span class="line"></span><br><span class="line">/* Don&#x27;t generate new IR that would need to be lowered in an additional</span><br><span class="line"> * pass.</span><br><span class="line"> */</span><br><span class="line">if (lowering(DIV_TO_MUL_RCP) &amp;&amp; (ir-&gt;type-&gt;is_float() ||</span><br><span class="line">    ir-&gt;type-&gt;is_double()))</span><br><span class="line">   div_to_mul_rcp(div_expr);</span><br><span class="line"></span><br><span class="line">ir_expression *const floor_expr =</span><br><span class="line">   new(ir) ir_expression(ir_unop_floor, x-&gt;type, div_expr);</span><br><span class="line"></span><br><span class="line">if (lowering(DOPS_TO_DFRAC) &amp;&amp; ir-&gt;type-&gt;is_double())</span><br><span class="line">   dfloor_to_dfrac(floor_expr);</span><br><span class="line"></span><br><span class="line">ir_expression *const mul_expr =</span><br><span class="line">   new(ir) ir_expression(ir_binop_mul,</span><br><span class="line">                         new(ir) ir_dereference_variable(y),</span><br><span class="line">                         floor_expr);</span><br><span class="line"></span><br><span class="line">ir-&gt;operation = ir_binop_sub;</span><br><span class="line">ir-&gt;operands[0] = new(ir) ir_dereference_variable(x);</span><br><span class="line">ir-&gt;operands[1] = mul_expr;</span><br><span class="line">this-&gt;progress = true;</span><br></pre></td></tr></table></figure>

<p>注意它做的第一件事是如何将操作数分配给变量。这样做的原因有点棘手：由于我们要将ir_binop_mod实现为op0 – op1 * floor(op0 &#x2F; op1)，因此我们需要在树中两次引用 IR 节点 op0 和 op1。但是，我们不能直接这样做，因为这意味着我们有从 IR 表达式树中的两个不同位置链接的相同节点（即相同的指针）。也就是说，我们想要这棵树：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   sub</span><br><span class="line"> /     \</span><br><span class="line">op0     mult</span><br><span class="line">       /    \</span><br><span class="line">    op1     floor</span><br><span class="line">              |</span><br><span class="line">             div</span><br><span class="line">            /   \</span><br><span class="line">         op0     op1</span><br></pre></td></tr></table></figure>

<p>而不是这棵树：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  sub</span><br><span class="line">/     \</span><br><span class="line">|      mult</span><br><span class="line">|     /   \</span><br><span class="line">|   floor  |</span><br><span class="line">|     |    |</span><br><span class="line">|    div   |</span><br><span class="line">|   /   \  |</span><br><span class="line"> op0     op1</span><br></pre></td></tr></table></figure>

<p>树的第二个版本是有问题的。例如，假设一个假设的优化过程检测到op1是一个值为1的常量整数，并意识到在这种情况下div(op0&#x2F;op1) &#x3D;&#x3D; op0。在进行优化时，我们的div子树被删除，这样，op1也可以被删除（并且可能被释放），在 IR 中留下对该操作数的另一个引用指向一个无效的内存位置……我们刚刚破坏了我们的 IR：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  sub</span><br><span class="line">/     \</span><br><span class="line">|      mult</span><br><span class="line">|     /    \</span><br><span class="line">|   floor   op1 [invalid pointer reference]</span><br><span class="line">|     |</span><br><span class="line">|    /</span><br><span class="line">|   /</span><br><span class="line"> op0</span><br></pre></td></tr></table></figure>

<p>相反，我们在这里要做的是每次在 IR 中需要对节点的新引用时克隆节点。为此，所有 IR 节点都有一个clone()方法。但是，在这种特殊情况下，克隆节点会产生一个新问题：op0和op1是ir_expression节点，因此，例如，op0可能是表达式a + b * c，因此克隆表达式将产生次优代码，其中表达式被复制. 这充其量会导致更慢<br>由于优化传递需要检测和修复的编译时间，更糟糕的是，优化器不会检测到，并导致性能更差，我们多次计算表达式的值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">        sub</span><br><span class="line">     /        \</span><br><span class="line">   add         mult</span><br><span class="line">  /   \       /    \</span><br><span class="line">a     mult  op1     floor</span><br><span class="line">      /   \          |</span><br><span class="line">     b     c        div</span><br><span class="line">                   /   \</span><br><span class="line">                add     op1</span><br><span class="line">               /   \</span><br><span class="line">              a    mult</span><br><span class="line">                  /    \</span><br><span class="line">                  b     c</span><br></pre></td></tr></table></figure>

<p>这个问题的解决方案是将表达式分配给一个变量，然后在我们需要的任何地方取消引用该变量（即读取它的值）。因此，实现定义了两个变量(x, y)，将op0和op1分配给它们，并在我们需要访问op0和op1表达式的值的任何地方创建新的解引用节点：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   =               =</span><br><span class="line"> /   \           /   \</span><br><span class="line">x     op0       y     op1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">         sub</span><br><span class="line">       /     \</span><br><span class="line">     *x       mult</span><br><span class="line">             /    \</span><br><span class="line">           *y     floor</span><br><span class="line">                    |</span><br><span class="line">                   div</span><br><span class="line">                  /   \</span><br><span class="line">                *x     *y</span><br></pre></td></tr></table></figure>

<p>在上图中，每个变量解引用都标有’*’，每个变量都是一个新的 IR 节点（因此’*x’ 的两次出现都指代不同的 IR 节点，都代表对同一变量的两个不同读取）。使用这个解决方案，我们只计算op0和op1表达式一次（当它们被分配给相应的变量时），我们从不从不同的地方两次引用同一个 IR 节点（因为每个变量取消引用都是一个新的 IR 节点）。</p>
<p>现在我们知道为什么要分配这两个变量了，让我们继续看降低传递的代码：</p>
<p>在下一步中，我们使用 ir_binop_div 表达式实现op0 &#x2F; op1。为了加快编译速度，如果驱动程序启用了DIV_TO_MUL_RCP降低传递，将a &#x2F; b转换为a * 1 &#x2F; b（其中1 &#x2F; b可能是本机指令），我们立即执行该表达式的降低传递。如果我们在这里不这样做，则生成的 IR 将包含一个除法运算，该运算可能必须在以后的传递中降低，从而使编译过程变慢。</p>
<p>下一步使用ir_unop_floor表达式来计算floor(op0&#x2F;op1)，并再次测试此操作是否也应该降低，如果操作数的类型是 64 位双精度数而不是常规的 32 位浮点数，则可能是这种情况，因为 GPU 可能只有 32 位浮点数的本机楼层指令。</p>
<p>接下来，我们将结果乘以op1得到op1 * floor(op0 &#x2F; op1)。</p>
<p>现在我们只需要从 op0 中减去它，这将是这个表达式的根 IR 节点。因为我们希望新的IR树从这个根节点产卵，以取代旧的实现，我们直接编辑，我们正在降低，以取代红外节点ir_binop_mod与运营商ir_binop_sub，做一个提领来OP1于第一运算和链接式保持OP1 * floor(op0 &#x2F; op1)在第二个操作数中，有效地附加了我们的新实现来代替旧版本。这是原始和降低的 IR 的样子：​​​​​​​</p>
<p>Original IR:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[prev inst] -&gt; mod -&gt; [next inst]</span><br><span class="line">              /   \</span><br><span class="line">           op0     op1</span><br></pre></td></tr></table></figure>

<p>Lowered IR:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[prev inst] -&gt; var x -&gt; var y -&gt;   =   -&gt;   =   -&gt;   sub   -&gt; [next inst]</span><br><span class="line">                                  / \      / \      /   \</span><br><span class="line">                                 x  op0   y  op1  *x     mult</span><br><span class="line">                                                        /    \</span><br><span class="line">                                                      *y      floor</span><br><span class="line">                                                                |</span><br><span class="line">                                                               div</span><br><span class="line">                                                              /   \</span><br><span class="line">                                                            *x     *y</span><br></pre></td></tr></table></figure>

<p>最后，我们返回 true 以让编译器知道我们已经优化了 IR，因此我们引入了可能会进一步降低传递的新节点，因此它可以运行新的传递。例如，我们刚刚添加的减法可能会再次降低到我们之前看到的负加法。</p>
<h2 id="接下来的是"><a href="#接下来的是" class="headerlink" title="接下来的是"></a>接下来的是</h2><p>现在我们了解了降低通道，我们还可以讨论优化通道，它们非常相似，因为它们也基于 Mesa 中的访问者实现，并且也以类似的方式转换Mesa IR。</p>
]]></content>
      <categories>
        <category>多媒体</category>
      </categories>
      <tags>
        <tag>mesa</tag>
        <tag>glsl</tag>
        <tag>opengl</tag>
      </tags>
  </entry>
  <entry>
    <title>glxinfo之Video Memory大小</title>
    <url>/post/18632.html</url>
    <content><![CDATA[<p>mesa中的显存大小：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">glxinfo -B</span></span><br><span class="line">name of display: :0</span><br><span class="line">display: :0  screen: 0</span><br><span class="line">direct rendering: Yes</span><br><span class="line">Extended renderer info (GLX_MESA_query_renderer):</span><br><span class="line">    Vendor: X.Org (0x1002)</span><br><span class="line">    Device: AMD OLAND (DRM 2.50.0, 5.3.8-050308-generic, LLVM 8.0.0) (0x6611)</span><br><span class="line">    Version: 19.1.6</span><br><span class="line">    Accelerated: yes</span><br><span class="line">    Video memory: 1024MB &lt;----------- 显存</span><br><span class="line">    Unified memory: no</span><br><span class="line">    Preferred profile: core (0x1)</span><br><span class="line">    Max core profile version: 4.5</span><br><span class="line">    Max compat profile version: 4.5</span><br><span class="line">    Max GLES1 profile version: 1.1</span><br><span class="line">    Max GLES[23] profile version: 3.2</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="glxinfo"><a href="#glxinfo" class="headerlink" title="glxinfo"></a>glxinfo</h2><p>源码文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone https://gitlab.freedesktop.org/mesa/demos.git</span><br></pre></td></tr></table></figure>

<p>获取显存大小：<code>queryInteger(GLX_RENDERER_VIDEO_MEMORY_MESA, v)</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">queryInteger(GLX_RENDERER_ACCELERATED_MESA, v);</span><br><span class="line">printf(&quot;    Accelerated: %s\n&quot;, *v ? &quot;yes&quot; : &quot;no&quot;);</span><br><span class="line">queryInteger(GLX_RENDERER_VIDEO_MEMORY_MESA, v);</span><br><span class="line">printf(&quot;    Video memory: %dMB\n&quot;, *v);</span><br><span class="line">queryInteger(GLX_RENDERER_UNIFIED_MEMORY_ARCHITECTURE_MESA, v);</span><br><span class="line">printf(&quot;    Unified memory: %s\n&quot;, *v ? &quot;yes&quot; : &quot;no&quot;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>file: glxinfo.c</p>
</blockquote>
<h2 id="mesa"><a href="#mesa" class="headerlink" title="mesa"></a>mesa</h2><p>queryInteger在mesa中的实现：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">glXQueryCurrentRendererIntegerMESA</span><br><span class="line">  \-&gt;__glXQueryRendererInteger --- GLX_RENDERER_VIDEO_MEMORY_MESA</span><br><span class="line">    -&gt; psc-&gt;vtable-&gt;query_renderer_integer()</span><br></pre></td></tr></table></figure>
<blockquote>
</blockquote>
<ul>
<li>dri3<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">glx_screen_vtable</span> <span class="title">dri3_screen_vtable</span> =</span> &#123;</span><br><span class="line">   .create_context         = dri3_create_context,</span><br><span class="line">   .create_context_attribs = dri3_create_context_attribs,</span><br><span class="line">   .query_renderer_integer = dri3_query_renderer_integer,</span><br><span class="line">   .query_renderer_string  = dri3_query_renderer_string,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dri3_query_renderer_integer</span><br><span class="line"> \-&gt; dri2_convert_glx_query_renderer_attribs</span><br><span class="line">    \/</span><br><span class="line">  dri_attribute = __DRI2_RENDERER_VIDEO_MEMORY &lt;--GLX_RENDERER_VIDEO_MEMORY_MESA</span><br><span class="line"> \-&gt;psc-&gt;rendererQuery-&gt;queryInteger((psc-&gt;driScreen, dri_attribute, value)</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> __DRI2rendererQueryExtension dri2RendererQueryExtension = &#123;</span><br><span class="line">    .base = &#123; __DRI2_RENDERER_QUERY, <span class="number">1</span> &#125;,</span><br><span class="line"></span><br><span class="line">    .queryInteger         = dri2_query_renderer_integer,</span><br><span class="line">    .queryString          = dri2_query_renderer_string</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>fire: src&#x2F;gallium&#x2F;state_trackers&#x2F;dri&#x2F;dri_query_renderer.c</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dri2_query_renderer_integer</span><br><span class="line"> \-&gt; __DRI2_RENDERER_VIDEO_MEMORY</span><br><span class="line">   &gt; screen-&gt;base.screen-&gt;get_param(screen-&gt;base.screen, PIPE_CAP_VIDEO_MEMORY)</span><br></pre></td></tr></table></figure>
<ul>
<li><code>get_param</code>接口是<code>struct pipe_screen</code>提供给驱动的接口，需要各个驱动自己实现。</li>
</ul>
<h3 id="virgl"><a href="#virgl" class="headerlink" title="virgl"></a>virgl</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> pipe_screen *</span><br><span class="line"><span class="title function_">virgl_create_screen</span><span class="params">(<span class="keyword">struct</span> virgl_winsys *vws)</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">virgl_screen</span> *<span class="title">screen</span> =</span> CALLOC_STRUCT(virgl_screen);</span><br><span class="line"></span><br><span class="line">   screen-&gt;base.get_name = virgl_get_name;</span><br><span class="line">   screen-&gt;base.get_vendor = virgl_get_vendor;</span><br><span class="line">   screen-&gt;base.get_param = virgl_get_param;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">virgl_get_param &lt;- PIPE_CAP_VIDEO_MEMORY</span><br><span class="line">\-&gt; &#123;</span><br><span class="line">      ...</span><br><span class="line">      case PIPE_CAP_VIDEO_MEMORY:</span><br><span class="line">      return 0;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>在virgl中没有实现显存接口，默认为0，无法通过glxinfo获取</strong></p>
</blockquote>
<p>在virgl中的部分其他参数是获取host端的参数，通过<code>struct virgl_winsys</code>结构体中的<code>get_caps</code>接口。</p>
<ul>
<li>drm： <code>DRM_IOCTL_VIRTGPU_GET_CAPS</code></li>
<li>vtest： <code>VCMD_GET_CAPS</code>+<code>VCMD_GET_CAPS2</code></li>
</ul>
<h3 id="radeonsi"><a href="#radeonsi" class="headerlink" title="radeonsi"></a>radeonsi</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">si_init_screen_get_functions</span><span class="params">(<span class="keyword">struct</span> si_screen *sscreen)</span></span><br><span class="line">&#123;</span><br><span class="line">  sscreen-&gt;b.get_name = si_get_name;</span><br><span class="line">  sscreen-&gt;b.get_vendor = si_get_vendor;</span><br><span class="line">  sscreen-&gt;b.get_device_vendor = si_get_device_vendor;</span><br><span class="line">  sscreen-&gt;b.get_param = si_get_param;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static int si_get_param(struct pipe_screen *pscreen, enum pipe_cap param)</span><br><span class="line">&#123;</span><br><span class="line">  switch (param) &#123;</span><br><span class="line">    case PIPE_CAP_VIDEO_MEMORY:</span><br><span class="line">      return sscreen-&gt;info.vram_size &gt;&gt; 20;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Radeon驱动中通过<code>drmCommandWriteRead</code>接口获取<code>DRM_RADEON_GEM_INFO</code>中的配置参数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* Get GEM info. */</span><br><span class="line">retval = drmCommandWriteRead(ws-&gt;fd, DRM_RADEON_GEM_INFO,</span><br><span class="line">        &amp;gem_info, sizeof(gem_info));</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>多媒体</category>
      </categories>
      <tags>
        <tag>glxinfo</tag>
        <tag>显存</tag>
      </tags>
  </entry>
  <entry>
    <title>多媒体硬件接口-HDMI、VGA</title>
    <url>/post/57610.html</url>
    <content><![CDATA[<p>常用的多媒体硬件接口的特性和基本数据传输原理</p>
<span id="more"></span>

<h2 id="HDMI"><a href="#HDMI" class="headerlink" title="HDMI"></a>HDMI</h2><blockquote>
<p>H-High，D-Definition，M-Multimedia，I-Interface；高清晰度多媒体接口</p>
</blockquote>
<h3 id="硬件接口"><a href="#硬件接口" class="headerlink" title="硬件接口"></a>硬件接口</h3><p><img data-src="/images/2018/08/hdmi_hardware_port.png" alt="hdmi_hardware_port"></p>
<blockquote>
<p>19pin脚</p>
</blockquote>
<ul>
<li><code>TMDS</code> data channels (6 pins)</li>
<li><code>TMDS</code> clock channel (2 pins)</li>
<li>Consumer Electronics Control (CEC) (1 pin)</li>
<li>Display Data Channel (DDC)(1 pin)</li>
<li>+5V power (1 pin)</li>
<li>Hot Plug Detect (1 pin)</li>
<li>TMDS Shield Lines (4 pins designated in yellow)</li>
<li>CEC&#x2F;DDC Ground (1 pin)</li>
</ul>
<h3 id="逻辑接口"><a href="#逻辑接口" class="headerlink" title="逻辑接口"></a>逻辑接口</h3><p><img data-src="/images/2018/08/hdmi_in_out.png" alt="hdmi_in_out"></p>
<p>信号介绍：</p>
<ol>
<li>4对<code>TMDS差分信号</code>：1对时钟+3对数据:<ul>
<li>TMDS通道0传输B信号，同时H信号和V信号也嵌入该通道</li>
<li>TMDS通道1传输G信号</li>
<li>TMDS通道2传输R信号，R和G通道的多余位置用来传输音频信号</li>
</ul>
</li>
<li><code>CEC</code>：消费电子控制通道，通过这条通道可以控制设备之间的交互</li>
<li><code>DDC</code>：就是<code>I²C信号</code>，主要是获取显示器的基本信息(比如EDID信息)</li>
<li><code>HPD</code>：热插拔信号，该信号比较重要，当HPD引脚大于2V，TMDS才会输出。因此，如果屏幕没有显示，首先要测量该信号</li>
</ol>
<blockquote>
<ul>
<li><code>DCC</code>遵守的是I2C协议，EDID 存储在一个ROM 芯片中，HDMI协议规定ROM的I2C 地址必须是<code>0xA0</code>.电路设计中DDC端口上需要安装上拉电阻，电阻值最小要求达到1.3K。</li>
<li><code>CEC</code>是一套完整的协议，电子设备可以借着CEC信号让用者可控制HDMI接口上所连接的装置。如单键播放(One Touch Play)，系统待机(System Standby)。 即是如果用者将影碟放进蓝光播放器时，电视会由于CEC信号的通知而自动开机，然后视频通道亦会自动切换到播放器连接的通道上。而当用者关掉电视时，CEC信号亦会通知HDMI相连接的装置一同进入待机。由于这样，所以就可以完全变成单一遥控器控制所有HDMI连接的装置。</li>
</ul>
</blockquote>
<p>HDMI接口中的数据信号采用的是S最小化传输<code>差分信号</code>协议。这种协议会将标准8bit数据转换为10bit信号，并且在转换过程中使用<code>微分传送</code>。</p>
<h3 id="CEC"><a href="#CEC" class="headerlink" title="CEC"></a>CEC</h3><p>CEC是<code>单总线协议</code>，通过Phsical address Discovery Process机制来分配物理地址，DDC信号把物理地址传输到设备中。当一个带CEC功能的设备获取到一个物理地址的时候，他将进行以下处理：</p>
<ol>
<li>主动申请分配与设备类型相应的逻辑地址</li>
<li>通过广播的方式来报告物理地址和对应的逻辑地址，实现绑定。</li>
</ol>
<h3 id="最大分辨率"><a href="#最大分辨率" class="headerlink" title="最大分辨率"></a>最大分辨率</h3><p><img data-src="/images/2018/08/hdmi_interface_max_pix.png" alt="hdmi_interface_max_pix"></p>
<blockquote>
<p>接口所支持的协议不同，最大分辨率将不同</p>
</blockquote>
<h2 id="VGA"><a href="#VGA" class="headerlink" title="VGA"></a>VGA</h2><p>VGA（Video Graphics Array）即<code>视频图形阵列</code>，是IBM在1987年随PS&#x2F;2（PS&#x2F;2 原是“Personal System 2”的意思，“个人系统2”.</p>
<p>VGA接口就是显卡上面输出模拟信号的接口。VGA接口是一种<code>D型接口</code>，上面共有<code>15针孔</code>，分成3排，每排5个，</p>
<p><img data-src="/images/2018/08/vga_hardware_port.png" alt="vga_hardware_port"></p>
<p>DDC:Display Data Channel(显示数据通道)， 用于EDID信息的传送，其实就是<code>I2C</code>数据线。</p>
<h3 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h3><p>VGA显示中，FPGA需要产生５个信号分别是：行<code>同步信号HS</code>、<code>场同步信号VS</code>、<code>R</code>、<code>G</code>、<code>B</code>三基色信号。</p>
<table>
<thead>
<tr>
<th align="center">信号</th>
<th align="left">定义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">HS</td>
<td align="left">行同步信号（3.3V）</td>
</tr>
<tr>
<td align="center">VS</td>
<td align="left">场 &#x2F; 帧 同步信号（3.3V）</td>
</tr>
<tr>
<td align="center">R</td>
<td align="left">红基色 （0~0.714V 模拟信号）</td>
</tr>
<tr>
<td align="center">G</td>
<td align="left">绿基色 （0~0.714V 模拟信号）</td>
</tr>
<tr>
<td align="center">B</td>
<td align="left">蓝基色 （0~0.714V 模拟信号）</td>
</tr>
</tbody></table>
<h3 id="最大分辨率-1"><a href="#最大分辨率-1" class="headerlink" title="最大分辨率"></a>最大分辨率</h3><p>VGA接口所能支持的最大分辨率是<code>2048X1536px</code></p>
<h2 id="DVI"><a href="#DVI" class="headerlink" title="DVI"></a>DVI</h2><p>DVI（Digital Visual Interface），即数字视频接口.</p>
<p><img data-src="/images/2018/09/dvi_interface.png" alt="DVI_interface"></p>
<p>DVI是基于<code>TMDS(Transition Minimized Differential Signaling)</code>，转换<code>最小差分信号</code>技术来传输数字信号，TMDS运用先进的编码算法把8bit数据(R、G、B中的每路基色信号)通过最小转换编码为10bit数据(包含行场同步信息、时钟信息、数据DE、纠错等)，经过DC平衡后，采用差分信号传输数据，它和LVDS、TTL相比有较好的电磁兼容性能，可以用低成本的专用电缆实现长距离、高质量的数字信号传输。</p>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ol>
<li>DVI-A（12+5）</li>
<li>DVI-D（24+1&#x2F;18+1）: 只有数字接口</li>
<li>DVI-I（24+5）: 有数字和模拟接口</li>
</ol>
<h3 id="最大分辨率-2"><a href="#最大分辨率-2" class="headerlink" title="最大分辨率"></a>最大分辨率</h3><ul>
<li>DVI-I单通道最大分辨率:<code>1920x1200,60Hz</code></li>
<li>DVI-I双通道最大分辨率:<code>2560x1600,60Hz/1920x1200,120Hz</code></li>
<li>DVI-D单通道最大分辨率:<code>1920x1200,60Hz</code></li>
<li>DVI-D双通道最大分辨率:<code>2560x1600,60Hz/1920x1080,120Hz</code></li>
</ul>
<h2 id="DP"><a href="#DP" class="headerlink" title="DP"></a>DP</h2><p>DisplayPort也是一种高清数字显示接口标准，可以连接电脑和显示器，也可以连接电脑和家庭影院。</p>
<p><img data-src="/images/2018/09/dp_interface.png" alt="dp_interface"></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1YW5neWFuZ3F1YW4vYXJ0aWNsZS9kZXRhaWxzLzc3NDg3MTE2">HDMI接口基础知识及硬件设计<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>多媒体</category>
      </categories>
  </entry>
  <entry>
    <title>OpenGL ES —— surfaces</title>
    <url>/post/b1cee24c.html</url>
    <content><![CDATA[<p>EGL™ is an interface between Khronos rendering APIs such as OpenGL ES or OpenVG and the underlying native platform window system. It handles graphics context management, surface&#x2F;buffer binding, and rendering synchronization and enables high-performance, accelerated, mixed-mode 2D and 3D rendering using other Khronos APIs. EGL also provides interop capability between Khronos to enable efficient transfer of data between APIs – for example between a video subsystem running OpenMAX AL and a GPU running OpenGL ES.</p>
<p>EGL provides mechanisms for creating rendering surfaces onto which client APIs like OpenGL ES and OpenVG can draw, creates graphics contexts for client APIs, and synchronizes drawing by client APIs as well as native platform rendering APIs. This enables seamless rendering using both OpenGL ES and OpenVG for high-performance, accelerated, mixed-mode 2D and 3D rendering.</p>
<span id="more"></span>

<blockquote>
<p>EGLSurface可以是一个EGL分配的离屏缓冲区(称为 “pbuffer”) 或由操作系统分配的窗口</p>
</blockquote>
<h2 id="Window-surfaces"><a href="#Window-surfaces" class="headerlink" title="Window surfaces"></a>Window surfaces</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* create an EGL window surface */</span></span><br><span class="line">surface = eglCreateWindowSurface(display, config, target, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (surface == EGL_NO_SURFACE) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Create surface failed: 0x%x\n&quot;</span>, eglGetError());</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Pixmap-surfaces"><a href="#Pixmap-surfaces" class="headerlink" title="Pixmap surfaces"></a>Pixmap surfaces</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">pmsurface = eglCreatePixmapSurface(display, chosen, gfsurface, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pmsurface == EGL_NO_SURFACE) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Create Pixmap failed: 0x%x\n&quot;</span>, eglGetError());</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="pbuffer-surfaces"><a href="#pbuffer-surfaces" class="headerlink" title="pbuffer surfaces"></a>pbuffer surfaces</h2><p>To create a pbuffer surface, the application must specify the width and height of the surfaces via the EGL_WIDTH and EGL_HEIGHT attributes. In the case of a pbuffer surface, the actual surface memory is always allocated internally by OpenGL ES.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* create an EGL pbuffer surface */</span></span><br><span class="line">pbsurface = eglCreatePbufferSurface(display, chosen, pb_attrs);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pbsurface == EGL_NO_SURFACE) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Create PBuffer failed: 0x%x\n&quot;</span>, eglGetError());</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* connect the context to the PBuffer surface */</span></span><br><span class="line"><span class="keyword">if</span> (eglMakeCurrent(display, pbsurface, pbsurface, context) == EGL_FALSE) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Make current failed: 0x%x\n&quot;</span>, eglGetError());</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>多媒体</category>
      </categories>
      <tags>
        <tag>opengl</tag>
        <tag>surfaces</tag>
      </tags>
  </entry>
  <entry>
    <title>VESA</title>
    <url>/post/293ebfd8.html</url>
    <content><![CDATA[<blockquote>
<p>Video Electronics Standards Association（视频电子标准协会，简称“VESA”）是制定计算机和小型工作站视频设备标准的国际组织，1989年由NEC及其他8家显卡制造商赞助成立。</p>
</blockquote>
<span id="more"></span>


<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><span class="exturl" data-url="aHR0cDovL3d3dy5tb25zdGVyc29mdC5jb20vdHV0b3JpYWwxL1ZFU0FfaW50cm8uaHRtbA==">Introduction to VESA programming<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>多媒体</category>
      </categories>
      <tags>
        <tag>vesa</tag>
        <tag>edid</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenGL测试</title>
    <url>/post/42765.html</url>
    <content><![CDATA[<p>OpenGL API相关测试：</p>
<span id="more"></span>


<h2 id="piglit"><a href="#piglit" class="headerlink" title="piglit"></a>piglit</h2><h2 id="WebGL-Test"><a href="#WebGL-Test" class="headerlink" title="WebGL Test"></a>WebGL Test</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cua2hyb25vcy5vcmcvcmVnaXN0cnkvd2ViZ2wvY29uZm9ybWFuY2Utc3VpdGVzLzEuMC4zL3dlYmdsLWNvbmZvcm1hbmNlLXRlc3RzLmh0bWw=">https://www.khronos.org/registry/webgl/conformance-suites/1.0.3/webgl-conformance-tests.html<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cua2hyb25vcy5vcmcvcmVnaXN0cnkvd2ViZ2wvY29uZm9ybWFuY2Utc3VpdGVzLzIuMC4wL3dlYmdsLWNvbmZvcm1hbmNlLXRlc3RzLmh0bWw=">https://www.khronos.org/registry/webgl/conformance-suites/2.0.0/webgl-conformance-tests.html<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<h3 id="查看浏览器是否支持webgl的方法"><a href="#查看浏览器是否支持webgl的方法" class="headerlink" title="查看浏览器是否支持webgl的方法"></a>查看浏览器是否支持webgl的方法</h3><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9nZXQud2ViZ2wub3JnLw==">https://get.webgl.org/<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p><img data-src="/images/2019/09/webgl_supports.png" alt="webgl_supports"></p>
<h3 id="浏览器对WebGL版本的支持"><a href="#浏览器对WebGL版本的支持" class="headerlink" title="浏览器对WebGL版本的支持"></a>浏览器对WebGL版本的支持</h3><ul>
<li><span class="exturl" data-url="aHR0cDovL2Nhbml1c2UuY29tLw==">http://caniuse.com<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p><img data-src="/images/2019/09/webgl_version.png" alt="webgl_version"></p>
<blockquote>
<p>在页面搜索<code>WebGL</code>,查找<code>WebGL - 3D Canvas graphics</code></p>
</blockquote>
<ul>
<li>图中，绿色部分为完全实现 webgl 标准功能的版本，但有些厂商的实现并不一定如其所述那样完整，而有些并没那么稳定</li>
<li>当某一浏览器无法运行 webgl 应用时，应考虑，是否需要手动开启 webgl 功能，如 safari;</li>
<li>当某一浏览器无法打开本地的 webgl 应用时，应考虑，浏览器对本地资源出于安全考虑，对本地资源的访问是需要设置是否允许的，针对不浏览器设置方法不同，而像 firefox 默认是开启的；</li>
</ul>
<h3 id="检测浏览器支持的WebGL-Report"><a href="#检测浏览器支持的WebGL-Report" class="headerlink" title="检测浏览器支持的WebGL Report"></a>检测浏览器支持的WebGL Report</h3><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly93ZWJnbHJlcG9ydC5jb20vP3Y9Mg==">https://webglreport.com/?v=2<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>多媒体</category>
      </categories>
      <tags>
        <tag>opengl</tag>
      </tags>
  </entry>
  <entry>
    <title>显示认证系统</title>
    <url>/post/48058.html</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="a1a7d3f01f307717ffb722027ce2cf849a98abc62593ae65f0bcb73025091710">2c5fa39a898b9a06001e3b53c4509dca1c81131a8a8fd414393b3c9f9fb5aa1ebf99f38c8ae323e3f975ae925239ca661ad66954c13121f6bab095f487f6fb780abde3e9454a48a056c7ae107665593dfc02788e72e7ab4d04223d37c037ebaf722447891117d380a76953b8929bc18bc9faadd919d983b7fd1a269be56644b5d470b9b9a8d1fc3421dd2c279eec5af84bf6faf98b5c4b173effa2a312618c456105d3c5264e44ad2351b6a8bd7a08fdfdbf39c447d92775b06f16ebcd27982ec3dbb8f323c5ad0227d0f742ccb44ecf31e972b48e8a0d1ada4d9c8d85427959f4846fe3b0216739332ed0383c9c40d722e98fe37e06e6df1be09c1c0a4f3b8383e9942c1a497d47d0378fb9644c8e787133458654f7ad1bf2df0415d346755ffa6ed087ea1dd143d93103d1672336bf02b3330160fff92852dd85a37181f615bb0781362c1db5210d2fa0e40d7c4ea2b32304ef0cd9e91e1dcd80e65b5771042c31ba8ef45106ad27a1aa1f8dfb32f9688beb7b1cfa19f76e138de836f00b47c333eef3784f2d6bcb8dc609aa3918dd16819a5f17560b2022a6396ddcc13c40a5bb32d325e16755a9600f7eef62c80d55743d99ccbd3b1145612d19198c5c038cc3da932cf5df2f843a95c9f2c26e5e52743146700f61acbf68c0b3f7766060600e1ba6cc4dc2cd30ffdc006735fd20318ad2d09fa74d4f7f63af5617b16af3255759886f37ba3d48ed4ebd877a4eff63a48169ee4ba3c1ca0e6ae4e8f3e8ae967ce7019ad16bcd6a865fd375a2bdb02ec0d8134332416bdef90a636a7ac5fa5dd07588f828f7ad8ae623bcd6c540422a4a055bbad396ab41491686a6f9819cd97add13a54a2b468991e7233c92a0cf32524d11a19b2c11db417bca85175d2743da600caf480c8117551bae7902e5117a02c19d0984ba6f33b1de961f41c009784be54a6a3c7b0ad37ee30ecc95fcc3b931239c17fe5d7fbf7fb971711ea363452067790667ef7ff8e3f47fc01927aa41af38a6c009a9a6eacf8dbf996096d3364a1cd7d2641ea68faaaf1d417982398870e8bd4423dc0b2c2f04f6e5ba71666b44edb1b9ffb08abfffec882eea5c7ee1070b7bea47f42cdf34ae277a2eef8dc5931018321757753b77d90e52dbc3bfa591219df5bf10607e01eab30a6e0aa61489bc711999e3dd5f172885d58239d5ba2970c95d99a239b4fae553914cc9af74fb528530430c960504658983f498d184ce1ce55bd21e02d29c9ed322d288c380b5dd1cf268d6c7fb2af6b3ec2a921f6355868d99fea85ebf4541b91bf5a025b924314aac74d103617c366c16a3cc87598eaa7d2d2917bb628e7172fb50414fb52f46ffeb554c4800bfe12f74fef726a0a17d37a125cba10cd2a2ad1d9b82707d67fb82021b3107a82f694be7940ace080e59dde586a36ecbfb83c50f91fc4023352b2d22705dbbafbc97899adc7a91c14bd54cf6fe7b48cf33d915a5acc0460d173e69760c1bd4499d20fc0d269558a6141f6a5e1b71cb8f2ed0493fb86dd59a7722864a0e6b1097b0887383ae0e2cdad41ac79bd8048526aeb29c74d7419ca6b0d3183311468b448e4379f89bea674f061840e2ff60403a4187eafb3dd8877da8e20a397dcb1c962cd747bbaddb6f4cfe61fe68d03220b61bec5d3f944712f0d1bf344a61d62ae91dc02768dcc635fbdfc071b9ae5456366fe7554c057d7e1d8311031e8cd4481c84fbd46d1b4f2156d78692422290b4e54d9d93b6cb7ce618f6cfed4567beb90980b9bb155b5027201ffa7cb100f39472b7a4703aeddb58c163cc855589fe0553e78e2c56c17b6d2e6ac37a48a608ab5a53c06ed41262adb07e1a69d8a677fb62f86fdd009eb4cf1ed03295338622af99d9892a821a8bcd2b569dcd87a888f34e2f2ca0055f12cd3f41b855ceb6c7edaafe3c1ac0d92513d8d4de381951af4a05b5739df903356f1602d4e8ecb7ef10148ed4d4e1b7101f63f59193f01b98ad87d9d9ec7c9100e7e1f3de0f0b185ef73c928f6bc903d66088a232893ec0fb07944856599c593ef20069017cd7aaaa64965d336dbb8917eb5d14159ccbf71203165a2a46eaf55cf9b52b5ce8b7cf799eb585fea6717c5ed84fc50bd44f1cba9f9296ef5a59012190d6772a65a4c015ccdbb068d9888ab501eb30b83a2cc591cd40af7abe6f22fa837571f5191ba5c1d81912c2ab5f457b4c892c88234a466214085565583971e934cb13153f445db0baa45130ba6710a05f68c9fd6522fb6eb825b9e7cc0b397058149f30870b3fab9a3e0cd8fecede7c115ed1725d6db1a190c2f98b48daebe379eee740a9143fa6fe19985f26678f2b7344fbf11ec15c6055aab0accf597aec71e232776c5ff2b30c4d041d88d99f1c7759c083734825d4b21fdf57d7990d167e9bfc979b6dfbd38704fb4167fcd7ff8715f2699ce1e84b022fb30162d6d2b2ae47e63b73d0dd2340a9967f31c742182ec5001b94c33f554492bd15244840d4beefccdaaae711f906b55c9de634603f7fe4352ae29d5c6f5f3e30cdd64b4c09212fcdc1ee1514661e6d10a1452609a81bd5bbb8583aab93fc29cb17b1a1d68f738643abf7e3ee56302311d8ede9ccc30d7eb9335a75608cda6837ea56133bd1eedd0051707eb03257d1d45f1dc152a593409b467d9840bf31cdd76498aafaa4ff843c40aac44186bf18d1aa33b17afee0e8963d34cdd411b94f057e197b35a87da8de8944864b0c988244e716e2083b2dab5a56789c8e683c3ebfa32478b14225c827473bdf1119487a6f825b7e23097abc65be21181f8584d24f1017a8e098c1b56e82211410442f29221c1437ca8ede91671a59f215c1f92a4c71864dbf5ff0e6878a296c5e652d5812e614b921d39366718304289aab1077590c346697743240207b13e6b18c82fcc844d4bcb751c6d6b19c7df24a4c436a2afe442d71b5152b1dfd1183f9e8c396c047c0df20401f2254db422490c729eac4a4dabf7924885b3c88a122118cd8a8d223067d32a7a88e573b4435f9cf264d298b276c9c6ab622074c2487f62da78623a3838c9ecc8f6a601cb44179627e5f628e9154406654e90e942796614e4ada6f2e34815a25adc379dcd10d1c8e60cf371afe316091b00d576905418cd5e620808ff62b14ef709991591eebd8f76dd3417c15be4b9ecc3c4c209e22a60f2f34eb292de168b0ca2545fff7d869d9ef4db49c98a6e4df7ab9effac055a8257a4319026470f76fba5236857e339c3d35061d43fe93af5892ed4d60847d7ed69b17dbe3f3ed59021cc10725561684b9eff9998d1df63bae97f56da3a3c7338cba05c1e8af4c398a35b5ff0d30e3c69cfab3ac4d3aa2dd15ab9ea8f2b58b52d5b219a8892c7837ff933d9db7470a61331ac21377528e7fc7f011687386a95a99cadd0ece895e9a3d86982944378a99e6a5e33141af4c090018fdefd4930956433d845816f611e8db4e8da630c70cbaae56687722cab40d422fd4539631c88dcf7361609c4cb0d1b66bc01f57c4c7987b4f6392271e061f6e2f07b2d4576f7690befe8ac9b924ce38c49622dc4dca3d567832fdf3c5576e8cd3a9f453d3afbc6ff094bec7ceeccb5c8f87e80dfed5195e45f9ce9f577c194d00b671ef3178ad2314a0bee7f652fea09ff7f9d88666e052a7cd8c87c8c38b41858217708955e90cf5856ad3fdd8e479b08bf828cd471c6c8e49b9cae2df16c45a03828c46e5b426b972668e8cbc82630229f2341a2b9603f3af4eeaa51728daa7e3f7320629c61f0d031866f6244d9f602d7ecdb8d5046ca0d55a59feda88480ffbdf37c503120b8f3cdd7389420411f271d55516c087e23a7f16f1877e63e5f035606aed800d9e8a9fc1b40a848458f3eeda3c891dd09fa02685160e55a54b8a5163ea5693a7180f7a5fe7032e0719ea9f08f436566f045744ed53f7f9fbfc4efdfb48db8bf14871f85b30af236a1c9e90aca745222ecebee17567733a043a0011c4d7954c8bfefda9eb0eb547b5abc3e14c5b36cede4fe11c3e5a995235aff78c138dccea3636e9165408af35a7684c4a490192f0c4ba022f189c3c2d848220ecef6882d9d10aadcd301ff1b91472c2ac11882e900dd76778dd3bfa8cc108ec766934c8e0ff4f5238ef6af761e5912fa271d636819d2675ca61aeb87a0eae832043bb862c24a0e96fb7ce276aa0796a0465a01a7b6cadbf1b0372371b5cd33f049c758d415cd52fbedfca8b71f2ef83ccfe2c6d73170b7e811a8035e1644df31162accd2e127486b3df33f8fcda951940ff70c5cb7609c8b6c2f0186273536c45bd669abfca0d0cbe6603655d4693701db5214b211e73247e6652bb785cab8abe1ed56f5daf5b6dc8a4d5b992cd1ddcf223461360ea72e63482d0fbc45104bd511ba5461a53ff447ffa2b1102e5a6cc1c5a478f785e017f7fbe1ae1ceaaac59a40c2e69c28657a51db58ee96ff367d3ce31b13c071168041a7a492aeff373310768e28de540fbcba6800ca7d641dadc1ff5ec6b1731f7024dca638abdf97ec4d3233f9059db21a72fb436506288b8a7ea6d503feed580c730ec8b71fb82a226099282061504c3fefd870f6cafa4f23a44d4a5e7ec3142ebf2a416c6aa47f3943c8864ed669faea775b9ca7a4eb8107f06c46fba1f388df95f90cc1ffc5dd135fa7bb2ba845ce36c9198507e7c96619fd5f5edc032f767d9a951bddd58a3f9ad3a406a96ee1556de04f1e060cc1b6d073dd3fe97b1baded025c28ac330b8390b25e641d7dfdc7c253846c9fc9496c12b8ba2f3b24ad09c371642f9e787a8493bf3cc2ad1061e2f241294c2e69fba6b18d63ff299be6c5125cf4e1381e38e9cca995dea0641af216ca3d76489556f29a014d2a8e808cdfb89c5fe94ea03bd763c41677fcb226ee235046d22e2f8709a98064688fd750978310b249592cd036d372137545289dddb62d09d5c34ab1091833a59c8bcc439ec09bda7195d7e68791eb305717926d1d3d38cc6b349d01b63fff5294cbcc396abb66c050034db27aa75</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>多媒体</category>
      </categories>
      <tags>
        <tag>数据传输</tag>
      </tags>
  </entry>
  <entry>
    <title>编码参数</title>
    <url>/post/5cd06009.html</url>
    <content><![CDATA[<p>记录H264、H265中用到的一些编码参数，及其特点等。</p>
<span id="more"></span>

<p>编码器相关参数说明：</p>
<h2 id="码率控制"><a href="#码率控制" class="headerlink" title="码率控制"></a>码率控制</h2><h3 id="CBR"><a href="#CBR" class="headerlink" title="CBR"></a>CBR</h3><ul>
<li>CBR：constant bitrate 恒定比特率编码，属于<strong>码率优先</strong>模型</li>
</ul>
<p>由于码率恒定，只能通过<strong>增大QP来减少码字</strong>大小，图像质量变差，当场景静止时，图像质量又变好，因此图像质量不稳定。这种算法优先考虑码率(带宽)。</p>
<h4 id="适用场景："><a href="#适用场景：" class="headerlink" title="适用场景："></a>适用场景：</h4><p>一般也不建议使用这种方式，虽然输出的码率总是处于一个稳定值，但是质量不稳定，不能充分有效利用网络带宽，因为这种模型不考虑视频内容的复杂性，把所有视频帧的内容统一对待。但是有些编码软件只支持固定质量或者固定码率方式，有时不得不用。用的时候在允许的带宽范围内尽可能把带宽设置大点，以防止复杂运动场景下视频质量很低，如果设置的不合理，在运动场景下直接就糊的看不成了。</p>
<h4 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h4><ul>
<li>码率稳定，但是质量不稳定，带宽有效利用率不高，特别当该值设置不合理，在复杂运动场景下，画面非常模糊，非常影响观看体验；</li>
<li>但是输出视频码率基本稳定，便于计算视频体积大小；</li>
</ul>
<h3 id="VBR"><a href="#VBR" class="headerlink" title="VBR"></a>VBR</h3><ul>
<li>VBR：variable bitrate 可变比特率编码</li>
</ul>
<p>比特分配<strong>根据图像内容的复杂度</strong>进行。如果图像细节较丰富或者含有大量的运动，则给其分配大一点的码流，若图像比较平坦，就给其分配较少的码流，这样既保证了质量，又兼顾带宽限制。</p>
<p>简单场景分配比较大的QP，压缩率小，质量高。复杂场景分配较小QP。得到基本稳定的视觉质量，因为人眼人眼本来就对复杂场景不敏感，缺点在于输出码率大小不可控。</p>
<p>有两种调控模式：<code>质量优先模式</code>和<code>2PASS二次编码模式</code>。</p>
<ul>
<li><code>质量优先模式</code>: 不考虑输出视频文件的大小，完全按照视频的内容复杂程度来分配码率，这样视频的播放效果质量最好。</li>
<li><code>2PASS二次编码模式</code>: 第一次编码检测视频内容的简单和复杂部分，同时确定简单和复杂的比例。第二遍编码会让视频的平均码率不变，复杂的地方分配多bit,简单地方分配少bit。这种编码虽然很好，但是速度会跟不上。</li>
</ul>
<h4 id="适用场景：-1"><a href="#适用场景：-1" class="headerlink" title="适用场景："></a>适用场景：</h4><p>VBR适用于那些对带宽和编码速度不太限制，但是对质量有很高要求的场景。特别是在运动的复杂场景下也可以保持比较高的清晰度且输出质量比较稳定，适合对延时不敏感的点播，录播或者存储系统。</p>
<h4 id="特点：-1"><a href="#特点：-1" class="headerlink" title="特点："></a>特点：</h4><ul>
<li>码率不稳定，质量基本稳定且非常高；</li>
<li>编码速度一般比较慢，点播、下载和存储系统可以优先使用，不适合低延时、直播系统；</li>
<li>这种模型完全不考虑输出的视频带宽，为了质量，需要多少码率就占用多少，也不太考虑编码速度；</li>
</ul>
<h3 id="CRF"><a href="#CRF" class="headerlink" title="CRF"></a>CRF</h3><ul>
<li>CRF：Constant Rate Factor 恒定码率系数，属于<strong>视频质量优先</strong>模型</li>
</ul>
<p>把某一个”视觉质量”作为输出目标。通过降低那些耗费码率但是又难以用肉眼察觉的帧（高速运动或者纹理丰富）的质量提升那些静态帧的码率来达到此目的。</p>
<h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h4><p>适用于对视频质量有一定要求的场合，CRF值可以简单理解为对视频质量期望的一个输出固定值，希望无论是在运动复杂场景下还是在静止简单情况下，都希望有一个稳定的主观视频质量可以选择该模式，该模式是视频质量优先模型。视频质量可以简单理解为视频的清晰度，像素的细腻程度和视频的流畅度。</p>
<h4 id="特点：-2"><a href="#特点：-2" class="headerlink" title="特点："></a>特点：</h4><ul>
<li>帧间QP变化，帧内宏块的QP变化，输出码率未知，各帧输出的视觉质量基本恒定，这种方式相当于固定质量模式+限制码率峰值的方式。</li>
<li>CRF值<strong>越大视频压缩率越高，但视频质量越低</strong>，各codec的CRF取值范围一般[0-51],但是一般默认值x264用23，x265库默认为28；</li>
</ul>
<h3 id="ABR"><a href="#ABR" class="headerlink" title="ABR"></a>ABR</h3><ul>
<li>ABR：(Average Bit Rate）恒定平均目标码率</li>
</ul>
<p>简单场景分配较低bit,复杂场景分配足够bit，使得有限的bit数能够在不同场景下合理分配，这类似VBR。同时一定时间内，平均码率又接近设置的目标码率，这样可以控制输出文件的大小，这又类似CBR。可以认为是CBR和VBR的折中方案，这是大多人的选择。特别在对质量和视频带宽都有要求的情况下，可以优先选择该模式，一般速度是VBR的两倍到三倍，相同体积的视频文件质量却比CBR好很多。</p>
<h4 id="适用场景：-2"><a href="#适用场景：-2" class="headerlink" title="适用场景："></a>适用场景：</h4><p>ABR在直播和低延时系统用的比较多，因为只编码了一次，所以速度快，同时兼顾了视频质量和带宽,对于转码速度有要求的情况下也可以选择该模式。B站的大部分视频就选择了该模式。</p>
<h4 id="特点：-3"><a href="#特点：-3" class="headerlink" title="特点："></a>特点：</h4><ul>
<li>视频质量整体可控，同时兼顾了视频码率和速度，是一个折中方案，实际用的比较多；</li>
<li>使用过程一般要让调用方设置，最低码率、最高码率和平均码率，这些值要尽可能设置合理点；</li>
</ul>
<h3 id="CQP"><a href="#CQP" class="headerlink" title="CQP"></a>CQP</h3><ul>
<li>CQP: Constant QP 固定QP</li>
</ul>
<p>最简单的码率控制方式，每帧图像都按照一个特定的QP来编码，每帧编码后的数据量有多大是未知的，既不是码率优先模型也不是质量优先模型，不过是实现最简单的模型；</p>
<h4 id="适用场景：-3"><a href="#适用场景：-3" class="headerlink" title="适用场景："></a>适用场景：</h4><p>一般不建议使用这种方式，因为这种方式不考虑编码内容的复杂性，用相同的压缩比处理每一帧。出来的视频质量和码率都不固定。个人觉得只有那种非常简单的场景，比如静止不变的场景运动量很小的场景可以尝试用，一遇到复杂场景，码率波动就非常大。或者在算法研究或者验证可以使用。</p>
<h4 id="特点：-4"><a href="#特点：-4" class="headerlink" title="特点："></a>特点：</h4><ul>
<li>瞬时码率会随场景复杂度波动；</li>
<li>编码速度快，调控最简单,每帧的QP值相同；</li>
<li>x264和x265中支持CQP模式，libvpx不支持；</li>
<li>H.264中QP范围是[0, 51]。QP值越大表示越大的量化步长，编码视频的质量越低。QP为0表示进行无损编码；</li>
</ul>
<h2 id="ROI-region-of-interest-encoding"><a href="#ROI-region-of-interest-encoding" class="headerlink" title="ROI (region of interest) encoding"></a>ROI (region of interest) encoding</h2><p>基于感兴趣区域的视频编码技术，对图像中感兴趣的区域减少量化参数值（qp：quantization parameter），从而分配更多码率以提升画面质量，而对不感兴趣的区域则增加量化参数值（qp），从而分配更少码率（这部分区域的画面质量会因此有所下降），这样，在不损失图像整体质量的前提下，可以节省网络带宽占用和视频存储空间，或者，在不增加网络带宽占用和存储空间的前提下，可以提高视频的整体质量。这在监控、窄带高清等领域都有较大的应用。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NoaXhpbl8wMTI1L2FydGljbGUvZGV0YWlscy8xMDg5OTU3MDU=">视频编码码率控制：CBR、VBR和ABR<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>多媒体</category>
      </categories>
      <tags>
        <tag>编码</tag>
      </tags>
  </entry>
  <entry>
    <title>视频编码分析工具——AVC/HEVC</title>
    <url>/post/5b258677.html</url>
    <content><![CDATA[<p>视频编解码分析工具，主要针对AVC&#x2F;HEVC码流的分析</p>
<span id="more"></span>

<h2 id="Elecard-StreamEye-Demo"><a href="#Elecard-StreamEye-Demo" class="headerlink" title="Elecard StreamEye Demo"></a>Elecard StreamEye Demo</h2><p>该软件可以对<code>AVC</code>和<code>HEVC</code>码流进行解析，但是付费软件，可以免费试用30天。如果超过30天后，将无法正常显示解码后的图像。</p>
<p>官网：<span class="exturl" data-url="aHR0cHM6Ly93d3cuZWxlY2FyZC5jb20vc29mdHdhcmU=">https://www.elecard.com/software<i class="fa fa-external-link-alt"></i></span></p>
<p>直接下载地址：</p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9lbi5mcmVlZG93bmxvYWRtYW5hZ2VyLm9yZy9XaW5kb3dzLVBDL0VsZWNhcmQtU3RyZWFtRXllLVN0dWRpby1Qcm8tRGVtby5odG1s">https://en.freedownloadmanager.org/Windows-PC/Elecard-StreamEye-Studio-Pro-Demo.html<i class="fa fa-external-link-alt"></i></span> （当前最新版本）</li>
</ul>
<blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9lbi5mcmVlZG93bmxvYWRtYW5hZ2VyLm9yZy9XaW5kb3dzLVBDL0VsZWNhcmQtU3RyZWFtRXllLmh0bWw=">https://en.freedownloadmanager.org/Windows-PC/Elecard-StreamEye.html<i class="fa fa-external-link-alt"></i></span> （旧版本，可以免费使用）</p>
</blockquote>
<h2 id="视频格式转换——在线文件转换器"><a href="#视频格式转换——在线文件转换器" class="headerlink" title="视频格式转换——在线文件转换器"></a>视频格式转换——在线文件转换器</h2><blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9jb252ZXJ0aW8uY28v">https://convertio.co<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<ul>
<li>WMV转换成MJPEG： <span class="exturl" data-url="aHR0cHM6Ly9jb252ZXJ0aW8uY28vemgvd212LW1qcGVnLw==">https://convertio.co/zh/wmv-mjpeg/<i class="fa fa-external-link-alt"></i></span></li>
<li>MP4转换成MJPEG： <span class="exturl" data-url="aHR0cHM6Ly9jb252ZXJ0aW8uY28vemgvbXA0LW1qcGVnLw==">https://convertio.co/zh/mp4-mjpeg/<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>多媒体</category>
      </categories>
      <tags>
        <tag>h264</tag>
        <tag>h265</tag>
      </tags>
  </entry>
  <entry>
    <title>sc boot</title>
    <url>/post/68e436e0.html</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="90fdbe9cee04ecb87a3760f373bdc7525157f96051d37ce2de9846955d2704e8">5b3594cd8b1eaf4f84b96bccf2fb17bc451ee141fcf1d0d6466345f11194fc493c1d899ddf65e9b4ebf709127e02084dc5d658b6c38484ced5348cfe55042b181ef5d7ed8cf9d31a7b407fc3da60a06e7fc90cb1f9ffaa6b61ccc052f556046f0ae9639f3e9565385753abdc613b632f068ef3bd8997f383cde2991bfa9fe6e04396d234e32a14a85962fe5ddddf58f6cd8f3b942829baf6349746d839b467a34ae5af19b52aef254e28f9cbca556858729d3b1ff2977053ecf513ea471ad3c7d3a8db45af69ed50ceeb56eef8104998481e6fd2e8548a9baa47401856a36d0349b9a7548a60ff79f8ee4fad9f591d7c1ee8b365e5c62e0dad5feba5c1fca9cdfdd72615afd9c3e2a957bc0615a6d04684605d2ca4d729f13c289b1c9fa22259f796aacb5c7d2aba804896adbcae6ace5aaef9496f07151fe3fd505d3732e3c1bbb4f67c39384d22647a06a40721a11d032eed0496931b3b1af67c1f8f592975086995f76bda00729e69726758e5e293db5ce897bff1d2ccb24cb57a0b0fc6c9d7372e0ba3424e615d0ef29beedbbe055de79e21e73b7d1f49102e6f50b1708c0f38033ac11c849568361fe8521e6d1334afe77c91a34686739c7f2f93cc57e1580c41630fcac0d4ce7eb1f697825b613bb2db5fff2c4dcdfe860838b3ef82e5407b582395de10db8ca6c730bfffbb36e42943ec44980db119a5d94cb21fabafeb9a753344ce4709f7ff9c09968730b77a1570531062fa3e8365b846e7b7dff279e9c37fa5d8a8b28791bdb9265723ce08cea529a788fbfc769bc69b1dbc5d889ded45b48dde1fc287c3f7ebdbb5b4852cfede3ce5ef44e95200938efd73b94a98761663b7113b49de53a6b020e7644ffa8699a700cf02638cda28c3d090568e73f9dfffbc7bc7ccaf1a65a68a73e0a27424648ad8871a814b12da2e57de8faa31e5e770114d7e1d63c565fec5b4847b6b8a3b41342ec445e941ef230914d0e1d4edb04870340d3bcccb7b969487ec72798c67c63ad0754a5f2a190a3f77f6508bff6b2fb3f621a901b0da14fd517a9557059c546b1080f9417f5e8084539167beeea062335f258ce5d5a9833f5ce4f7296b5834aa581603082a141a20805087002c0a1d49c7d35197ea2650efea494c180dea1d4729748a22e8ae9b39967cf4b7e99971c5e8539782293c407fa3c577511fd976866d4393e11b7ee36cf861e63c712bee9a78794a7ac33363440bea070cea487114fb468181b78ebdaf3f89ce1a2898c0b81bab903fa9477fee86fae03008db82d80955a1eb3454be618c003fdd7cf0372edd197af86922b2517b149ae2d359e550f052b8ff579a325dfea70f1624337dbf282cd717ba37fb69c50549aeb47f997a51b12631b11a22d5d0e24677b163ba319eec39ba78c6ff3cefb1d70023e3e5a64f3337e26e1e043a68aa987c87dc28121d89695ba80673b7c2bab3161b6d8174f3bb84a1d67bbcaa8129d6</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>boot</tag>
      </tags>
  </entry>
  <entry>
    <title>clash for linux</title>
    <url>/post/9992854.html</url>
    <content><![CDATA[<p>Clash 是一个使用 Go 语言编写，基于规则的跨平台代理软件核心程序。</p>
<span id="more"></span>


<h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://github.com/Dreamacro/clash/releases/download/v1.13.0/clash-linux-amd64-v1.13.0.gz</span><br></pre></td></tr></table></figure>
<p>最新版本 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0RyZWFtYWNyby9jbGFzaC9yZWxlYXNlcw==">https://github.com/Dreamacro/clash/releases<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>解压后直接执行，将在<code>~/.config/</code>目录下生成一个clash目录，其中有配置文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gzip -d clash-linux-amd64-v1.13.0.gz</span><br><span class="line">chmod +x clash-linux-amd64-v1.13.0</span><br><span class="line">./clash-linux-amd64-v1.13.0</span><br><span class="line">INFO[0000] Can&#x27;t find config, create a initial config file</span><br><span class="line">INFO[0000] Can&#x27;t find MMDB, start download</span><br></pre></td></tr></table></figure>

<p>为了后期管理方便，可以之间将解压后的clash拷贝到<code>~/.config/clash</code>目录下，并重命名为clash</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp ./clash-linux-amd64-v1.13.0 ~/.config/clash/clash</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash"><span class="built_in">ls</span> ~/.config/clash/</span></span><br><span class="line">clash  config.yaml</span><br></pre></td></tr></table></figure>


<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>下载配置文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget -O config.yaml &quot;代理商提供的订阅链接&quot;</span><br><span class="line">wget -O config.yaml &quot;https://xxxxxxxxxxxxxxxxxx06d2739906177ad22&amp;flag=clash&quot;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果下载到的是一大堆字符则需要在订阅链接的后面添加 <strong>&amp;flag&#x3D;clash</strong></p>
</blockquote>
<p>执行<code>./clash</code>，将会下载<code>Country.mmdb</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./clash</span><br><span class="line">WARN[0000] MMDB invalid, remove and download</span><br></pre></td></tr></table></figure>

<p>如果下载失败进行手动下载</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">./clash</span></span><br><span class="line">WARN[0000] MMDB invalid, remove and download</span><br><span class="line">FATA[0030] Initial configuration directory error: can&#x27;t initial MMDB: can&#x27;t download MMDB: Get &quot;https://cdn.jsdelivr.net/gh/Dreamacro/maxmind-geoip@release/Country.mmdb&quot;: dial tcp 146.75.113.229:443: i/o timeout</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget -O Country.mmdb https://www.sub-speeder.com/client-download/Country.mmdb</span><br></pre></td></tr></table></figure>

<p>在 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0RyZWFtYWNyby9tYXhtaW5kLWdlb2lwL3JlbGVhc2Vz">https://github.com/Dreamacro/maxmind-geoip/releases<i class="fa fa-external-link-alt"></i></span> 下载也可以</p>
<p>以上准备配置文件弄号后就可以运行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">~/.config/clash</span><br><span class="line">↪ =&gt;$ls</span><br><span class="line">clash  config.yaml  Country.mmdb</span><br><span class="line"></span><br><span class="line">↪ =&gt;$./clash</span><br><span class="line">INFO[0000] Start initial compatible provider 故障转移</span><br><span class="line">INFO[0000] Start initial compatible provider 自动选择</span><br><span class="line">INFO[0000] Start initial compatible provider 一元机场</span><br><span class="line">INFO[0000] RESTful API listening at: 127.0.0.1:9090</span><br><span class="line">INFO[0000] Mixed(http+socks) proxy listening at: [::]:7890</span><br></pre></td></tr></table></figure>

<p>在<code>clash</code>启动后用浏览器访问网址<code>http://clash.razord.top/</code> ，在这里修改配置信息</p>
<h2 id="配置代理"><a href="#配置代理" class="headerlink" title="配置代理"></a>配置代理</h2><h3 id="系统代理配置——浏览器生效"><a href="#系统代理配置——浏览器生效" class="headerlink" title="系统代理配置——浏览器生效"></a>系统代理配置——浏览器生效</h3><p><img data-src="/../../images/clash%20for%20linux.png"></p>
<p>命令行设置：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gsettings set org.gnome.system.proxy.http host &#x27;127.0.0.1&#x27;</span><br><span class="line">gsettings set org.gnome.system.proxy.http port 7890</span><br><span class="line">gsettings set org.gnome.system.proxy.https host &#x27;127.0.0.1&#x27;</span><br><span class="line">gsettings set org.gnome.system.proxy.https port 7890</span><br><span class="line">gsettings set org.gnome.system.proxy.ftp host &#x27;&#x27;</span><br><span class="line">gsettings set org.gnome.system.proxy.ftp port 0</span><br><span class="line">gsettings set org.gnome.system.proxy.socks host &#x27;127.0.0.1&#x27;</span><br><span class="line">gsettings set org.gnome.system.proxy.socks port 7890</span><br><span class="line"></span><br><span class="line">gsettings set org.gnome.system.proxy mode &#x27;manual&#x27;;</span><br></pre></td></tr></table></figure>

<h3 id="git代理"><a href="#git代理" class="headerlink" title="git代理"></a>git代理</h3><h4 id="https传输"><a href="#https传输" class="headerlink" title="https传输"></a>https传输</h4><ul>
<li><p>http代理</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global http.proxy &#x27;http://127.0.0.1:1080&#x27;</span><br><span class="line">git config --global https.proxy &#x27;http://127.0.0.1:1080&#x27;</span><br></pre></td></tr></table></figure>
</li>
<li><p>socks5代理</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global http.proxy &#x27;socks5://127.0.0.1:1081&#x27;  </span><br><span class="line">git config --global https.proxy &#x27;socks5://127.0.0.1:1081&#x27;</span><br></pre></td></tr></table></figure>
</li>
<li><p>取消代理</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global --unset http.proxy  </span><br><span class="line">git config --global --unset https.proxy</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="ssh传输"><a href="#ssh传输" class="headerlink" title="ssh传输"></a>ssh传输</h4><p>通过 <span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTmV0Y2F0">netcat<i class="fa fa-external-link-alt"></i></span> 或 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dvdG9oL3NzaC1jb25uZWN0">ssh-connect<i class="fa fa-external-link-alt"></i></span> 可以建立连接以供 ssh 使用。</p>
<p>修改 OpenSSH 的 <code>config</code> 文件（Unix&#x2F;Linux&#x2F;Git-Bash：<code>~/.ssh/config</code>），添加如下内容之一</p>
<h5 id="netcat"><a href="#netcat" class="headerlink" title="netcat"></a>netcat</h5><ul>
<li>http代理<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Host github.com  </span><br><span class="line">	HostName github.com  </span><br><span class="line">	User git  </span><br><span class="line">	ProxyCommand nc -v -X connect -x 127.0.0.1:1080 %h %p</span><br></pre></td></tr></table></figure></li>
<li>socks5代理<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Host github.com  </span><br><span class="line">	HostName github.com  </span><br><span class="line">	User git  </span><br><span class="line">	ProxyCommand nc -v -x 127.0.0.1:1081 %h %p</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="ssh-connect"><a href="#ssh-connect" class="headerlink" title="ssh-connect"></a>ssh-connect</h5><ul>
<li><p>http代理</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Host github.com  </span><br><span class="line">	HostName github.com  </span><br><span class="line">	User git  </span><br><span class="line">	ProxyCommand connect -H 127.0.0.1:1080 %h %p</span><br></pre></td></tr></table></figure>
</li>
<li><p>socks5代理</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Host github.com  </span><br><span class="line">	HostName github.com  </span><br><span class="line">	User git  </span><br><span class="line">	ProxyCommand connect -S 127.0.0.1:1081 %h %p</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="命令行下载代理——proxychains"><a href="#命令行下载代理——proxychains" class="headerlink" title="命令行下载代理——proxychains"></a>命令行下载代理——proxychains</h2><p>需要socks代理端口</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install proxychains</span><br></pre></td></tr></table></figure>

<p>ProxyChains 的配置文件位于 &#x2F;etc&#x2F;proxychains.conf ，打开后你需要在末尾添加你使用的代理。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[ProxyList]</span><br><span class="line"># add proxy here ...</span><br><span class="line"># meanwile</span><br><span class="line"># defaults set to &quot;tor&quot;</span><br><span class="line">#socks4 	127.0.0.1 9050</span><br><span class="line"></span><br><span class="line">socks5 127.0.0.1 7890   # 配置为混合端口，因此不需要区分</span><br></pre></td></tr></table></figure>

<ul>
<li>测试</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">proxychains ping www.google.com</span><br><span class="line">ProxyChains-3.1 (http://proxychains.sf.net)</span><br><span class="line">ERROR: ld.so: object &#x27;libproxychains.so.3&#x27; from LD_PRELOAD cannot be preloaded (cannot open shared object file): ignored.</span><br><span class="line">PING www.google.com (199.59.149.201) 56(84) bytes of data.</span><br></pre></td></tr></table></figure>

<ul>
<li>解决方法：</li>
</ul>
<p>查找<code>libproxychains.so.3</code>位置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">whereis libproxychains.so.3</span><br><span class="line">libproxychains.so: /usr/lib/x86_64-linux-gnu/libproxychains.so.3</span><br></pre></td></tr></table></figure>

<p>修改<code>/usr/bin/proxychains</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line">echo &quot;ProxyChains-3.1 (http://proxychains.sf.net)&quot;</span><br><span class="line">if [ $# = 0 ] ; then</span><br><span class="line">	echo &quot;	usage:&quot;</span><br><span class="line">	echo &quot;		proxychains &lt;prog&gt; [args]&quot;</span><br><span class="line">	exit</span><br><span class="line">fi</span><br><span class="line">export LD_PRELOAD=/usr/lib/x86_64-linux-gnu/libproxychains.so.3   # 使用绝对路径</span><br><span class="line">exec &quot;$@&quot;</span><br></pre></td></tr></table></figure>


<h3 id="代理与source执行"><a href="#代理与source执行" class="headerlink" title="代理与source执行"></a>代理与source执行</h3><p>在需要代理并通过source执行脚本时，可以使用以下方法：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">proxychains bash -c source install.sh</span><br></pre></td></tr></table></figure>


<h3 id="代理与sudo"><a href="#代理与sudo" class="headerlink" title="代理与sudo"></a>代理与sudo</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo proxychains apt-get update</span><br></pre></td></tr></table></figure>


<h2 id="clash的自启动"><a href="#clash的自启动" class="headerlink" title="clash的自启动"></a>clash的自启动</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pkill -9 clash # 先杀死之前的进程</span><br><span class="line">rm nohuop.out # 删除刚刚生成的nohup.out文件</span><br><span class="line">nohup ./clash -d . &gt; /dev/null 2&gt;&amp;1 &amp; # 不生成文件</span><br><span class="line">lsof -i:7890 # 查看端口占用情况</span><br></pre></td></tr></table></figure>

<p>创建一个<code>auto_run.sh</code>脚本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nohup $HOME/.config/clash/clash -d $HOME/.config/clash/ &gt; /dev/null 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure>

<p>将clash注册为systemctl服务 &#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system下新建一个文件clash.service 填入内容</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo vim /usr/lib/systemd/system/clash.service</span><br><span class="line"></span><br><span class="line">cat /usr/lib/systemd/system/clash.service</span><br><span class="line">[Unit]</span><br><span class="line">Description=clash linux</span><br><span class="line">After=network-online.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=simple</span><br><span class="line">ExecStart=/opt/clash/clash -d /opt/clash</span><br><span class="line">Restart=always</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>
<blockquote>
<p>根据实际配置路径进行修改</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重新加载配置文件</span></span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置开机自启</span></span><br><span class="line">sudo systemctl enable clash</span><br><span class="line"></span><br><span class="line">service clash start   # 启动</span><br><span class="line">service clash stop    # 停止</span><br><span class="line">service clash restart # 重启</span><br><span class="line">service clash status  # 状态</span><br></pre></td></tr></table></figure>


<h2 id="自动更新配置文件"><a href="#自动更新配置文件" class="headerlink" title="自动更新配置文件"></a>自动更新配置文件</h2><p>配置文件信息是会更新的，我们也需要定时地更新本地的配置文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget -O /home/your_name/.config/clash/config.yaml &quot;订阅链接&quot;</span><br></pre></td></tr></table></figure>

<p>使用linux自带的<code>cron</code>定时器，设定每日都运行一遍</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">crontab -e # 编辑定时任务</span><br><span class="line">25 20 * * * wget -O /home/your_name/.config/clash/config.yaml [订阅地址]</span><br><span class="line">service cron restart # 修改完都需要重启服务，不然不能生效</span><br></pre></td></tr></table></figure>
<blockquote>
<p>每天的<code>20:25</code>定时执行更新命令</p>
</blockquote>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8zNjY1ODk0MDc=">如何在Linux中使用Clash<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWx2aW5rd29rLmNuLzIwMjIvMDEvMjkvMjAyMi8wMS9DbGFzaCUyMEZvciUyMExpbnV4JTIwSW5zdGFsbCUyMEd1aWRlLw==">CLash for Linux 安装配置<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLnp6c3F3cS5jbi9wb3N0cy9ob3ctdG8tdXNlLWNsYXNoLW9uLWxpbnV4Lw==">如何在 Linux 上优雅的使用 Clash？<i class="fa fa-external-link-alt"></i></span> —— Docker</li>
</ul>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>科学上网</tag>
      </tags>
  </entry>
  <entry>
    <title>C与YAML的解析</title>
    <url>/post/865ecfcc.html</url>
    <content><![CDATA[<p><code>YAML</code>是”YAML Ain’t a Markup Language”（YAML不是一种标记语言）的递归缩写。在开发的这种语言时，YAML 的意思其实是：”Yet Another Markup Language”（仍是一种标记语言），但为了强调这种语言以数据做为中心，而不是以标记语言为重点，而用反向缩略语重命名。</p>
<p>YAML 的语法和其他高级语言类似，并且可以简单表达清单、散列表，标量等数据形态</p>
<p>适用场景:</p>
<ul>
<li>脚本语言</li>
<li>序列化</li>
<li>配置文件</li>
</ul>
<span id="more"></span>

<p>C语言解析库:<span class="exturl" data-url="aHR0cHM6Ly9weXlhbWwub3JnL3dpa2kvTGliWUFNTA==">https://pyyaml.org/wiki/LibYAML<i class="fa fa-external-link-alt"></i></span></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/yaml/libyaml</span><br></pre></td></tr></table></figure>

<h2 id="安装依赖库"><a href="#安装依赖库" class="headerlink" title="安装依赖库"></a>安装依赖库</h2><ul>
<li>ubuntu<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install libyaml-dev</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># config/public.yaml</span><br><span class="line"></span><br><span class="line">title   : Finex 2011</span><br><span class="line">img_url : /finex/html/img/</span><br><span class="line">css_url : /finex/html/style/</span><br><span class="line">js_url  : /finex/html/js/</span><br><span class="line"></span><br><span class="line">template_dir: html/templ/</span><br><span class="line"></span><br><span class="line">default_act : idx    # used for invalid/missing act=</span><br><span class="line"></span><br><span class="line">pages:</span><br><span class="line">  - act   : idx</span><br><span class="line">    title : Welcome</span><br><span class="line">    html  : public/welcome.phtml</span><br><span class="line">  - act   : reg</span><br><span class="line">    title : Register</span><br><span class="line">    html  : public/register.phtml</span><br><span class="line">  - act   : log</span><br><span class="line">    title : Log in</span><br><span class="line">    html  : public/login.phtml</span><br><span class="line">  - act   : out</span><br><span class="line">    title : Log out</span><br><span class="line">    html  : public/logout.phtml</span><br></pre></td></tr></table></figure>


<h3 id="解析代码"><a href="#解析代码" class="headerlink" title="解析代码"></a>解析代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;yaml.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    FILE *fh = fopen(<span class="string">&quot;public.yaml&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="type">yaml_parser_t</span> parser;</span><br><span class="line">    <span class="type">yaml_token_t</span>  token;   <span class="comment">/* new variable */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Initialize parser */</span></span><br><span class="line">    <span class="keyword">if</span>(!yaml_parser_initialize(&amp;parser))</span><br><span class="line">        <span class="built_in">fputs</span>(<span class="string">&quot;Failed to initialize parser!\n&quot;</span>, <span class="built_in">stderr</span>);</span><br><span class="line">    <span class="keyword">if</span>(fh == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">fputs</span>(<span class="string">&quot;Failed to open file!\n&quot;</span>, <span class="built_in">stderr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Set input file */</span></span><br><span class="line">    yaml_parser_set_input_file(&amp;parser, fh);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* BEGIN new code */</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        yaml_parser_scan(&amp;parser, &amp;token);</span><br><span class="line">        <span class="keyword">switch</span>(token.type)&#123;</span><br><span class="line">        <span class="comment">/* Stream start/end */</span></span><br><span class="line">        <span class="keyword">case</span> YAML_STREAM_START_TOKEN:</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;STREAM START&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> YAML_STREAM_END_TOKEN:</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;STREAM END&quot;</span>);   <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">/* Token types (read before actual token) */</span></span><br><span class="line">        <span class="keyword">case</span> YAML_KEY_TOKEN:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;(Key token)   &quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> YAML_VALUE_TOKEN:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;(Value token) &quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">/* Block delimeters */</span></span><br><span class="line">        <span class="keyword">case</span> YAML_BLOCK_SEQUENCE_START_TOKEN:</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;&lt;b&gt;Start Block (Sequence)&lt;/b&gt;&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> YAML_BLOCK_ENTRY_TOKEN:</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;&lt;b&gt;Start Block (Entry)&lt;/b&gt;&quot;</span>);    <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> YAML_BLOCK_END_TOKEN:</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;&lt;b&gt;End block&lt;/b&gt;&quot;</span>);              <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">/* Data */</span></span><br><span class="line">        <span class="keyword">case</span> YAML_BLOCK_MAPPING_START_TOKEN:</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;[Block mapping]&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> YAML_SCALAR_TOKEN:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;scalar %s \n&quot;</span>, token.data.scalar.value); <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">/* Others */</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Got token of type %d\n&quot;</span>, token.type);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(token.type != YAML_STREAM_END_TOKEN)</span><br><span class="line">            yaml_token_delete(&amp;token);</span><br><span class="line">    &#125; <span class="keyword">while</span>(token.type != YAML_STREAM_END_TOKEN);</span><br><span class="line">    yaml_token_delete(&amp;token);</span><br><span class="line">    <span class="comment">/* END new code */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Cleanup */</span></span><br><span class="line">    yaml_parser_delete(&amp;parser);</span><br><span class="line">    fclose(fh);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解析结果"><a href="#解析结果" class="headerlink" title="解析结果"></a>解析结果</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$./a.out</span><br><span class="line">STREAM START</span><br><span class="line">[Block mapping]</span><br><span class="line">(Key token)   scalar title</span><br><span class="line">(Value token) scalar Finex 2011</span><br><span class="line">(Key token)   scalar img_url</span><br><span class="line">(Value token) scalar /finex/html/img/</span><br><span class="line">(Key token)   scalar css_url</span><br><span class="line">(Value token) scalar /finex/html/style/</span><br><span class="line">(Key token)   scalar js_url</span><br><span class="line">(Value token) scalar /finex/html/js/</span><br><span class="line">(Key token)   scalar template_dir</span><br><span class="line">(Value token) scalar html/templ/</span><br><span class="line">(Key token)   scalar default_act</span><br><span class="line">(Value token) scalar idx</span><br><span class="line">(Key token)   scalar pages</span><br><span class="line">(Value token) &lt;b&gt;Start Block (Sequence)&lt;/b&gt;</span><br><span class="line">&lt;b&gt;Start Block (Entry)&lt;/b&gt;</span><br><span class="line">[Block mapping]</span><br><span class="line">(Key token)   scalar act</span><br><span class="line">(Value token) scalar idx</span><br><span class="line">(Key token)   scalar title</span><br><span class="line">(Value token) scalar Welcome</span><br><span class="line">(Key token)   scalar html</span><br><span class="line">(Value token) scalar public/welcome.phtml</span><br><span class="line">&lt;b&gt;End block&lt;/b&gt;</span><br><span class="line">&lt;b&gt;Start Block (Entry)&lt;/b&gt;</span><br><span class="line">[Block mapping]</span><br><span class="line">(Key token)   scalar act</span><br><span class="line">(Value token) scalar reg</span><br><span class="line">(Key token)   scalar title</span><br><span class="line">(Value token) scalar Register</span><br><span class="line">(Key token)   scalar html</span><br><span class="line">(Value token) scalar public/register.phtml</span><br><span class="line">&lt;b&gt;End block&lt;/b&gt;</span><br><span class="line">&lt;b&gt;Start Block (Entry)&lt;/b&gt;</span><br><span class="line">[Block mapping]</span><br><span class="line">(Key token)   scalar act</span><br><span class="line">(Value token) scalar log</span><br><span class="line">(Key token)   scalar title</span><br><span class="line">(Value token) scalar Log in</span><br><span class="line">(Key token)   scalar html</span><br><span class="line">(Value token) scalar public/login.phtml</span><br><span class="line">&lt;b&gt;End block&lt;/b&gt;</span><br><span class="line">&lt;b&gt;Start Block (Entry)&lt;/b&gt;</span><br><span class="line">[Block mapping]</span><br><span class="line">(Key token)   scalar act</span><br><span class="line">(Value token) scalar out</span><br><span class="line">(Key token)   scalar title</span><br><span class="line">(Value token) scalar Log out</span><br><span class="line">(Key token)   scalar html</span><br><span class="line">(Value token) scalar public/logout.phtml</span><br><span class="line">&lt;b&gt;End block&lt;/b&gt;</span><br><span class="line">&lt;b&gt;End block&lt;/b&gt;</span><br><span class="line">&lt;b&gt;End block&lt;/b&gt;</span><br><span class="line">STREAM END</span><br></pre></td></tr></table></figure>


<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZjNjZ2Y2MvYXJ0aWNsZS9kZXRhaWxzLzc5NDk3NDY2">YAML C语言范例<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>yaml</tag>
        <tag>配置文件</tag>
      </tags>
  </entry>
  <entry>
    <title>emacs操作快捷键</title>
    <url>/post/6c6f22c4.html</url>
    <content><![CDATA[<p>在无意中看到这张emacs快捷键图片,在这里保存一下,说不定啥时候在想尝试一下emacs了可以直接查找.</p>
<span id="more"></span>

<p><img data-src="/images/2020/07/emacs.png" alt="emacs"></p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>emacs</tag>
      </tags>
  </entry>
  <entry>
    <title>expect脚本交互操作——FIT升级FAT</title>
    <url>/post/20230.html</url>
    <content><![CDATA[<h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><blockquote>
<p>脚本自动控制通过SSH自动登录到路由器，并执行相关命令进行自动升级</p>
</blockquote>
<p>** shell脚本无法完成这种交互，最终选择<code>expect</code>脚本进行操作**</p>
<span id="more"></span>


<h2 id="expect"><a href="#expect" class="headerlink" title="expect"></a>expect</h2><p>expect用于自动化地执行linux环境下的命令行交互任务，例如<code>scp</code>、<code>ssh</code>之类需要用户手动输入密码然后确认的任务</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get install expect</span><br></pre></td></tr></table></figure>
<blockquote>
<p>操作系统：ubuntu18.04</p>
</blockquote>
<h3 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h3><p>expect的实现核心是<code>spawn</code> <code>expect</code> <code>send</code> <code>set</code></p>
<table>
<thead>
<tr>
<th align="center">关键字</th>
<th align="left">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">spawn</td>
<td align="left">调用要执行的命令</td>
</tr>
<tr>
<td align="center">expect</td>
<td align="left">等待命令提示信息的出现，也就是捕获用户输入提示</td>
</tr>
<tr>
<td align="center">send</td>
<td align="left">发送要交互的值，替代用户手动输入内容</td>
</tr>
<tr>
<td align="center">set</td>
<td align="left">设置变量值</td>
</tr>
<tr>
<td align="center">interact</td>
<td align="left">执行完成后保持交互状态，把控制权交给控制台，这个时候就可以手工操作了。如果没有这一句登录完成后会退出，而不是留在远程终端上。</td>
</tr>
<tr>
<td align="center">expect eof</td>
<td align="left">这个一定要加，与spawn对应表示捕获终端输出信息终止，类似于if….endif</td>
</tr>
</tbody></table>
<p>expect脚本必须以<code>interact</code>或<code>expect eof</code>结束，执行自动化任务通常<code>expect eof</code>就可以</p>
<p><strong>脚本第一行必须是<code>#!/usr/bin/expect</code>，第一行注释也不行，否则执行报错</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/usr/bin/expect</span></span><br><span class="line">set timeout 5  //设置超时时间5秒</span><br><span class="line">set server [lindex $argv 0]  //传入的第一个参数</span><br><span class="line">set user [lindex $argv 1]</span><br><span class="line">set passwd [lindex $argv 2]</span><br><span class="line"></span><br><span class="line">spawn ssh -l $user $server   //执行ssh命令</span><br><span class="line"></span><br><span class="line">//如果匹配到了yes/no就发送yes，接着在匹配password，发送密码</span><br><span class="line">expect &#123;</span><br><span class="line">&quot;*yes/no&quot; &#123; send &quot;yes\r&quot;; exp_continue&#125;</span><br><span class="line">&quot;*password:&quot; &#123; send &quot;$passwd\r&quot; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">expect *Last login*</span><br><span class="line"></span><br><span class="line">//执行完成后保持交互状态，把控制权交给控制台，就可以手工操作</span><br><span class="line">interact</span><br></pre></td></tr></table></figure>

<ul>
<li>执行命令的超时时间可以设置<code>set timeout 5</code>,默认的超时时间是<code>10s</code>,如果设置为<code>-1</code>表示永不超时</li>
</ul>
<h2 id="示例–FIT升级FAT"><a href="#示例–FIT升级FAT" class="headerlink" title="示例–FIT升级FAT"></a>示例–FIT升级FAT</h2><h3 id="shell脚本"><a href="#shell脚本" class="headerlink" title="shell脚本"></a>shell脚本</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">netstat=$(ping -c1 169.254.1.1 |grep transmitted |awk &#x27;&#123;print $4&#125;&#x27;)</span><br><span class="line">if [ &quot;$netstat&quot; -eq &quot;0&quot; ]; then</span><br><span class="line">    echo &quot;      ***********************************&quot;</span><br><span class="line">    echo &quot;      * Network connection disconnected *&quot;</span><br><span class="line">    echo &quot;      ***********************************&quot;</span><br><span class="line">    echo &quot;Configuring a local network, IP: 169.254.1.100&quot;</span><br><span class="line">    exit 1</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">ssh-keygen -f &quot;$home/.ssh/known_hosts&quot; -R &quot;169.254.1.1&quot;</span><br><span class="line"></span><br><span class="line">cat &gt; update.exp &lt;&lt; EOF</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/usr/bin/expect -f</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="built_in">set</span> <span class="built_in">timeout</span> 10</span></span><br><span class="line">spawn ssh admin@169.254.1.1</span><br><span class="line"></span><br><span class="line">expect &#123;</span><br><span class="line">	&quot;*yes/no&quot; &#123;</span><br><span class="line">		send &quot;yes\r&quot;;</span><br><span class="line">		exp_continue</span><br><span class="line">	&#125;</span><br><span class="line">	&quot;*password:&quot; &#123;</span><br><span class="line">		send &quot;admin@huawei.com\r&quot;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">expect &#123;</span><br><span class="line">   &quot;&lt;Huawei&gt;&quot; &#123;</span><br><span class="line">       send &quot;system-view\r&quot;</span><br><span class="line">       send &quot;ap-mode-switch prepare\r&quot;</span><br><span class="line">       send &quot;ap-mode-switch check\r&quot;</span><br><span class="line">       set timeout -1</span><br><span class="line">       send &quot;ap-mode-switch tftp FatAP3010DN-V2_V200R008C10SPC500.bin 169.254.1.100\r&quot;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">expect &#123;</span><br><span class="line">   &quot;Y/N&quot; &#123;</span><br><span class="line">       set timeout 10</span><br><span class="line">       send &quot;Y\r\n&quot;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">expect eof</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">chmod a+x update.exp</span><br><span class="line">./update.exp</span><br><span class="line">rm ./update.exp</span><br><span class="line"></span><br><span class="line">netstat=$(ping -c3 169.254.1.1 |grep transmitted |awk &#x27;&#123;print $4&#125;&#x27;)</span><br><span class="line">while [ &quot;$netstat&quot; -ne &quot;0&quot; ]</span><br><span class="line">do</span><br><span class="line">    echo -n &quot;#&quot;</span><br><span class="line">    netstat=$(ping -c3 169.254.1.1 |grep transmitted |awk &#x27;&#123;print $4&#125;&#x27;)</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">echo &quot;Firmware upgrade succeeded&quot;</span><br><span class="line"></span><br><span class="line">echo &quot;&quot;</span><br><span class="line">echo &quot;Device restart ...&quot;</span><br><span class="line"></span><br><span class="line">netstat=$(ping -c3 169.254.1.1 |grep transmitted |awk &#x27;&#123;print $4&#125;&#x27;)</span><br><span class="line">while [ &quot;$netstat&quot; -eq &quot;0&quot; ]</span><br><span class="line">do</span><br><span class="line">    echo -n &quot;*&quot;</span><br><span class="line">    netstat=$(ping -c3 169.254.1.1 |grep transmitted |awk &#x27;&#123;print $4&#125;&#x27;)</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">echo &quot;Device restart succeeded&quot;</span><br><span class="line">echo &quot;over&quot;</span><br><span class="line">echo &quot;over&quot;</span><br></pre></td></tr></table></figure>
<h3 id="expect脚本"><a href="#expect脚本" class="headerlink" title="expect脚本"></a>expect脚本</h3><ul>
<li>处理的交互流程：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ssh admin@169.254.1.1</span><br><span class="line">The authenticity of host &#x27;169.254.1.1 (169.254.1.1)&#x27; can&#x27;t be established.</span><br><span class="line">RSA key fingerprint is SHA256:ANKtrCYlGExlxhtgCoD1ZiOxflXyEsyvswS4fC5nzc8.</span><br><span class="line">Are you sure you want to continue connecting (yes/no)? yes</span><br><span class="line">Warning: Permanently added &#x27;169.254.1.1&#x27; (RSA) to the list of known hosts.</span><br><span class="line">admin@169.254.1.1&#x27;s password:</span><br><span class="line"></span><br><span class="line">Info: Current mode: Fit (managed by the AC).</span><br><span class="line">Info: You are advised to change the password to ensure security.</span><br><span class="line">&lt;Huawei&gt;system-view</span><br><span class="line">Enter system view, return user view with Ctrl+Z.</span><br><span class="line">[Huawei]ap-mode-switch prepare</span><br><span class="line">Info: Prepare is ok, Use ap-mode-switch command to switch to fat ap.</span><br><span class="line"></span><br><span class="line">[Huawei]ap-mode-switch check</span><br><span class="line">Info: Ap-mode-switch check ok.</span><br><span class="line"></span><br><span class="line">[Huawei]ap-mode-switch tftp FatAP3010DN-V2_V200R008C10SPC500.bin 169.254.1.100</span><br><span class="line">Info: Preparing to upgrade. Please wait a moment .............</span><br><span class="line">Warning: Do Not Power-off!</span><br><span class="line">......................................................................................................................................................................................................................................................................................................................</span><br><span class="line">Info: Upgrade upgrade-assistant-package succeeded.</span><br><span class="line"></span><br><span class="line">Warning: System will reboot, if you want to switch to upgrade-assistant-package.</span><br><span class="line">Are you sure to execute these operations ? [Y/N]:Y</span><br><span class="line">Info: system is rebooting ,please wait...</span><br></pre></td></tr></table></figure>

<ul>
<li>实现：</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/usr/bin/expect -f</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="built_in">set</span> <span class="built_in">timeout</span> 10</span></span><br><span class="line">spawn ssh admin@169.254.1.1</span><br><span class="line"></span><br><span class="line">expect &#123;</span><br><span class="line">    &quot;*yes/no&quot; &#123;</span><br><span class="line">		send &quot;yes\r&quot;;</span><br><span class="line">		exp_continue</span><br><span class="line">	&#125;</span><br><span class="line">    &quot;*password:&quot; &#123;</span><br><span class="line">		send &quot;admin@huawei.com\r&quot;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">expect &#123;</span><br><span class="line">   &quot;&lt;Huawei&gt;&quot; &#123;</span><br><span class="line">       send &quot;system-view\r&quot;</span><br><span class="line">       send &quot;ap-mode-switch prepare\r&quot;</span><br><span class="line">       send &quot;ap-mode-switch check\r&quot;</span><br><span class="line">       set timeout -1</span><br><span class="line">       send &quot;ap-mode-switch tftp FatAP3010DN-V2_V200R008C10SPC500.bin 169.254.1.100\r&quot;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">expect &#123;</span><br><span class="line">   &quot;Y/N&quot; &#123;</span><br><span class="line">       set timeout 10</span><br><span class="line">       send &quot;Y\r\n&quot;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">expect eof</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vbGl4aWdhbmcvYXJ0aWNsZXMvNDg0OTUyNy5odG1s">Shell脚本学习之expect命令<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>expect</tag>
        <tag>ap</tag>
      </tags>
  </entry>
  <entry>
    <title>IPMI接口的BMC系统管理工具——ipmitool</title>
    <url>/post/c41b411e.html</url>
    <content><![CDATA[<p><code>ipmitool</code>是一种可用在 Linux&#x2F;Unix 系统下的基于命令行方式的 ipmi 平台管理工具。它支持 ipmi 1.5 和ipmi 2.0 规范（最新的规范为 ipmi 2.0）。利用它可以实现获取传感器的信息、显示系统日志内容、网络远程开关机等功能。其主要功能包括读取和显示传感器数据（SDR），显示System Evernt Log（SEL）的内容，显示打印Field Replaceable Unit（FRU）信息，<code>读取和设置BMC模块</code>的LAN配置，远程控制服务器主机的电源。</p>
<span id="more"></span>


<h2 id="查看BMC的信息"><a href="#查看BMC的信息" class="headerlink" title="查看BMC的信息"></a>查看BMC的信息</h2><ul>
<li>本机BMC信息<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ipmitool mc info</span></span><br><span class="line">Device ID                 : 34</span><br><span class="line">Device Revision           : 1</span><br><span class="line">Firmware Revision         : 2.48</span><br><span class="line">IPMI Version              : 2.0</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="查看BMC的LAN信息"><a href="#查看BMC的LAN信息" class="headerlink" title="查看BMC的LAN信息"></a>查看BMC的LAN信息</h2><ul>
<li><p>本机LAN信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ipmitool lan <span class="built_in">print</span> 1</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>设定channel1从DHCP获得IP:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ipmitool lan <span class="built_in">set</span> 1 ipsrc dhcp</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>设置channel1为静态IP</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ipmitool lan <span class="built_in">set</span> 1 ipsrc static</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>设置channel1的地址为192.168.1.11</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ipmitool lan <span class="built_in">set</span> 1 ipaddr 192.168.1.11</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ipmitool lan <span class="built_in">set</span> 1 netmask 255.255.255.0</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ipmitool lan <span class="built_in">set</span> 1 defgw ipaddr 192.168.1.1</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="重置BMC（包括BIOS）"><a href="#重置BMC（包括BIOS）" class="headerlink" title="重置BMC（包括BIOS）"></a>重置BMC（包括BIOS）</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ipmitool raw 0x32 0x66</span></span><br></pre></td></tr></table></figure>

<p><img data-src="/images/2021/03/ipmitool_restore_bmc.png" alt="ipmitool_restore_bmc"></p>
<blockquote>
<p>来源：<span class="exturl" data-url="aHR0cDovL3d3dy5zdGFyb2NlYW5zLm9yZy9lLWJvb2svUzJCJTIwSVBNSSUyMENvbW1hbmRzLnBkZg==">IPMI Commands<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<h2 id="查看主机传感器信息"><a href="#查看主机传感器信息" class="headerlink" title="查看主机传感器信息"></a>查看主机传感器信息</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ipmitool sensor | grep <span class="string">&quot;Temp &quot;</span></span></span><br><span class="line">BB Inlet Temp    | 25.000     | degrees C  | ok    | na        | 5.000     | 10.000    | 60.000    | 65.000    | na</span><br><span class="line">BB BMC Temp      | 36.000     | degrees C  | ok    | na        | 5.000     | 10.000    | 85.000    | 90.000    | na</span><br><span class="line">BB CPU1 VR Temp  | 47.000     | degrees C  | ok    | na        | 5.000     | 10.000    | 110.000   | 115.000   | na</span><br><span class="line">BB CPU2 VR Temp  | 37.000     | degrees C  | ok    | na        | 5.000     | 10.000    | 110.000   | 115.000   | na</span><br><span class="line">BB MISC VR Temp  | 49.000     | degrees C  | ok    | na        | 5.000     | 10.000    | 110.000   | 115.000   | na</span><br><span class="line">BB Outlet Temp   | 46.000     | degrees C  | ok    | na        | 5.000     | 10.000    | 110.000   | 115.000   | na</span><br><span class="line">SSB Temp         | 42.000     | degrees C  | ok    | na        | 5.000     | 10.000    | 98.000    | 103.000   | na</span><br><span class="line">LAN NIC Temp     | 56.000     | degrees C  | ok    | na        | 5.000     | 10.000    | 115.000   | 120.000   | na</span><br><span class="line">Mem 1 VRD Temp   | 39.000     | degrees C  | ok    | na        | 5.000     | 10.000    | 110.000   | 115.000   | na</span><br><span class="line">Mem 2 VRD Temp   | 25.000     | degrees C  | ok    | na        | 5.000     | 10.000    | 110.000   | 115.000   | na</span><br><span class="line">EV CPU1VR Temp   | 37.000     | degrees C  | ok    | na        | 5.000     | 10.000    | 110.000   | 115.000   | na</span><br></pre></td></tr></table></figure>

<h2 id="配置用户名密码"><a href="#配置用户名密码" class="headerlink" title="配置用户名密码"></a>配置用户名密码</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">配置channel3通过dhcp获取ip</span></span><br><span class="line">ipmitool lan set 3 ipsrc dhcp</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看channel3的ip</span></span><br><span class="line">ipmitool lan print 3</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">获取ip后查看channel3的用户信息</span></span><br><span class="line">ipmitool user list 3</span><br><span class="line">ID  Name	     Callin  Link Auth	IPMI Msg   Channel Priv Limit</span><br><span class="line">1                    true    false      false      NO ACCESS</span><br><span class="line">2                    true    false      false      NO ACCESS</span><br><span class="line">3   test             true    false      false      NO ACCESS</span><br><span class="line">4                    true    false      false      NO ACCESS</span><br><span class="line">...</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">选择用户ID 3，配置用户名密码</span></span><br><span class="line">ipmitool user set name 3 test</span><br><span class="line">ipmitool user set password 3 123456@abc#ABC</span><br><span class="line">ipmitool channel setaccess 1 3 callin=on ipmi=on link=on privilege=4</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">设置用户3的访问权限</span></span><br><span class="line">ipmitool user priv 3 0x4 3</span><br><span class="line">ipmitool user list 3</span><br><span class="line">ID  Name	     Callin  Link Auth	IPMI Msg   Channel Priv Limit</span><br><span class="line">1                    true    false      false      NO ACCESS</span><br><span class="line">2                    true    false      false      NO ACCESS</span><br><span class="line">3   test             true    false      false      ADMINISTRATOR</span><br><span class="line">4                    true    false      false      NO ACCESS</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注： channel的选择以接入的网口所属channel为主，配置用户名和密码是用户ID和channel id选择一致</p>
</blockquote>
<h2 id="常用的基本命令"><a href="#常用的基本命令" class="headerlink" title="常用的基本命令"></a>常用的基本命令</h2><table>
<thead>
<tr>
<th align="left">命令</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>ipmitool sel list</code></td>
<td align="left">打印日志</td>
</tr>
<tr>
<td align="left"><code>ipmitool sensor</code></td>
<td align="left">获取传感器中的各种监测值和该值的监测阈值，包括（CPU温度，电压，风扇转速，电源调制模块温度，电源电压等信息）</td>
</tr>
<tr>
<td align="left"><code>ipmitool chassis status</code></td>
<td align="left">查看底盘状态，其中包括了底盘电源信息，底盘工作状态等</td>
</tr>
<tr>
<td align="left"><code>ipmitool user list 1</code></td>
<td align="left">查询当前BMC的用户</td>
</tr>
<tr>
<td align="left"><code>ipmitool sdr</code></td>
<td align="left">查看SDR Sensor信息</td>
</tr>
</tbody></table>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vbGlhbmdsYWIvcC8xNDEwNjExMy5odG1s">运维管理利器系列–ipmitool<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BhbnNha3kvYXJ0aWNsZS9kZXRhaWxzLzEwMjgwNzA0Ng==">IPMITOOL工具使用详解（待验证）<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>bmc</tag>
        <tag>ipmitool</tag>
      </tags>
  </entry>
  <entry>
    <title>jlink v8固件升级</title>
    <url>/post/ec73df9d.html</url>
    <content><![CDATA[<p>翻出以前在学校用过几次的jlink，想看看还能不能用，插电脑上可以正常识别，安装完驱动打算试试时提示固件升级，没有多想就直接升级了。但是固件升级失败，重新插拔指示灯不亮也无法识别。在网上搜索一番后确定已经变砖块不能用了，如果想让其正常工作必须重新刷固件，在linux下试了一下，无法写入固件，最终只能安装xp虚拟机操作，折腾了一天将固件升级成功。在这里记录一下升级的过程和中间遇到的问题。</p>
<span id="more"></span>

<blockquote>
<p>丢失固件的表现：Jlink的指示灯不亮<br><strong>在linux下使用Jlink时，遇到提示固件升级的情况，建议不进行升级，因为Linux系统下由于USB相关驱动的问题，可能导致升级失败，原固件丢失变“砖头”</strong></p>
</blockquote>
<h2 id="我的Jlink-v8"><a href="#我的Jlink-v8" class="headerlink" title="我的Jlink v8"></a>我的Jlink v8</h2><p><img data-src="/images/2022/04/jlink_v8.jpg" alt="jlink_v8"></p>
<ul>
<li>主芯片：<code>AT91SAM7S64</code></li>
<li>ERASE: 删除旧的固件</li>
<li>TST: 使其进入可编程模式</li>
</ul>
<h2 id="升级环境"><a href="#升级环境" class="headerlink" title="升级环境"></a>升级环境</h2><p>jlink固件升级网上教程很多，也有很多人说自己操作成功的，但是很多都没有说明操作系统环境。我最开始是在win10虚拟机中操作，SAM-BA刷固件时总是无法弹出升级界面，更好多个软件版本和驱动都不行，最后经过网上搜索基本确定是jlink在编程模式下的驱动安装问题。<br>win10不行就直接安装win xp虚拟机，网上很多人提到xp下升级，包括一些问题上面的截图也是xp风格就选择了xp。在xp下驱动安装也存在问题，没有正确的驱动程序，最后也是试了多个版本后才成功。</p>
<p>操作系统：<code>Windows XP</code><br>升级所需<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1dpbmRkb2luZy9qbGlua192OF9maXJ3YXJlX3VwZ3JhZGU=">软件包<i class="fa fa-external-link-alt"></i></span>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$tree -L 1</span><br><span class="line">.</span><br><span class="line">├── Install_AT91-ISP_v1.13.exe   #安装出现sam-ba v2.9（固件升级需要）和SAM-PROG v2.4（不需要）两个软件</span><br><span class="line">├── jlink-v8.bin                 #处理好的升级固件，网上找的https://blog.csdn.net/best_xiaolong/article/details/117173826</span><br><span class="line">├── JLink_Windows_V760_i386.exe  #比较新的jlink工具，第一次使用提示升级固件，固件版本Firmware: J-Link ARM V8 compiled Nov 28 2014 13:44:46</span><br><span class="line">├── SAM-BA v2.18 for Windows.exe #安装后只需要安装目录下的驱动，因为sam-ba v2.9的驱动无法使用</span><br><span class="line">├── Setup_JLinkARM_V450l.zip     #jlink工具可以修改SN号，他也会进行固件升级版本在2012</span><br><span class="line">└── 编程模式下驱动来自SAM-BAv2.18   #SAM-BAv2.18安装后的驱动，在这里备份是为了下次可以直接使用</span><br></pre></td></tr></table></figure>

<h2 id="固件升级流程"><a href="#固件升级流程" class="headerlink" title="固件升级流程"></a>固件升级流程</h2><h3 id="使jlink进入编程状态"><a href="#使jlink进入编程状态" class="headerlink" title="使jlink进入编程状态"></a>使jlink进入编程状态</h3><p>第一步：</p>
<ol>
<li>用 USB 线连接 JLink 与 PC，JLink供电</li>
<li>可靠短接，图中“ERASE”处的两个过孔，保持 30 秒</li>
<li>拔掉 JLink 与 PC 间的 USB 线，JLink断电</li>
<li>断开“ERASE”处的短接</li>
</ol>
<p>第二步：</p>
<ol>
<li>可靠短接，图中“TST”处的两个过孔       </li>
<li>用 USB 线连接 JLink 与 PC，JLink 供电</li>
<li>保持 120 秒（不要放开“TST”处短接）       </li>
<li>拔掉 JLink 与 PC 间的 USB 线（不要放开“TST”处短接）       </li>
<li>至此，断开“TST”处的短接</li>
</ol>
<p>经过以上两个步骤后，重新连接jlink，可以看到以下usb信息，表明已经进入编程模式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$lsusb</span><br><span class="line">Bus 001 Device 019: ID 03eb:6124 Atmel Corp. at91sam SAMBA bootloader</span><br></pre></td></tr></table></figure>

<h3 id="查看并更新驱动"><a href="#查看并更新驱动" class="headerlink" title="查看并更新驱动"></a>查看并更新驱动</h3><p>驱动来源：<br>一种：直接拷贝升级包中的<code>编程模式下驱动来自SAM-BAv2.18</code>目录下驱动<br>另一种：安装<code>SAM-BA v2.18 for Windows.exe</code>,在其安装目录下驱动，二者为相同的文件</p>
<p>在设备管理中找到<code>usb转串口的设备</code>或者<code>没有驱动的设备</code>，<code>更新驱动</code>(如果更新不成功可以先卸载再安装)选择<code>从列表指定位置安装</code>，下一步，<code>选择sam-ba-2.18的安装目录中的drv</code>确定，下一步，弹出驱动列表选择驱动<code>atm6124开头的驱动</code>，进行下一步安装<br>驱动安装成功后将在<code>通用串口总线控制器</code>中显示，表明这个时候驱动已经安装成功并且可以使用</p>
<p><img data-src="/images/2022/04/jlink%E5%8F%AF%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%BC%8F%E9%A9%B1%E5%8A%A8.png" alt="jlink可编程模式驱动"></p>
<blockquote>
<p>驱动安装成功后，如上图并在红框处出现包含<code>atm6124</code>的驱动名字</p>
</blockquote>
<h3 id="刷固件"><a href="#刷固件" class="headerlink" title="刷固件"></a>刷固件</h3><p>安装<code>Install_AT91-ISP_v1.13.exe</code>,打开<code>sam-ba v2.9</code></p>
<ol>
<li>选择板级<code>at91sam7s64-ek</code>与主芯片一致。</li>
<li>弹出固件升级界面，在<code>Send File Name</code>处选择升级的固件，并点击<code>Send File</code></li>
<li>弹出<code>Unlock regions</code>界面，选择<code>是</code></li>
<li>弹处<code>Lock regions</code>界面，选择<code>否</code>（也就是第一次选择Y，第二次选择N）</li>
<li>等没有日志输出，基本上升级完成了</li>
</ol>
<h3 id="修改jlink-V8-S-x2F-N并升级固件"><a href="#修改jlink-V8-S-x2F-N并升级固件" class="headerlink" title="修改jlink V8 S&#x2F;N并升级固件"></a>修改jlink V8 S&#x2F;N并升级固件</h3><ol>
<li>安装<code>Setup_JLinkARM_V450l.zip</code>(其他版本可能无法设置SN)</li>
<li>打开JLINK 4.50l的<code>jlink commander</code>，这时会跳出一个界面叫我们更新最新的firmware，到这里一定先不要更新，我们需要做的工作是修改jlink的SN码，输入指令<code>exec setsn=20060125</code>,提示OK.</li>
</ol>
<p>到这里固件基本刷完了，现在在jlink是可以正常使用的，但是默认的固件版本过低，为了支持更多芯片选择升级一个新的固件</p>
<p>安装<code>JLink_Windows_V760_i386.exe</code>,再一次其打开<code>jlink commander</code>，提示升级固件时可以进行升级了，升级成功后固件版本是2014</p>
<h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><p>在整个固件升级的过程中需要注意的有亮点，一是驱动的安装，一般无法进入下载界面主要原因在于驱动；另一个就是SAM-BA软件的选择，在启动安装正常的情况下，打开SAM-BA可以识别出连接USB的就可以进行固件升级。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTMzODE2MDgvYXJ0aWNsZS9kZXRhaWxzLzExNjcxNTQ1NQ==">JLink V8刷固件方式 转载整合<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Jlc3RfeGlhb2xvbmcvYXJ0aWNsZS9kZXRhaWxzLzExNzE3MzgyNg==">J-Link该如何升级固件？<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>jlink</tag>
        <tag>调试</tag>
        <tag>firware</tag>
      </tags>
  </entry>
  <entry>
    <title>linux下出现死机的处理方法</title>
    <url>/post/8229.html</url>
    <content><![CDATA[<p>服务器中Linux系统出现死机后的处理：查看系统<strong>日志</strong>，定位死机原因</p>
<blockquote>
<p>linux系统： CentOS</p>
</blockquote>
<span id="more"></span>

<h2 id="查看运行日志"><a href="#查看运行日志" class="headerlink" title="查看运行日志"></a>查看运行日志</h2><h3 id="TTY文字界面"><a href="#TTY文字界面" class="headerlink" title="TTY文字界面"></a>TTY文字界面</h3><p>按<code>Ctrl+Alt+F1</code>,就会切换到TTY文字界面</p>
<blockquote>
<p><code>Ctrl + Alt + Backspace</code>重启 X server</p>
</blockquote>
<h3 id="log"><a href="#log" class="headerlink" title="log"></a>log</h3><ul>
<li><code>/var/log/message</code>: 系统启动后的信息和错误日志</li>
<li><code>/var/log/secure</code>: 与安全相关的日志信息</li>
<li><code>/var/log/maillog</code>: 与邮件相关的日志信息</li>
<li><code>/var/log/cron</code>: 与定时任务相关的日志信息</li>
<li><code>/var/log/spooler</code>: 与UUCP和news设备相关的日志信息</li>
<li><code>/var/log/boot.log</code>: 守护进程启动和停止相关的日志消息</li>
<li><code>/var/log/wtmp</code>: 永久记录每个用户登录、注销及系统的启动、停机的事件</li>
<li><code>/var/run/utmp</code>: 记录当前正在登录系统的用户信息；</li>
<li><code>/var/log/btmp</code>: 记录失败的登录尝试信息。</li>
</ul>
<h3 id="x2F-var-x2F-log-x2F-messages"><a href="#x2F-var-x2F-log-x2F-messages" class="headerlink" title="&#x2F;var&#x2F;log&#x2F;messages"></a>&#x2F;var&#x2F;log&#x2F;messages</h3><blockquote>
<p>用于记录系统常见的系统和服务错误信息.</p>
</blockquote>
<p>如果系统默认没有开启，打开方法：</p>
<p>将<code>/etc/rsyslog.d/50-default.conf</code>文件中的相关注释去掉</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#</span><br><span class="line"># Some &quot;catch-all&quot; log files.</span><br><span class="line">#</span><br><span class="line">#*.=debug;\</span><br><span class="line">#   auth,authpriv.none;\</span><br><span class="line">#   news.none;mail.none -/var/log/debug</span><br><span class="line">#*.=info;*.=notice;*.=warn;\</span><br><span class="line">#   auth,authpriv.none;\</span><br><span class="line">#   cron,daemon.none;\</span><br><span class="line">#   mail,news.none      -/var/log/messages</span><br><span class="line">#</span><br></pre></td></tr></table></figure>
<p>去掉第<code>4</code>行到第<code>10</code>行的<code>#</code>注释，并重启<code>rsyslog</code>服务：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo /etc/init.d/rsyslog restart</span><br></pre></td></tr></table></figure>
<p><strong>注</strong>：如果 &#x2F;var&#x2F;log&#x2F;messages 被写满，导致空间被占用较多，可以查看下哪些内容被写入到文件了，然后在<code>/etc/rsyslog.d/50-default.conf</code>文件中注释掉即可.</p>
<h2 id="reisb"><a href="#reisb" class="headerlink" title="reisb"></a>reisb</h2><p>利用<code>reisub</code>,可以在各种情况下安全地重启计算机</p>
<p>在系统正常启动后需要激活内核<code>sysrq</code>功能:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo &quot;1&quot; &gt; /proc/sys/Kernel/sysrq</span><br><span class="line"></span><br><span class="line">sysctl -w kernel.sysrq=1</span><br></pre></td></tr></table></figure>
<p>或者，修改<code>/etc/sysctl.conf</code>文件，设置<code>kernel.sysrq = 1</code></p>
<blockquote>
<p>方法： 按住 <code>Alt+Print(Sys Rq)</code>,然后依次按下 <code>reisub</code> 这几个键,按完<code>b</code>系统就会重启。</p>
</blockquote>
<ul>
<li><code>r</code>: unRaw 将键盘控制从 X Server 那里抢回来</li>
<li><code>e</code>: tErminate 给所有进程发送 SIGTERM 信号,让他们自己解决善后</li>
<li><code>i</code>: kIll 给所有进程发送 SIGKILL 信号,强制他们马上关闭</li>
<li><code>s</code>: Sync 将所有数据同步至磁盘</li>
<li><code>u</code>: Unmount 将所有分区挂载为只读模式</li>
<li><code>b</code>: reBoot 重启</li>
</ul>
<h2 id="判断死机情况"><a href="#判断死机情况" class="headerlink" title="判断死机情况"></a>判断死机情况</h2><ul>
<li>在桌面卡死不动的情况下，可以通过键盘<code>Caps Lock/Num Lock/Scroll Lock</code>按键按后,判断对应LED可以正常亮灭，确定属于X server崩溃，还是内核崩溃<ul>
<li>LED亮灭正常，属于X server崩溃</li>
<li>LED灯没反应，属于内核崩溃</li>
</ul>
</li>
</ul>
<h2 id="Kdump-crash"><a href="#Kdump-crash" class="headerlink" title="Kdump + crash"></a>Kdump + crash</h2><p><code>kdump</code>是一种基于kexec的内核崩溃转储技术。kdump需要两个内核，分别是生产内核和捕获内核，生产内核是捕获内核服务的对象，且保留了内存的一部分给捕获内核启动使用。当系统崩溃时，kdump使用kexec启动捕获内核，以相应的ramdisk一起组建一个微环境，用以对生产内核下的内存进行收集和转存。</p>
<p><code>kexec</code>是一个Linux内核到内核的引导加载程序，可以帮助从第一个内核的上下文引导到第二个内核。kexec会关闭第一个内核，绕过BIOS或固件阶段，并跳转到第二个内核。当第一个内核崩溃时第二个内核启动，第二个内核用于复制第一个内核的内存转储，可以使用gdb和crash等工具分析崩溃的原因。</p>
<p><code>crash</code>用于调试内核崩溃的转储文件</p>
<p><img data-src="/images/2019/09/kdump_panic.png" alt="kdump-panic"></p>
<blockquote>
<p><span class="exturl" data-url="aHR0cDovL2xzZS5zb3VyY2Vmb3JnZS5uZXQva2R1bXAvZG9jdW1lbnRhdGlvbi9vbHMyMDA1LWtkdW1wLXByZXNlbnRhdGlvbi5wZGY=">A Kexec Based Kernel Crash Dumping Mechanism<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<h3 id="CentOS-7"><a href="#CentOS-7" class="headerlink" title="CentOS 7"></a>CentOS 7</h3><blockquote>
<p>Linux localhost.localdomain 4.14.0-115.10.1.el7a.aarch64 #1 SMP Tue Jul 30 14:50:37 UTC 2019 aarch64 aarch64 aarch64 GNU&#x2F;Linux</p>
</blockquote>
<h4 id="安装kexec-tools"><a href="#安装kexec-tools" class="headerlink" title="安装kexec-tools"></a>安装kexec-tools</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># yum install kexec-tools</span><br></pre></td></tr></table></figure>
<h4 id="配置GRUB2中的内存"><a href="#配置GRUB2中的内存" class="headerlink" title="配置GRUB2中的内存"></a>配置GRUB2中的内存</h4><ul>
<li>在内核崩溃后，转存coredump文件所需的内存大小，配置参数<code>crashkernel=[size]</code></li>
</ul>
<blockquote>
<p>配置文件： &#x2F;etc&#x2F;default&#x2F;grub</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GRUB_TIMEOUT=5</span><br><span class="line">GRUB_DISTRIBUTOR=&quot;$(sed &#x27;s, release .*$,,g&#x27; /etc/system-release)&quot;</span><br><span class="line">GRUB_DEFAULT=saved</span><br><span class="line">GRUB_DISABLE_SUBMENU=true</span><br><span class="line">GRUB_TERMINAL_OUTPUT=&quot;console&quot;</span><br><span class="line">GRUB_CMDLINE_LINUX=&quot;crashkernel=auto rd.lvm.lv=centos/root rd.lvm.lv=centos/swap&quot;</span><br><span class="line">GRUB_DISABLE_RECOVERY=&quot;true&quot;</span><br></pre></td></tr></table></figure>
<p><strong>注</strong>：在网络大多数的文章说<code>crashkernel=128M或512M</code>，但是测试直接配置<code>crashkernel=auto</code>同样可以转存coredump文件</p>
<blockquote>
<p>在Linux4.15中使用<code>crashkernel=auto</code>，内核将通过<code>memblock_find_in_range</code>自动计算小内核的内存大小和起始位置，但是有些内核可能不支持，需要手动指定大小</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">if</span> (!high)</span><br><span class="line">    crash_base = memblock_find_in_range(CRASH_ALIGN,</span><br><span class="line">                CRASH_ADDR_LOW_MAX,</span><br><span class="line">                crash_size, CRASH_ALIGN);</span><br><span class="line"><span class="keyword">if</span> (!crash_base)</span><br><span class="line">    crash_base = memblock_find_in_range(CRASH_ALIGN,</span><br><span class="line">                CRASH_ADDR_HIGH_MAX,</span><br><span class="line">                crash_size, CRASH_ALIGN);</span><br></pre></td></tr></table></figure>
<p>file：arch&#x2F;x86&#x2F;kernel&#x2F;setup.c</p>
</blockquote>
<ul>
<li>如果修改grub文件后，需要重新生成grub文件</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">grub2-mkconfig -o /boot/grub2/grub.cfg</span><br></pre></td></tr></table></figure>

<p> <strong>注意不同的系统可能使用的grub不同</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ls -ls /boot/grub2</span><br><span class="line">0 lrwxrwxrwx. 1 root root 25 Aug 13 04:34 grubenv -&gt; ../efi/EFI/centos/grubenv</span><br></pre></td></tr></table></figure>

<h4 id="配置kdump"><a href="#配置kdump" class="headerlink" title="配置kdump"></a>配置kdump</h4><blockquote>
<p>配置文件路径： <code>/etc/kdump.conf</code></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">path /var/crash   #指定coredump文件放在/var/crash文件夹中</span><br><span class="line">core_collector makedumpfile -l --message-level 1 -d 31</span><br><span class="line">default reboot    #生成coredump后，重启系统</span><br></pre></td></tr></table></figure>

<h4 id="开启kdump"><a href="#开启kdump" class="headerlink" title="开启kdump"></a>开启kdump</h4><ul>
<li>检查内核启动命令</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ cat /proc/cmdline</span><br><span class="line">BOOT_IMAGE=/vmlinuz-4.14.0-115.10.1.el7a.aarch64 root=/dev/mapper/centos-root ro crashkernel=auto rd.lvm.lv=centos/root rd.lvm.lv=centos/swap LANG=en_US.UTF-8</span><br></pre></td></tr></table></figure>

<ul>
<li>开启kdump服务</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl enable kdump.service  #设置开机启动</span><br><span class="line">systemctl start kdump.service   #启动kdump</span><br></pre></td></tr></table></figure>

<h4 id="测试kdump"><a href="#测试kdump" class="headerlink" title="测试kdump"></a>测试kdump</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># systemctl is-active kdump</span><br><span class="line">active</span><br></pre></td></tr></table></figure>

<ul>
<li>查看捕获内核是否加载</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># cat /sys/kernel/kexec_crash_loaded</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<ul>
<li>查看当前的保留内存</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat /sys/kernel/kexec_crash_size</span><br><span class="line">536870912</span><br></pre></td></tr></table></figure>
<blockquote>
<p>保留内存大小：512M<br>cat &#x2F;proc&#x2F;iomem | grep “Crash kernel” 应该有一个分配的范围。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dmesg | grep crashkernel</span><br></pre></td></tr></table></figure>

<ul>
<li>查看kdump服务状态</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># service kdump status</span><br><span class="line">Redirecting to /bin/systemctl status kdump.service</span><br><span class="line">● kdump.service - Crash recovery kernel arming</span><br><span class="line">   Loaded: loaded (/usr/lib/systemd/system/kdump.service; enabled; vendor preset: enabled)</span><br><span class="line">   Active: active (exited) since Wed 2019-09-04 02:04:18 EDT; 1h 8min ago</span><br><span class="line">  Process: 1825 ExecStart=/usr/bin/kdumpctl start (code=exited, status=0/SUCCESS)</span><br><span class="line"> Main PID: 1825 (code=exited, status=0/SUCCESS)</span><br><span class="line">    Tasks: 0</span><br><span class="line">   CGroup: /system.slice/kdump.service</span><br><span class="line"></span><br><span class="line">Sep 04 02:04:16 localhost.localdomain dracut[3545]: drwxr-xr-x   2 root     root            0 Sep  4  2019 usr/share/zoneinfo/America</span><br><span class="line">Sep 04 02:04:16 localhost.localdomain dracut[3545]: -rw-r--r--   1 root     root         3519 Jul 10 17:44 usr/share/zoneinfo/America/New_York</span><br><span class="line">Sep 04 02:04:16 localhost.localdomain dracut[3545]: drwxr-xr-x   2 root     root            0 Sep  4  2019 var</span><br><span class="line">Sep 04 02:04:16 localhost.localdomain dracut[3545]: lrwxrwxrwx   1 root     root           11 Sep  4  2019 var/lock -&gt; ../run/lock</span><br><span class="line">Sep 04 02:04:16 localhost.localdomain dracut[3545]: lrwxrwxrwx   1 root     root            6 Sep  4  2019 var/run -&gt; ../run</span><br><span class="line">Sep 04 02:04:16 localhost.localdomain dracut[3545]: ========================================================================</span><br><span class="line">Sep 04 02:04:16 localhost.localdomain dracut[3545]: *** Creating initramfs image file &#x27;/boot/initramfs-4.14.0-115.10.1.el7a.aarch64kdump.img&#x27; done ***</span><br><span class="line">Sep 04 02:04:18 localhost.localdomain kdumpctl[1825]: kexec: loaded kdump kernel</span><br><span class="line">Sep 04 02:04:18 localhost.localdomain kdumpctl[1825]: Starting kdump: [OK]</span><br><span class="line">Sep 04 02:04:18 localhost.localdomain systemd[1]: Started Crash recovery kernel arming.</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># echo 1 &gt; /proc/sys/kernel/sysrq</span><br><span class="line"># echo c &gt; /proc/sysrq-trigger</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li><code>c</code>: Will perform a system crash by a NULL pointer dereference.(故意使内核崩溃)</li>
</ul>
</blockquote>
<p>这将强制Linux内核崩溃，并且<code>loaclhost(ip)-YYYY-MM-DD-HH：MM：SS/vmcore</code>文件将被复制到配置中选择的位置, 默认<code>/var/crash</code></p>
<h4 id="用crash工具分析"><a href="#用crash工具分析" class="headerlink" title="用crash工具分析"></a>用crash工具分析</h4><ul>
<li>安装对应的kernel-debuginfo软件包,<span class="exturl" data-url="aHR0cDovL2RlYnVnaW5mby5jZW50b3Mub3JnLzcv">地址<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<blockquote>
<p>内核版本：<code>uname -r</code> 4.14.0-115.10.1.el7a.aarch64</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget http://debuginfo.centos.org/7/aarch64/kernel-debuginfo-$(uname -r).rpm</span><br><span class="line">wget http://debuginfo.centos.org/7/aarch64/kernel-debuginfo-common-aarch64-$(uname -r).rpm</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">rpm -ivh kernel-debuginfo-common-aarch64-4.14.0-115.10.1.el7a.aarch64.rpm</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">rpm -ivh kernel-debuginfo-4.14.0-115.10.1.el7a.aarch64.rpm</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ls /usr/lib/debug/lib/modules/4.14.0-115.10.1.el7a.aarch64/vmlinux</span><br><span class="line">/usr/lib/debug/lib/modules/4.14.0-115.10.1.el7a.aarch64/vmlinux</span><br></pre></td></tr></table></figure>

<ul>
<li>启动crash</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">crash /usr/lib/debug/lib/modules/4.14.0-115.10.1.el7a.aarch64/vmlinux /var/crash/127.0.0.1-2019-09-04-10\:02\:53/vmcore</span><br></pre></td></tr></table></figure>
<p>在输入<code>bt</code>可以展示kernel-stack的backtrace，更多crash中的命令见<code>man crash</code></p>
<h3 id="ubuntu18-04"><a href="#ubuntu18-04" class="headerlink" title="ubuntu18.04"></a>ubuntu18.04</h3><h4 id="安装crashdump工具包"><a href="#安装crashdump工具包" class="headerlink" title="安装crashdump工具包"></a>安装crashdump工具包</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get install linux-crashdump</span><br></pre></td></tr></table></figure>
<blockquote>
<p>linux-crashdump实际上安装了三个工具，分别是：crash，kexec-tools，以及makedumpfile</p>
</blockquote>
<h4 id="开启kdump服务"><a href="#开启kdump服务" class="headerlink" title="开启kdump服务"></a>开启kdump服务</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">service kdump start</span><br></pre></td></tr></table></figure>

<h4 id="查看kdump配置"><a href="#查看kdump配置" class="headerlink" title="查看kdump配置"></a>查看kdump配置</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$kdump-config show</span><br><span class="line">DUMP_MODE:        kdump</span><br><span class="line">USE_KDUMP:        1</span><br><span class="line">KDUMP_SYSCTL:     kernel.panic_on_oops=1</span><br><span class="line">KDUMP_COREDIR:    /var/crash</span><br><span class="line">crashkernel addr: 0x</span><br><span class="line">   /var/lib/kdump/vmlinuz: symbolic link to /boot/vmlinuz-4.15.0-58-generic</span><br><span class="line">kdump initrd:</span><br><span class="line">   /var/lib/kdump/initrd.img: symbolic link to /var/lib/kdump/initrd.img-4.15.0-58-generic</span><br><span class="line">current state:    ready to kdump</span><br><span class="line"></span><br><span class="line">kexec command:</span><br><span class="line">  /sbin/kexec -p --command-line=&quot;BOOT_IMAGE=/vmlinuz-4.15.0-58-generic root=UUID=1ff21bc1-eece-439d-a3ab-de37bc03537f ro quiet splash vt.handoff=1 nr_cpus=1 systemd.unit=kdump-tools-dump.service irqpoll nousb ata_piix.prefer_ms_hyperv=0&quot; --initrd=/var/lib/kdump/initrd.img /var/lib/kdump/vmlinuz</span><br></pre></td></tr></table></figure>

<h4 id="Crash文件分析"><a href="#Crash文件分析" class="headerlink" title="Crash文件分析"></a>Crash文件分析</h4><p>crash工具需要内核调试信息<code>dbgsym</code></p>
<ul>
<li>安装dbgsym，下载<span class="exturl" data-url="aHR0cDovL2RkZWJzLnVidW50dS5jb20vcG9vbC9tYWluL2wvbGludXgv">地址<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat /proc/version</span><br><span class="line">Linux version 4.15.0-58-generic (buildd@lcy01-amd64-013) (gcc version 7.4.0 (Ubuntu 7.4.0-1ubuntu1~18.04.1)) #64-Ubuntu SMP Tue Aug 6 11:12:41 UTC 2019</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget http://ddebs.ubuntu.com/pool/main/l/linux/linux-image-4.15.0-58-generic-dbgsym_4.15.0-58.64_arm64.ddeb</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo dpkg -i linux-image-unsigned-4.15.0-58-generic-dbgsym_4.15.0-58.64_amd64.ddeb</span><br><span class="line"></span><br><span class="line">$ ls -lsh /usr/lib/debug/boot/vmlinux-4.15.0-58-generic</span><br><span class="line">566M -rw-r--r-- 1 root root 566M 8月   6 18:45 /usr/lib/debug/boot/vmlinux-4.15.0-58-generic</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo crash /usr/lib/debug/boot/vmlinux-4.15.0-58-generic /var/crash/201909041647/dump.201909041647</span><br></pre></td></tr></table></figure>


<h2 id="ubuntu-apport"><a href="#ubuntu-apport" class="headerlink" title="ubuntu apport"></a>ubuntu apport</h2><p><code>apport</code>就是ubuntu上的”crash report”服务，就是当有程序崩溃时弹出的那个发送error report的程序窗口, 并在<code>/var/crash/</code>中将保存一个<code>*.crash</code>的文件，其中存在CoreDump转储文件和当前崩溃程序运行环境的信息，可以解压获取并通过gdb获取相关信息。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apport-unpack systemGeneratedCrashReportPath.crash yourNewUnpackDirectoryHere</span><br><span class="line">cd yourNewUnpackDirectoryHere/</span><br><span class="line">gdb `cat ExecutablePath` CoreDump #(pay attention to tildes here!)</span><br><span class="line">bt  #(output actual back-trace)</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash"><span class="built_in">cat</span> ExecutablePath</span></span><br><span class="line">/usr/lib/x86_64-linux-gnu/piglit/bin/shader_runner</span><br></pre></td></tr></table></figure>

<h3 id="配置apport"><a href="#配置apport" class="headerlink" title="配置apport"></a>配置apport</h3><blockquote>
<p>默认属于开启状态</p>
</blockquote>
<ul>
<li>关闭<code>crash report</code>服务，修改<code>/etc/default/apport</code>文件中的<code>enabled=0</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># set this to 0 to disable apport, or to 1 to enable it</span><br><span class="line"># you can temporarily override this with</span><br><span class="line"># sudo service apport start force_start=1</span><br><span class="line">enabled=1</span><br></pre></td></tr></table></figure>

<h2 id="定期清理内存-——-桌面卡死"><a href="#定期清理内存-——-桌面卡死" class="headerlink" title="定期清理内存 —— 桌面卡死"></a>定期清理内存 —— 桌面卡死</h2><blockquote>
<p>该操作可能导致部分浏览器页面内容丢失</p>
</blockquote>
<p>主要用于电脑系统内存、交换分区饱满，导致系统桌面卡死的问题</p>
<ul>
<li>清理脚本<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">used=`free -m | awk &#x27;NR==2&#x27; | awk &#x27;&#123;print $3&#125;&#x27;`</span><br><span class="line">free=`free -m | awk &#x27;NR==2&#x27; | awk &#x27;&#123;print $4&#125;&#x27;`</span><br><span class="line"></span><br><span class="line">echo &quot;===========================&quot; &gt;&gt; /var/log/mem.log</span><br><span class="line">date &gt;&gt; /var/log/mem.log</span><br><span class="line">echo &quot;Memory usage | [Use：$&#123;used&#125;MB][Free：$&#123;free&#125;MB]&quot; &gt;&gt; /var/log/mem.log</span><br><span class="line"></span><br><span class="line">if [ $free -le 100 ] ; then</span><br><span class="line">	sync &amp;&amp; echo 1 &gt; /proc/sys/vm/drop_caches</span><br><span class="line">	sync &amp;&amp; echo 2 &gt; /proc/sys/vm/drop_caches</span><br><span class="line">	sync &amp;&amp; echo 3 &gt; /proc/sys/vm/drop_caches</span><br><span class="line">	echo &quot;OK&quot; &gt;&gt; /var/log/mem.log</span><br><span class="line">else</span><br><span class="line">	echo &quot;Not required&quot; &gt;&gt; /var/log/mem.log</span><br><span class="line">fi</span><br></pre></td></tr></table></figure></li>
</ul>
<p>-定期执行脚本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">crontab -e</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">添加：</span></span><br><span class="line">*/10 * * * * /root/freemem.sh</span><br></pre></td></tr></table></figure>
<blockquote>
<p>每十分钟执行一次内存清理脚本</p>
</blockquote>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuaWJtLmNvbS9kZXZlbG9wZXJ3b3Jrcy9jbi9saW51eC9sLWNuLWtkdW1wMy9pbmRleC5odG1sP2NhPWRycy0=">Kdump 实现的基本原理<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuaWJtLmNvbS9kZXZlbG9wZXJ3b3Jrcy9jbi9saW51eC9sLWNuLWtkdW1wNC9pbmRleC5odG1sP2NhPWRycy0=">kdump 的亲密战友 crash<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC84ZTAzMWIyOGQ5OGI=">CentOS7配置kdump<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL3d3dy4zNjF3YXkuY29tL2NlbnRvcy1rZHVtcC8zNzUxLmh0bWw=">centos配置kdump捕获内核崩溃<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cudGhlZ2Vla2RpYXJ5LmNvbS9jZW50b3MtcmhlbC03LWhvdy10by1jb25maWd1cmUta2R1bXAv">CentOS &#x2F; RHEL 7 : How to configure kdump<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>死机</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux下去掉^M的方法</title>
    <url>/post/18189.html</url>
    <content><![CDATA[<p>在linux下去掉文件行尾的<code>^M</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat -A filename</span><br></pre></td></tr></table></figure>
<blockquote>
<p>查看到windows下的断元字符^M</p>
</blockquote>
<span id="more"></span>

<h2 id="dos2unix"><a href="#dos2unix" class="headerlink" title="dos2unix"></a>dos2unix</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dos2unix filename</span><br></pre></td></tr></table></figure>

<p>多文件处理</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ls ./*.c | xargs dos2unix</span><br></pre></td></tr></table></figure>

<h2 id="sed"><a href="#sed" class="headerlink" title="sed"></a>sed</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sed -i &#x27;s/^M//g&#x27; filename</span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sed -i &#x27;s/\r//g&#x27; filename</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：^M的输入方式是 <code>Ctrl + v</code> ，然后<code>Ctrl + M</code> 
 </p>
</blockquote>
<h2 id="vi"><a href="#vi" class="headerlink" title="vi"></a>vi</h2><p>将两个命令合并成一个，并添加的vi的快捷键中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nmap dm :%s/\r\+$//e&lt;cr&gt;:set ff=unix&lt;cr&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>用法： 打开文件直接敲<code>dm</code>即可，最后保存</p>
</blockquote>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>linux下性能分析---perf</title>
    <url>/post/d5a39290.html</url>
    <content><![CDATA[<p><code>perf</code>是Linux kernel自带的系统性能优化工具</p>
<span id="more"></span>


<h2 id="perf"><a href="#perf" class="headerlink" title="perf"></a>perf</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">perf</span></span><br><span class="line"></span><br><span class="line"> usage: perf [--version] [--help] [OPTIONS] COMMAND [ARGS]</span><br><span class="line"></span><br><span class="line"> The most commonly used perf commands are:</span><br><span class="line">   annotate        Read perf.data (created by perf record) and display annotated code</span><br><span class="line">   archive         Create archive with object files with build-ids found in perf.data file</span><br><span class="line">   bench           General framework for benchmark suites</span><br><span class="line">   buildid-cache   Manage build-id cache.</span><br><span class="line">   buildid-list    List the buildids in a perf.data file</span><br><span class="line">   c2c             Shared Data C2C/HITM Analyzer.</span><br><span class="line">   config          Get and set variables in a configuration file.</span><br><span class="line">   data            Data file related processing</span><br><span class="line">   diff            Read perf.data files and display the differential profile</span><br><span class="line">   evlist          List the event names in a perf.data file</span><br><span class="line">   ftrace          simple wrapper for kernel&#x27;s ftrace functionality</span><br><span class="line">   inject          Filter to augment the events stream with additional information</span><br><span class="line">   kallsyms        Searches running kernel for symbols</span><br><span class="line">   kmem            Tool to trace/measure kernel memory properties</span><br><span class="line">   kvm             Tool to trace/measure kvm guest os</span><br><span class="line">   list            List all symbolic event types</span><br><span class="line">   lock            Analyze lock events</span><br><span class="line">   mem             Profile memory accesses</span><br><span class="line">   record          Run a command and record its profile into perf.data</span><br><span class="line">   report          Read perf.data (created by perf record) and display the profile</span><br><span class="line">   sched           Tool to trace/measure scheduler properties (latencies)</span><br><span class="line">   script          Read perf.data (created by perf record) and display trace output</span><br><span class="line">   stat            Run a command and gather performance counter statistics</span><br><span class="line">   test            Runs sanity tests.</span><br><span class="line">   timechart       Tool to visualize total system behavior during a workload</span><br><span class="line">   top             System profiling tool.</span><br><span class="line">   version         display the version of perf binary</span><br><span class="line">   probe           Define new dynamic tracepoints</span><br><span class="line">   trace           strace inspired tool</span><br><span class="line"></span><br><span class="line"> See &#x27;perf help COMMAND&#x27; for more information on a specific command.</span><br></pre></td></tr></table></figure>


<h2 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h2><table>
<thead>
<tr>
<th align="center">参数</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">top</td>
<td align="center">动态时实追踪显示占用CPU较高的进程</td>
</tr>
<tr>
<td align="center">record</td>
<td align="center">由于top只能实时查看不能保存，不便于事后分析，用此参数保存追踪的内容，文件名为perf.data</td>
</tr>
<tr>
<td align="center">report</td>
<td align="center">重放perf.data的内容</td>
</tr>
</tbody></table>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">记录</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">sudo perf record -g -p &lt;pid&gt;</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">回放</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">sudo perf report</span></span><br></pre></td></tr></table></figure>


<h3 id="KVM"><a href="#KVM" class="headerlink" title="KVM"></a>KVM</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">perf kvm <span class="built_in">stat</span> record -a <span class="built_in">sleep</span> 100</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">perf kvm <span class="built_in">stat</span> report</span></span><br><span class="line"></span><br><span class="line">Analyze events for all VMs, all VCPUs:</span><br><span class="line"></span><br><span class="line">             VM-EXIT    Samples  Samples%     Time%    Min Time    Max Time         Avg time</span><br><span class="line"></span><br><span class="line">           MSR_WRITE      42521    53.32%     0.06%      0.50us     52.94us      1.71us ( +-   0.48% )</span><br><span class="line">                 HLT      15885    19.92%    99.89%      0.63us  17539.26us   8224.34us ( +-   0.61% )</span><br><span class="line">      IO_INSTRUCTION      10892    13.66%     0.03%      2.14us     47.60us      3.02us ( +-   0.48% )</span><br><span class="line">          APIC_WRITE       6226     7.81%     0.02%      0.52us     41.71us      3.88us ( +-   0.94% )</span><br><span class="line">  EXTERNAL_INTERRUPT       1965     2.46%     0.00%      0.42us     42.59us      1.46us ( +-   2.38% )</span><br><span class="line">    PREEMPTION_TIMER       1805     2.26%     0.00%      0.54us     16.87us      2.13us ( +-   1.59% )</span><br><span class="line">       EPT_MISCONFIG        302     0.38%     0.00%      0.76us    171.85us     16.38us ( +-   7.97% )</span><br><span class="line">            MSR_READ        132     0.17%     0.00%      0.74us      3.52us      1.56us ( +-   4.86% )</span><br><span class="line">   PAUSE_INSTRUCTION         16     0.02%     0.00%      0.45us      0.87us      0.66us ( +-   4.89% )</span><br><span class="line"></span><br><span class="line">Total Samples:79744, Total events handled time:130785328.50us.</span><br></pre></td></tr></table></figure>

<ul>
<li><code>HLT</code>: (halt)是由于CPU进入idle状态时，就会调用该指令把CPU挂起。这样虚拟CPU挂起后就能出让物理CPU给其它进程使用。</li>
</ul>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>perf</tag>
        <tag>性能</tag>
      </tags>
  </entry>
  <entry>
    <title>linux下硬盘检查</title>
    <url>/post/f6f2a529.html</url>
    <content><![CDATA[<p>通过<code>hdparm</code>、<code>smartctl</code>、<code>badblocks</code>等命令，获取硬盘详细信息和测试硬盘读取速度等</p>
<span id="more"></span>

<h2 id="hdparm"><a href="#hdparm" class="headerlink" title="hdparm"></a>hdparm</h2><blockquote>
<p>可检测，显示与设定IDE或SCSI硬盘的参数</p>
</blockquote>
<p><img data-src="/images/2020/05/tool_hdparm_cmd.png" alt="tool_hdparm_cmd"><br><strong>hdparm的改变的配置是个临时的状态，下次启动Linux系统的时候hdparm的配置将会消失，如果需要必须加入开机启动脚本&#96;&#96;</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">sudo hdparm  /dev/sdb</span></span><br><span class="line"></span><br><span class="line">/dev/sdb:</span><br><span class="line"> multcount     = 16 (on)</span><br><span class="line"> IO_support    =  1 (32-bit)</span><br><span class="line"> readonly      =  0 (off)</span><br><span class="line"> readahead     = 256 (on)</span><br><span class="line"> geometry      = 121601/255/63, sectors = 1953525168, start = 0</span><br></pre></td></tr></table></figure>

<h3 id="测试读取速度"><a href="#测试读取速度" class="headerlink" title="测试读取速度"></a>测试读取速度</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">sudo hdparm -tT /dev/sdb</span></span><br><span class="line"></span><br><span class="line">/dev/sdb:</span><br><span class="line"> Timing cached reads:   9084 MB in  1.99 seconds = 4560.73 MB/sec</span><br><span class="line"> Timing buffered disk reads: 418 MB in  3.01 seconds = 139.02 MB/sec</span><br></pre></td></tr></table></figure>

<h3 id="检测硬盘的电源管理模式"><a href="#检测硬盘的电源管理模式" class="headerlink" title="检测硬盘的电源管理模式"></a>检测硬盘的电源管理模式</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">sudo hdparm -C /dev/sdb</span></span><br><span class="line"></span><br><span class="line">/dev/sdb:</span><br><span class="line"> drive state is:  active/idle</span><br></pre></td></tr></table></figure>

<h3 id="进入省电模式"><a href="#进入省电模式" class="headerlink" title="进入省电模式"></a>进入省电模式</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">sudo hdparm -Y /dev/sdb</span></span><br><span class="line"></span><br><span class="line">/dev/sdb:</span><br><span class="line"> issuing sleep command</span><br></pre></td></tr></table></figure>
<h3 id="设置硬盘省电策略"><a href="#设置硬盘省电策略" class="headerlink" title="设置硬盘省电策略"></a>设置硬盘省电策略</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">sudo hdparm -S 60 /dev/sdb</span></span><br><span class="line"></span><br><span class="line">/dev/sdb:</span><br><span class="line"> setting standby to 60 (5 minutes)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在无数据访问后，5分钟硬盘自动停转进入休眠模式</p>
</blockquote>
<p><strong><code>0</code>表示“超时已禁用”：设备不会自动进入待机模式。从1到240指定5秒的倍数，产生5秒到20分钟的超时。</strong></p>
<h2 id="smartctl"><a href="#smartctl" class="headerlink" title="smartctl"></a>smartctl</h2><blockquote>
<p><code>SMART</code>是一种磁盘自我分析检测技术</p>
</blockquote>
<h3 id="获取硬盘详细信息"><a href="#获取硬盘详细信息" class="headerlink" title="获取硬盘详细信息"></a>获取硬盘详细信息</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">sudo smartctl -i /dev/sdb</span></span><br><span class="line">smartctl 7.1 2019-12-30 r5022 [x86_64-linux-5.4.0-31-generic] (local build)</span><br><span class="line">Copyright (C) 2002-19, Bruce Allen, Christian Franke, www.smartmontools.org</span><br><span class="line"></span><br><span class="line">=== START OF INFORMATION SECTION ===</span><br><span class="line">Device Model:     TOSHIBA MQ04ABF100</span><br><span class="line">Serial Number:    30IAP8ZKT</span><br><span class="line">LU WWN Device Id: 5 000039 9e26062ca</span><br><span class="line">Firmware Version: JU002U</span><br><span class="line">User Capacity:    1,000,204,886,016 bytes [1.00 TB]</span><br><span class="line">Sector Sizes:     512 bytes logical, 4096 bytes physical</span><br><span class="line">Rotation Rate:    5400 rpm</span><br><span class="line">Form Factor:      2.5 inches</span><br><span class="line">Device is:        Not in smartctl database [for details use: -P showall]</span><br><span class="line">ATA Version is:   ACS-3 T13/2161-D revision 5</span><br><span class="line">SATA Version is:  SATA 3.3, 3.0 Gb/s (current: 3.0 Gb/s)</span><br><span class="line">Local Time is:    Sat May 23 23:36:34 2020 CST</span><br><span class="line">SMART support is: Available - device has SMART capability.</span><br><span class="line">SMART support is: Enabled</span><br></pre></td></tr></table></figure>

<h2 id="badblocks"><a href="#badblocks" class="headerlink" title="badblocks"></a>badblocks</h2><blockquote>
<p>检查磁盘装置中损坏的区块</p>
</blockquote>
<h3 id="坏道检查"><a href="#坏道检查" class="headerlink" title="坏道检查"></a>坏道检查</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">sudo badblocks -s -v /dev/sdb</span></span><br><span class="line">Checking blocks 0 to 976762583</span><br><span class="line">Checking for bad blocks (read-only test): done</span><br><span class="line">Pass completed, 0 bad blocks found. (0/0/0 errors)</span><br></pre></td></tr></table></figure>
<ul>
<li><code>-s</code>: 在检查时显示进度</li>
<li><code>-v</code>: 执行时显示详细的信息</li>
</ul>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>硬盘</tag>
        <tag>系统</tag>
      </tags>
  </entry>
  <entry>
    <title>Multiseat System</title>
    <url>/post/1458b897.html</url>
    <content><![CDATA[<p><code>Multiseat system</code>: 可以由多个用户同时共享一个PC的大部分资源使用，比如独立的鼠标键盘、显示器</p>
<blockquote>
<p>Multiseat主要是硬件，然后才是软件配置</p>
</blockquote>
<p>在每个使用<code>Xorg</code>的Linux中，即使您不想安装多座linux系统，也总是有一个席位。 该座位名为“seat0”，您无法重命名。</p>
<span id="more"></span>

<h2 id="软件配置"><a href="#软件配置" class="headerlink" title="软件配置"></a>软件配置</h2><ul>
<li>创建一个seat；</li>
<li>删除座位seat；</li>
<li>为seat分配资源；</li>
<li>查看分配给特定seat的资源。</li>
</ul>
<blockquote>
<p>规则，seat名称必须以<code>seat-</code>作为前缀</p>
</blockquote>
<p><strong>无论在任何情况下都遇到麻烦，如果遇到麻烦，您总是可以通过以下简单的单个命令将所有设备重新分配给seat0</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo loginctl flush-devices</span><br></pre></td></tr></table></figure>
<h3 id="列出当前seat"><a href="#列出当前seat" class="headerlink" title="列出当前seat"></a>列出当前seat</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo loginctl list-seats</span><br></pre></td></tr></table></figure>

<h3 id="创建seat并分配资源"><a href="#创建seat并分配资源" class="headerlink" title="创建seat并分配资源"></a>创建seat并分配资源</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo loginctl attach seat-[name] /sys/devices/pci0000:00/0000:00:06.0/0000:02:00.0/drm/card1</span><br></pre></td></tr></table></figure>
<ul>
<li>给已经存在的seat,添加资源,比如其他的设备外设</li>
</ul>
<h3 id="查看seat状态"><a href="#查看seat状态" class="headerlink" title="查看seat状态"></a>查看seat状态</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo loginctl seat-status seat0</span><br></pre></td></tr></table></figure>

<h2 id="udev"><a href="#udev" class="headerlink" title="udev"></a>udev</h2><p>多设备并且固定时,可以通过udev批量添加, 在<code>/etc/udev/rules.d</code>目录下根据udev规则添加seat配置文件</p>
<h3 id="添加udev规则"><a href="#添加udev规则" class="headerlink" title="添加udev规则"></a>添加udev规则</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">cat</span> 72-seat-*</span></span><br><span class="line">SUBSYSTEM==&quot;pci&quot;, DEVPATH==&quot;/devices/pci0000:00/0000:00:02.2/0000:03:00.0&quot;, TAG+=&quot;seat-1&quot;, TAG+=&quot;master-of-seat&quot;, ENV&#123;ID_AUTOSEAT&#125;=&quot;1&quot;, ENV&#123;ID_SEAT&#125;=&quot;seat-1&quot;</span><br><span class="line">SUBSYSTEM==&quot;pci&quot;, DEVPATH==&quot;/devices/pci0000:00/0000:00:03.0/0000:04:00.0&quot;, TAG+=&quot;seat-2&quot;, TAG+=&quot;master-of-seat&quot;, ENV&#123;ID_AUTOSEAT&#125;=&quot;1&quot;, ENV&#123;ID_SEAT&#125;=&quot;seat-2&quot;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>DEVPATH</code>指设置地址,通过<code>loginctl seat-status seat0</code>获取</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">loginctl seat-status seat0 | grep <span class="string">&quot;drm:card&quot;</span> -A4</span></span><br><span class="line">		  │ drm:card1</span><br><span class="line">		  ├─/sys/device...0:00/0000:00:02.2/0000:03:00.0/drm/renderD128</span><br><span class="line">		  │ drm:renderD128</span><br><span class="line">		  ├─/sys/device...0000:00/0000:00:02.2/0000:03:00.1/sound/card0</span><br><span class="line">		  │ sound:card0</span><br><span class="line">--</span><br><span class="line">		  │ drm:card2</span><br><span class="line">		  ├─/sys/device...0:00/0000:00:03.0/0000:04:00.0/drm/renderD129</span><br><span class="line">		  │ drm:renderD129</span><br><span class="line">		  ├─/sys/device...0000:00/0000:00:03.0/0000:04:00.1/sound/card1</span><br><span class="line">		  │ sound:card1</span><br></pre></td></tr></table></figure>

<h3 id="生成seats分组"><a href="#生成seats分组" class="headerlink" title="生成seats分组"></a>生成seats分组</h3><blockquote>
<p>udevadm - udev management tool</p>
</blockquote>
<p><code>udevadm</code>是一个udev的管理工具，可以用来监视和控制udev运行时的行为，请求内核事件，管理事件队列，以及提供简单的调试机制。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo udevadm trigger</span><br></pre></td></tr></table></figure>
<blockquote>
<p>从内核请求events事件,主要用于重放coldplug事件信息.(相当于模拟一次重启后的设置加载)<br><code>coldplug</code>:内核在启动时已经检测到了系统的硬件设备，并把硬件设备信息通过sysfs内核虚拟文件系统导出。udev扫描sysfs文件系统，根据硬件设备信息生成热插拔（hotplug）事件，udev再读取这些事件，生成对应的硬件设备文件。由于没有实际的硬件插拔动作，所以这一过程被称为coldplug。</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo loginctl list-seats</span><br><span class="line">SEAT</span><br><span class="line">seat-1</span><br><span class="line">seat-2</span><br><span class="line">seat0</span><br><span class="line"></span><br><span class="line">3 seats listed.</span><br></pre></td></tr></table></figure>

<blockquote>
<p>有时可能无法生成seats分组,需要将本机的所有设备重新分配到seat0,重启设备后重新通过<code>udevadm trigger</code>生成分组<br><strong>注意</strong>: 通过<code>loginctl flush-devices</code>重置到seat0之前,需要备份我们在<code>/etc/udev/rules.d</code>目录下,编辑的udev文件,否则重置时将自动删除</p>
</blockquote>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuZnJlZWRlc2t0b3Aub3JnL3dpa2kvU29mdHdhcmUvc3lzdGVtZC9tdWx0aXNlYXQv">multiseat<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cueC5vcmcvd2lraS9EZXZlbG9wbWVudC9Eb2N1bWVudGF0aW9uL011bHRpc2VhdC8=">Multiseat<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93aWtpLmFyY2hsaW51eC5vcmcvaW5kZXgucGhwL1hvcmdfbXVsdGlzZWF0">Xorg multiseat<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9zYW11bG9vcC5naXRodWIuaW8vbGludXgvbXVsdGlzZWF0Lmh0bWwjY3JlYXRlX3NlYXQ=">How to configure a Multiseat system<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly91bml4LnN0YWNrZXhjaGFuZ2UuY29tL3F1ZXN0aW9ucy84NzE2OS9hdXRvc3RhcnQtYWxsLWxpZ2h0ZG0tc2VhdHMtYW5kLXNob3ctb25lLWFzLWRlZmF1bHQ=">Autostart all LightDM seats and show one as default<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly91bml4LnN0YWNrZXhjaGFuZ2UuY29tL3F1ZXN0aW9ucy8xNjc3MDkvZGVidWdnaW5nLW11bHRpc2VhdC1ob3ctdG8tcnVuLXR3by14LXNlcnZlci1sYXlvdXRzLXRvZ2V0aGVyLXdpdGhvdXQtZGlzcGxheS1tYQ==">Debugging multiseat: How to run two X server layouts together without display manager?<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>seat</tag>
        <tag>x11</tag>
      </tags>
  </entry>
  <entry>
    <title>My TiddlyWiki</title>
    <url>/post/8982b524.html</url>
    <content><![CDATA[<p>Tiddlywiki 的使用方法很简单，先打开 <span class="exturl" data-url="aHR0cDovL3RpZGRseXdpa2kuY29tLw==">http://tiddlywiki.com<i class="fa fa-external-link-alt"></i></span> 点击「Download Empty」下载一个空文档。然后在浏览器中打开这个文档，之后就可以进行修改标题、输入文字、插入图片和链接等等操作</p>
<span id="more"></span>

<h2 id="本地搭建"><a href="#本地搭建" class="headerlink" title="本地搭建"></a>本地搭建</h2><p>本地搭建可以作为简单个人笔记,随手记录一些想法,这里可以使用docker进行搭建不用进行烦琐的配置.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone git@github.com:Winddoing/tiddlyWiki.git</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9odWIuZG9ja2VyLmNvbS9yL25pY29sYXcvdGlkZGx5d2lraQ==">Docker–nicolaw&#x2F;tiddlywiki<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL2Jsb2cuZGltcHVyci5jb20vdGlkZGx5LXdpa2kv">使用 TiddlyWiki 打造轻便个人 Wiki 知识库<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>wiki</tag>
      </tags>
  </entry>
  <entry>
    <title>repo服务器的搭建测试</title>
    <url>/post/44256.html</url>
    <content><![CDATA[<p><code>repo</code>的作用就是进行多个git仓库的统一管理，其实repo就是一个python的脚本，这里测试repo服务的搭建和使用</p>
<span id="more"></span>

<h2 id="下载repo"><a href="#下载repo" class="headerlink" title="下载repo"></a>下载repo</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone https://review.mfunz.com/git-repo git-repo-core.git</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>服务端</code>和<code>客户端</code></p>
<ul>
<li>服务端： <code>git-repo-core</code></li>
<li>客户端： <code>git-repo-core/repo</code></li>
</ul>
</blockquote>
<ol>
<li><p>进入<code>git-repo-core</code>将<code>repo</code>拷贝到客户端或本地的<code>/user/bin/</code>下（或者自定义的目录下使用时通过绝对路径）</p>
</li>
<li><p>指定拷贝后客户端使用的<code>repo</code>中的<code>REPO_URL</code>变量为<code>git-repo-core</code>的路径（服务器将是IP:path）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">REPO_URL = &#x27;/home/xxx/test/repo-test/server/git-repo-core.git&#x27;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>edit: <code>vi client/repo</code></p>
</blockquote>
</li>
<li><p>测试目录结构</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$tree -L 2</span><br><span class="line">.</span><br><span class="line">├── client</span><br><span class="line">│   └── repo</span><br><span class="line">└── server</span><br><span class="line">    └── git-repo-core.git</span><br></pre></td></tr></table></figure>
<blockquote>
<p>pwd:<code>/home/xxx/test/repo-test</code></p>
</blockquote>
</li>
</ol>
<h2 id="repo服务器"><a href="#repo服务器" class="headerlink" title="repo服务器"></a>repo服务器</h2><h3 id="新建manifest仓库"><a href="#新建manifest仓库" class="headerlink" title="新建manifest仓库"></a>新建manifest仓库</h3><p>在server目录下创建</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir -p repos/manifest</span><br></pre></td></tr></table></figure>

<p>在manifest目录下添加<code>default.xml</code>文件。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">manifest</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">remote</span> <span class="attr">name</span>=<span class="string">&quot;origin&quot;</span></span></span><br><span class="line"><span class="tag">		<span class="attr">fetch</span>=<span class="string">&quot;/home/xxx/test/repo-test/server/repos&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">default</span> <span class="attr">remote</span>=<span class="string">&quot;origin&quot;</span> <span class="attr">revision</span>=<span class="string">&quot;master&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">project</span> <span class="attr">name</span>=<span class="string">&quot;test1&quot;</span> <span class="attr">path</span>=<span class="string">&quot;test1&quot;</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">project</span> <span class="attr">name</span>=<span class="string">&quot;test2&quot;</span> <span class="attr">path</span>=<span class="string">&quot;test2&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">project</span> <span class="attr">name</span>=<span class="string">&quot;test3&quot;</span> <span class="attr">path</span>=<span class="string">&quot;tst333&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>file: default.xml</p>
</blockquote>
<h4 id="xml文件语法"><a href="#xml文件语法" class="headerlink" title="xml文件语法"></a>xml文件语法</h4><ul>
<li><code>remote</code>: 设置服务器端的路径和名称<ul>
<li><code>name</code>: 服务器端名称</li>
<li><code>fetch</code>：指repo仓库服务器端所在的位置，可以是远程，也可以是本地，测试使用本地  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git remote -v</span><br><span class="line">origin	/home/xxx/test/repo-test/server/repos/test1 (fetch)</span><br><span class="line">origin	/home/xxx/test/repo-test/server/repos/test1 (push)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><code>default</code>: 设置服务器端名和分支名<ul>
<li><code>remote</code>: 服务器端名称（与<code>remote</code>中的name相同）</li>
<li><code>revision</code>: 分支名</li>
<li><code> sync-j</code>： 指定在sync操作时的线程数，（sync-j&#x3D;”4”）</li>
</ul>
</li>
<li><code>project</code>: 设置repo管理的git仓库<ul>
<li><code>name</code>： git仓库服务端（远端）的名字</li>
<li><code>path</code>： clone到本地的名字</li>
<li><code>revision</code>： 指定需要获取的git提交点，可以定义成固定的branch，或者是明确的commit哈希值  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;project name=&quot;test1&quot; path=&quot;test1&quot; revision=&quot;088216c4e32e&quot;/&gt;</span><br></pre></td></tr></table></figure>
<h4 id="manifest文件格式"><a href="#manifest文件格式" class="headerlink" title="manifest文件格式"></a>manifest文件格式</h4></li>
</ul>
</li>
</ul>
<ul>
<li><copyfile>标签</li>
</ul>
<blockquote>
<p>可以作为<project>标签的子标签，每一个<copyfile>标签表明了在repo sync的时候从src把文件拷贝到dest。 src相对于该project来说，dest相对于根目录来说。</p>
</blockquote>
<ul>
<li><linkfile>标签</li>
</ul>
<blockquote>
<p>和<copyfile>标签的作用类似，不过是不进行拷贝，而是进行一个符号链接</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-       &lt;project name=&quot;tools&quot; path=&quot;tools&quot;/&gt;</span><br><span class="line">+       &lt;project name=&quot;tools&quot; path=&quot;tools&quot;&gt;</span><br><span class="line">+               &lt;linkfile dest=&quot;envsetup.sh&quot; src=&quot;envsetup.sh&quot;/&gt;</span><br><span class="line">+       &lt;/project&gt;</span><br><span class="line">+</span><br></pre></td></tr></table></figure>

<ul>
<li><include>标签</li>
</ul>
<blockquote>
<p>用来引入一个其他的manifest,有一个name属性指向被引用的manifest, 路径是相对于mamanifest库的根目录</p>
</blockquote>
<h4 id="初始化仓库"><a href="#初始化仓库" class="headerlink" title="初始化仓库"></a>初始化仓库</h4><ol>
<li><p>进入<code>manifest</code>目录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git init</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git add .</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git commit -m <span class="string">&quot;init manifest&quot;</span></span></span><br></pre></td></tr></table></figure></li>
<li><p>返回<code>manifest</code>上一级目录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">clone</span> --bare manifest</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>新建完成<code>manifest.git</code>仓库后，<code>manifest</code>可以删除</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[xxx@xxx-pc]~/test/repo-test/server/repos</span><br><span class="line">=====&gt;$ls</span><br><span class="line">manifest manifest.git</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="新建test1和test2仓库"><a href="#新建test1和test2仓库" class="headerlink" title="新建test1和test2仓库"></a>新建test1和test2仓库</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mkdir</span> test1 test2</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> test1</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> test1 &gt; readme.md</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git init</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git add .</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git commit -m <span class="string">&quot;init test1&quot;</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> ..</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">clone</span> --bare test1</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>test2</code>仓库以相同的步骤建立</p>
</blockquote>
<ul>
<li>结果：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[xxx@xxx-pc]~/test/repo-test/server/repos</span><br><span class="line">=====&gt;$ls</span><br><span class="line">manifest  manifest.git  test1  test1.git  test2  test2.git  test3  test3.git</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="repo测试"><a href="#repo测试" class="headerlink" title="repo测试"></a>repo测试</h2><p>进入client目录</p>
<h3 id="初始化-repo-init"><a href="#初始化-repo-init" class="headerlink" title="初始化 repo init"></a>初始化 repo init</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">./repo init -u /home/xxx/test/repo-test/server/repos/manifest.git</span></span><br><span class="line">Get /home/xxx/test/repo-test/server/git-repo-core.git</span><br><span class="line">remote: Counting objects: 4050, done.</span><br><span class="line">remote: Compressing objects: 100% (1844/1844), done.</span><br><span class="line">remote: Total 4050 (delta 2144), reused 4050 (delta 2144)</span><br><span class="line">Receiving objects: 100% (4050/4050), 3.45 MiB | 31.58 MiB/s, done.</span><br><span class="line">Resolving deltas: 100% (2144/2144), done.</span><br><span class="line">From /home/xxx/test/repo-test/server/git-repo-core</span><br><span class="line"> * [new branch]      stable     -&gt; origin/stable</span><br><span class="line"> * [new tag]         v1.0       -&gt; v1.0</span><br><span class="line"> ...</span><br><span class="line"> * [new tag]         v1.9.4     -&gt; v1.9.4</span><br><span class="line"> * [new tag]         v1.9.5     -&gt; v1.9.5</span><br><span class="line"> * [new tag]         v1.9.6     -&gt; v1.9.6</span><br><span class="line">Get /home/xxx/test/repo-test/server/repos/manifest.git</span><br><span class="line">remote: Counting objects: 9, done.</span><br><span class="line">remote: Compressing objects: 100% (6/6), done.</span><br><span class="line">remote: Total 9 (delta 2), reused 0 (delta 0)</span><br><span class="line">From /home/xxx/test/repo-test/server/repos/manifest</span><br><span class="line"> * [new branch]      master     -&gt; origin/master</span><br><span class="line"></span><br><span class="line">Your identity is: xxx &lt;xxx@xx.com&gt;</span><br><span class="line">If you want to change this, please re-run &#x27;repo init&#x27; with --config-name</span><br><span class="line"></span><br><span class="line">repo has been initialized in /home/xxx/test/repo-test/client</span><br></pre></td></tr></table></figure>
<h3 id="同步代码-repo-sync"><a href="#同步代码-repo-sync" class="headerlink" title="同步代码 repo sync"></a>同步代码 repo sync</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">./repo <span class="built_in">sync</span></span></span><br><span class="line">Fetching project test2</span><br><span class="line">remote: Counting objects: 3, done.</span><br><span class="line">remote: Total 3 (delta 0), reused 0 (delta 0)</span><br><span class="line">From /home/xxx/test/repo-test/server/repos/test2</span><br><span class="line"> * [new branch]      master     -&gt; origin/master</span><br><span class="line">Fetching project test1</span><br><span class="line">remote: Counting objects: 3, done.</span><br><span class="line">remote: Total 3 (delta 0), reused 0 (delta 0)</span><br><span class="line">From /home/xxx/test/repo-test/server/repos/test1</span><br><span class="line"> * [new branch]      master     -&gt; origin/master</span><br></pre></td></tr></table></figure>
<ul>
<li>下载目录<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ls</span><br><span class="line">repo  test1  test2  tst333</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="遍历repo每个仓库并执行相同代码-repo-forall"><a href="#遍历repo每个仓库并执行相同代码-repo-forall" class="headerlink" title="遍历repo每个仓库并执行相同代码 repo forall"></a>遍历repo每个仓库并执行相同代码 repo forall</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./repo forall -h</span><br><span class="line">Usage: repo forall [&lt;project&gt;...] -c &lt;command&gt; [&lt;arg&gt;...]</span><br><span class="line">repo forall -r str1 [str2] ... -c &lt;command&gt; [&lt;arg&gt;...]&quot;</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  -h, --help            show this help message and exit</span><br><span class="line">  -r, --regex           Execute the command only on projects matching regex or</span><br><span class="line">                        wildcard expression</span><br><span class="line">  -i, --inverse-regex   Execute the command only on projects not matching</span><br><span class="line">                        regex or wildcard expression</span><br><span class="line">  -g GROUPS, --groups=GROUPS</span><br><span class="line">                        Execute the command only on projects matching the</span><br><span class="line">                        specified groups</span><br><span class="line">  -c, --command         Command (and arguments) to execute</span><br><span class="line">  -e, --abort-on-errors</span><br><span class="line">                        Abort if a command exits unsuccessfully</span><br><span class="line"></span><br><span class="line">  Output:</span><br><span class="line">    -p                  Show project headers before output</span><br><span class="line">    -v, --verbose       Show command error messages</span><br><span class="line">    -j JOBS, --jobs=JOBS</span><br><span class="line">                        number of commands to execute simultaneously</span><br></pre></td></tr></table></figure>

<ul>
<li>示例<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">=====&gt;$./repo forall -c &quot;git log&quot;</span><br><span class="line">commit 088216c4e32e0257ec23f2ac61c87866f8e8dd98 (HEAD, origin/master, m/master)</span><br><span class="line">Author: xxx &lt;xxx@xx.com&gt;</span><br><span class="line">Date:   Thu Oct 11 20:04:17 2018 +0800</span><br><span class="line"></span><br><span class="line">    init test1</span><br><span class="line">commit c150415858ffbdfa7c010d35d66b6282cd7b3cbe (HEAD, origin/master, m/master)</span><br><span class="line">Author: xxx &lt;xxx@xx.com&gt;</span><br><span class="line">Date:   Thu Oct 11 20:05:19 2018 +0800</span><br><span class="line"></span><br><span class="line">    init test2</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="repo支持命令"><a href="#repo支持命令" class="headerlink" title="repo支持命令"></a>repo支持命令</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">./repo --trace</span></span><br><span class="line">usage: repo COMMAND [ARGS]</span><br><span class="line">The most commonly used repo commands are:</span><br><span class="line">  abandon        Permanently abandon a development branch</span><br><span class="line">  branch         View current topic branches</span><br><span class="line">  branches       View current topic branches</span><br><span class="line">  checkout       Checkout a branch for development</span><br><span class="line">  cherry-pick    Cherry-pick a change.</span><br><span class="line">  diff           Show changes between commit and working tree</span><br><span class="line">  diffmanifests  Manifest diff utility</span><br><span class="line">  download       Download and checkout a change</span><br><span class="line">  grep           Print lines matching a pattern</span><br><span class="line">  info           Get info on the manifest branch, current branch or unmerged branches</span><br><span class="line">  init           Initialize repo in the current directory</span><br><span class="line">  list           List projects and their associated directories</span><br><span class="line">  overview       Display overview of unmerged project branches</span><br><span class="line">  prune          Prune (delete) already merged topics</span><br><span class="line">  rebase         Rebase local branches on upstream branch</span><br><span class="line">  smartsync      Update working tree to the latest known good revision</span><br><span class="line">  stage          Stage file(s) for commit</span><br><span class="line">  start          Start a new branch for development</span><br><span class="line">  status         Show the working tree status</span><br><span class="line">  sync           Update working tree to the latest revision</span><br><span class="line">  upload         Upload changes for code review</span><br><span class="line">See &#x27;repo help &lt;command&gt;&#x27; for more information on a specific command.</span><br><span class="line">See &#x27;repo help --all&#x27; for a complete list of recognized commands.</span><br></pre></td></tr></table></figure>


<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><span class="exturl" data-url="aHR0cDovL3d3dy4zNjBkb2MuY29tL2NvbnRlbnQvMTUvMDEyMi8yMi80MjYwODVfNDQyOTU2NjE5LnNodG1s">本地&#x2F;远程搭建repo<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Vhc3Rtb29uNTAyMTM2L2FydGljbGUvZGV0YWlscy83MjU5ODI5Nw==">简易repo服务器搭建<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC9kNDA0NDQyNjdlOGQ=">repo manifest文件格式说明<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>repo</tag>
      </tags>
  </entry>
  <entry>
    <title>博客文件整理——分类/标签</title>
    <url>/post/39420.html</url>
    <content><![CDATA[<h2 id="批量修改分类名"><a href="#批量修改分类名" class="headerlink" title="批量修改分类名"></a>批量修改分类名</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls *.md | xargs sed  -i &#x27;/categories:</span><br><span class="line">  -/&#123;s/单片机/嵌入式/; &#125;&#x27;</span><br></pre></td></tr></table></figure>

<h2 id="文件指定行数的字符大写转小写"><a href="#文件指定行数的字符大写转小写" class="headerlink" title="文件指定行数的字符大写转小写"></a>文件指定行数的字符大写转小写</h2><p>所有tag改为小写</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find -name &quot;*.md&quot; | xargs sed -i &#x27;4,9s/.*/\L&amp;/&#x27;</span><br></pre></td></tr></table></figure>

<h2 id="删除所有文件行尾空格"><a href="#删除所有文件行尾空格" class="headerlink" title="删除所有文件行尾空格"></a>删除所有文件行尾空格</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find source/_posts/ -name &quot;*.md&quot; | xargs sed -i &#x27;s/[ ]*$//g&#x27;</span><br></pre></td></tr></table></figure>

<h2 id="标签一行变两行"><a href="#标签一行变两行" class="headerlink" title="标签一行变两行"></a>标签一行变两行</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">categories:</span><br><span class="line">  - 工具</span><br><span class="line">转</span><br><span class="line">categories:</span><br><span class="line">  -</span><br><span class="line">  - 工具</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grep &quot;categories: &quot; _posts/ -rn | awk -F: &#x27;&#123;print $1&#125;&#x27; | xargs sed -i &quot;s/categories:/categories:\\n  -/g&quot;</span><br></pre></td></tr></table></figure>

<h2 id="统计当前所有的标签"><a href="#统计当前所有的标签" class="headerlink" title="统计当前所有的标签"></a>统计当前所有的标签</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grep &quot;tags&quot; ../_posts/ -rn -A 6 | grep &quot; - &quot; | awk &#x27;&#123;print $3&#125;&#x27; | sort -u</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>TestDisk</title>
    <url>/post/6126d557.html</url>
    <content><![CDATA[<p><code>TestDisk</code>是一款强大的免费数据恢复软件! 早期主要是设计用来在使用有缺陷的软件，病毒或人为误操作（如不小心删除分区表）导致的分区丢失后，帮助用户恢复丢失分区，或修复不能启动的磁盘。 用Testdisk来恢复分区表非常简单。</p>
<blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cuY2dzZWN1cml0eS5vcmcvd2lraS9UZXN0RGlza19DTg==">https://www.cgsecurity.org/wiki/TestDisk_CN<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<span id="more"></span>

<p>TestDisk支持以下功能:</p>
<ul>
<li>修复分区表, 恢复已删除分区</li>
<li>用FAT32备份表恢复启动扇区</li>
<li>重建FAT12&#x2F;FAT16&#x2F;FAT32启动扇区</li>
<li>修复FAT表</li>
<li>重建NTFS启动扇区</li>
<li>用备份表恢复NTFS启动扇区</li>
<li>用MFT镜像表(MFT Mirror)修复MFT表</li>
<li>查找ext2&#x2F;ext3&#x2F;ext4备份的SuperBlock</li>
<li>从FAT,NTFS及ext2文件系统恢复删除文件</li>
<li>从已删除的FAT,NTFS及ext2&#x2F;ext3&#x2F;ext4分区复制文件.</li>
</ul>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>通过dd误将磁盘分区表删除后，使用TestDisk进行了恢复，数据均正常。注意我的数据恢复是在知道误删除后，直接进行恢复，如果是重启了就会使系统无法启动，这个工具可能就无法用了。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vZmluZHVtYXJzL3AvNzE5MjI5MS5odG1s">TestDisk 数据恢复 重建分区表恢复文件-恢复diskpart clean <i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>TestDisk</tag>
        <tag>分区</tag>
        <tag>磁盘恢复</tag>
      </tags>
  </entry>
  <entry>
    <title>Travis CI的部署与发布</title>
    <url>/post/768dddf0.html</url>
    <content><![CDATA[<p>由于国内对一些资源的限制，在无法翻墙的情况下，借助于Travis CI的部署发布功能进行代码的编译，将最终的二进制文件发布后下载使用。<br>比如编译<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2Fpc291YXJkL2xpYndlYnJ0Yw==">libwebrtc<i class="fa fa-external-link-alt"></i></span>，生产静态库和一些头文件，供本地开发使用。</p>
<span id="more"></span>



<h2 id="The-Job-Lifecycle"><a href="#The-Job-Lifecycle" class="headerlink" title="The Job Lifecycle #"></a>The Job Lifecycle <span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnRyYXZpcy1jaS5jb20vdXNlci9qb2ItbGlmZWN5Y2xlI3RoZS1qb2ItbGlmZWN5Y2xl">#<i class="fa fa-external-link-alt"></i></span></h2><p>Each <em>job</em> is a sequence of <span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnRyYXZpcy1jaS5jb20vZm9yLWJlZ2lubmVycy8jYnVpbGRzLWpvYnMtc3RhZ2VzLWFuZC1waGFzZXM=">phases<i class="fa fa-external-link-alt"></i></span>. The <em>main phases</em> are:</p>
<ol>
<li><code>install</code> - install any dependencies required</li>
<li><code>script</code> - run the build script</li>
</ol>
<p>Travis CI can run custom commands in the phases:</p>
<ol>
<li><code>before_install</code> - before the install phase</li>
<li><code>before_script</code> - before the script phase</li>
<li><code>after_script</code> - after the script phase.</li>
<li><code>after_success</code> - when the build <em>succeeds</em> (e.g. building documentation), the result is in <code>TRAVIS_TEST_RESULT</code> environment variable</li>
<li><code>after_failure</code> - when the build <em>fails</em> (e.g. uploading log files), the result is in <code>TRAVIS_TEST_RESULT</code> environment variable</li>
</ol>
<p>There are three optional <em>deployment phases</em>.</p>
<p>The complete sequence of phases of a job is the lifecycle. The steps are:</p>
<ol>
<li>OPTIONAL Install <a href="https://docs.travis-ci.com/user/installing-dependencies/#installing-packages-with-the-apt-addon"><code>apt addons</code></a></li>
<li>OPTIONAL Install <a href="https://docs.travis-ci.com/user/caching"><code>cache components</code></a></li>
<li><code>before_install</code></li>
<li><code>install</code></li>
<li><code>before_script</code></li>
<li><code>script</code></li>
<li>OPTIONAL <code>before_cache</code> (if and only if caching is effective)</li>
<li><code>after_success</code> or <code>after_failure</code></li>
<li>OPTIONAL <code>before_deploy</code> (if and only if deployment is active)</li>
<li>OPTIONAL <code>deploy</code></li>
<li>OPTIONAL <code>after_deploy</code> (if and only if deployment is active)</li>
<li><code>after_script</code></li>
</ol>
<blockquote>
<p>A <em>build</em> can be composed of many jobs.</p>
</blockquote>
<h2 id="Travis-CI关键字"><a href="#Travis-CI关键字" class="headerlink" title="Travis CI关键字"></a>Travis CI关键字</h2><table>
<thead>
<tr>
<th align="center">关键字</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>dist</code></td>
<td align="center">指定系统版本,dist: bionic(ubuntu18.04)</td>
</tr>
</tbody></table>
<h2 id="添加python"><a href="#添加python" class="headerlink" title="添加python"></a>添加python</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python:</span><br><span class="line">   - &quot;3.6&quot;</span><br></pre></td></tr></table></figure>

<h2 id="deploy"><a href="#deploy" class="headerlink" title="deploy"></a>deploy</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  provider: releases</span><br><span class="line">  api_key: $GITHUB_TOKEN</span><br><span class="line">  file_glob: true</span><br><span class="line">  file: &quot;$&#123;TRAVIS_ARTIFACTS&#125;&quot;</span><br><span class="line">  skip_cleanup: true</span><br><span class="line">  on:</span><br><span class="line">    tags: true</span><br><span class="line">    repo: Winddoing/libwebrtc</span><br></pre></td></tr></table></figure>
<blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL1dpbmRkb2luZy9saWJ3ZWJydGMvbXlkZXYvLnRyYXZpcy55bWw=">https://raw.githubusercontent.com/Winddoing/libwebrtc/mydev/.travis.yml<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<ul>
<li><code>GITHUB_TOKEN</code>: setting-&gt;Developer settings-&gt;Personal access tokens:Generate new token</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnRyYXZpcy1jaS5jb20vdXNlci90dXRvcmlhbC8=">Travis CI Tutorial<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>travis-ci</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title>ubuntu查询相关库的情况</title>
    <url>/post/31784.html</url>
    <content><![CDATA[<p>查询一个库的<code>位置</code></p>
<span id="more"></span>

<blockquote>
<p><strong>环境</strong>: Ubuntu 18.04.1 LTS</p>
<ul>
<li>测试库名: libmpfr</li>
</ul>
</blockquote>
<h2 id="库的相关描述"><a href="#库的相关描述" class="headerlink" title="库的相关描述"></a>库的相关描述</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$dpkg -l &quot;*库信息*&quot;</span><br></pre></td></tr></table></figure>
<p>示例:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$dpkg -l &quot;*libmpfr*&quot;</span><br><span class="line">Desired=Unknown/Install/Remove/Purge/Hold</span><br><span class="line">| Status=Not/Inst/Conf-files/Unpacked/halF-conf/Half-inst/trig-aWait/Trig-pend</span><br><span class="line">|/ Err?=(none)/Reinst-required (Status,Err: uppercase=bad)</span><br><span class="line">||/ Name                                     Version                   Architecture              Description</span><br><span class="line">+++-========================================-=========================-=========================-======================================================================================</span><br><span class="line">ii  libmpfr6:amd64                           4.0.1-1                   amd64                     multiple precision floating-point computation</span><br></pre></td></tr></table></figure>

<h2 id="库的位置"><a href="#库的位置" class="headerlink" title="库的位置"></a>库的位置</h2><p>查询<code>libmpfr</code>的路径</p>
<h3 id="直接查找"><a href="#直接查找" class="headerlink" title="直接查找"></a>直接查找</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ldconfig -p | grep &quot;库信息&quot;</span><br></pre></td></tr></table></figure>
<p>示例:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ldconfig -p | grep &quot;libmpfr&quot;</span><br><span class="line">	libmpfr.so.6 (libc6,x86-64) =&gt; /usr/lib/x86_64-linux-gnu/libmpfr.so.6</span><br></pre></td></tr></table></figure>
<h3 id="间接查找"><a href="#间接查找" class="headerlink" title="间接查找"></a>间接查找</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dpkg -L &quot;库名称&quot;</span><br></pre></td></tr></table></figure>
<p>示例:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$dpkg -L &quot;libmpfr6:amd64&quot;</span><br><span class="line">/.</span><br><span class="line">/usr</span><br><span class="line">/usr/lib</span><br><span class="line">/usr/lib/x86_64-linux-gnu</span><br><span class="line">/usr/lib/x86_64-linux-gnu/libmpfr.so.6.0.1</span><br><span class="line">/usr/share</span><br><span class="line">/usr/share/doc</span><br><span class="line">/usr/share/doc/libmpfr6</span><br><span class="line">/usr/share/doc/libmpfr6/AUTHORS</span><br><span class="line">/usr/share/doc/libmpfr6/BUGS</span><br><span class="line">/usr/share/doc/libmpfr6/NEWS.gz</span><br><span class="line">/usr/share/doc/libmpfr6/README</span><br><span class="line">/usr/share/doc/libmpfr6/TODO.gz</span><br><span class="line">/usr/share/doc/libmpfr6/changelog.Debian.gz</span><br><span class="line">/usr/share/doc/libmpfr6/copyright</span><br><span class="line">/usr/lib/x86_64-linux-gnu/libmpfr.so.6</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>库</tag>
      </tags>
  </entry>
  <entry>
    <title>WiFi配置——ubuntu20.04 server</title>
    <url>/post/9cb9cc51.html</url>
    <content><![CDATA[<p>前段时间发现之前给老家买的mini主机很久没用了，拿来加了个无线网卡和硬盘通过nextcloud搭建一个私人网盘备份一些文件，在家里也方便手机共享。在wifi的配置时踩过一些坑，在这里简单记录下。</p>
<span id="more"></span>

<p>在ubuntu18.04中就发现使用<code>netplan</code>进行网络配置，WiFi同样可以通过netplan的简单配置实现上网，不需要我们在配置wpa_supplicant</p>
<p>netplan配置文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat /etc/netplan/00-installer-config.yaml</span><br><span class="line"># This is the network config written by &#x27;subiquity&#x27;</span><br><span class="line">network:</span><br><span class="line">  version: 2</span><br><span class="line">  ethernets:</span><br><span class="line">    enp2s0:</span><br><span class="line">      dhcp4: true</span><br><span class="line">      dhcp6: true</span><br><span class="line">  wifis:</span><br><span class="line">    wlp3s0:</span><br><span class="line">      dhcp4: false</span><br><span class="line">      dhcp6: true</span><br><span class="line">      optional: true</span><br><span class="line">      addresses: [192.168.1.38/24]</span><br><span class="line">      gateway4: 192.168.1.1</span><br><span class="line">      nameservers:</span><br><span class="line">          addresses: [8.8.8.8]</span><br><span class="line">      access-points:</span><br><span class="line">          &quot;ChinaNet-xxx&quot;:</span><br><span class="line">              password: &quot;xxxxx&quot;</span><br></pre></td></tr></table></figure>
<p>常用的命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">netplan generate</span><br><span class="line">netplan apply</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li><code>generate</code>: 从<code>/etc/netplan/*.yaml</code>生成特定于后端的配置文件</li>
<li><code>apply</code>: 应用配置(以便生效),在每一次修改完配置文件后需要执行，使配置生效</li>
</ul>
</blockquote>
<p>配置完成执行以上两个命令后，系统可以正常上网，但是在系统重启后存在两个问题。</p>
<ol>
<li>系统重启时间过长，两分钟多</li>
<li>重启后，无线网卡可以正常配置IPv4地址，但是IPv6地址没有配置成功（nextcloud通过docker安装，局域网访问需要IPv6地址配置成功）</li>
</ol>
<h2 id="优化开机时间"><a href="#优化开机时间" class="headerlink" title="优化开机时间"></a>优化开机时间</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">systemd-analyze</span></span><br><span class="line">Startup finished in 2.582s (firmware) + 4.843s (loader) + 5.075s (kernel) + 2min 15.951s (userspace) = 2min 28.453s</span><br><span class="line">graphical.target reached after 2min 14.410s in userspace</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">systemd-analyze blame</span></span><br><span class="line">2min 213ms systemd-networkd-wait-online.service</span><br><span class="line">    7.145s docker.service</span><br></pre></td></tr></table></figure>
<p>耗时最多的是<code>systemd-networkd-wait-online.service</code>服务其超时后才退出，主要用于检查网络配置是否成功，便于后面其他依赖于网络的服务启动，直接禁掉最省事，网络连接也不会受影响。但是<code>netdata</code>的服务启动会受影响导致失败，因此不能直接mark掉。</p>
<p>通过对系统log的分析这里主要原因是，检查网络连接失败最后导致的超时，网络链接失败是由于该主机有两张网卡（有线网卡，无线网卡），但是我没有使用，导致检查超时。由于后期可能会用到有线网卡，不打算有线网卡的检查过滤掉，同时为了方便只能牺牲一些开机时间，将该服务的超时时间重新配置为30s</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Service]</span><br><span class="line">TimeoutStartSec=30</span><br></pre></td></tr></table></figure>
<blockquote>
<p>file: &#x2F;lib&#x2F;systemd&#x2F;system&#x2F;systemd-networkd-wait-online.service</p>
</blockquote>
<h2 id="配置IPv6网络"><a href="#配置IPv6网络" class="headerlink" title="配置IPv6网络"></a>配置IPv6网络</h2><p>通过系统启动日志，发现网络配置存在异常，可能是导致IPv6网络配置失败的原因</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">May 24 22:36:39 ubuntu NetworkManager[874]: &lt;warn&gt;  [1590330999.7653] device (wlp3s0): re-acquiring supplicant interface (#1).</span><br><span class="line">May 24 22:36:39 ubuntu systemd-networkd[816]: wlp3s0: Lost carrier</span><br><span class="line">May 24 22:36:39 ubuntu systemd-networkd[816]: wlp3s0: Gained carrier</span><br><span class="line">May 24 22:36:39 ubuntu systemd[1]: NetworkManager-dispatcher.service: Succeeded.</span><br><span class="line">May 24 22:36:39 ubuntu wpa_supplicant[897]: ctrl_iface exists and seems to be in use - cannot override it</span><br><span class="line">May 24 22:36:39 ubuntu wpa_supplicant[897]: Delete &#x27;/run/wpa_supplicant/wlp3s0&#x27; manually if it is not used anymore</span><br><span class="line">May 24 22:36:39 ubuntu wpa_supplicant[897]: Failed to initialize control interface &#x27;/run/wpa_supplicant&#x27;.</span><br><span class="line">                                            You may have another wpa_supplicant process already running or the file was</span><br><span class="line">                                            left by an unclean termination of wpa_supplicant in which case you will need</span><br><span class="line">                                            to manually remove this file before starting wpa_supplicant again.</span><br><span class="line">May 24 22:36:39 ubuntu systemd-networkd[816]: wlp3s0: Lost carrier</span><br><span class="line">May 24 22:36:39 ubuntu systemd-networkd[816]: wlp3s0: Gained carrier</span><br><span class="line">May 24 22:36:39 ubuntu wpa_supplicant[897]: nl80211: deinit ifname=wlp3s0 disabled_11b_rates=0</span><br><span class="line">May 24 22:36:39 ubuntu NetworkManager[874]: &lt;error&gt; [1590330999.9224] sup-iface[0x558f502f31f0,wlp3s0]: error adding interface: wpa_supplicant</span><br><span class="line">couldn&#x27;t grab this interface.</span><br><span class="line">May 24 22:36:39 ubuntu NetworkManager[874]: &lt;info&gt;  [1590330999.9225] device (wlp3s0): supplicant interface state: starting -&gt; down</span><br><span class="line">May 24 22:36:42 ubuntu snapd[891]: stateengine.go:150: state ensure error: decode new commands catalog: net/http: request canceled (Client.</span><br><span class="line">Timeout exceeded while reading body)</span><br><span class="line">May 24 22:36:49 ubuntu NetworkManager[874]: &lt;warn&gt;  [1590331009.7629] device (wlp3s0): re-acquiring supplicant interface (#2).</span><br><span class="line">May 24 22:36:49 ubuntu systemd-networkd[816]: wlp3s0: Lost carrier</span><br><span class="line">May 24 22:36:49 ubuntu systemd-networkd[816]: wlp3s0: Gained carrier</span><br><span class="line">May 24 22:36:49 ubuntu wpa_supplicant[897]: ctrl_iface exists and seems to be in use - cannot override it</span><br><span class="line">May 24 22:36:49 ubuntu wpa_supplicant[897]: Delete &#x27;/run/wpa_supplicant/wlp3s0&#x27; manually if it is not used anymore</span><br><span class="line">May 24 22:36:49 ubuntu wpa_supplicant[897]: Failed to initialize control interface &#x27;/run/wpa_supplicant&#x27;.</span><br><span class="line">                                            You may have another wpa_supplicant process already running or the file was</span><br><span class="line">                                            left by an unclean termination of wpa_supplicant in which case you will need</span><br><span class="line">                                            to manually remove this file before starting wpa_supplicant again.</span><br><span class="line">May 24 22:36:49 ubuntu systemd-networkd[816]: wlp3s0: Lost carrier</span><br><span class="line">May 24 22:36:49 ubuntu systemd-networkd[816]: wlp3s0: Gained carrier</span><br></pre></td></tr></table></figure>

<p>在系统的启动日志里，WiFi的配置被进行了两次，在第一次配置中日志显示ipv6地址获取成功，可能是第二次失败导致ipv6地址无法获取。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">May 26 23:00:43 ubuntu wpa_supplicant[663]: Successfully initialized wpa_supplicant</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">May 26 23:00:48 ubuntu wpa_supplicant[1002]: Successfully initialized wpa_supplicant</span><br></pre></td></tr></table></figure>

<p>在这里无线网络被配置两次是由于系统启动时两个网络配置的服务（<code>NetworkManager.service</code>，<code>network-manager.service</code>）都被启动了，我们禁掉<code>NetworkManager.service</code>服务重启后网络配置正常。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo systemctl disable NetworkManager.service</span><br></pre></td></tr></table></figure>

<h2 id="netplan的配置"><a href="#netplan的配置" class="headerlink" title="netplan的配置"></a>netplan的配置</h2><blockquote>
<p><code>NetworkManager</code>主要用于在桌面系统上管理网络设备。如果您使用<code>NetworkManager</code>作为网络设备管理的系统守护程序，将会使用 NetworkManager 的图形程序来管理网络接口。</p>
<ul>
<li><a href="https://winddoing.github.io/post/18692.html">网络配置</a></li>
</ul>
</blockquote>
<p>在netplan的配置文件中有一个<code>renderer</code>字段将其指定为<code>networkd</code>，或许也可以解决上面的问题，没有进行验证，不过netplan手册说其是默认值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">renderer (scalar)</span><br><span class="line">       Use  the  given  networking backend for this definition.  Currently supported are networkd and NetworkManager.  This property can be</span><br><span class="line">       specified globally in networks:, for a device type (in e.  g.  ethernets:) or for a particular device definition.  Default  is  net‐</span><br><span class="line">       workd.</span><br><span class="line"></span><br><span class="line">       The renderer property has one additional acceptable value for vlan objects (i.  e.  defined in vlans:): sriov.  If a vlan is defined</span><br><span class="line">       with the sriov renderer for an SR-IOV Virtual Function interface, this causes netplan to set up  a  hardware  VLAN  filter  for  it.</span><br><span class="line">       There can be only one defined per VF.</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly94emNsaXAuY24vdGVjaC1yZWNvcmRzL3N5c3RlbWQtbmV0d29ya2Qtd2FpdC1vbmxpbmUtc3R1Y2stYm9vdC11YnVudHUtMTgwNC8=">systemd-networkd-wait-online拖慢Ubuntu 18.04云主机开机的排查手记<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RvdXNoaS9hcnRpY2xlL2RldGFpbHMvMTA0MDYyNDgy">ubuntu命令行配置wifi，不使用NetworkManager和netplan<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>wifi</tag>
        <tag>server</tag>
      </tags>
  </entry>
  <entry>
    <title>交换机配置</title>
    <url>/post/e0896859.html</url>
    <content><![CDATA[<p>交换机配置相关信息：</p>
<span id="more"></span>



<h1 id="二层交换机"><a href="#二层交换机" class="headerlink" title="二层交换机"></a>二层交换机</h1><p>二层交换机属<code>数据链路层</code>设备，可以识别数据包中的MAC地址信息，根据MAC地址进行转发，并将这些<code>MAC地址</code>与对应的<code>端口</code>记录在自己内部的一个地址表中。</p>
<h2 id="二层接口模式"><a href="#二层接口模式" class="headerlink" title="二层接口模式"></a>二层接口模式</h2><p>交换机每一个端口可以配置为以下二层模式</p>
<ul>
<li>Access 模式:只接收没有 VLAN 标记的数据包,带有 VLAN 标记的数据包会被丢弃。接收到的数据包会自动标记为端口的 VLAN 信息,只能属于1个VLAN。通常用于服务器和交换机之间的链接。</li>
<li>Trunk 模式:接收和发送带有 VLAN 标记的数据包,没有 VLAN 标记的数据包将被丢弃。这个模式可以配置多个 VLAN ID。</li>
<li>Hybrid 模式:带有 VLAN 标记和没有 VLAN 标记的数据包均可以被接收, 同时传送多个VLAN的包</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; show interfaces switchport</span><br><span class="line"></span><br><span class="line">---------------------------------------------------------------------------------------</span><br><span class="line">Interface         Mode           Access vlan          Allowed vlans</span><br><span class="line">---------------------------------------------------------------------------------------</span><br><span class="line">Eth1/1            access         1</span><br><span class="line">Eth1/2            access         1</span><br><span class="line">Eth1/3            access         1</span><br><span class="line">Eth1/4            access         1</span><br><span class="line">Eth1/5            access         1</span><br><span class="line">Eth1/6            access         1</span><br><span class="line">Eth1/7            access         1</span><br><span class="line">Eth1/8            access         1</span><br><span class="line">Eth1/9            access         1</span><br><span class="line">Eth1/10           access         1</span><br><span class="line">Eth1/11           access         1</span><br></pre></td></tr></table></figure>



<h1 id="三层交换机"><a href="#三层交换机" class="headerlink" title="三层交换机"></a>三层交换机</h1><p>三层交换技术就是将路由技术与交换技术合二为一的技术。在对第一个数据流进行路由后，它将会产生一个<code>MAC地址</code>与<code>IP地址</code>的映射表，当同样的数据流再次通过时，将根据此表直接从二层通过而不是再次路由，从而消除了路由器进行路由选择而造成网络的延迟，提高了数据包转发的效率。</p>
<h1 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h1><h2 id="端口速度配置"><a href="#端口速度配置" class="headerlink" title="端口速度配置"></a>端口速度配置</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">master] &gt; enable</span><br><span class="line">master] # configure terminal</span><br><span class="line">master] (config) # interface ethernet 1/6 speed 10G force</span><br></pre></td></tr></table></figure>
<blockquote>
<p>配置第6个端口的速率为10G</p>
</blockquote>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>交换机</tag>
      </tags>
  </entry>
  <entry>
    <title>内网穿透——cpolar</title>
    <url>/post/28389.html</url>
    <content><![CDATA[<p><code>cpolar</code>工具从家庭或本地网络外部访问内网设备，比如树莓派、群晖等。</p>
<span id="more"></span>


<h2 id="cpolar"><a href="#cpolar" class="headerlink" title="cpolar"></a>cpolar</h2><p>cpolar是一种安全的隧道服务，可以在任何地方在线提供您的设备。 隧道是一种在两台计算机之间通过互联网等公共网络建立专线的方法。 当您在两台计算机之间设置隧道时，它应该是安全且私有的，并且能够通过网络障碍，如端口阻塞路由器和防火墙。 这是一个方便的服务，允许您在安全的无线网络或防火墙后面将请求从公共互联网连接到本地计算机。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://www.cpolar.com/static/downloads/cpolar-stable-linux-amd64.zip</span><br><span class="line"></span><br><span class="line">unzip cpolar-stable-linux-amd64.zip</span><br></pre></td></tr></table></figure>

<h2 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h2><p>在<span class="exturl" data-url="aHR0cHM6Ly9kYXNoYm9hcmQuY3BvbGFyLmNvbS8=">cpolar官网<i class="fa fa-external-link-alt"></i></span>注册账户，以获取authtoken密钥。使用免费版本，您每次希望建立远程连接并与远程用户共享地址时，都必须从本地生成主机地址。</p>
<ul>
<li>本地添加token认证</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./cpolar authtoken  &lt;yourauthtoken&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>执行一次认证，它就会存储在配置文件中<code>/home/user/.cpolar/cpolar.yml</code></p>
</blockquote>
<h2 id="SSH穿透"><a href="#SSH穿透" class="headerlink" title="SSH穿透"></a>SSH穿透</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./cpolar tcp 22</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cpolar by @bestexpresser</span><br><span class="line"></span><br><span class="line">Tunnel Status                 online</span><br><span class="line">Account                       xxx (Plan: Free)</span><br><span class="line">Version                       2.62/2.58</span><br><span class="line">Web Interface                 127.0.0.1:4040</span><br><span class="line">Forwarding                    tcp://1.tcp.cpolar.io:1111 -&gt; tcp://127.0.0.1:22</span><br><span class="line"># Conn                        0</span><br><span class="line">Avg Conn Time                 0.00ms</span><br></pre></td></tr></table></figure>

<h3 id="远程连接访问"><a href="#远程连接访问" class="headerlink" title="远程连接访问"></a>远程连接访问</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh -p &lt;cpolar公网端口号&gt;  &lt;用户名@1.tcp.cpolar.io&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh -p 1111 username@1.tcp.cpolar.io</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>cpolar</tag>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>磁盘分区表恢复</title>
    <url>/post/e64328de.html</url>
    <content><![CDATA[<p>最近在进行SD卡的分区与格式化时，为了方便将分区的几步操作实现脚本统一操作。最开始需要对SD的己有分区进行删除，直接通过dd进行操作<code>sudo dd if=/dev/zero of=/dev/sdb bs=1K count=1 seek=0</code>,在最初的脚本中将设备路径<code>/dev/sdb</code>直接写死，没有使用统一变量，导致在更换PC后进行分区时，误将硬盘（&#x2F;dev&#x2F;sdb）上的分区直接删除，实际SD设备路径是&#x2F;dev&#x2F;sdc。</p>
<p>经过网上查询可以通过<code>TestDisk</code>工具进行恢复，注意如果误删的是当前系统分区表，最好不要重启系统，将分区表恢复后，进行重启操作。</p>
<p>我是在发现脚本错误后，没有进行系统重启的情况下，确定已误删除磁盘分区表后，通过<code>TestDisk</code>将分区表进行恢复的。</p>
<span id="more"></span>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install testdisk</span><br></pre></td></tr></table></figure>

<p>具体的操作可以根据软件提示或者网上教程进行，恢复分区表比恢复磁盘数据容易。</p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>分区</tag>
      </tags>
  </entry>
  <entry>
    <title>系统启动引导修复</title>
    <url>/post/15947.html</url>
    <content><![CDATA[<p>在对磁盘分区进行增删以后导致整个系统的磁盘序号错误，会造成系统无法正常启动的现象：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">error: unknown filesystem</span><br><span class="line">Entering rescue mode ...</span><br><span class="line">grub rescue&gt; _</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>ls</code>可以看到磁盘分区</p>
</blockquote>
<span id="more"></span>

<h2 id="grub-rescue修复"><a href="#grub-rescue修复" class="headerlink" title="grub rescue修复"></a>grub rescue修复</h2><p>命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">grub rescue&gt;ls</span><br><span class="line">grub rescue&gt;set</span><br></pre></td></tr></table></figure>

<p>查找ubuntu的boot分区所在磁盘</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">grub rescue&gt;ls (hd0,msdos1)</span><br></pre></td></tr></table></figure>

<p>如果</p>
<h2 id="ubuntu18-04引导修复"><a href="#ubuntu18-04引导修复" class="headerlink" title="ubuntu18.04引导修复"></a>ubuntu18.04引导修复</h2><p>修复工具：<code>boot-repair</code></p>
<p>通过ubuntu的U盘安装进入试用模式，并进行联网</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo add-apt-repository ppa:yannubuntu/boot-repair</span><br><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get install -y boot-repair</span><br><span class="line">boot-repair</span><br></pre></td></tr></table></figure>
<p>根据提示选择yes，直到修复成功。</p>
<h2 id="window引导修复"><a href="#window引导修复" class="headerlink" title="window引导修复"></a>window引导修复</h2><p>通过window PE进行一键修复</p>
<p>修复工具：<code>easyBCD</code></p>
<blockquote>
<p>无法修复ubuntu18.04的引导</p>
</blockquote>
<h2 id="ubuntu-终端乱码"><a href="#ubuntu-终端乱码" class="headerlink" title="ubuntu 终端乱码"></a>ubuntu 终端乱码</h2><blockquote>
<p>改成全英文环境来解决乱码</p>
</blockquote>
<p>在<code>/var/lib/locales/supported.d/en</code>中添加：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">en_US.UTF-8 UTF-8</span><br></pre></td></tr></table></figure>

<p>保存，并执行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo locale-gen</span><br></pre></td></tr></table></figure>

<p>修改<code>/etc/default/locale</code>中的<code>LANG</code>和<code>LANGUAGE</code>，并重启系统</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LANG=&quot;en_US.UTF-8&quot;</span><br><span class="line">LANGUAGE=&quot;en_US:en&quot;</span><br></pre></td></tr></table></figure>



<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vbWVuZ2ZhbnJvbmcvcC8zNzUxMTg1Lmh0bWw=">“error : unknown filesystem”的解决的方法<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>引导</tag>
      </tags>
  </entry>
  <entry>
    <title>翻译工具——GoldenDict</title>
    <url>/post/eba28245.html</url>
    <content><![CDATA[<p><span class="exturl" data-url="aHR0cDovL3d3dy5nb2xkZW5kaWN0Lm9yZy8=">GoldenDict<i class="fa fa-external-link-alt"></i></span>翻译软件可以划词翻译，并且可以跨软件，比有道词典显示速度快。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install goldendict</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="配置中文语言"><a href="#配置中文语言" class="headerlink" title="配置中文语言"></a>配置中文语言</h2><p>打开GoldenDict，【编辑】- 【首选项】-【界面语言】</p>
<p>修改完语言后，必须重启才能生效。</p>
<h2 id="添加谷歌翻译"><a href="#添加谷歌翻译" class="headerlink" title="添加谷歌翻译"></a>添加谷歌翻译</h2><h3 id="安装translate-shell"><a href="#安装translate-shell" class="headerlink" title="安装translate-shell"></a>安装translate-shell</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get install translate-shell</span><br></pre></td></tr></table></figure>

<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>打开GoldenDict，【编辑】-【词典】-【词典来源】-【程序】，点击【添加】，勾上【已启用】，填写【类型】和【名称】，在【命令行】中输入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">trans -e google -s auto -t zh-CN -show-original y -show-original-phonetics n -show-translation y -no-ansi -show-translation-phonetics n -show-prompt-message n -show-languages y -show-original-dictionary n -show-dictionary n -show-alternatives n “%GDWORD%”</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">trans -e google -s auto -t zh-CN -show-original y -show-original-phonetics y -show-translation y -no-ansi -show-translation-phonetics n -show-prompt-message n -show-languages y -show-original-dictionary n -show-dictionary y -show-alternatives n &quot;%GDWORD%&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>类型</code>: 纯文本</li>
<li><code>名称</code>: Google (可以随意填写)</li>
</ul>
<h2 id="屏幕取词"><a href="#屏幕取词" class="headerlink" title="屏幕取词"></a>屏幕取词</h2><p>配置快捷键<code>Ctrl+Alt</code>，只有同时按下是才会取词翻译。</p>
<p>【编辑】-【首选项】-【屏幕取词】</p>
<p>关闭翻译剪切板单词，防止在多次<code>Ctrl+c</code>时误触发。</p>
<p>【编辑】-【首选项】-【热键】</p>
<h2 id="添加字典"><a href="#添加字典" class="headerlink" title="添加字典"></a>添加字典</h2><p>下载地址： <span class="exturl" data-url="aHR0cDovL2Rvd25sb2FkLmh1emhlbmcub3JnL3poX0NOLw==">http://download.huzheng.org/zh_CN/<i class="fa fa-external-link-alt"></i></span></p>
<ul>
<li><span class="exturl" data-url="aHR0cDovL2Rvd25sb2FkLmh1emhlbmcub3JnL3poX0NOL3N0YXJkaWN0LWxhbmdkYW8tY2UtZ2ItMi40LjIudGFyLmJ6Mg==">http://download.huzheng.org/zh_CN/stardict-langdao-ce-gb-2.4.2.tar.bz2<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL2Rvd25sb2FkLmh1emhlbmcub3JnL3poX0NOL3N0YXJkaWN0LWxhbmdkYW8tZWMtZ2ItMi40LjIudGFyLmJ6Mg==">http://download.huzheng.org/zh_CN/stardict-langdao-ec-gb-2.4.2.tar.bz2<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL2Rvd25sb2FkLmh1emhlbmcub3JnL3poX0NOL3N0YXJkaWN0LW94Zm9yZC1nYi0yLjQuMi50YXIuYnoy">http://download.huzheng.org/zh_CN/stardict-oxford-gb-2.4.2.tar.bz2<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL2Rvd25sb2FkLmh1emhlbmcub3JnL3poX0NOL3N0YXJkaWN0LWtkaWMtY29tcHV0ZXItZ2ItMi40LjIudGFyLmJ6Mg==">http://download.huzheng.org/zh_CN/stardict-kdic-computer-gb-2.4.2.tar.bz2<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>翻译</tag>
        <tag>GoldenDict</tag>
      </tags>
  </entry>
  <entry>
    <title>SElinux与文件属性权限</title>
    <url>/post/38ee39e7.html</url>
    <content><![CDATA[<p>文件属性与权限的相关记录：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@test ~]# ls -lsh /dir-path</span><br><span class="line">8.9M -rw-r--r--. 1 root root 8.9M 9月</span><br><span class="line"> 66M -rw-r--r--. 1 root root  66M 9月</span><br><span class="line">1.8M -rw-r--r--. 1 root root 1.8M 9月</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在文件的属性权限后面出现了一个小点<code>.</code>, 这是在SElinux开启的情况下创建的文件所有，表示文件带有“SELinux的安全上下文”。</p>
</blockquote>
<span id="more"></span>

<p>传统的Linux系统中，默认权限是对文件或目录的所有者、所属组和其他人的读、写和执行权限进行控制，这种控制方式称为<code>自主访问控制（DAC）</code>方式；而在 SELinux 中，采用的是<code>强制访问控制（MAC）</code>系统，也就是控制一个进程对具体文件系统上面的文件或目录是否拥有访问权限，而判断进程是否可以访问文件或目录的依据，取决于 SELinux 中设定的很多策略规则</p>
<ul>
<li>开启了SELinux功能的Linux系统就会有这个点。</li>
<li>这个点表示文件带有“SELinux的安全上下文”。</li>
<li>关闭SELinux，新创建的文件就不会再有这个点了。</li>
<li>但是，以前创建的文件本来有这个点的还会显示这个点（虽然SELinux不起作用了）。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ll</span></span><br><span class="line">-rwxr-xr--  root root    #没有selinux上下文，没有ACL</span><br><span class="line">-rwx--xr-x+ root root    #只有ACL，没有selinux上下文</span><br><span class="line">-rw-r--r--. root root    #只有selinux上下文，没有ACL</span><br><span class="line">-rwxrwxr--+ root root    #有selinux上下文，有ACL</span><br></pre></td></tr></table></figure>

<h2 id="关闭SElinux——永久"><a href="#关闭SElinux——永久" class="headerlink" title="关闭SElinux——永久"></a>关闭SElinux——永久</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vi /etc/sysconfig/selinux</span><br><span class="line">SELINUX=disabled</span><br></pre></td></tr></table></figure>
<h3 id="在线关闭selinux——临时"><a href="#在线关闭selinux——临时" class="headerlink" title="在线关闭selinux——临时"></a>在线关闭selinux——临时</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">setenforce 0</span><br></pre></td></tr></table></figure>

<h2 id="查看状态"><a href="#查看状态" class="headerlink" title="查看状态"></a>查看状态</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sestatus</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">getenforce</span><br></pre></td></tr></table></figure>
<p>SElinux的状态分为以下三种：</p>
<ul>
<li><code>Enforcing</code>    （1）   强制模式</li>
<li><code>Permissive</code>   （0）   警告模式<ul>
<li><code>Disabled</code>          关闭模式</li>
</ul>
</li>
</ul>
<h2 id="SELinux权限"><a href="#SELinux权限" class="headerlink" title="SELinux权限"></a>SELinux权限</h2><ul>
<li><code>ls -Z</code>: 可以查看文件所拥有的SELinux权限的具体信息</li>
<li><code>chcon</code>: 手动修改文件的SELinux安全上下文</li>
<li><code>restorecon</code>: 恢复为默认的SELinux权限类型</li>
<li><code>semanage</code>: 查询&#x2F;修改&#x2F;增加&#x2F;删除文件的默认SELinux权限类型</li>
</ul>
<h2 id="SELinux安全上下文"><a href="#SELinux安全上下文" class="headerlink" title="SELinux安全上下文"></a>SELinux安全上下文</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash"><span class="built_in">ls</span> -Zd tmp/</span></span><br><span class="line">drwxr-xr-x. root root unconfined_u:object_r:unlabeled_t:s0 tmp</span><br></pre></td></tr></table></figure>
<blockquote>
<p>目录</p>
</blockquote>
<p>安全上下文使用<code>:</code>分隔为5字段，只是最后一个“类别”字段是可选的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">system_u：object_r：httpd_sys_content_t：s0：[类别]</span><br><span class="line">#身份字段：角色：类型：灵敏度：[类别]</span><br></pre></td></tr></table></figure>
<ul>
<li><code>unconfined_u</code>: (身份字段)一个普通的标签，该标签表示不受SELinux的限制（没有约束）</li>
<li><code>object_r</code>:（角色字段）这里代表该数据目录（文件）</li>
<li><code>unlabeled_t</code>: （类型字段）无效的标签，该文件被创建是没有有效的SELinux上下文进行关联，因此在某些应用读写该文件时将无法操作。需要给其一个有效的<code>type</code>,一般与读写的应用类型一样</li>
<li><code>s0</code>:（灵敏度）</li>
</ul>
<h3 id="身份字段（user"><a href="#身份字段（user" class="headerlink" title="身份字段（user)"></a>身份字段（user)</h3><p>用于标识该数据被哪个身份所拥有，相当于权限中的用户身份。这个字段并没有特别的作用</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# seinfo -u</span><br><span class="line">Users：9</span><br><span class="line">sysadm_u</span><br><span class="line">system_u</span><br><span class="line">xguest_u</span><br><span class="line">root</span><br><span class="line">guest_u</span><br><span class="line">staff_u</span><br><span class="line">user_u</span><br><span class="line">unconfined_u</span><br><span class="line">git_shell_u</span><br></pre></td></tr></table></figure>
<h3 id="角色（role）"><a href="#角色（role）" class="headerlink" title="角色（role）"></a>角色（role）</h3><p>主要用来表示此数据是进程还是文件或目录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# seinfo -r</span><br><span class="line">Roles：12</span><br><span class="line">guest_r</span><br><span class="line">staff_r</span><br><span class="line">user_r</span><br><span class="line">git_shell_r</span><br><span class="line">logadm_r</span><br><span class="line">object_r</span><br><span class="line">sysadm_r</span><br><span class="line">system_r</span><br><span class="line">webadm_r</span><br><span class="line">xguest_r</span><br><span class="line">nx_server_r</span><br><span class="line">unconfined_r</span><br></pre></td></tr></table></figure>

<ul>
<li><code>object_r</code>：代表该数据是文件或目录，这里的<code>_r</code>代表 role。</li>
<li><code>system_r</code>：代表该数据是进程，这里的<code>_r</code>代表 role。</li>
</ul>
<h3 id="类型（type）"><a href="#类型（type）" class="headerlink" title="类型（type）"></a>类型（type）</h3><p>类型字段是安全上下文中最重要的字段，进程是否可以访问文件，主要就是看进程的安全上下文类型字段是否和文件的安全上下文类型字段相匹配，如果匹配则可以访问</p>
<blockquote>
<p><strong>注意</strong>:类型字段在文件或目录的安全上下文中被称作类型（type），但是在进程的安全上下文中被称作域（domain）。也就是说，在主体（Subject）的安全上下文中，这个字段被称为域；在目标（Object）的安全上下文中，这个字段被称为类型。域和类型需要匹配（进程的类型要和文件的类型相匹配），才能正确访问。</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# seinfo -t | more</span><br><span class="line">Types：3488</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">共有3488个类型</span></span><br><span class="line">bluetooth_conf_t</span><br><span class="line">cmirrord_exec_t</span><br><span class="line">foghorn_exec_t</span><br><span class="line">jacorb_port_t</span><br><span class="line">sosreport_t</span><br><span class="line">etc_runtime_t</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h3 id="灵敏度"><a href="#灵敏度" class="headerlink" title="灵敏度"></a>灵敏度</h3><p>灵敏度一般是用<code>s0</code>、<code>s1</code>、<code>s2</code>来命名的，数字代表灵敏度的分级。数值越大，代表灵敏度越高</p>
<h3 id="类别"><a href="#类别" class="headerlink" title="类别"></a>类别</h3><p>类别字段不是必须有的，所以我们使用 ls 和 ps 命令查询的时候并没有看到类别字段</p>
<h2 id="修改SELinux上下文——type"><a href="#修改SELinux上下文——type" class="headerlink" title="修改SELinux上下文——type"></a>修改SELinux上下文——type</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chcon -R -t public_content_t /var/ftp</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chcon -R -t bin_t tmp/</span><br></pre></td></tr></table></figure>

<h2 id="删除SELinux上下文"><a href="#删除SELinux上下文" class="headerlink" title="删除SELinux上下文"></a>删除SELinux上下文</h2><blockquote>
<p><code>setfacl -b</code> will remove the ACL on a file. <code>setfattr -x security.selinux</code> will remove the SELinux file context, but you will probably have to boot with SELinux completely disabled.</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">setfattr -x security.selinux tmp/test.txt</span><br></pre></td></tr></table></figure>

<p>批量处理：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find tmp/ -exec setfattr -h -x security.selinux &#123;&#125; \;</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vZGF2aWRzaGVuL3AvODE0NTk0Ni5odG1s">linux初学者-SElinux篇<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20veGlhb3lhbmdlci9wLzcyNjQxNTEuaHRtbA==">Linux文件权限属性后面有个点<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL2MuYmlhbmNoZW5nLm5ldC92aWV3LzExNDkuaHRtbA==">SELinux安全上下文查看方法（超详细）<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNTg0NDQxNTcvdW5jb25maW5lZC10LXZzLXVubGFiZWxlZC10LWluLXNlbGludXg=">unconfined_t vs unlabeled_t in SELinux<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9zdXBlcnVzZXIuY29tL3F1ZXN0aW9ucy8xOTE5MDMvaG93LWRvLWktcmVtb3ZlLWFueS1zZWxpbnV4LWNvbnRleHQtb3ItYWNs">How do I remove any SELinux context or ACL?<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>文件系统</category>
      </categories>
      <tags>
        <tag>权限</tag>
        <tag>selinux</tag>
      </tags>
  </entry>
  <entry>
    <title>文件系统性能测试--iozone</title>
    <url>/post/40023.html</url>
    <content><![CDATA[<h2 id="iozone"><a href="#iozone" class="headerlink" title="iozone"></a>iozone</h2><blockquote>
<p>一个文件系统性能评测工具，可以测试Read, write, re-read,re-write, read backwards, read strided, fread, fwrite, random read, pread, mmap, aio_read, aio_write 等不同模式下不同文件系统的读写性能</p>
</blockquote>
<p>官网： <span class="exturl" data-url="aHR0cDovL3d3dy5pb3pvbmUub3JnLw==">http://www.iozone.org<i class="fa fa-external-link-alt"></i></span></p>
<span id="more"></span>
<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><table>
<thead>
<tr>
<th align="center">参数</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">-a</td>
<td align="center">全自动模式测试。测试记录块大小从4k到16M，测试文件从64k到512M</td>
</tr>
<tr>
<td align="center">-A</td>
<td align="center">使用自动模式虽然测试比较全面，但是比较花时间。-a选项将在文件大于32MB时停止使用低于64k一下记录块，来节省时间。-A通知iozone不要节省时间，进行所有测试。注：在3.61版本以后不建议使用，用-az代替-aA</td>
</tr>
<tr>
<td align="center">-B</td>
<td align="center">使用mmap()。这将使用mmap()接口来创建并访问所有测试用的临时文件。一些应用程序倾向于将文件当作内存的一块来看待。这些应用程序对文件执行mmap()调用，然后就可以以读写内存的方式访问那个块来完成文件I&#x2F;O。</td>
</tr>
<tr>
<td align="center">-c</td>
<td align="center">计算时间将close()包括进来</td>
</tr>
<tr>
<td align="center">-C</td>
<td align="center">显示吞吐量测试中每个客户端的字节数。</td>
</tr>
<tr>
<td align="center">-D</td>
<td align="center">对mmap文件使用MSYNC(MS_ASYNC)。告诉操作系统在mmap空间的所有数据需要被异步的写到磁盘上。</td>
</tr>
<tr>
<td align="center">-e</td>
<td align="center">测试时间是包含flush(fsync, fflush)</td>
</tr>
<tr>
<td align="center">-f filename</td>
<td align="center">指定用来测试临时文件，在测试完成后将被自动删除</td>
</tr>
<tr>
<td align="center">-F filename filename …</td>
<td align="center">指定测试中每个临时文件名，文件名的数量应该和指定的进程或线程数相同</td>
</tr>
<tr>
<td align="center">-g #</td>
<td align="center">在自动模式下设置文件最大值，可以使用#k #m #g分别表示kb，mb，gb</td>
</tr>
<tr>
<td align="center">-G</td>
<td align="center">对mmap文件使用msync(MS_SYNC)。告诉操作系统在mmap空间的所有数据需要被同步的写到磁盘上</td>
</tr>
<tr>
<td align="center">-h</td>
<td align="center">显示帮助</td>
</tr>
<tr>
<td align="center">-i #</td>
<td align="center">指定运行于哪种模式测试。可以使用-i # -i # -i #进行多个测试</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">0&#x3D;write&#x2F;rewrite</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">1&#x3D;read&#x2F;re-read</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">2&#x3D;random read&#x2F;random write</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">3&#x3D;backwards read</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">4&#x3D;re-write-record</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">5&#x3D;stride-read</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">6&#x3D;fwirte&#x2F;re-fwrite</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">7&#x3D;fread&#x2F;re-fread</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">8&#x3D;random mix</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">9&#x3D;pwrite&#x2F;re-pwrite</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">10&#x3D;pread&#x2F;re-pread</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">11&#x3D;pwritev&#x2F;re-pwritev</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">12&#x3D;preadv&#x2F;re-preadv</td>
</tr>
<tr>
<td align="center">-I</td>
<td align="center">对所有文件操作使用DIRECT I&#x2F;O。通知文件系统所有操作跳过缓存直接在磁盘上操作</td>
</tr>
<tr>
<td align="center">-j #</td>
<td align="center">设置访问文件的跨度为(# * 块)。stride read测试将使用这个跨度来读块</td>
</tr>
<tr>
<td align="center">-J #（毫秒）</td>
<td align="center">在每个I&#x2F;O操作之前产生指定毫秒的计算延迟。看-X和-Y获取控制计算延迟的其他参数</td>
</tr>
<tr>
<td align="center">-l #</td>
<td align="center">设置程序最小进程数。在测试过程允许用户设置的最小进程或线程数。需要配合-u选项使用。</td>
</tr>
<tr>
<td align="center">-L #</td>
<td align="center">设置处理器交换信息的单位量为#（bytes）。可以加速测试。</td>
</tr>
<tr>
<td align="center">-m</td>
<td align="center">iozone将在内部使用多个缓存。一些程序反复复写一块缓存，还有就是设置多个缓存块。此参数将允许使用这两种模式。iozone默认行为是重复使用内部一个缓存。此选项将允许在内部使用多个缓存块。</td>
</tr>
<tr>
<td align="center">-M</td>
<td align="center">调用uname()，将返回字符串放在输出文件中</td>
</tr>
<tr>
<td align="center">-n #</td>
<td align="center">设置自动模式下测试文件的最小值</td>
</tr>
<tr>
<td align="center">-N</td>
<td align="center">报告结果以毫秒每操作的方式显示</td>
</tr>
<tr>
<td align="center">-o</td>
<td align="center">写方式是同步写到磁盘上</td>
</tr>
<tr>
<td align="center">-O</td>
<td align="center">报告结果以操作每秒方式显示</td>
</tr>
<tr>
<td align="center">-q #</td>
<td align="center">在自动模式下设置记录块的最大值，可以使用#k(kb)，#m(mb)，#g(gb)。使用-y可以设置最小值</td>
</tr>
<tr>
<td align="center">-r #</td>
<td align="center">设置记录块大小为#</td>
</tr>
<tr>
<td align="center">-R</td>
<td align="center">使用Excel显示结果</td>
</tr>
<tr>
<td align="center">-s #</td>
<td align="center">设置测试文件大小</td>
</tr>
<tr>
<td align="center">-S #</td>
<td align="center">设置处理器的缓存大小</td>
</tr>
<tr>
<td align="center">-t #</td>
<td align="center">设置测试程序的线程或进程数</td>
</tr>
<tr>
<td align="center">-T</td>
<td align="center">使用POSIX的pthreads进行测试</td>
</tr>
<tr>
<td align="center">-u #</td>
<td align="center">设置最大进程或线程数，需要配合-l参数使用</td>
</tr>
<tr>
<td align="center">-U mountpoint</td>
<td align="center">在测试开始之前，iozone将unmount和remount挂载点。这将保证测试中缓存不包含任何文件</td>
</tr>
<tr>
<td align="center">-w</td>
<td align="center">在测试结束后不要删除临时文件。临时文件将在测试过后保存下来</td>
</tr>
<tr>
<td align="center">-W</td>
<td align="center">在测试过程中，当读或写文件时锁住文件</td>
</tr>
<tr>
<td align="center">-y #</td>
<td align="center">设置记录块最小值</td>
</tr>
<tr>
<td align="center">-z</td>
<td align="center">同-a一起使用，进行全部测试</td>
</tr>
<tr>
<td align="center">-Z</td>
<td align="center">允许mmap I&#x2F;O和file I&#x2F;O混合使用</td>
</tr>
</tbody></table>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo iozone -ac -s 8m   -f /home/testfile -y 2k -q 8m</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Time Resolution = 0.000001 seconds.</span><br><span class="line">Processor cache size set to 1024 Kbytes.</span><br><span class="line">Processor cache line size set to 32 bytes.</span><br><span class="line">File stride size set to 17 * record size.</span><br><span class="line">                                                     random  random    bkwd   record   stride</span><br><span class="line">       KB  reclen   write rewrite    read    reread    read   write    read  rewrite     read   fwrite frewrite   fread  freread</span><br><span class="line">     8192       2  189862  415349  1181932  1608842 1018766  374677 1329412   398615   665257   405521   367288 1569381  1528607</span><br><span class="line">     8192       4  237746  686099  1981095  2178140 1788563  536369 1336133   765253  1662395   391698   586565 1920739  2217786</span><br><span class="line">     8192       8  312623  871304  1620222  1851298 2215927  607182 2392438   979445  1817225   853513   873808 2615731  2264859</span><br><span class="line">     8192      16  280834  625953  2536184  2567262 2224823 1134478 2546334  1416090  2339815   938923   890545 2510611  2251797</span><br><span class="line">     8192      32  395003 1122984  1941688  1715601 1975400  721755 2480882  1573550  1757908   940543  1122654 2917577  2592443</span><br><span class="line">     8192      64  270175 1053372  2642689  2850293 2632364 1407332 2715153  1819245  2919312  1094161  1165811 1840095  1886259</span><br><span class="line">     8192     128  275769 1149623  2585809  2727871 2409382 1451995 2636606  1789028  2325877  1041968  1090826 2615731  1923858</span><br><span class="line">     8192     256  291167 1144454  2486987  2536184 2369668 1446067 2202151  1263978  2343965  1137144  1136994 2354728  2517417</span><br><span class="line">     8192     512  349935 1193800  2327295  2420755 2422804 1362140 1923427  1698135  2658845  1083329  1143007 1855096  1833907</span><br><span class="line">     8192    1024  333752 1308403  2522962  2538433 2496020 1461568 2443132  1573550  2954201   901409  1139520 1943115  2304969</span><br><span class="line">     8192    2048  276766 1110176  2367709  2430860 2420755 1338162 1757548  1406583  1580571   805492  1024660 2241221  2357313</span><br><span class="line">     8192    4096  592891 1179538  2268747  2339337 2063424 1196419 1890618  1383531  1853795   204928  1006737 1808425  1798486</span><br><span class="line">     8192    8192  328823 1199761  2394606  2408707 2175244 1265747 2327926  1293333  2159657  1222513  1181607 2380009  2428798</span><br></pre></td></tr></table></figure>
<p>结果： 左边第一列是测试文件大小，第二列是记录块大小（单位是kb），以后每列就是测试模式（单位是kb&#x2F;s）</p>
<h3 id="测试项"><a href="#测试项" class="headerlink" title="测试项"></a>测试项</h3><table>
<thead>
<tr>
<th align="center">测试项</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Write</td>
<td align="center">测试向一个新文件写入的性能。当一个新文件被写入时，不仅仅是那些文件中的数据需要被存储，还包括那些用于定位数据存储在存储介质的具体位置的额外信息。这些额外信息被称作“元数据”。它包括目录信息，所分配的空间和一些与该文件有关但又并非该文件所含数据的其他数据。拜这些额外信息所赐，Write的性能通常会比Re-write的性能低。</td>
</tr>
<tr>
<td align="center">Re-write</td>
<td align="center">测试向一个已存在的文件写入的性能。当一个已存在的文件被写入时，所需工作量较少，因为此时元数据已经存在。Re-write的性能通常比Write的性能高。</td>
</tr>
<tr>
<td align="center">Read</td>
<td align="center">测试读一个已存在的文件的性能。</td>
</tr>
<tr>
<td align="center">Re-Read</td>
<td align="center">测试读一个最近读过的文件的性能。Re-Read性能会高些，因为操作系统通常会缓存最近读过的文件数据。这个缓存可以被用于读以提高性能。</td>
</tr>
<tr>
<td align="center">Random Read</td>
<td align="center">测试读一个文件中的随机偏移量的性能。许多因素可能影响这种情况下的系统性能，例如：操作系统缓存的大小，磁盘数量，寻道延迟和其他。</td>
</tr>
<tr>
<td align="center">Random Write</td>
<td align="center">测试写一个文件中的随机偏移量的性能。同样，许多因素可能影响这种情况下的系统性能，例如：操作系统缓存的大小，磁盘数量，寻道延迟和其他。</td>
</tr>
<tr>
<td align="center">Random Mix</td>
<td align="center">测试读写一个文件中的随机偏移量的性能。同样，许多因素可能影响这种情况下的系统性能，例如：操作系统缓存的大小，磁盘数量，寻道延迟和其他。这个测试只有在吞吐量测试模式下才能进行。每个线程&#x2F;进程运行读或写测试。这种分布式读&#x2F;写测试是基于round robin 模式的。最好使用多于一个线程&#x2F;进程执行此测试。</td>
</tr>
<tr>
<td align="center">Backwards Read</td>
<td align="center">测试使用倒序读一个文件的性能。这种读文件方法可能看起来很可笑，事实上，有些应用确实这么干。MSC Nastran是一个使用倒序读文件的应用程序的一个例子。它所读的文件都十分大（大小从G级别到T级别）。尽管许多操作系统使用一些特殊实现来优化顺序读文件的速度，很少有操作系统注意到并增强倒序读文件的性能。</td>
</tr>
<tr>
<td align="center">Record Rewrite</td>
<td align="center">测试写与覆盖写一个文件中的特定块的性能。这个块可能会发生一些很有趣的事。如果这个块足够小（比CPU数据缓存小），测出来的性能将会非常高。如果比CPU数据缓存大而比TLB小，测出来的是另一个阶段的性能。如果比此二者都大，但比操作系统缓存小，得到的性能又是一个阶段。若大到超过操作系统缓存，又是另一番结果。</td>
</tr>
<tr>
<td align="center">Strided Read</td>
<td align="center">测试跳跃读一个文件的性能。举例如下：在0偏移量处读4Kbytes，然后间隔200Kbytes,读4Kbytes，再间隔200Kbytes，如此反复。此时的模式是读4Kbytes，间隔200Kbytes并重复这个模式。这又是一个典型的应用行为，文件中使用了数据结构并且访问这个数据结构的特定区域的应用程序常常这样做。许多操作系统并没注意到这种行为或者针对这种类型的访问做一些优化。同样，这种访问行为也可能导致一些有趣的性能异常。一个例子是在一个数据片化的文件系统里，应用程序的跳跃导致某一个特定的磁盘成为性能瓶颈。</td>
</tr>
<tr>
<td align="center">Fwrite</td>
<td align="center">测试调用库函数fwrite()来写文件的性能。这是一个执行缓存与阻塞写操作的库例程。缓存在用户空间之内。如果一个应用程序想要写很小的传输块，fwrite()函数中的缓存与阻塞I&#x2F;O功能能通过减少实际操作系统调用并在操作系统调用时增加传输块的大小来增强应用程序的性能。这个测试是写一个新文件，所以元数据的写入也是要的。</td>
</tr>
<tr>
<td align="center">Frewrite</td>
<td align="center">测试调用库函数fwrite()来写文件的性能。这是一个执行缓存与阻塞写操作的库例程。缓存在用户空间之内。如果一个应用程序想要写很小的传输块，fwrite()函数中的缓存与阻塞I&#x2F;O功能能通过减少实际操作系统调用并在操作系统调用时增加传输块的大小来增强应用程序的性能。</td>
</tr>
</tbody></table>
<h2 id="导出Excel表格"><a href="#导出Excel表格" class="headerlink" title="导出Excel表格"></a>导出Excel表格</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">iozone -i 0 -i 1 -s 8m   -f /testfile -y 2k -q 8m -Rab /iozone_test.xls</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在嵌入式开发板上导出表格数据全为0，无法使用</p>
</blockquote>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./iozone -s 100M -ac -S 512k 2&gt;&amp;1 | tee test.log</span><br></pre></td></tr></table></figure>


<h3 id="只测试读写模式，测试文件4g"><a href="#只测试读写模式，测试文件4g" class="headerlink" title="只测试读写模式，测试文件4g"></a>只测试读写模式，测试文件4g</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">iozone -Rab -g 4g -i 0 -i 1  output.xls</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>文件系统</category>
      </categories>
      <tags>
        <tag>文件系统</tag>
        <tag>iozone</tag>
      </tags>
  </entry>
  <entry>
    <title>udev的使用</title>
    <url>/post/3820.html</url>
    <content><![CDATA[<p>udev版本：udev-167</p>
<p>udev 是 Linux2.6 内核里的一个功能，它替代了原来的 <code>devfs</code>，成为当前 Linux 默认的设备管理工具。udev 以<code>守护进程</code>的形式运行，通过侦听内核发出来的 uevent 来管理 &#x2F;dev目录下的设备文件。不像之前的设备管理工具，udev 在<code>用户空间 (user space)</code> 运行，而不在内核空间 (kernel space) 运行。</p>
<p>udev下载：<span class="exturl" data-url="aHR0cDovL3d3dy5rZXJuZWwub3JnL3B1Yi9saW51eC91dGlscy9rZXJuZWwvaG90cGx1Zy8=">http://www.kernel.org/pub/linux/utils/kernel/hotplug/<i class="fa fa-external-link-alt"></i></span></p>
<span id="more"></span>

<h2 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h2><p>我们都知道，所有的设备在 Linux 里都是以设备文件的形式存在。在早期的 Linux 版本中，&#x2F;dev目录包含了所有可能出现的设备的设备文件。很难想象 Linux 用户如何在这些大量的设备文件中找到匹配条件的设备文件。现在 udev 只为那些连接到 Linux 操作系统的设备产生设备文件。并且 udev 能通过定义一个 udev 规则 (rule) 来产生匹配设备属性的设备文件，这些设备属性可以是内核设备名称、总线路径、厂商名称、型号、序列号或者磁盘大小等等。</p>
<ul>
<li><code>动态管理</code>：当设备添加 &#x2F; 删除时，udev 的守护进程侦听来自内核的 <code>uevent</code>，以此添加或者删除 &#x2F;dev下的设备文件，所以 udev 只为已经连接的设备产生设备文件，而不会在 &#x2F;dev下产生大量虚无的设备文件, 同时根据udev的规则可以在添加&#x2F;删除时，执行脚本。</li>
<li><code>自定义命名规则</code>：通过 Linux 默认的规则文件，udev 在 &#x2F;dev&#x2F; 里为所有的设备定义了内核设备名称，比如 &#x2F;dev&#x2F;sda、&#x2F;dev&#x2F;hda、&#x2F;dev&#x2F;fd等等。由于 udev 是在用户空间 (user space) 运行，Linux 用户可以通过自定义的规则文件，灵活地产生标识性强的设备文件名，比如 &#x2F;dev&#x2F;boot_disk、&#x2F;dev&#x2F;root_disk、&#x2F;dev&#x2F;color_printer等等。</li>
<li><code>设定设备的权限和所有者/组</code>：udev 可以按一定的条件来设置设备文件的权限和设备文件所有者 &#x2F; 组。在不同的 udev 版本中，实现的方法不同，在“如何配置和使用 udev”中会详解。</li>
</ul>
<h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><p><img data-src="/images/udev/udev_work_flow.jpg" alt="udev工作流程"></p>
<h2 id="配置udev"><a href="#配置udev" class="headerlink" title="配置udev"></a>配置udev</h2><p>udev需要内核<code>sysfs</code>和<code>tmpfs</code>的支持，sysfs为udev提供<code>设备入口</code>和<code>uevent通道</code>，tmpfs为udev设备文件提供存放空间.</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="启动udev的守护进程"><a href="#启动udev的守护进程" class="headerlink" title="启动udev的守护进程"></a>启动udev的守护进程</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir -p /dev/.udev</span><br><span class="line">udevd --daemon</span><br><span class="line">udevadm trigger</span><br></pre></td></tr></table></figure>

<h3 id="配置文件及规则"><a href="#配置文件及规则" class="headerlink" title="配置文件及规则"></a>配置文件及规则</h3><ul>
<li>目录结构</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /etc/udev</span><br><span class="line"></span><br><span class="line">├── rules.d</span><br><span class="line">│   ├── 22-xxx.rules</span><br><span class="line">│   └── 99-fuse.rules</span><br><span class="line">└── udev.conf</span><br></pre></td></tr></table></figure>

<p>在规则文件里，除了以“#”开头的行（注释），所有的非空行都被视为一条规则，但是一条规则不能扩展到多行。规则都是由多个 键值对（key-value pairs）组成，并由逗号隔开，键值对可以分为 <code>条件匹配键值对</code>( 以下简称“匹配键 ”) 和 <code>赋值键值对</code>( 以下简称“赋值键 ”)，一条规则可以有多条匹配键和多条赋值键。匹配键是匹配一个设备属性的所有条件，当一个设备的属性匹配了该规则里所有的匹配键，就认为这条规则生效，然后按照赋值键的内容，执行该规则的赋值。下面是一个简单的规则：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">KERNEL==&quot;sda&quot;, NAME=&quot;my_root_disk&quot;, MODE=&quot;0660&quot;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>KERNEL</code>是匹配键，<code>NAME</code>和<code>MODE</code>是赋值键。这条规则的意思是：如果有一个设备的内核设备名称为 sda，则该条件生效，执行后面的赋值：在 &#x2F;dev下产生一个名为 my_root_disk的设备文件，并把设备文件的权限设为 0660。</p>
</blockquote>
<p>添加规则时，多从官方文档（<span class="exturl" data-url="aHR0cDovL3d3dy5yZWFjdGl2YXRlZC5uZXQvd3JpdGluZ191ZGV2X3J1bGVzLmh0bWw=">Writing udev rules<i class="fa fa-external-link-alt"></i></span>）获取信息</p>
<h4 id="规则操作符"><a href="#规则操作符" class="headerlink" title="规则操作符"></a>规则操作符</h4><ul>
<li>“&#x3D;&#x3D;”：比较键、值，若等于，则该条件满足；</li>
<li>“!&#x3D;”： 比较键、值，若不等于，则该条件满足；</li>
<li>“&#x3D;”： 对一个键赋值；</li>
<li>“+&#x3D;”：为一个表示多个条目的键赋值。</li>
<li>“:&#x3D;”：对一个键赋值，并拒绝之后所有对该键的改动。目的是防止后面的规则文件对该键赋值。</li>
</ul>
<h4 id="规则匹配键"><a href="#规则匹配键" class="headerlink" title="规则匹配键"></a>规则匹配键</h4><ul>
<li>ACTION： 事件 (uevent) 的行为，例如：add( 添加设备 )、remove( 删除设备 )。</li>
<li>KERNEL： 内核设备名称，例如：sda, cdrom。</li>
<li>DEVPATH：设备的 devpath 路径。</li>
<li>SUBSYSTEM： 设备的子系统名称，例如：sda 的子系统为 block。</li>
<li>BUS： 设备在 devpath 里的总线名称，例如：usb。</li>
<li>DRIVER： 设备在 devpath 里的设备驱动名称，例如：ide-cdrom。</li>
<li>ID： 设备在 devpath 里的识别号。</li>
<li>SYSFS{filename}： 设备的 devpath 路径下，设备的属性文件“filename”里的内容。</li>
</ul>
<h4 id="规则赋值键"><a href="#规则赋值键" class="headerlink" title="规则赋值键"></a>规则赋值键</h4><ul>
<li>NAME：在 &#x2F;dev下产生的设备文件名。只有第一次对某个设备的 NAME 的赋值行为生效，之后匹配的规则再对该设备的 NAME 赋值行为将被忽略。如果没有任何规则对设备的 NAME 赋值，udev 将使用内核设备名称来产生设备文件。</li>
<li>SYMLINK：为 &#x2F;dev&#x2F;下的设备文件产生符号链接。由于 udev 只能为某个设备产生一个设备文件，所以为了不覆盖系统默认的 udev 规则所产生的文件，推荐使用符号链接。</li>
<li>OWNER, GROUP, MODE：为设备设定权限。</li>
<li>ENV{key}：导入一个环境变量。</li>
</ul>
<h4 id="值可调用的替换操作符"><a href="#值可调用的替换操作符" class="headerlink" title="值可调用的替换操作符"></a>值可调用的替换操作符</h4><p>在键值对中的键和操作符都介绍完了，最后是值 (value)。Linux 用户可以随意地定制 udev 规则文件的值。例如：my_root_disk, my_printer。同时也可以引用下面的替换操作符：</p>
<ul>
<li>$kernel, %k：设备的内核设备名称，例如：sda、cdrom。</li>
<li>$number, %n：设备的内核号码，例如：sda3 的内核号码是 3。</li>
<li>$devpath, %p：设备的 devpath路径。</li>
<li>$id, %b：设备在 devpath里的 ID 号。</li>
<li>$sysfs{file}, %s{file}：设备的 sysfs里 file 的内容。其实就是设备的属性值。</li>
</ul>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><h4 id="hidraw"><a href="#hidraw" class="headerlink" title="hidraw"></a>hidraw</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ACTION!=&quot;add&quot;, GOTO=&quot;uibc_exit&quot;</span><br><span class="line">KERNEL==&quot;hidraw2&quot;, SUBSYSTEM==&quot;hidraw&quot;, RUN+=&quot;/etc/udev/xxx.sh&quot;</span><br><span class="line">LABEL=&quot;uibc_exit&quot;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>file: &#x2F;etc&#x2F;udev&#x2F;rules.d&#x2F;22-xxx.rules</p>
</blockquote>
<h4 id="SD"><a href="#SD" class="headerlink" title="SD"></a>SD</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">action!=&quot;add&quot;,goto=&quot;farsight&quot;</span><br><span class="line">kernel==&quot;mmcblk[0-9]p[0-9]&quot;,run+=&quot;/sbin/mount-sd.sh %k&quot;</span><br><span class="line">label=&quot;farsight&quot;</span><br></pre></td></tr></table></figure>

<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ul>
<li>在每条规则中，赋值的字符串必须使用<code>双引号</code>括起来。</li>
<li>设备添加&#x2F;删除后，触发uevent执行<code>RUN+</code>的脚本时，在该脚本中不能直接使用<code>echo</code>输出打印信息，应该导入终端的串口节点。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo &quot;print debug info ...&quot; &gt; /dev/ttyS000</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="制定-udev-规则和查询设备信息"><a href="#制定-udev-规则和查询设备信息" class="headerlink" title="制定 udev 规则和查询设备信息"></a>制定 udev 规则和查询设备信息</h2><blockquote>
<p>如何查找设备的信息 ( 属性 ) 来制定 udev 规则：</p>
</blockquote>
<h3 id="查询sysfs文件系统："><a href="#查询sysfs文件系统：" class="headerlink" title="查询sysfs文件系统："></a>查询sysfs文件系统：</h3><p>例如：设备 sda 的 SYSFS{size} 可以通过 cat &#x2F;sys&#x2F;block&#x2F;sda&#x2F;size得到；SYSFS{model} 信息可以通过 cat &#x2F;sys&#x2F;block&#x2F;sda&#x2F;device&#x2F;model得到。</p>
<h3 id="udevadm-info"><a href="#udevadm-info" class="headerlink" title="udevadm info"></a>udevadm info</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">udevadm info  --query=all --name=/dev/hidraw2</span><br></pre></td></tr></table></figure>

<p>设备信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># udevadm info  --query=all --name=/dev/hidraw2</span><br><span class="line">P: /devices/platform/soc/f9890000.ehci/usb1/1-1/1-1:1.2/0003:1C4D:0503.0003/hidraw/hidraw2</span><br><span class="line">N: hidraw2</span><br><span class="line">S: usb/by-devid/_/hidraw2</span><br><span class="line">E: UDEV_LOG=3</span><br><span class="line">E: DEVPATH=/devices/platform/soc/f9890000.ehci/usb1/1-1/1-1:1.2/0003:1C4D:0503.0003/hidraw/hidraw2</span><br><span class="line">E: MAJOR=251</span><br><span class="line">E: MINOR=2</span><br><span class="line">E: DEVNAME=/dev/hidraw2</span><br><span class="line">E: SUBSYSTEM=hidraw</span><br><span class="line">E: DEVLINKS=/dev/usb/by-devid/_/hidraw2</span><br></pre></td></tr></table></figure>

<h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><h3 id="查看udev是否处理内核的uevent事件"><a href="#查看udev是否处理内核的uevent事件" class="headerlink" title="查看udev是否处理内核的uevent事件"></a>查看udev是否处理内核的uevent事件</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">udevadm  monitor</span><br></pre></td></tr></table></figure>

<p>例如：U盘的插入&#x2F;拔出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># udevadm monitor</span><br><span class="line">monitor will print the received events for:</span><br><span class="line">UDEV - the event which udev sends out after rule processing</span><br><span class="line">KERNEL - the kernel uevent</span><br><span class="line"></span><br><span class="line">usb 1-1: new high-speed USB device number 4 using ehci-platform</span><br><span class="line">KERNEL[209.826989] add  usb-storage 1-1:1.0: USB Mass Storage device detected</span><br><span class="line">    /devices/platform/soscsi host0: usb-storage 1-1:1.0</span><br><span class="line">c/f9890000.ehci/usb1/1-1 (usb)</span><br><span class="line">KERNEL[209.827627] add      /devices/platform/soc/f9890000.ehci/usb1/1-1/1-1:1.0 (usb)</span><br><span class="line">UDEV  [209.834354] add      /devices/platform/soc/f9890000.ehci/usb1/1-1 (usb)</span><br><span class="line">...</span><br><span class="line">UDEV  [209.841660] add      /devices/platform/soc/f9890000.ehci/usb1/1-1/1-1:1.0/host0/scsi_host/host0 (scsi_host)</span><br><span class="line">scsi 0:0:0:0: Direct-Access     General  UDisk            5.00 PQ: 0 ANSI: 2</span><br><span class="line">KERNEL[210.848174] add      /devsd 0:0:0:0: [sda] 15728640 512-byte logical blocks: (8.05 GB/7.50 GiB)</span><br><span class="line">ices/platform/soc/f98900sd 0:0:0:0: [sda] Write Protect is off</span><br><span class="line">00.ehci/usb1/1-1/1-1:1.0sd 0:0:0:0: [sda] No Caching mode page found</span><br><span class="line">/host0/target0:0sd 0:0:0:0: [sda] Assuming drive cache: write through</span><br><span class="line">:0 (scsi)</span><br><span class="line">KERNEL[210.848626] add      /devices/platform/soc/f9890000.ehci/usb1/ sda: sda1 sda2</span><br><span class="line">1-1/1-1:1.0/host0/target0:0:0/0:0:0:0 (scsi)</span><br><span class="line">KERNEL[210.848995]sd 0:0:0:0: [sda] Attached SCSI removable disk</span><br><span class="line"> add      /devices/platform/soc/f9890000.ehci/usb1/1-1/1-1:1.0/host0/target0:0:0/0:0:0:0/scsi_disk/0:0:0:0 (scsi_disk)</span><br><span class="line">KERNEL[210.849804] add      /devices/platform/soc/f9890000.ehci/usb1/1-1/1-1:1.0/host0/target0:0:0/0:0:0:0/scsi_device/0:0:0:0 (scsi_device)</span><br><span class="line">UDEV  [210.858522] add      /devices/platform/soc/f9890000.ehci/usb1/1-1/1-1:1.0/host0/target0:0:0/0:0:0:0/scsi_device/0:0:0:0 (scsi_device)</span><br><span class="line">...</span><br><span class="line">dudisk1110 -&gt; /dev/sda</span><br><span class="line">udisk1110p1 -&gt; /dev/sda1</span><br><span class="line"></span><br><span class="line">usb usb1-port1: disabled by hub (EMI?), re-enabling...</span><br><span class="line">usb 1-1: USB disconnect, device number 4</span><br><span class="line">KERNEL[213.650748] remove   /devices/platform/soc/f9890000.ehci/usb1/1-1/1-1:1.0/host0/target0:0:0/0:0:0:0/bsg/0:0:0:0 (bsg)</span><br><span class="line">...</span><br><span class="line">UDEV  [213.652991] remove   /devices/platform/soc/f9890000.ehci/usb1/1-1/1-1:1.0/host0/target0:0:0/0:0:0:0/bsg/0:0:0:0 (bsg)</span><br><span class="line">KERNEL[213.653175] remove   /devices/virtual/bdi/8:0 (bdi)</span><br><span class="line">UDEV  [213.774157] remove   /devices/platform/soc/f9890000.ehci/usb1/1-1/1-1:1.0 (usb)</span><br></pre></td></tr></table></figure>

<h3 id="重启udev"><a href="#重启udev" class="headerlink" title="重启udev"></a>重启udev</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">udevadm trigger --type=devices --action=change</span><br></pre></td></tr></table></figure>

<h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><h3 id="udev-和-devfs-是什么关系"><a href="#udev-和-devfs-是什么关系" class="headerlink" title="udev 和 devfs 是什么关系"></a>udev 和 devfs 是什么关系</h3><p>udev 完全在用户态 (userspace) 工作，利用设备加入或移除时内核所发送的hotplug 事件 (event) 来工作。关于设备的详细信息是由内核输出 (export) 到位于 &#x2F;sys 的 sysfs 文件系统的。所有的设备命名策略、权限控制和事件处理都是在用户态下完成的。与此相反，devfs 是作为内核的一部分工作的。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><span class="exturl" data-url="aHR0cDovL3d3dy5yZWFjdGl2YXRlZC5uZXQvd3JpdGluZ191ZGV2X3J1bGVzLmh0bWw=">Writing udev rules<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuaWJtLmNvbS9kZXZlbG9wZXJ3b3Jrcy9jbi9saW51eC9sLWNuLXVkZXYvaW5kZXguaHRtbD9jYT1kcnMtY24tMDMwNA==">使用 udev 高效、动态地管理 Linux 设备文件<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL2Jsb2cuY2hpbmF1bml4Lm5ldC91aWQtMjY1MTQ4MTUtaWQtMzQ1MzIwOC5odG1s">udev使用方法（附实例）<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>文件系统</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>udev</tag>
      </tags>
  </entry>
  <entry>
    <title>时钟线中串联电阻的作用--阻抗匹配</title>
    <url>/post/20813.html</url>
    <content><![CDATA[<p>时钟线上接电阻，对整个电路的影响，和输出时钟的影响</p>
<blockquote>
<p>如果阻抗不匹配会有什么不良后果呢？如果不匹配，则会形成反射，能量传递不过去，降低效率；会在传输线上形成驻波（简单的理解，就是有些地方信号强，有些地方信号弱），导致传输线的有效功率容量降低；功率发射不出去，甚至会损坏发射设备。</p>
</blockquote>
<span id="more"></span>

<h2 id="信号线电阻串联应用"><a href="#信号线电阻串联应用" class="headerlink" title="信号线电阻串联应用"></a>信号线电阻串联应用</h2><p><code>高速信号线</code>中才考虑使用这样的电阻，在<code>低频信号线</code>，一般是直接连接；</p>
<p>作用：</p>
<blockquote>
<p>第一:<code>阻抗匹配</code>。因为信号源的阻抗很低，跟信号线之间阻抗不匹配，串上一个电阻后，可改善匹配情况，以减少反射，避免振荡等；</p>
</blockquote>
<blockquote>
<p>第二：可以<code>减少信号边沿的陡峭程度</code>，从而减少高频噪声以及过冲等，因为串联的电阻，跟信号线的分布电容以及负载的输入电容等形成一个<code>RC电路</code>，这样就会降低信号边沿的陡峭程度，如果一个信号的边沿非常陡峭，含有大量的高频成分，将会辐射干扰，另外，也容易产生过冲；</p>
</blockquote>
<h2 id="阻抗匹配"><a href="#阻抗匹配" class="headerlink" title="阻抗匹配"></a>阻抗匹配</h2><p><code>阻抗匹配</code>是指<code>信号源</code>或者<code>传输线</code>跟<code>负载</code>之间的一种合适的搭配方式阻抗匹配分为<code>低频</code>和<code>高频</code>两种情况</p>
<p>先从<code>直流电压源驱动一个负载</code>入手。由于实际的电压源，总是有<code>内阻</code>的（请参看输出阻抗一问），我们可以把一个实际电压源，等效成一个理想的电压源跟一个电阻r串联的模型。</p>
<p><img data-src="/images/2018/07/DC-cicuit-1.png" alt="直流电路"></p>
<p>假设负载电阻为R，电源电动势为U，内阻为r，那么我们可以计算：</p>
<ul>
<li><p>负载R的电流为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">I=U/(R+r)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>负载电阻R越小，则输出电流越大。</p>
</blockquote>
</li>
<li><p>负载R的电压为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Uo=IR=U/[1+(r/R)]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>负载电阻R越大，则输出电压Uo越高。</p>
</blockquote>
</li>
<li><p>负载R消耗的功率为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">P=I^2×R=[U/(R+r)]^2×R=U^2×R/(R^2+2xR×r+r^2)</span><br><span class="line">      =U^2×R/[(R-r)^2+4×R×r]</span><br><span class="line">      =U^2/&#123;[(R-r)2/R]+4×r&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>对于一个给定的信号源，其<code>内阻r是固定</code>的，而负载电阻R则是由我们来选择的注意式中<code>[(R-r)2/R]</code>:<br>当<code>R=r</code>时，<code>[(R-r)2/R]</code>可取得最小值0，这时负载电阻R上可获得最大输出功率Pmax&#x3D;U^2&#x2F;(4×r)即，当<code>负载电阻跟信号源内阻相等时，负载可获得最大输出功率</code>，这就是我们常说的阻抗匹配之一。</p>
</blockquote>
</li>
</ul>
<p>对于纯电阻电路，<code>此结论同样适用于低频电路及高频电路</code>，当交流电路中含有容性或感性阻抗时，结论有所改变，就是需要信号源与负载阻抗的实部相等，虚部互为相反数，这叫做共扼匹配；</p>
<p>在低频电路中，我们一般不考虑传输线的匹配问题，只考虑信号源跟负载之间的情况，因为低频信号的波长相对于传输线来说很长，传输线可以看成是“短线”，反射可以不考虑（可以这么理解：因为线短，即使反射回来，跟原信号还是一样的）</p>
<p>在高频电路中，我们还必须考虑反射的问题当信号的频率很高时，则信号的波长就很短，当波长短得跟传输线长度可以比拟时，反射信号叠加在原信号上将会改变原信号的形状，如果传输线的特征阻抗跟负载阻抗不相等（即不匹配）时，在负载端就会产生反射。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>如果是高速信号线上串小电阻，那就应该是终端阻抗匹配</li>
<li>如果是GPIO口上串了小电阻，很可能是抗小能量电压脉冲</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><span class="exturl" data-url="aHR0cDovL2Jsb2cuc2luYS5jb20uY24vcy9ibG9nXzZkYjI3NWRhMDEwMHo4NWouaHRtbA==">信号线时钟线地址线GPIO串联小电阻作用<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>电子电路</category>
      </categories>
      <tags>
        <tag>电路</tag>
      </tags>
  </entry>
  <entry>
    <title>RC电路</title>
    <url>/post/40769.html</url>
    <content><![CDATA[<p>由电阻R和电容C组成的电路称为阻容电路，简称<code>RC电路</code></p>
<span id="more"></span>

<h2 id="RC串联电路"><a href="#RC串联电路" class="headerlink" title="RC串联电路"></a>RC串联电路</h2><h2 id="RC并联电路"><a href="#RC并联电路" class="headerlink" title="RC并联电路"></a>RC并联电路</h2><h2 id="RC-串并联电路"><a href="#RC-串并联电路" class="headerlink" title="RC 串并联电路"></a>RC 串并联电路</h2><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><span class="exturl" data-url="aHR0cDovL2JhaWppYWhhby5iYWlkdS5jb20vcz9pZD0xNTc5NTc0NTc1MTM2NDU4MDEwJndmcj1zcGlkZXImZm9yPXBj">RC电路（一）RC串联、并联电路详解<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>电子电路</category>
      </categories>
      <tags>
        <tag>电路</tag>
      </tags>
  </entry>
  <entry>
    <title>VCC（电源）和GND（地）之间电容的作用</title>
    <url>/post/5a220639.html</url>
    <content><![CDATA[<p><img data-src="/images/2021/11/vcc_and_gnd.png" alt="VCC_and_GND"></p>
<blockquote>
<p>作用： 电源输入&#x2F;输出滤波电容，主要用于稳定输出，对稳压有利</p>
</blockquote>
<span id="more"></span>

<h2 id="电容的主要作用"><a href="#电容的主要作用" class="headerlink" title="电容的主要作用"></a>电容的主要作用</h2><h3 id="稳压"><a href="#稳压" class="headerlink" title="稳压"></a>稳压</h3><p>电源与地之间接电容的原因有两个作用，储能和旁路储能：电路的耗电有时候大，有时候小，当耗电突然增大的时候如果没有电容，电源电压会被拉低，产生噪声，振铃，严重会导致CPU重启，这时候大容量的电容可以暂时把储存的电能释放出来，稳定电源电压，就像河流和水库的关系旁路：电路电流很多时候有脉动，例如数字电路的同步频率，会造成电源电压的脉动，这是一种交流噪声，小容量的无极电容可以把这种噪声旁路到地（电容可以通交流，阻直流，小容量电容通频带比大电容高得多），也是为了提高稳定性</p>
<h3 id="电源滤波"><a href="#电源滤波" class="headerlink" title="电源滤波"></a>电源滤波</h3><p>电容的容量&#x3D;介电常数<em>面积&#x2F;距离&#x3D;ε</em>S&#x2F;d，通常ε、d 不易改动，只能改动S来改变电容量。当电容很大时，S必然大，为了减小体积，不得不用卷叠的方式，但卷叠必然增加电感量（尽管对称双绕）。As you know 电容实际是R、L、C的组合，如此，大电容相对电感量L也大。例如：用2200uF电容波时，对于低频50Hz是很好的，但是对于高频（K、MHz）来说，一点用也没有，因为L太大。所以高手很讲究电源的滤波，会采用大、中、小三种电容，分别针对低、中、高频来滤波。常用以下组合：2200&#x2F;47&#x2F;0.1uF220&#x2F;4.7&#x2F;0.1uF1nf、0.1u和4.7uf</p>
<h2 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h2><ol>
<li>在直流电源（Vcc）和地之间并接电容的电容可称为滤波电容．滤波电容<code>滤除电源的杂波和交流成分</code>，压平滑脉动直流电，储存电能．取值一般100－4700uF．取值与负载电流和对电源的纯净度有关，容量越大越好．有时在大电容傍边会并有一个容量较小的电容，叫高频去耦电容．也是滤波的一种型式用来滤除电源中的高频杂波以免电路态产生自激，稳定电路工作状．取值一般0．1－10uF．取值与滤除杂波的频率有关．</li>
</ol>
<ul>
<li>这样接的作用一般叫“退耦”，也叫“退交连”、“旁路”电容，常按排在电源供给、IC和功能模块电路附近。以无感的瓷片、独石电容为佳。</li>
<li>作用是为高频信号提供通路，减小电源内阻，去除电源和地线在敷铜板上“走长线”的影响，防止公用电源的各部分电路之间的“有害交连”等等。常用10nF。</li>
</ul>
<ol start="2">
<li>在开发板上，通常直流电源和地之间有很多<code>0.1uF非电解电容</code>和<code>10uF的电解电容</code>。</li>
</ol>
<p>  这些电容，<code>目的是使电源线和地线之间为低阻抗，电源接近理想电压源</code>。你要说是滤波作用也可以，但需要弄清楚是滤什么波。不是滤电源的纹波，而是某芯片电流发生变化在电源线上造成的纹波，使其不影响其它芯片。<br>  使用0.1uF无极性电容和10uF电解电容并联，是<code>因为电解电容的寄生电感比较大，消除高频纹波能力较差。而无极性电容寄生电感小，滤除高频纹波能力较好</code>。但若根据低频的要求选择容量，则无极性电容体积太大，成本也高，电解电容体积小，同样容量价格较便宜。故采用两种电容并联<br>  你自己设计电路，也应该这样使用，而且各电容位置和走线很有讲究。</p>
<p>只能说两句原则：</p>
<ul>
<li>各小容量的无极性电容两端到芯片的电源引脚和地引脚联接线尽可能短，越短越好。</li>
<li>电源通常由其它电路板引入，电解电容通常每块电路板上只有一个两个。一个电解电容的话，放到电源进入该电路板之处。此时电解电容当然离各芯片较远，但因电解电容主要在较低频率起作用，所以稍远一点没有关系。如果该电路板上用两支电解电容，另一支放到耗电最多的芯片附近。<br>这些和电路板元件布局、地线的走线安排(多层板通常有地层)都有关系</li>
</ul>
<p>10MHz以下的噪声0.1μF电容效果好<br>按C&#x3D;1&#x2F;F，即10MHz取0.1μF</p>
<p>简单的说是，将干扰通过电容接地</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyNTU5NC9hcnRpY2xlL2RldGFpbHMvODA2NTA4NTg=">【硬件】电容一端接电源，另一端接地，起什么作用，什么时候才会有这样的接法<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuMjFpYy5jb20vYXBwL2VkYS8yMDE4MDkvNzk4NzkzLmh0bQ==">电源与地之间为何要接电容？<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZseWluZ19tYW5fL2FydGljbGUvZGV0YWlscy84MjU1NzgxNg==">Vcc（电源）和GND（地）之间接电容的作用<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>电子电路</category>
      </categories>
      <tags>
        <tag>电源</tag>
        <tag>电容</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux基本目录规范——XDG</title>
    <url>/post/ef694e1f.html</url>
    <content><![CDATA[<p><code>XDG</code> Base Directory Specification</p>
<blockquote>
<p>该规范定义了一套指向应用程序的环境变量，这些变量指明的就是这些程序应该存储的基准目录。而变量的具体值取决于用户，若用户未指定，将由程序本身指向一个默认目录，该默认目录也应该遵从标准，而不是用户主目录。</p>
</blockquote>
<span id="more"></span>

<h2 id="环境变量清单：用户层面变量（User-Level-Variables）"><a href="#环境变量清单：用户层面变量（User-Level-Variables）" class="headerlink" title="环境变量清单：用户层面变量（User-Level Variables）"></a>环境变量清单：用户层面变量（User-Level Variables）</h2><h3 id="XDG-DATA-HOME"><a href="#XDG-DATA-HOME" class="headerlink" title="$XDG_DATA_HOME"></a><code>$XDG_DATA_HOME</code></h3><p><code>$XDG_DATA_HOME</code> 定义了应存储用户特定的数据文件的基准目录。默认值是 <code>$HOME/.local/share</code>。</p>
<p>使用场景：</p>
<ul>
<li>用户下载的插件；</li>
<li>程序产生的数据库；</li>
<li>用户输入历史、书签、邮件等。</li>
</ul>
<h3 id="XDG-CONFIG-HOME"><a href="#XDG-CONFIG-HOME" class="headerlink" title="$XDG_CONFIG_HOME"></a><code>$XDG_CONFIG_HOME</code></h3><p><code>$XDG_CONFIG_HOME</code> 定义了应存储用户特定的配置文件的基准目录。默认值是 <code>$HOME/.config</code>。</p>
<p>使用场景：</p>
<ul>
<li>用户配置。</li>
</ul>
<blockquote>
<p>一般来说，这个地方可以在程序初始化的时候存储一个默认的配置文件供加载和修改。</p>
</blockquote>
<h3 id="XDG-CACHE-HOME"><a href="#XDG-CACHE-HOME" class="headerlink" title="$XDG_CACHE_HOME"></a><code>$XDG_CACHE_HOME</code></h3><p><code>$XDG_CACHE_HOME</code> 定义了应存储用户特定的非重要性数据文件的基准目录。默认值是 <code>$HOME/.cache</code>。</p>
<p>使用场景：</p>
<ul>
<li>缓存的缩略图、歌曲文件、视频文件等。</li>
</ul>
<blockquote>
<p>程序应该做到哪怕这个目录被用户删了也能正常运行。</p>
</blockquote>
<h3 id="XDG-RUNTIME-DIR"><a href="#XDG-RUNTIME-DIR" class="headerlink" title="$XDG_RUNTIME_DIR"></a><code>$XDG_RUNTIME_DIR</code></h3><p><code>$XDG_RUNTIME_DIR</code> 定义了应存储用户特定的非重要性运行时文件和一些其他文件对象。</p>
<p>使用场景：</p>
<ul>
<li>套接字 (socket)、命名管道 (named pipes) 等。</li>
</ul>
<blockquote>
<p>该目录必须由用户拥有，并且该用户必须是唯一具有读写访问权限的。 目录的 Unix 访问模式必须是 <code>0700</code>。</p>
</blockquote>
<h2 id="环境变量清单：系统层面变量（System-Level-Variables）"><a href="#环境变量清单：系统层面变量（System-Level-Variables）" class="headerlink" title="环境变量清单：系统层面变量（System-Level Variables）"></a>环境变量清单：系统层面变量（System-Level Variables）</h2><h3 id="XDG-CONFIG-DIRS"><a href="#XDG-CONFIG-DIRS" class="headerlink" title="$XDG_CONFIG_DIRS"></a><code>$XDG_CONFIG_DIRS</code></h3><p><code>$XDG_CONFIG_DIRS</code> 定义了一套按照偏好顺序的基准目录集，用来搜索除了 <code>$XDG_CONFIG_HOME</code> 目录之外的配置文件。该目录中的文件夹应该用冒号（<code>:</code>）隔开。默认值是 <code>/etc/xdg</code>。</p>
<p>使用场景：</p>
<ul>
<li>可以被用户特定的配置文件所覆盖的系统层面的配置文件。</li>
</ul>
<blockquote>
<p>一般来说，应用程序安装的时候可以加载配置文件到这个目录。</p>
</blockquote>
<h3 id="XDG-DATA-DIRS"><a href="#XDG-DATA-DIRS" class="headerlink" title="$XDG_DATA_DIRS"></a><code>$XDG_DATA_DIRS</code></h3><p><code>$XDG_DATA_DIRS</code> 定义了一套按照偏好顺序的基准目录集，用来搜索除了 <code>$XDG_DATA_HOME</code> 目录之外的数据文件。该目录中的文件夹应该用冒号（<code>:</code>）隔开。默认值是 <code>/usr/local/share/:/usr/share/</code>。</p>
<p>使用场景：</p>
<ul>
<li>可以被所有用户使用的插件或者主题。</li>
</ul>
<blockquote>
<p>一般来说，应用程序安装的时候可以加载插件、主题等文件到这个目录。</p>
</blockquote>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9zcGVjaWZpY2F0aW9ucy5mcmVlZGVza3RvcC5vcmcvYmFzZWRpci1zcGVjL2Jhc2VkaXItc3BlYy1sYXRlc3QuaHRtbA==">XDG Base Directory Specification<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9zb25na2V5cy5naXRodWIuaW8vcG9zdHMveGRjLXNwZWMv">消灭泛滥的点文件：XDG 基准目录规范<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>系统应用</category>
      </categories>
      <tags>
        <tag>xdg</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux for ARM</title>
    <url>/post/35642.html</url>
    <content><![CDATA[<p>支持arm架构CPU的PC或服务器中linux相关系统或软件</p>
<span id="more"></span>


<h2 id="CentOS"><a href="#CentOS" class="headerlink" title="CentOS"></a>CentOS</h2><h3 id="IOS镜像下载"><a href="#IOS镜像下载" class="headerlink" title="IOS镜像下载"></a>IOS镜像下载</h3><ul>
<li><span class="exturl" data-url="aHR0cDovL2lzb3JlZGlyZWN0LmNlbnRvcy5vcmcvYWx0YXJjaC83L2lzb3MvYWFyY2g2NC8=">http://isoredirect.centos.org/altarch/7/isos/aarch64/<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly92YXVsdC5jZW50b3Mub3JnL2FsdGFyY2gvNy44LjIwMDMvaXNvcy8=">https://vault.centos.org/altarch/7.8.2003/isos/<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly92YXVsdC5jZW50b3Mub3JnL2NlbnRvcy83LjguMjAwMy9pc29zLw==">https://vault.centos.org/centos/7.8.2003/isos/<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<h3 id="软件包"><a href="#软件包" class="headerlink" title="软件包"></a>软件包</h3><ul>
<li><span class="exturl" data-url="aHR0cDovL21pcnJvci5jZW50b3Mub3JnL2FsdGFyY2gvNy9vcy9hYXJjaDY0L1BhY2thZ2VzLw==">http://mirror.centos.org/altarch/7/os/aarch64/Packages/<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<h3 id="不同版本"><a href="#不同版本" class="headerlink" title="不同版本"></a>不同版本</h3><ul>
<li><span class="exturl" data-url="aHR0cDovL21pcnJvci5jZW50b3Mub3JnLw==">http://mirror.centos.org<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<h2 id="Archlinux"><a href="#Archlinux" class="headerlink" title="Archlinux"></a>Archlinux</h2><blockquote>
<p>We build optimized packages for soft-float ARMv5te, hard-float ARMv6 and ARMv7, and ARMv8 AArch64 instruction sets to use each platform to its full potential.</p>
</blockquote>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9hcmNobGludXhhcm0ub3JnLw==">https://archlinuxarm.org/<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93aWtpLmFyY2hsaW51eC5vcmcvaW5kZXgucGhwL0tlcm5lbA==">https://wiki.archlinux.org/index.php/Kernel<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul>
<li>系统软件更新快，版本新</li>
</ul>
<h2 id="ubuntu-for-arm"><a href="#ubuntu-for-arm" class="headerlink" title="ubuntu for arm"></a>ubuntu for arm</h2><blockquote>
<p>配置清华源<code>ubuntu-ports</code></p>
</blockquote>
<h2 id="华为TaiShan服务器"><a href="#华为TaiShan服务器" class="headerlink" title="华为TaiShan服务器"></a>华为TaiShan服务器</h2><p>服务器MGMT网口，即BMC（iBMC&#x2F;iMana）的默认IP地址与子网掩码如下：<br>默认IP地址：192.168.2.100<br>默认子网掩码：255.255.255.0</p>
<p>iBMC（iBMC&#x2F;iMana）默认用户名和密码如下：<br>默认用户名：root<br>默认密码：Huawei12#$</p>
<p>定制后的固件中iBMC（iBMC&#x2F;iMana）默认用户名和密码如下：<br>默认用户名：Administrator<br>默认密码：Huawei12#$ —&gt; Ziguang12#$</p>
<h2 id="Beyond-Linux®-From-Scratch-System-V-Edition"><a href="#Beyond-Linux®-From-Scratch-System-V-Edition" class="headerlink" title="Beyond Linux® From Scratch (System V Edition)"></a>Beyond Linux® From Scratch (System V Edition)</h2><ul>
<li><span class="exturl" data-url="aHR0cDovL3d3dy5saW51eGZyb21zY3JhdGNoLm9yZy9ibGZzL3ZpZXcvc3ZuL2luZGV4Lmh0bWw=">http://www.linuxfromscratch.org/blfs/view/svn/index.html<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vbHNneGV2YS9wLzEwMzcxMjc2Lmh0bWw=">华为TaiShan 2280 ARM 服务器<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>系统应用</category>
      </categories>
      <tags>
        <tag>arm</tag>
      </tags>
  </entry>
  <entry>
    <title>rpc</title>
    <url>/post/62149.html</url>
    <content><![CDATA[<blockquote>
<p><code>RPC</code>是远程过程调用（Remote Procedure Call）的缩写形式。SAP系统RPC调用的原理其实很简单，有一些类似于三层构架的C&#x2F;S系统，第三方的客户程序通过接口调用SAP内部的标准或自定义函数，获得函数返回的数据进行处理后显示或打印</p>
</blockquote>
<span id="more"></span>

<blockquote>
<p>Since the idea of <span class="exturl" data-url="aHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9SZW1vdGVfcHJvY2VkdXJlX2NhbGw=">RPC<i class="fa fa-external-link-alt"></i></span>  goes back to 1976 and the first business use was by Xerox in 1981, I’m  not exactly sure what qualifies as a really old tutorial.</p>
</blockquote>
<blockquote>
<p>Here are a few resources you might find helpful.</p>
</blockquote>
<ul>
<li><span class="exturl" data-url="aHR0cDovL2Jvb2tzLmdvb2dsZS5jb20vYm9va3M/aWQ9UE4yaGNSRDI5SlVDJmRxPVBvd2VyK1Byb2dyYW1taW5nK3dpdGgrUlBD">Power Programming with RPC<i class="fa fa-external-link-alt"></i></span> (1992)</li>
<li><span class="exturl" data-url="aHR0cDovL3d3dy5saW51eGpvdXJuYWwuY29tL2FydGljbGUvMjIwNA==">Remote Procedure Calls | Linux Journal<i class="fa fa-external-link-alt"></i></span> (Oct 01, 1997)</li>
<li><span class="exturl" data-url="aHR0cDovL3d3dy5jcy5jZi5hYy51ay9EYXZlL0Mvbm9kZTMzLmh0bWw=">Remote Procedure Calls (RPC)<i class="fa fa-external-link-alt"></i></span> (1999)</li>
<li><span class="exturl" data-url="aHR0cDovL2RvY3MuZnJlZWJzZC5vcmcvNDRkb2MvcHNkLzIzLnJwYy9wYXBlci5wZGY=">Remote Procedure Call Programming Guide<i class="fa fa-external-link-alt"></i></span> (PDF link)</li>
<li><span class="exturl" data-url="aHR0cDovL2xpbnV4LmRpZS5uZXQvbWFuLzMvcnBj">rpc(3) - Linux man page<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<h2 id="rpcgen"><a href="#rpcgen" class="headerlink" title="rpcgen"></a>rpcgen</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$rpcgen --version</span><br><span class="line">rpcgen (Ubuntu GLIBC 2.27-3ubuntu1) 2.27</span><br></pre></td></tr></table></figure>
<h2 id="rpcinfo"><a href="#rpcinfo" class="headerlink" title="rpcinfo"></a>rpcinfo</h2><blockquote>
<p>report RPC information</p>
</blockquote>
<h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><h3 id="Cannot-register-service-RPC-Unable-to-receive-errno-x3D-Connection-refused"><a href="#Cannot-register-service-RPC-Unable-to-receive-errno-x3D-Connection-refused" class="headerlink" title="Cannot register service: RPC: Unable to receive; errno &#x3D; Connection refused"></a>Cannot register service: RPC: Unable to receive; errno &#x3D; Connection refused</h3><p><code>portmap</code>是为RPC程序服务的。每一个RPC server程序启动的时候要向portmap程序注册。这样portmap程序就知道这些RPC server监听在哪个端口。 而RPC client在发起连接向portmap发起查询，知道了想要查询的RPC server的监听端口后再去连接server</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install portmap rpcbind</span><br><span class="line">sudo systemctl status portmap.service</span><br></pre></td></tr></table></figure>

<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">find /usr/include/ -name <span class="string">&quot;*.x&quot;</span></span></span><br><span class="line">/usr/include/rpcsvc/key_prot.x</span><br><span class="line">/usr/include/rpcsvc/bootparam_prot.x</span><br><span class="line">/usr/include/rpcsvc/sm_inter.x</span><br><span class="line">/usr/include/rpcsvc/klm_prot.x</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">program YPPASSWDPROG &#123;</span><br><span class="line">        version YPPASSWDVERS &#123;</span><br><span class="line">                /*</span><br><span class="line">                 * Update my passwd entry</span><br><span class="line">                 */</span><br><span class="line">                int</span><br><span class="line">                YPPASSWDPROC_UPDATE(yppasswd) = 1;</span><br><span class="line">        &#125; = 1;</span><br><span class="line">&#125; = 100009;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">struct passwd &#123;</span><br><span class="line">        string pw_name&lt;&gt;;       /* username */</span><br><span class="line">        string pw_passwd&lt;&gt;;     /* encrypted password */</span><br><span class="line">        int pw_uid;             /* user id */</span><br><span class="line">        int pw_gid;             /* group id */</span><br><span class="line">        string pw_gecos&lt;&gt;;      /* in real life name */</span><br><span class="line">        string pw_dir&lt;&gt;;        /* home directory */</span><br><span class="line">        string pw_shell&lt;&gt;;      /* default shell */</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct yppasswd &#123;</span><br><span class="line">        string oldpass&lt;&gt;;       /* unencrypted old password */</span><br><span class="line">        passwd newpw;           /* new passwd entry */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly91bml4LnN0YWNrZXhjaGFuZ2UuY29tL3F1ZXN0aW9ucy8zNDQwMTUvd2hhdC1hcmUtdGhlLXgtZmlsZXMtaW4tdXNyLWluY2x1ZGU=">https://unix.stackexchange.com/questions/344015/what-are-the-x-files-in-usr-include<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<h3 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h3><h2 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cubGludXhqb3VybmFsLmNvbS9hcnRpY2xlLzIyMDQ=">Remote Procedure Calls<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMjUyNjIyNy9jLWMtcnBjLXR1dG9yaWFsLWZvci1saW51eA==">C&#x2F;C++ RPC Tutorial for Linux [closed]<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2l3MTIxMC9hcnRpY2xlL2RldGFpbHMvNDEwNTE3Nzk=">Linux下C语言RPC（远程过程调用）编程实例<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmZyZWVic2Qub3JnLzQ0ZG9jL3BzZC8yMi5ycGNnZW4vcGFwZXIucGRm">rpcgen Programming Guide<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY3Byb2dyYW1taW5nLmNvbS90dXRvcmlhbC9ycGMvcmVtb3RlX3Byb2NlZHVyZV9jYWxsX3N0YXJ0Lmh0bWw=">Writing Remote Procedural Calls (RPCs) in C<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMjg4MjI0MzYvcGFzc2luZy1jaGFyYWN0ZXItcG9pbnRlcnMtZnJvbS1jbGllbnQtdG8tc2VydmVyLWluLXJwY2dlbg==">Passing character pointers from client to server in RPCGen<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL25lby5kbWNzLnBsL3Jzby9kdS9vbmMtcnBjMy5odG1s">Writing RPC Applications with the rpcgen Protocol Compiler<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>系统应用</category>
      </categories>
      <tags>
        <tag>rpc</tag>
      </tags>
  </entry>
  <entry>
    <title>相对坐标与绝对坐标</title>
    <url>/post/1dbfe64.html</url>
    <content><![CDATA[<p><img data-src="/images/2022/01/%E7%9B%B8%E5%AF%B9%E5%9D%90%E6%A0%87%E4%B8%8E%E7%BB%9D%E5%AF%B9%E5%9D%90%E6%A0%87.png" alt="相对坐标与绝对坐标"></p>
<span id="more"></span>

<ul>
<li>绝对坐标</li>
</ul>
<p>指定<code>EV_ABS</code>值，则dx和dy包含<code>0</code>到<code>65,535</code>之间的<code>归一化绝对坐标</code>。 事件过程将这些坐标映射到显示表面上。 坐标 (0,0) 映射到显示表面的左上角(65535,65535) 映射到右下角。</p>
<ul>
<li>相对坐标</li>
</ul>
<p>未指定<code>EV_ABS</code>值，则dx和dy指定从生成<code>最后一个点击事件（最后报告的位置）开始的相对运动</code>。 正值表示光标向右（或向下）移动； 负值表示光标向左（或向上）移动。</p>
<h2 id="Linux中输入设备的事件类型"><a href="#Linux中输入设备的事件类型" class="headerlink" title="Linux中输入设备的事件类型"></a>Linux中输入设备的事件类型</h2><ul>
<li><code>EV_SYN</code> 0x00 同步事件</li>
<li><code>EV_KEY</code> 0x01 按键事件，如KEY_VOLUMEDOWN</li>
<li><code>EV_REL</code> 0x02 相对坐标，如鼠标上报的坐标</li>
<li><code>EV_ABS</code> 0x03 绝对坐标，如触摸屏上报的坐标</li>
<li><code>EV_MSC</code> 0x04 其它</li>
<li><code>EV_LED</code> 0x11 LED</li>
<li><code>EV_SND</code> 0x12 声音</li>
<li><code>EV_REP</code> 0x14 Repeat</li>
<li><code>EV_FF</code>  0x15 力反馈</li>
</ul>
<h2 id="获取鼠标坐标值"><a href="#获取鼠标坐标值" class="headerlink" title="获取鼠标坐标值"></a>获取鼠标坐标值</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/input.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> fd, retval;</span><br><span class="line">	<span class="type">char</span> buf[<span class="number">6</span>];</span><br><span class="line">	fd_set readfds;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></span><br><span class="line"></span><br><span class="line">	fd = open( <span class="string">&quot;/dev/input/mice&quot;</span>, O_RDONLY );</span><br><span class="line">	<span class="keyword">if</span>(fd&lt;<span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Failed to open \&quot;/dev/input/mice\&quot;.\n&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;open \&quot;/dev/input/mice\&quot; successfuly.\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">		tv.tv_sec = <span class="number">5</span>;</span><br><span class="line">		tv.tv_usec = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		FD_ZERO(&amp;readfds);</span><br><span class="line">		FD_SET(fd, &amp;readfds);</span><br><span class="line"></span><br><span class="line">		retval = select(fd+<span class="number">1</span>, &amp;readfds, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;tv);</span><br><span class="line">		<span class="keyword">if</span>(retval == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;Time out!\n&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(FD_ISSET(fd,&amp;readfds)) &#123;</span><br><span class="line">			<span class="keyword">if</span>(read(fd, buf, <span class="number">6</span>) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;Button type=%d, X=%d, Y=%d, Z=%d\n&quot;</span>, (buf[<span class="number">0</span>] &amp; <span class="number">0x07</span>), buf[<span class="number">1</span>], buf[<span class="number">2</span>],   buf[<span class="number">3</span>]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	close(fd);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>系统应用</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>相对坐标</tag>
        <tag>绝对坐标</tag>
      </tags>
  </entry>
  <entry>
    <title>ABRT</title>
    <url>/post/46984.html</url>
    <content><![CDATA[<p>ABRT (Automated Bug Reporting Tool) Daemon:</p>
<blockquote>
<p>ABRT is an application, included in Fedora Linux Distribution, that is used to report bugs in the software packages whenever crash occurs. Due to this, ABRT also helps in creation of core dump files. Multiple packages may be needed to run various features of ABRT daemon, and their listing is as follows.</p>
</blockquote>
<p>在linux调试程序，程序异常宕掉，没有core文件，很难定位问题。但是有了core文件就容易定位多了， 一般是可以通过在环境变量中设置<code>ulimit -c unlimited</code>。</p>
<p>但是现场实施人员有时会忘记设置这条命令， 因此可以通过设置linux的<code>abrt</code>服务来实现。</p>
<span id="more"></span>

<p>系统：CentOS7</p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Product Signing (GPG) Keys:</span><br><span class="line"># https://access.redhat.com/security/team/key</span><br><span class="line">#</span><br><span class="line">OpenGPGCheck = no #捕获所有程序的崩溃信息</span><br><span class="line"></span><br><span class="line"># Blacklisted packages</span><br><span class="line">#</span><br><span class="line">BlackList = nspluginwrapper, valgrind, strace, mono-core</span><br><span class="line"></span><br><span class="line"># Process crashes in executables which do not belong to any package?</span><br><span class="line">#</span><br><span class="line">ProcessUnpackaged = yes #保存捕获程序异常的core文件</span><br><span class="line"></span><br><span class="line"># Blacklisted executable paths (shell patterns)</span><br><span class="line">#</span><br><span class="line">BlackListedPaths = /usr/share/doc/*, */example*, /usr/bin/nspluginviewer, /usr/lib/xulrunner-*/plugin-container</span><br><span class="line"></span><br><span class="line"># interpreters names</span><br><span class="line">Interpreters = python2, python2.7, python, python3, python3.3, perl, perl5.16.2</span><br></pre></td></tr></table></figure>
<blockquote>
<p>配置文件： <code>/etc/abrt/abrt-action-save-package-data.conf</code></p>
</blockquote>
<blockquote>
<p>配置文件：<code>/etc/abrt/abrt.conf</code></p>
</blockquote>
<ul>
<li><p>配置参数<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmZlZG9yYXByb2plY3Qub3JnL2VuLVVTL0ZlZG9yYS8xNC9odG1sL0RlcGxveW1lbnRfR3VpZGUvY29uZmlndXJpbmcuaHRtbA==">解析<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li><p>重启服务</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">service abrtd restart</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看状态</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">service abrtd status</span><br></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sysctl -a | grep core_pattern</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sed -i &#x27;s/ProcessUnpackaged = no/ProcessUnpackaged = yes/g&#x27; /etc/abrt/abrt-action-save-package-data.conf&amp;&amp; service abrtd restart</span><br></pre></td></tr></table></figure>

<h2 id="操作命令"><a href="#操作命令" class="headerlink" title="操作命令"></a>操作命令</h2><h3 id="查看文件的包"><a href="#查看文件的包" class="headerlink" title="查看文件的包"></a>查看文件的包</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">abrt-cli list</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># abrt-cli list</span><br><span class="line">id 3c0df29571be38a595b2034cfa631d3e6b569d34</span><br><span class="line">reason:         Unable to handle kernel NULL pointer dereference at virtual address 00000000</span><br><span class="line">time:           2019年09月11日 星期三 20时26分26秒</span><br><span class="line">uid:            0 (root)</span><br><span class="line">count:          1</span><br><span class="line">Directory:      /var/spool/abrt/vmcore-127.0.0.1-2019-09-05-10:31:32</span><br><span class="line"></span><br><span class="line">The Autoreporting feature is disabled. Please consider enabling it by issuing</span><br><span class="line">&#x27;abrt-auto-reporting enabled&#x27; as a user with root privileges</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># ls /var/spool/abrt/ccpp-2019-09-21-16:26:32-16439</span><br><span class="line">abrt_version  architecture  cmdline         coredump  dso_list  event_log   exploitable  hostname  last_occurrence  machineid  open_fds  os_release  proc_pid_status  reason    time  uid       uuid</span><br><span class="line">analyzer      cgroup        core_backtrace  count     environ   executable  global_pid   kernel    limits           maps       os_info   pid         pwd              runlevel  type  username  var_log_messages</span><br></pre></td></tr></table></figure>

<h3 id="删除文件包"><a href="#删除文件包" class="headerlink" title="删除文件包"></a>删除文件包</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">abrt-cli rm &lt;ccpp folder from list &gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># abrt-cli rm /var/spool/abrt/vmcore-127.0.0.1-2019-09-05-10:31:32</span><br><span class="line">rm &#x27;/var/spool/abrt/vmcore-127.0.0.1-2019-09-05-10:31:32&#x27;</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9hY2Nlc3MucmVkaGF0LmNvbS9kb2N1bWVudGF0aW9uL2VuLXVzL3JlZF9oYXRfZW50ZXJwcmlzZV9saW51eC82L2h0bWwvZGVwbG95bWVudF9ndWlkZS9jaC1hYnJ0">Chapter 28. Automatic Bug Reporting Tool (ABRT)<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>系统服务</category>
      </categories>
      <tags>
        <tag>dump</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker 搭建 Nextcloud</title>
    <url>/post/efa23dc6.html</url>
    <content><![CDATA[<p>系统：ubuntu18.04</p>
<p>搭建个人网盘</p>
<span id="more"></span>

<h2 id="Docker环境"><a href="#Docker环境" class="headerlink" title="Docker环境"></a>Docker环境</h2><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><ol>
<li>添加可信任的 GPG 公钥<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -</span><br></pre></td></tr></table></figure></li>
<li>查看 GPG 公钥<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt-key fingerprint 0EBFCD88</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">apt-key fingerprint 0EBFCD88</span></span><br><span class="line">pub   rsa4096 2017-02-22 [SCEA]</span><br><span class="line">     9DC8 5822 9FC7 DD38 854A  E2D8 8D81 803C 0EBF CD88</span><br><span class="line">uid           [ unknown] Docker Release (CE deb) &lt;docker@docker.com&gt;</span><br><span class="line">sub   rsa4096 2017-02-22 [S]</span><br></pre></td></tr></table></figure></li>
<li>添加镜像源<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo add-apt-repository &quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu  $(lsb_release -cs) stable&quot;</span><br></pre></td></tr></table></figure></li>
<li>安装 Docker-CE 及其依赖<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install -y docker-ce</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun</span><br></pre></td></tr></table></figure>

<h3 id="Docker-镜像加速器"><a href="#Docker-镜像加速器" class="headerlink" title="Docker 镜像加速器"></a>Docker 镜像加速器</h3><ol>
<li>添加网易云 Docker 镜像加速器<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -sSL https://get.daocloud.io/daotools/set_mirror.sh | sh -s https://hub-mirror.c.163.com/</span><br></pre></td></tr></table></figure></li>
<li>重启 Docker 服务<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo systemctl restart docker.service</span><br></pre></td></tr></table></figure></li>
<li>检查 Docker 是否安装成功<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo docker info</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="安装-docker-compose-工具"><a href="#安装-docker-compose-工具" class="headerlink" title="安装 docker-compose 工具"></a>安装 docker-compose 工具</h2><p>docker-compose 是一个由 Docker 官方提供的管理工具，适合一个应用需要多个容器配合统一管理，进一步简化应用部署、应用升级步骤。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install -y python3 python3-pip</span><br><span class="line">sudo pip3 install docker-compose</span><br></pre></td></tr></table></figure>
<p>在安装<code>docker-compose</code>时，由于网络原因下载可能会总超时，可以使用该脚本安装直到成功</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo pip3 install docker-compose</span><br><span class="line">while [ $? != 0 ]; do</span><br><span class="line">    sleep 3</span><br><span class="line">    sudo pip3 install docker-compose</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<h3 id="直接下载"><a href="#直接下载" class="headerlink" title="直接下载"></a>直接下载</h3><p>进入<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2RvY2tlci9jb21wb3NlL3JlbGVhc2Vz">https://github.com/docker/compose/releases<i class="fa fa-external-link-alt"></i></span> 查看最新版本，选择当前版本为<code>1.25.5</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -L https://github.com/docker/compose/releases/download/1.25.5/docker-compose-`uname -s`-`uname -m` -o docker-compose</span><br><span class="line">chmod +x docker-compose</span><br></pre></td></tr></table></figure>

<p>查看是否安装成功</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./docker-compose --version</span><br></pre></td></tr></table></figure>

<h2 id="安装nextcloud"><a href="#安装nextcloud" class="headerlink" title="安装nextcloud"></a>安装nextcloud</h2><ol>
<li><p>编写docker-compose.yml文件<br>docker-compose 的管理主要依赖于一个名为 docker-compose.yml 的 yaml 文件来进行管理，当然这个文件也可以以任何别的名称并以<code>-f filename</code>的方式来启用，但必须是符合yaml格式和Docker官方定义的字段和方式。</p>
</li>
<li><p>启动容器<br>以下命令即可开始拉取所需容器的镜像文件并根据<code>docker-compose.yml</code>文件配置好本地文件夹挂载和端口映射。（由于需要拉取镜像，可能需要等一段时间，与当前网络环境相关。）</p>
</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo ./docker–compose up –d</span><br></pre></td></tr></table></figure>


<p>查看容器是否启动</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo docker ps -a</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>应用初始化配置</li>
</ol>
<p>访问 http:&#x2F;&#x2F;&lt;IP 地址&gt; 设置管理员用户名和密码（比如 admin 和 <span class="exturl" data-url="bWFpbHRvOiYjeDYxOyYjeDY0OyYjeDZkOyYjeDY5OyYjMTEwOyYjNjQ7JiMxMTA7JiN4NjU7JiN4Nzg7JiN4NzQ7JiM5OTsmIzEwODsmIzExMTsmIzExNzsmI3g2NDsmI3gyZTsmI3g2MzsmIzExMTsmI3g2ZDs=">&#x61;&#x64;&#x6d;&#x69;&#110;&#64;&#110;&#x65;&#x78;&#x74;&#99;&#108;&#111;&#117;&#x64;&#x2e;&#x63;&#111;&#x6d;<i class="fa fa-external-link-alt"></i></span> ），数据目录默认即可，数据库信息填写如 docker-composer.yml 中所示，数据库主机名填 db （配置文件中的数据库应用名）</p>
<ol start="4">
<li>更新应用至最新版</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo docker pull nextcloud</span><br><span class="line">sudo ./docker-compose down &amp;&amp; sudo ./docker-compose up -d</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly90c292Lm5ldC9ob21lL3ZpZXcvMjA3Ny8=">Nginx配合docker安装nextcloud<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNjg1MTUwMC9hcnRpY2xlL2RldGFpbHMvOTA0MDkxOTU=">Docker 搭建 Nextcloud<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>系统服务</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>kernel: mce: [Hardware Error]: Machine check events logged</title>
    <url>/post/3ae1a27e.html</url>
    <content><![CDATA[<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">localhost.localdomain kernel: mce: [Hardware Error]: Machine check events logged</span><br><span class="line">localhost.localdomain mcelog[2226]: Hardware event. This is not a software error.</span><br><span class="line">localhost.localdomain mcelog[2226]: MCE 0</span><br><span class="line">localhost.localdomain mcelog[2226]: CPU 0 BANK 7 TSC b98e63765d2</span><br><span class="line">localhost.localdomain mcelog[2226]: MISC 200005c280201086 ADDR 20b5cf8880</span><br><span class="line">localhost.localdomain mcelog[2226]: TIME 1617035952 Tue Mar 30 00:39:12 2021</span><br><span class="line">localhost.localdomain mcelog[2226]: MCG status:</span><br><span class="line">localhost.localdomain mcelog[2226]: MCi status:</span><br><span class="line">localhost.localdomain mcelog[2226]: Corrected error</span><br><span class="line">localhost.localdomain mcelog[2226]: Error enabled</span><br><span class="line">localhost.localdomain mcelog[2226]: MCi_MISC register valid</span><br><span class="line">localhost.localdomain mcelog[2226]: MCi_ADDR register valid</span><br><span class="line">localhost.localdomain mcelog[2226]: MCA: MEMORY CONTROLLER RD_CHANNEL0_ERR</span><br><span class="line">localhost.localdomain mcelog[2226]: Transaction: Memory read error</span><br><span class="line">localhost.localdomain mcelog[2226]: M2M: MscodDataRdErr</span><br><span class="line">localhost.localdomain mcelog[2226]: STATUS 9c00004001010090 MCGSTATUS 0</span><br><span class="line">localhost.localdomain mcelog[2226]: MCGCAP f000c14 APICID 0 SOCKETID 0</span><br><span class="line">localhost.localdomain mcelog[2226]: CPUID Vendor Intel Family 6 Model 85</span><br><span class="line">localhost.localdomain mcelog[2226]: warning: 8 bytes ignored in each record</span><br><span class="line">localhost.localdomain mcelog[2226]: consider an update</span><br></pre></td></tr></table></figure>
<p>内存模块出现错误</p>
<span id="more"></span>

<h2 id="Machine-Check-Exceptions-MCE"><a href="#Machine-Check-Exceptions-MCE" class="headerlink" title="Machine Check Exceptions (MCE)"></a>Machine Check Exceptions (MCE)</h2><blockquote>
<p>X86 CPUs report errors detected by the CPU as machine check events (MCEs). These can be data corruption detected in the CPU caches, in main memory by an integrated memory controller, data transfer errors on the front side bus or CPU interconnect or other internal errors. Possible causes can be cosmic radiation, instable power supplies, cooling problems, broken hardware, running systems out of specification, or bad luck.</p>
</blockquote>
<blockquote>
<p>Most errors can be corrected by the CPU by internal error correction mechanisms. Uncorrected errors cause machine check exceptions which may kill processes or panic the machine. A small number of corrected errors is usually not a cause for worry, but a large number can indicate future failure.</p>
</blockquote>
<blockquote>
<p>When a corrected or recovered error happens the x86 kernel writes a record describing the MCE into a internal ring buffer available through the &#x2F;dev&#x2F;mcelog device. mcelog retrieves errors from &#x2F;dev&#x2F;mcelog, decodes them into a human readable format and prints them on the standard output or optionally into the system log.</p>
</blockquote>
<p>用来报告主机硬件相关问题的一种日志机制</p>
<h2 id="常见的MCE错误原因"><a href="#常见的MCE错误原因" class="headerlink" title="常见的MCE错误原因"></a>常见的MCE错误原因</h2><ul>
<li>内存错误或ECC(Error Correction Code)问题</li>
<li>冷却不充分&#x2F;处理器过热</li>
<li>系统总线错误</li>
<li>处理器或硬件的缓存错误</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><span class="exturl" data-url="aHR0cDovL21jZWxvZy5vcmcvbWFucGFnZS5odG1s">mcelog<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>系统服务</category>
      </categories>
      <tags>
        <tag>kernel</tag>
        <tag>linux</tag>
        <tag>mce</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux中systemd的日志管理——journalctl</title>
    <url>/post/50280.html</url>
    <content><![CDATA[<p><code>Systemd</code>统一管理所有linux的启动日志。带来的好处就是，可以只用<code>journalctl</code>一个命令，查看所有日志（内核日志和应用日志）。日志的配置文件<code>/etc/systemd/journald.conf</code></p>
<span id="more"></span>

<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><blockquote>
<p>配置文件：<code>/etc/systemd/journald.conf</code></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Journal]</span><br><span class="line">#Storage=auto</span><br><span class="line">#Compress=yes</span><br><span class="line">#Seal=yes</span><br><span class="line">#SplitMode=uid</span><br><span class="line">#SyncIntervalSec=5m</span><br><span class="line">#RateLimitIntervalSec=30s</span><br><span class="line">#RateLimitBurst=1000</span><br><span class="line">//指定journal所能使用的最高持久存储容量。</span><br><span class="line">#SystemMaxUse=</span><br><span class="line">//指定journal在添加新条目时需要保留的剩余空间。</span><br><span class="line">#SystemKeepFree=</span><br><span class="line">//控制单一journal文件大小，符合要求方可被转为持久存储。</span><br><span class="line">#SystemMaxFileSize=</span><br><span class="line">#SystemMaxFiles=100</span><br><span class="line">//指定易失性存储中的最大可用磁盘容量（/run文件系统之内）</span><br><span class="line">#RuntimeMaxUse=</span><br><span class="line">//指定向易失性存储内写入数据时为其它应用保留的空间量（/run文件系统之内）</span><br><span class="line">#RuntimeKeepFree=</span><br><span class="line">//指定单一journal文件可占用的最大易失性存储容量（/run文件系统之内）</span><br><span class="line">#RuntimeMaxFileSize=</span><br><span class="line">#RuntimeMaxFiles=100</span><br><span class="line">#MaxRetentionSec=</span><br><span class="line">#MaxFileSec=1month</span><br><span class="line">#ForwardToSyslog=yes</span><br><span class="line">#ForwardToKMsg=no</span><br><span class="line">#ForwardToConsole=no</span><br><span class="line">#ForwardToWall=yes</span><br><span class="line">#TTYPath=/dev/console</span><br><span class="line">#MaxLevelStore=debug</span><br><span class="line">#MaxLevelSyslog=debug</span><br><span class="line">#MaxLevelKMsg=notice</span><br><span class="line">#MaxLevelConsole=info</span><br><span class="line">#MaxLevelWall=emerg</span><br><span class="line">#LineMax=48K</span><br></pre></td></tr></table></figure>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuZnJlZWRlc2t0b3Aub3JnL3NvZnR3YXJlL3N5c3RlbWQvbWFuL2pvdXJuYWxkLmNvbmYuaHRtbA==">Journal service configuration files<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<h3 id="把日志保存到文件中"><a href="#把日志保存到文件中" class="headerlink" title="把日志保存到文件中"></a>把日志保存到文件中</h3><ul>
<li><p>方法1： 创建目录<code>/var/log/journal</code>，然后重启日志服务<code>systemd-journald.service</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo mkdir -p /var/log/journal</span><br></pre></td></tr></table></figure></li>
<li><p>方法2： 修改配置文件<code>/etc/systemd/journald.conf</code>，把<code>Storage=auto</code>改为<code>Storage=persistent</code>，并取消注释，然后重启日志服务<code>systemd-journald.service</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo systemctl restart systemd-journald</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">journalctl -h</span></span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">man journalctl</span></span><br></pre></td></tr></table></figure>

<h2 id="常见用法"><a href="#常见用法" class="headerlink" title="常见用法"></a>常见用法</h2><h3 id="查看所有日志（默认情况下-，只保存本次启动的日志）"><a href="#查看所有日志（默认情况下-，只保存本次启动的日志）" class="headerlink" title="查看所有日志（默认情况下 ，只保存本次启动的日志）"></a>查看所有日志（默认情况下 ，只保存本次启动的日志）</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">journalctl</span></span><br></pre></td></tr></table></figure>

<h3 id="查看当前最后一次启动后日志"><a href="#查看当前最后一次启动后日志" class="headerlink" title="查看当前最后一次启动后日志"></a>查看当前最后一次启动后日志</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">journalctl -xb</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>-x</code>: 使用消息目录中的说明文本扩充日志行<br><code>-b</code>: 参数为空时，将显示当前引导的日志</p>
</blockquote>
<h3 id="查看内核日志（不显示应用日志）"><a href="#查看内核日志（不显示应用日志）" class="headerlink" title="查看内核日志（不显示应用日志）"></a>查看内核日志（不显示应用日志）</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">journalctl -k</span></span><br></pre></td></tr></table></figure>

<h3 id="查看系统本次启动的日志"><a href="#查看系统本次启动的日志" class="headerlink" title="查看系统本次启动的日志"></a>查看系统本次启动的日志</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">journalctl -b</span></span><br></pre></td></tr></table></figure>

<h3 id="查看某次启动后的日志"><a href="#查看某次启动后的日志" class="headerlink" title="查看某次启动后的日志"></a>查看某次启动后的日志</h3><p>默认情况下<code>systemd-journald</code>服务只保存本次启动后的日志(重新启动后丢掉以前的日志)。此时<code>-b</code>选项是没啥用的。当我们把<code>systemd-journald</code>服务收集到的日志保存到文件中之后，就可以通过下面的命令查看系统的重启记录：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">journalctl --list-boots</span></span><br><span class="line">-82 672e675b37f74b72b2900c13743675e9 Mon 2019-03-18 11:11:20 CST—Fri 2019-03-22 09:17:58 CST</span><br><span class="line">-81 f857b21a80db4be3acfdf7d04247e4bd Fri 2019-03-22 09:18:44 CST—Fri 2019-03-22 18:13:10 CST</span><br><span class="line">-80 ee3d23ea84434be2b7d6a6353733e37c Sat 2019-03-23 11:23:40 CST—Sat 2019-03-23 13:28:06 CST</span><br></pre></td></tr></table></figure>
<p>通过<code>-b</code>选项来选择查看某次运行过程中的日志:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">journalctl -b -82</span></span><br><span class="line">或</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">journalctl -b 672e675b37f74b72b2900c13743675e9</span></span><br></pre></td></tr></table></figure>

<h3 id="查看指定时间段的日志"><a href="#查看指定时间段的日志" class="headerlink" title="查看指定时间段的日志"></a>查看指定时间段的日志</h3><p>利用<code>--since</code>与<code>--until</code>选项设定时间段，二者分别负责指定给定时间之前与之后的日志记录。时间值可以使用多种格式，比如下面的格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">YYYY-MM-DD HH:MM:SS</span><br></pre></td></tr></table></figure>

<p>如果我们要查询2018年3月26日下午8:20之后的日志：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">journalctl --since <span class="string">&quot;2018-03-26 20:20:00&quot;</span></span></span><br></pre></td></tr></table></figure>

<h3 id="通过日志级别进行过滤"><a href="#通过日志级别进行过滤" class="headerlink" title="通过日志级别进行过滤"></a>通过日志级别进行过滤</h3><p>除了通过<code>PRIORITY=</code>的方式，还可以通过<code>-p</code>选项来过滤日志的级别。 可以指定的优先级如下：</p>
<table>
<thead>
<tr>
<th align="center">优先级</th>
<th align="center">名称</th>
<th align="center">严重性</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">emerg</td>
<td align="center">系统不可用</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">alert</td>
<td align="center">必须立即采取措施</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">crit</td>
<td align="center">严重状况</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">err</td>
<td align="center">非严重错误状况</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">warning</td>
<td align="center">警告状况</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">notice</td>
<td align="center">正常但重要的事件</td>
</tr>
<tr>
<td align="center">6</td>
<td align="center">info</td>
<td align="center">信息性事件</td>
</tr>
<tr>
<td align="center">7</td>
<td align="center">debug</td>
<td align="center">调试级别消息</td>
</tr>
</tbody></table>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">journalctl -p err</span></span><br></pre></td></tr></table></figure>

<h3 id="实时更新日志"><a href="#实时更新日志" class="headerlink" title="实时更新日志"></a>实时更新日志</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">journalctl -f</span></span><br></pre></td></tr></table></figure>

<h3 id="按可执行文件的路径过滤"><a href="#按可执行文件的路径过滤" class="headerlink" title="按可执行文件的路径过滤"></a>按可执行文件的路径过滤</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">journalctl /bin/bash</span></span><br></pre></td></tr></table></figure>

<h3 id="查看指定应用日志"><a href="#查看指定应用日志" class="headerlink" title="查看指定应用日志"></a>查看指定应用日志</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">journalctl -t sshd</span></span><br></pre></td></tr></table></figure>

<h3 id="查看指定进程的日志"><a href="#查看指定进程的日志" class="headerlink" title="查看指定进程的日志"></a>查看指定进程的日志</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">journalctl _PID=1234</span></span><br></pre></td></tr></table></figure>

<h2 id="维护"><a href="#维护" class="headerlink" title="维护"></a>维护</h2><h3 id="查看当前日志占用磁盘的空间的总大小"><a href="#查看当前日志占用磁盘的空间的总大小" class="headerlink" title="查看当前日志占用磁盘的空间的总大小"></a>查看当前日志占用磁盘的空间的总大小</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">journalctl --disk-usage</span></span><br><span class="line">Archived and active journals take up 3.9G in the file system.</span><br></pre></td></tr></table></figure>

<h3 id="指定日志文件最大空间"><a href="#指定日志文件最大空间" class="headerlink" title="指定日志文件最大空间"></a>指定日志文件最大空间</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">journalctl --vacuum-size=1G</span></span><br></pre></td></tr></table></figure>

<h3 id="指定日志文件保存多久"><a href="#指定日志文件保存多久" class="headerlink" title="指定日志文件保存多久"></a>指定日志文件保存多久</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">journalctl --vacuum-time=1years</span></span><br></pre></td></tr></table></figure>

<h3 id="检查journal是否运行正常以及日志文件是否完整无损坏"><a href="#检查journal是否运行正常以及日志文件是否完整无损坏" class="headerlink" title="检查journal是否运行正常以及日志文件是否完整无损坏"></a>检查journal是否运行正常以及日志文件是否完整无损坏</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">journalctl --verify</span></span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><span class="exturl" data-url="aHR0cDovL3d3dy5qaW5idWd1by5jb20vc3lzdGVtZC9qb3VybmFsY3RsLmh0bWw=">journalctl 中文手册<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>系统服务</category>
      </categories>
      <tags>
        <tag>log</tag>
      </tags>
  </entry>
  <entry>
    <title>systemd原理与使用</title>
    <url>/post/14807.html</url>
    <content><![CDATA[<p><code>Systemd</code>（系统管理守护进程）的主要目的就是减少系统引导时间和计算开销。</p>
<span id="more"></span>
<p>Systemd 的核心是一个叫单元unit的概念，它是一些存有关于<code>服务service</code>（在运行在后台的程序）、<code>设备</code>、<code>挂载点</code>、和操作系统其他方面信息的配置文件。Systemd 的其中一个目标就是简化这些事物之间的相互作用，因此如果你有程序需要在某个挂载点被创建或某个设备被接入后开始运行，Systemd 可以让这一切正常运作起来变得相当容易。</p>
<p><img data-src="/images/2020/02/systemd_unit.png" alt="systemd_unit"></p>
<p>Systemd中的所有操作都是通过<code>systemctl</code>交互控制</p>
<table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">systemctl list-unit-files</td>
<td align="center">列出系统上的所有单元</td>
</tr>
<tr>
<td align="center">systemctl list-unit-files –type&#x3D;service</td>
<td align="center">限制输出列表只包含服务</td>
</tr>
<tr>
<td align="center">systemctl status ssh.service</td>
<td align="center">查看服务的状态</td>
</tr>
<tr>
<td align="center">systemctl stop ssh.service</td>
<td align="center">停止服务</td>
</tr>
<tr>
<td align="center">systemctl start ssh.service</td>
<td align="center">开启服务</td>
</tr>
<tr>
<td align="center">systemctl enable ssh.service</td>
<td align="center">设置开机自启</td>
</tr>
<tr>
<td align="center">systemctl disable ssh.service</td>
<td align="center">禁止开机自启</td>
</tr>
</tbody></table>
<p><code>systemctl list-units --type=target</code>命令可以获取当前正在使用的运行目标</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$systemctl list-units --type=target</span><br><span class="line">UNIT                   LOAD   ACTIVE SUB    DESCRIPTION</span><br><span class="line">basic.target           loaded active active Basic System</span><br><span class="line">cryptsetup.target      loaded active active Encrypted Volumes</span><br><span class="line">getty.target           loaded active active Login Prompts</span><br><span class="line">graphical.target       loaded active active Graphical Interface</span><br><span class="line">local-fs-pre.target    loaded active active Local File Systems (Pre)</span><br><span class="line">local-fs.target        loaded active active Local File Systems</span><br><span class="line">multi-user.target      loaded active active Multi-User System</span><br><span class="line">network-online.target  loaded active active Network is Online</span><br><span class="line">network.target         loaded active active Network</span><br><span class="line">nss-user-lookup.target loaded active active User and Group Name Lookups</span><br><span class="line">paths.target           loaded active active Paths</span><br><span class="line">remote-fs.target       loaded active active Remote File Systems</span><br><span class="line">slices.target          loaded active active Slices</span><br><span class="line">sockets.target         loaded active active Sockets</span><br><span class="line">sound.target           loaded active active Sound Card</span><br><span class="line">swap.target            loaded active active Swap</span><br><span class="line">sysinit.target         loaded active active System Initialization</span><br><span class="line">time-sync.target       loaded active active System Time Synchronized</span><br><span class="line">timers.target          loaded active active Timers</span><br><span class="line"></span><br><span class="line">LOAD   = Reflects whether the unit definition was properly loaded.</span><br><span class="line">ACTIVE = The high-level unit activation state, i.e. generalization of SUB.</span><br><span class="line">SUB    = The low-level unit activation state, values depend on unit type.</span><br><span class="line"></span><br><span class="line">19 loaded units listed. Pass --all to see loaded but inactive units, too.</span><br><span class="line">To show all installed unit files use &#x27;systemctl list-unit-files&#x27;.</span><br></pre></td></tr></table></figure>

<h2 id="Systemd-目录"><a href="#Systemd-目录" class="headerlink" title="Systemd 目录"></a>Systemd 目录</h2><ul>
<li><code>/etc/systemd/system</code>：系统或用户自定义的配置文件</li>
<li><code>/run/systemd/system</code>：软件运行时生成的配置文件</li>
<li><code>/usr/lib/systemd/system</code>：系统或第三方软件安装时添加的配置文件。</li>
<li>CentOS：Unit 文件指向该目录</li>
<li>Ubuntu：被移到了<code>/lib/systemd/system</code></li>
</ul>
<p>Systemd 默认从目录<code>/etc/systemd/system/</code>读取配置文件。但是，里面存放的大部分文件都是符号链接，指向目录 &#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;，真正的配置文件存放在那个目录</p>
<h2 id="system配置文件"><a href="#system配置文件" class="headerlink" title="system配置文件"></a>system配置文件</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=Anbox Container Manager</span><br><span class="line">After=network.target</span><br><span class="line">Wants=network.target</span><br><span class="line">ConditionPathExists=/home/xxx/work1/android-for-anbox/android_x86.img</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">ExecStartPre=/sbin/modprobe ashmem_linux</span><br><span class="line">ExecStartPre=/sbin/modprobe binder_linux</span><br><span class="line">ExecStart=/usr/local/bin/anbox container-manager --daemon --privileged --data-path=/home/xxx/work1/android-for-anbox/anbox-data/ --android-image=/home/xxx/work1/android-for-anbox/android_x86.img --use-rootfs-overlay</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>
<ul>
<li><code>Unit</code>和<code>Install</code>段：所有 Unit 文件通用，用于配置服务（或其它系统资源）的描述、依赖和随系统启动的方式</li>
<li><code>Service</code> 段：服务（Service）类型的 Unit 文件（后缀为 .service）特有的，用于定义服务的具体管理和操作方法</li>
</ul>
<h3 id="Unit"><a href="#Unit" class="headerlink" title="Unit"></a>Unit</h3><table>
<thead>
<tr>
<th align="center">属性</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Description</td>
<td align="center">描述这个 Unit 文件的信息</td>
</tr>
<tr>
<td align="center">Requires</td>
<td align="center">依赖的其它 Unit 列表，列在其中的 Unit 模板会在这个服务启动时的同时被启动。并且，如果其中任意一个服务启动失败，这个服务也会被终止</td>
</tr>
<tr>
<td align="center">After</td>
<td align="center">与 Requires 相似，但是在后面列出的所有模块全部启动完成以后，才会启动当前的服务</td>
</tr>
<tr>
<td align="center">Want</td>
<td align="center">与 Requires 相似，但只是在被配置的这个 Unit 启动时，触发启动列出的每个 Unit 模块，而不去考虑这些模板启动是否成功</td>
</tr>
<tr>
<td align="center">ConditionPathExists</td>
<td align="center">是指定在服务启动时检查指定文件的存在状态。如果指定的绝对路径名不存在，这个条件的结果就是失败。如果绝对路径的带有!前缀，则条件反转，即只有路径不存在时服务才启动。</td>
</tr>
</tbody></table>
<h3 id="service"><a href="#service" class="headerlink" title="service"></a>service</h3><table>
<thead>
<tr>
<th align="center">属性</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">ExecStartPre</td>
<td align="center">指定在ExecStart之前用户自定义执行的脚本</td>
</tr>
<tr>
<td align="center">ExecStart</td>
<td align="center">指定启动单元的命令或者脚本</td>
</tr>
</tbody></table>
<h3 id="Install"><a href="#Install" class="headerlink" title="Install"></a>Install</h3><p>这部分配置的目标模块通常是特定运行目标的 .target 文件，用来使得服务在系统启动时自动运行。</p>
<table>
<thead>
<tr>
<th align="center">属性</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">WantedBy</td>
<td align="center">和 Unit 段的 Wants 作用相似，只有后面列出的不是服务所依赖的模块，而是依赖当前服务的模块。</td>
</tr>
</tbody></table>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9tYW4ubGludXhkZS5uZXQvc3lzdGVtY3Rs">systemctl命令<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9jbG91ZC50ZW5jZW50LmNvbS9kZXZlbG9wZXIvYXJ0aWNsZS8xNTE2MTI1">可能是史上最全面易懂的 Systemd 服务管理教程<i class="fa fa-external-link-alt"></i></span><a href="https://winddoing.github.io/downloads/linux/systemd.pdf"></a></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vemhvdWhiaW5nL3AvNDAyMTYzNS5odG1s">systemd服务内容详解<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>系统服务</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>systemd</tag>
      </tags>
  </entry>
  <entry>
    <title>systemd服务的添加</title>
    <url>/post/1fc281b1.html</url>
    <content><![CDATA[<p>在linux的平时使用中，需要一些常驻后台的程序，这些为了方便操作可以将其作成一个systemd服务，通过systemd的操作命令进行管理。</p>
<span id="more"></span>

<p>systemd服务的目录<code>/usr/lib/systemd/system</code>下添加<code>test.service</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=Test service</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Environment=&quot;LD_LIBRARY_PATH=/usr/local/lib/:/usr/local/lib64/&quot;</span><br><span class="line">Environment=&quot;MY_ENV=123&quot;</span><br><span class="line">ExecStart=/bin/testcmd</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>
<ul>
<li>开启：<code>systemctl start test</code></li>
<li>关闭：<code>systemctl stop test</code></li>
</ul>
<h2 id="添加环境变量"><a href="#添加环境变量" class="headerlink" title="添加环境变量"></a>添加环境变量</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Service]</span><br><span class="line">Environment=&quot;LD_LIBRARY_PATH=/usr/local/lib/:/usr/local/lib64/&quot;</span><br><span class="line">Environment=&quot;MY_ENV=123&quot;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>systemctl --help</code></p>
</blockquote>
<p><code>EnvironmentFile</code>关键字是在环境变量配置较多的情况下，可以编辑到一个文件通过该变量一次性导入，编辑文件的一行为一个环境变量的定义。</p>
<h2 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a>命令执行</h2><ul>
<li><code>ExecStart=</code>： 启动服务时执行的命令</li>
<li><code>ExecStartPre=, ExecStartPost=</code>： 启动服务之前与之后执行的命令</li>
</ul>
<p>在启动服务前执行的相关命令中，如果存在权限问题可以在执行命令前加<code>+</code>，如<code>ExecStartPre=+/bin/mkdir test</code></p>
<blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cuZnJlZWRlc2t0b3Aub3JnL3NvZnR3YXJlL3N5c3RlbWQvbWFuL3N5c3RlbWQuc2VydmljZS5odG1sI0V4ZWNTdGFydD0=">https://www.freedesktop.org/software/systemd/man/systemd.service.html#ExecStart=<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<h2 id="Unit模板"><a href="#Unit模板" class="headerlink" title="Unit模板"></a>Unit模板</h2><p>模板文件的主要特点是，文件名以<code>@</code>符号结尾，而启动的时候指定的Unit名称为模板名称附加一个参数字符串,比如<code>test@.service</code>, 在服务启动时可以在<code>@</code>后面放置一个用于区分服务实例的附加字符串参数,这样在参数将会传入到服务启动文件，在文件内部可以通过占位符<code>%i</code>获取服务启动是传入的参数，从而达到启动多个服务实例的目的。</p>
<ul>
<li>启动：<code>systemctl start test@1</code> 这样<code>1</code>将传入服务编辑文件，可以通过<code>%i</code>传给服务启动的进程中</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=Test service mul</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Environment=&quot;LD_LIBRARY_PATH=/usr/local/lib/:/usr/local/lib64/&quot;</span><br><span class="line">Environment=&quot;MY_ENV=123&quot;</span><br><span class="line">ExecStart=/bin/testcmd  %i #传入的参数</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">占位符</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>%n</code></td>
<td align="center">完整的 Unit 文件名字，包括 .service 后缀名</td>
</tr>
<tr>
<td align="center"><code>%m</code></td>
<td align="center">实际运行的节点的 Machine ID，适合用来做Etcd路径的一部分，例如 &#x2F;machines&#x2F;%m&#x2F;units</td>
</tr>
<tr>
<td align="center"><code>%b</code></td>
<td align="center">作用有点像 Machine ID，但这个值每次节点重启都会改变，称为 Boot ID</td>
</tr>
<tr>
<td align="center"><code>%H</code></td>
<td align="center">实际运行节点的主机名</td>
</tr>
<tr>
<td align="center"><code>%p</code></td>
<td align="center">Unit 文件名中在 @ 符号之前的部分，不包括 @ 符号</td>
</tr>
<tr>
<td align="center"><code>%i</code></td>
<td align="center">Unit 文件名中在 @ 符号之后的部分，不包括 @ 符号和 .service 后缀名</td>
</tr>
</tbody></table>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9jbG91ZC50ZW5jZW50LmNvbS9kZXZlbG9wZXIvYXJ0aWNsZS8xNTE2MTI1">可能是史上最全面易懂的 Systemd 服务管理教程！( 强烈建议收藏 )<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9zZXJ2ZXJmYXVsdC5jb20vcXVlc3Rpb25zLzQxMzM5Ny9ob3ctdG8tc2V0LWVudmlyb25tZW50LXZhcmlhYmxlLWluLXN5c3RlbWQtc2VydmljZQ==">How to set environment variable in systemd service?<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL3d3dy5qaW5idWd1by5jb20vc3lzdGVtZC9zeXN0ZW1kLnNlcnZpY2UuaHRtbA==">systemd.service 中文手册<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>系统服务</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>systemd</tag>
        <tag>服务</tag>
      </tags>
  </entry>
  <entry>
    <title>升级Centos7系统内核版本（for arm64）</title>
    <url>/post/51885.html</url>
    <content><![CDATA[<p>升级CentOS7中的内核版本：</p>
<span id="more"></span>


<h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><h3 id="认证错误"><a href="#认证错误" class="headerlink" title="认证错误"></a>认证错误</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">target `certs/centos.pem&#x27;, needed by `certs/x509_certificate_list&#x27;.  Stop</span><br></pre></td></tr></table></figure>
<ul>
<li>注释掉<code>.config</code>中的相关配置<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CONFIG_SYSTEM_TRUSTED_KEYS=&quot;certs/centos.pem&quot;</span><br></pre></td></tr></table></figure></li>
<li><span class="exturl" data-url="aHR0cHM6Ly91bml4LnN0YWNrZXhjaGFuZ2UuY29tL3F1ZXN0aW9ucy8yOTM2NDIvYXR0ZW1wdGluZy10by1jb21waWxlLWFueS1rZXJuZWwteWllbGRzLWEtY2VydGlmaWNhdGlvbi1lcnJvci8yOTQxMTY=">Attempting to compile any kernel yields a certification error<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cua2VybmVsLm9yZy9kb2MvaHRtbC92NS4zLXJjOC9hZG1pbi1ndWlkZS9tb2R1bGUtc2lnbmluZy5odG1s">Kernel module signing facility<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9saXN0cy5kZWJpYW4ub3JnL2RlYmlhbi1rZXJuZWwvMjAxNi8wNC9tc2cwMDU3OS5odG1s">Bug#823107: marked as done (linux: make deb-pkg fails: No rule to make target ‘debian&#x2F;certs&#x2F;benh@debian.org.cert.pem')<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLnppa2kuY24vcG9zdC9jb21waWxlLWtlcm5lbC8=">https://blog.ziki.cn/post/compile-kernel/<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>系统服务</category>
      </categories>
      <tags>
        <tag>centos</tag>
      </tags>
  </entry>
  <entry>
    <title>autotools自动编译---手动添加依赖库</title>
    <url>/post/31094.html</url>
    <content><![CDATA[<p><code>autotools</code>根据配置文件(configure.ac)自动生成<code>makefile</code></p>
<span id="more"></span>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./autogen.sh  #根据configure.ac生成configure与相关头文件</span><br><span class="line">./configure --prefix=$ALT_LOCAL --enable-debug</span><br><span class="line">make -j4</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>

<h2 id="在现有应用中添加SDL的依赖"><a href="#在现有应用中添加SDL的依赖" class="headerlink" title="在现有应用中添加SDL的依赖"></a>在现有应用中添加SDL的依赖</h2><p>将gcc的编译参数<code>-lSDL2</code>,添加到<code>configure</code>生成的Makefile，并可以在配置阶段检测系统是否以安装SDL2相关库</p>
<h3 id="修改configure-ac"><a href="#修改configure-ac" class="headerlink" title="修改configure.ac"></a>修改configure.ac</h3><p>添加对SDL2库的检测</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PKG_CHECK_MODULES([SDL2], [sdl2])</span><br></pre></td></tr></table></figure>

<p>执行<code>autogen.sh</code>生成configure和config.log等，在<code>config.log</code>中将生成：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SDL2_CFLAGS=&#x27;-D_REENTRANT -I/usr/include/SDL2&#x27;</span><br><span class="line">SDL2_LIBS=&#x27;-lSDL2&#x27;</span><br></pre></td></tr></table></figure>
<h3 id="编辑Makefile-am"><a href="#编辑Makefile-am" class="headerlink" title="编辑Makefile.am"></a>编辑Makefile.am</h3><p>修改需要链接SDL2的源码目录中的<code>Makefile.am</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AM_LDFLAGS = $(SDL2_LIBS)</span><br><span class="line">AM_CFLAGS = $(SDL2_CFLAGS)</span><br></pre></td></tr></table></figure>

<h2 id="make参数"><a href="#make参数" class="headerlink" title="make参数"></a>make参数</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">make -j4 --trace</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>--trace</code>: 打印gcc编译的详细数据</p>
</blockquote>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2tvbmdzaHVhaTE5OTAwNTA1L2FydGljbGUvZGV0YWlscy83OTEwNDQ0Mg==">autotools自动编译系列之三—autogen.sh实例<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>编译工具</category>
      </categories>
      <tags>
        <tag>autotools</tag>
        <tag>configure</tag>
        <tag>autogen</tag>
      </tags>
  </entry>
  <entry>
    <title>Centos源码编译安装gcc</title>
    <url>/post/bb09b834.html</url>
    <content><![CDATA[<p>升级centos中默认的gcc版本</p>
<span id="more"></span>


<h2 id="安装依赖包"><a href="#安装依赖包" class="headerlink" title="安装依赖包"></a>安装依赖包</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install -y epel-release</span><br><span class="line">yum install -y gcc gcc-c++ gcc-gnat libgcc libgcc.i686 glibc-devel bison flex texinfo build-essential</span><br></pre></td></tr></table></figure>

<h2 id="下载gcc源码"><a href="#下载gcc源码" class="headerlink" title="下载gcc源码"></a>下载gcc源码</h2><blockquote>
<p>最新的gcc版本：<span class="exturl" data-url="aHR0cDovL2Z0cC5nbnUub3JnL2dudS9nY2M=">http://ftp.gnu.org/gnu/gcc<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget http://ftp.gnu.org/gnu/gcc/gcc-8.2.0/gcc-8.2.0.tar.xz</span><br><span class="line">tar -xJvf gcc-8.2.0.tar.xz</span><br></pre></td></tr></table></figure>

<h2 id="编译安装"><a href="#编译安装" class="headerlink" title="编译安装"></a>编译安装</h2><h3 id="下载编译依赖库"><a href="#下载编译依赖库" class="headerlink" title="下载编译依赖库"></a>下载编译依赖库</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd gcc-8.2.0</span><br><span class="line">./contrib/download_prerequisites</span><br></pre></td></tr></table></figure>
<blockquote>
<p>需要等一段时间，下载并解压完成，无需手动编译，下面编译时会自动编译安装</p>
</blockquote>
<h3 id="编译安装-1"><a href="#编译安装-1" class="headerlink" title="编译安装"></a>编译安装</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd gcc-8.2.0</span><br><span class="line">./configure --prefix=/usr/local/gcc-8.2.0</span><br><span class="line">make -j 4 &amp;&amp; make install</span><br></pre></td></tr></table></figure>

<h2 id="指定运行库"><a href="#指定运行库" class="headerlink" title="指定运行库"></a>指定运行库</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vi /etc/ld.so.conf</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">include ld.so.conf.d/*.conf</span><br><span class="line"></span><br><span class="line">/usr/local/gcc-8.2.0/lib</span><br></pre></td></tr></table></figure>

<blockquote>
<p>更新运行库文件的缓存：<code>ldconfig -v</code></p>
</blockquote>
<h2 id="scl软件集"><a href="#scl软件集" class="headerlink" title="scl软件集"></a>scl软件集</h2><h3 id="安装scl源"><a href="#安装scl源" class="headerlink" title="安装scl源"></a>安装scl源</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install centos-release-scl scl-utils-build</span><br></pre></td></tr></table></figure>

<h3 id="列出scl有哪些可用软件"><a href="#列出scl有哪些可用软件" class="headerlink" title="列出scl有哪些可用软件"></a>列出scl有哪些可用软件</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum list all --enablerepo=&#x27;centos-sclo-rh&#x27;</span><br></pre></td></tr></table></figure>

<h3 id="安装gcc8"><a href="#安装gcc8" class="headerlink" title="安装gcc8"></a>安装gcc8</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install devtoolset-8-gcc.x86_64</span><br></pre></td></tr></table></figure>

<h3 id="切换版本"><a href="#切换版本" class="headerlink" title="切换版本"></a>切换版本</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scl enable devtoolset-4 bash</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC80NDQxNjlhMzcyMWE=">Centos7.5下源码编译安装gcc-8.2.0<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>编译工具</category>
      </categories>
      <tags>
        <tag>centos</tag>
        <tag>gcc</tag>
      </tags>
  </entry>
  <entry>
    <title>cmake</title>
    <url>/post/24934.html</url>
    <content><![CDATA[<p><code>cmake</code>使用技巧记录</p>
<span id="more"></span>

<h2 id="显示编译详细信息"><a href="#显示编译详细信息" class="headerlink" title="显示编译详细信息"></a>显示编译详细信息</h2><p>打印make进行编译过程中详细的gcc&#x2F;g++参数信息。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">make VERBOSE=1</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在CMakeLists.txt中配置<code>set(CMAKE_VERBOSE_MAKEFILE ON)</code></p>
</blockquote>
<h2 id="debug调试"><a href="#debug调试" class="headerlink" title="debug调试"></a>debug调试</h2><ul>
<li>使用set命令，修改CMake文件</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET(CMAKE_CXX_FLAGS_DEBUG &quot;$ENV&#123;CXXFLAGS&#125; -O0 -Wall -g&quot;)</span><br></pre></td></tr></table></figure>

<ul>
<li>使用环境变量</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir Debug</span><br><span class="line">cd Debug</span><br><span class="line">cmake -DCMAKE_BUILD_TYPE=Debug ..</span><br></pre></td></tr></table></figure>

<h2 id="常见常量"><a href="#常见常量" class="headerlink" title="常见常量"></a>常见常量</h2><h3 id="PROJECT-SOURCE-DIR与CMAKE-SOURCE-DIR"><a href="#PROJECT-SOURCE-DIR与CMAKE-SOURCE-DIR" class="headerlink" title="PROJECT_SOURCE_DIR与CMAKE_SOURCE_DIR"></a>PROJECT_SOURCE_DIR与CMAKE_SOURCE_DIR</h3><ul>
<li>这两个变量所指的路径是一样的，编译时的顶层路径</li>
<li>CMAKE_SOURCE_DIR确实引用了定义顶级CMakeLists.txt的文件夹。 但是，PROJECT_SOURCE_DIR引用包含最新<code>project()</code>命令的CMakeLists.txt文件夹。</li>
<li>CMAKE_SOURCE_DIR: 真对于“主”目录</li>
<li>PROJECT_SOURCE_DIR： 针对于“子”目录</li>
<li><span class="exturl" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMzIwMjg2NjcvYXJlLWNtYWtlLXNvdXJjZS1kaXItYW5kLXByb2plY3Qtc291cmNlLWRpci10aGUtc2FtZS1pbi1jbWFrZSM6fjp0ZXh0PUNNQUtFX1NPVVJDRV9ESVIlMjBkb2VzJTIwaW5kZWVkJTIwcmVmZXIlMjB0byUyMHRoZSUyMGZvbGRlciUyMHdoZXJlLGElMjBzdWJkaXJlY3RvcnklMjB3aXRoJTIwaXRzJTIwb3duJTIwcHJvamVjdCUyMGNhbGxlZCUyMElubmVyLg==">Are CMAKE_SOURCE_DIR and PROJECT_SOURCE_DIR the same in CMake?<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<h3 id="PROJECT-BINARY-DIR与PROJECT-SOURCE-DIR"><a href="#PROJECT-BINARY-DIR与PROJECT-SOURCE-DIR" class="headerlink" title="PROJECT_BINARY_DIR与PROJECT_SOURCE_DIR"></a>PROJECT_BINARY_DIR与PROJECT_SOURCE_DIR</h3><ul>
<li>这两个变量所指路径也是一样的，都表示编译时生成的结果和中间文件存放位置</li>
<li>与上面类似</li>
</ul>
<h2 id="生成编译命令文件-compile-commands-json"><a href="#生成编译命令文件-compile-commands-json" class="headerlink" title="生成编译命令文件 - compile_commands.json"></a>生成编译命令文件 - compile_commands.json</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set(CMAKE_EXPORT_COMPILE_COMMANDS ON)</span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cmake -DCMAKE_EXPORT_COMPILE_COMMANDS=ON</span><br></pre></td></tr></table></figure>
<p>将在编译目录下生成<code>compile_commands.json</code>文件</p>
<h2 id="添加版本及git信息"><a href="#添加版本及git信息" class="headerlink" title="添加版本及git信息"></a>添加版本及git信息</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">execute_process(</span><br><span class="line">    COMMAND git rev-parse --short HEAD</span><br><span class="line">    OUTPUT_VARIABLE COMMIT_HASH</span><br><span class="line">    OUTPUT_STRIP_TRAILING_WHITESPACE</span><br><span class="line">    ERROR_QUIET</span><br><span class="line">    WORKING_DIRECTORY $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span><br><span class="line">)</span><br><span class="line">add_definitions( -DCOMMIT_HASH=\&quot;$&#123;COMMIT_HASH&#125;\&quot;)</span><br><span class="line"></span><br><span class="line">execute_process(</span><br><span class="line">    COMMAND git symbolic-ref --short -q HEAD</span><br><span class="line">    OUTPUT_VARIABLE BRANCH_NAME</span><br><span class="line">    OUTPUT_STRIP_TRAILING_WHITESPACE</span><br><span class="line">    ERROR_QUIET</span><br><span class="line">    WORKING_DIRECTORY $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span><br><span class="line">)</span><br><span class="line">add_definitions( -DBRANCH_NAME=\&quot;$&#123;BRANCH_NAME&#125;\&quot;)</span><br><span class="line"></span><br><span class="line"># 当前编译时间</span><br><span class="line">string(TIMESTAMP COMPILE_TIME %Y%m%d_%H%M%S)</span><br></pre></td></tr></table></figure>

<h2 id="引入外部项目"><a href="#引入外部项目" class="headerlink" title="引入外部项目"></a>引入外部项目</h2><h3 id="子模块"><a href="#子模块" class="headerlink" title="子模块"></a>子模块</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">add_subdirectory(xxx)</span><br></pre></td></tr></table></figure>

<h3 id="编译时下载项目并引入"><a href="#编译时下载项目并引入" class="headerlink" title="编译时下载项目并引入"></a>编译时下载项目并引入</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">include(ExternalProject)</span><br><span class="line"></span><br><span class="line">set(SPDLOG_ROOT $&#123;CMAKE_BINARY_DIR&#125;/thirdparty/SPDLOG)</span><br><span class="line">set(SPDLOG_GIT_TAG  v1.4.1)  # 指定版本</span><br><span class="line">set(SPDLOG_GIT_URL      https://github.com/gabime/spdlog.git)  # 指定git仓库地址</span><br><span class="line">set(SPDLOG_CONFIGURE    cd $&#123;SPDLOG_ROOT&#125;/src/SPDLOG &amp;&amp; cmake -D CMAKE_INSTALL_PREFIX=$&#123;SPDLOG_ROOT&#125; .)  # 指定配置指令（注意此处修改了安装目录，否则默认情况下回安装到系统目录）</span><br><span class="line">set(SPDLOG_MAKE         cd $&#123;SPDLOG_ROOT&#125;/src/SPDLOG &amp;&amp; make)  # 指定编译指令（需要覆盖默认指令，进入我们指定的SPDLOG_ROOT目录下）</span><br><span class="line">set(SPDLOG_INSTALL      cd $&#123;SPDLOG_ROOT&#125;/src/SPDLOG &amp;&amp; make install)  # 指定安装指令（需要覆盖默认指令，进入我们指定的SPDLOG_ROOT目录下）</span><br><span class="line"></span><br><span class="line">ExternalProject_Add(SPDLOG</span><br><span class="line">        PREFIX            $&#123;SPDLOG_ROOT&#125;</span><br><span class="line">        GIT_REPOSITORY    $&#123;SPDLOG_GIT_URL&#125;</span><br><span class="line">        GIT_TAG           $&#123;SPDLOG_GIT_TAG&#125;</span><br><span class="line">        CONFIGURE_COMMAND $&#123;SPDLOG_CONFIGURE&#125;</span><br><span class="line">        BUILD_COMMAND     $&#123;SPDLOG_MAKE&#125;</span><br><span class="line">        INSTALL_COMMAND   $&#123;SPDLOG_INSTALL&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"># 指定编译好的静态库文件的路径</span><br><span class="line">set(SPDLOG_LIB       $&#123;SPDLOG_ROOT&#125;/lib/spdlog/libspdlog.a)</span><br><span class="line"># 指定头文件所在的目录</span><br><span class="line">set(SPDLOG_INCLUDE_DIR   $&#123;SPDLOG_ROOT&#125;/include)</span><br></pre></td></tr></table></figure>

<h2 id="install命令"><a href="#install命令" class="headerlink" title="install命令"></a>install命令</h2><p>install用于指定在安装时运行的规则。它可以用来安装很多内容，可以包括目标二进制、动态库、静态库以及文件、目录、脚本等</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">install(TARGETS &lt;target&gt;... [...])</span><br><span class="line">install(&#123;FILES | PROGRAMS&#125; &lt;file&gt;... [...])</span><br><span class="line">install(DIRECTORY &lt;dir&gt;... [...])</span><br><span class="line">install(SCRIPT &lt;file&gt; [...])</span><br><span class="line">install(CODE &lt;code&gt; [...])</span><br><span class="line">install(EXPORT &lt;export-name&gt; [...])</span><br></pre></td></tr></table></figure>

<h2 id="cpack打包"><a href="#cpack打包" class="headerlink" title="cpack打包"></a>cpack打包</h2><h3 id="打包rpm"><a href="#打包rpm" class="headerlink" title="打包rpm"></a>打包rpm</h3><ul>
<li>组件打包<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cpack_add_component</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 设置每个分组打包成一个 rpm 包</span><br><span class="line">set(CPACK_COMPONENTS_GROUPING ONE_PER_GROUP)</span><br><span class="line"># 设置支持 COMPONENT</span><br><span class="line">set(CPACK_RPM_COMPONENT_INSTALL ON)</span><br><span class="line"></span><br><span class="line">include(CPack)</span><br><span class="line"></span><br><span class="line"># 添加一个名为 AComponent 的 component</span><br><span class="line">cpack_add_component(AComponent</span><br><span class="line">    DISPLAY_NAME  &quot;A program&quot;</span><br><span class="line">    DESCRIPTION   &quot;The program for test&quot;</span><br><span class="line">    GROUP Aprogram)</span><br><span class="line"># 添加一个名为 BComponent 的 component</span><br><span class="line">cpack_add_component(BComponent</span><br><span class="line">    DISPLAY_NAME  &quot;B program&quot;</span><br><span class="line">    DESCRIPTION   &quot;The program for test&quot;</span><br><span class="line">    GROUP Bprogram)</span><br><span class="line"># 添加一个名为 Aprogram 的 group, 这个名字会作为 rpm 包名字的一部分</span><br><span class="line">cpack_add_component_group(Aprogram)</span><br><span class="line"># 添加一个名为 Bprogram 的 group</span><br><span class="line">cpack_add_component_group(Bprogram)</span><br><span class="line"></span><br><span class="line">set(CPACK_RPM_Aprogram_PACKAGE_SUMMARY &quot;Aprogram. Build: git-$&#123;BRANCH_NAME&#125;-$&#123;COMMIT_HASH&#125;&quot;)</span><br><span class="line">set(CPACK_RPM_Bprogram_PACKAGE_SUMMARY &quot;Bprogram. Build: git-$&#123;BRANCH_NAME&#125;-$&#123;COMMIT_HASH&#125;&quot;)</span><br><span class="line"></span><br><span class="line"># 组件Bprogram安装之后执行的脚本</span><br><span class="line">set(CPACK_RPM_Bprogram_POST_INSTALL_SCRIPT_FILE &quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/script/postinst.sh&quot;)</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="安装前后的动作"><a href="#安装前后的动作" class="headerlink" title="安装前后的动作"></a>安装前后的动作</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 设置安装前执行的脚本文件 preinst</span><br><span class="line">set(CPACK_RPM_PRE_INSTALL_SCRIPT_FILE &quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/scripts/preinst.sh&quot;)</span><br><span class="line"># 设置卸载前执行的脚本文件 prerm</span><br><span class="line">set(CPACK_RPM_PRE_UNINSTALL_SCRIPT_FILE &quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/scripts/prerm.sh&quot;)</span><br><span class="line"># 设置安装后执行的脚本文件 postinst</span><br><span class="line">set(CPACK_RPM_POST_INSTALL_SCRIPT_FILE &quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/scripts/postinst.sh&quot;)</span><br><span class="line"># 设置卸载后执行的脚本文件 postrm</span><br><span class="line">set(CPACK_RPM_POST_UNINSTALL_SCRIPT_FILE “$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/scripts/postrm.sh&quot;)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果执行脚本出现权限问题,不要使用chmod u+x来赋权限,最好使用chmod 0777</p>
</blockquote>
<h3 id="取消yum自动依赖关系"><a href="#取消yum自动依赖关系" class="headerlink" title="取消yum自动依赖关系"></a>取消yum自动依赖关系</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set(CPACK_RPM_PACKAGE_AUTOREQPROV &quot; no&quot;)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在<code>no</code>前面（或后面）需要<strong>添加空格</strong>才能使其工作。 cpack的RPM模块似乎有一个错误，这使得它不会让您将某些变量设置为短于3个字符的任何长度。</p>
</blockquote>
<p>参考：<span class="exturl" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTQ2NTgwMzQvaG93LWRvLXlvdS1tYWtlLWl0LXNvLXRoYXQtY3BhY2stZG9lc250LWFkZC1yZXF1aXJlZC1saWJyYXJpZXMtdG8tYW4tcnBt">https://stackoverflow.com/questions/14658034/how-do-you-make-it-so-that-cpack-doesnt-add-required-libraries-to-an-rpm<i class="fa fa-external-link-alt"></i></span></p>
<p>手动设置必要软件依赖：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set(CPACK_RPM_PACKAGE_REQUIRES &quot;python &gt;= 2.5.0, cmake &gt;= 2.8&quot;)</span><br></pre></td></tr></table></figure>

<h2 id="rpm包的安装"><a href="#rpm包的安装" class="headerlink" title="rpm包的安装"></a>rpm包的安装</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rpm -ivh --nodeps --replacefiles test.rpm</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li><code>--nodeps</code>: 忽略依赖软件包</li>
<li><code>--replacefiles</code>: 替换包或文件 用于替换原有包，覆盖安装</li>
<li><code>--force</code>: 忽略冲突，强行安装</li>
<li><code>--test</code>: 测试安装，但不真正执行安装，即dry run模式</li>
</ul>
</blockquote>
<h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="安装rpm包时出现filesystem-3-2-25-el7-x86-64冲突"><a href="#安装rpm包时出现filesystem-3-2-25-el7-x86-64冲突" class="headerlink" title="安装rpm包时出现filesystem-3.2-25.el7.x86_64冲突"></a>安装rpm包时出现filesystem-3.2-25.el7.x86_64冲突</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">file /home from install of example-1.0.0-1.x86_64 conflicts with file from package filesystem-3.2-25.el7.x86_64</span><br></pre></td></tr></table></figure>
<ul>
<li><p>原因：</p>
<ol>
<li>打包时存在新建目录</li>
<li>打包时将home目录也打包其中</li>
</ol>
</li>
<li><p>解决方法：</p>
<ol>
<li>针对第一种，最好不要新建目录，如果是必须的在安装时强制安装</li>
<li>针对第二种，添加如下配置<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">list(APPEND CPACK_RPM_EXCLUDE_FROM_AUTO_FILELIST_ADDITION &quot;/usr/local&quot;)</span><br><span class="line">list(APPEND CPACK_RPM_EXCLUDE_FROM_AUTO_FILELIST_ADDITION &quot;/usr/local/lib&quot;)</span><br><span class="line">list(APPEND CPACK_RPM_EXCLUDE_FROM_AUTO_FILELIST_ADDITION &quot;/usr/local/bin&quot;)</span><br><span class="line">list(APPEND CPACK_RPM_EXCLUDE_FROM_AUTO_FILELIST_ADDITION &quot;/usr/lib/systemd&quot;)</span><br><span class="line">list(APPEND CPACK_RPM_EXCLUDE_FROM_AUTO_FILELIST_ADDITION &quot;/usr/lib/systemd/system&quot;)</span><br><span class="line">list(APPEND CPACK_RPM_EXCLUDE_FROM_AUTO_FILELIST_ADDITION &quot;/etc/ld.so.conf.d&quot;)</span><br><span class="line">list(APPEND CPACK_RPM_EXCLUDE_FROM_AUTO_FILELIST_ADDITION &quot;/home/xxx&quot;)</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cudzNjc2Nob29sLmNuL2RvY19jbWFrZV8zXzgvY21ha2VfM184LW1vZHVsZS1jcGFja3JwbS5odG1s">CPackRPM<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FuZHJld2dpdGh1Yi9hcnRpY2xlL2RldGFpbHMvMTA4MjQ5MDY1">cmake的使用-if-else的逻辑流程详解<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0pDWUFPXy9hcnRpY2xlL2RldGFpbHMvMTE1MTc5MDE1">Cmake获取编译时间添加版本信息<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDEwNzMwL2FydGljbGUvZGV0YWlscy8xMDI4Mzc0MDE=">【CMake】cmake的install指令<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3EzNDU5MTE1NzIvYXJ0aWNsZS9kZXRhaWxzLzEwNTI1MDYzMw==">CMake 基本常用语法 CMakeLists.txt<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8xMDIwNTA3NTA=">CMake之引入外部项目的三种方法<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>编译工具</category>
      </categories>
      <tags>
        <tag>makefile</tag>
      </tags>
  </entry>
  <entry>
    <title>C与C++混合编译</title>
    <url>/post/74f3b3c3.html</url>
    <content><![CDATA[<p>在C代码中引用C++编译的库时，编译错误处理</p>
<span id="more"></span>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">undefined reference to `std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;::~basic_string()&#x27;</span><br><span class="line">undefined reference to `std::allocator&lt;char&gt;::~allocator()&#x27;</span><br><span class="line">undefined reference to `std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;::~basic_string()&#x27;</span><br><span class="line">undefined reference to `std::allocator&lt;char&gt;::~allocator()&#x27;</span><br><span class="line">undefined reference to `std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;::~basic_string()&#x27;</span><br><span class="line">undefined reference to `std::allocator&lt;char&gt;::~allocator()&#x27;</span><br><span class="line">undefined reference to `__cxa_free_exception&#x27;</span><br><span class="line">undefined reference to `std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;::~basic_string()&#x27;</span><br><span class="line">undefined reference to `std::allocator&lt;char&gt;::~allocator()&#x27;</span><br><span class="line">undefined reference to `std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;::~basic_string()&#x27;</span><br><span class="line">undefined reference to `std::allocator&lt;char&gt;::~allocator()&#x27;</span><br><span class="line">undefined reference to `std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;::~basic_string()&#x27;</span><br><span class="line">undefined reference to `std::allocator&lt;char&gt;::~allocator()&#x27;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>链接时的错误信息</p>
</blockquote>
<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><h3 id="编译器版本不兼容"><a href="#编译器版本不兼容" class="headerlink" title="编译器版本不兼容"></a>编译器版本不兼容</h3><p>添加编译选项</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-D_GLIBCXX_USE_CXX11_ABI=1</span><br></pre></td></tr></table></figure>
<blockquote>
<p>cmake: <code>add_definitions(-D_GLIBCXX_USE_CXX11_ABI=1)</code></p>
</blockquote>
<h3 id="未引用C-库"><a href="#未引用C-库" class="headerlink" title="未引用C++库"></a>未引用C++库</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-lstdc++</span><br></pre></td></tr></table></figure>
<blockquote>
<p>camke: <code>target_link_libraries(exe_target stdc++)</code></p>
</blockquote>
]]></content>
      <categories>
        <category>编译工具</category>
      </categories>
      <tags>
        <tag>编译</tag>
        <tag>c</tag>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>gcc编译参数：-Wl,-Bsymbolic与-Bsymbolic</title>
    <url>/post/2a74814.html</url>
    <content><![CDATA[<p>在实际应用中，编译C++代码时使用了<code>-Wl,-Bsymbolic</code>参数编译后生成的动态库文件，在被加载使用时出现错误</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">** Error in `.a.out&#x27;: free(): invalid pointer: 0x0000000000414320 ***</span><br><span class="line">======= Backtrace: =========</span><br><span class="line">/lib64/libc.so.6(+0x81299)[0x7ff6d99a1299]</span><br></pre></td></tr></table></figure>
<p>同样的代码，同样的编译参数，编译生成静态库可以正常使用，但是动态库只要运行时就报错。将<code>-Wl,-Bsymbolic</code>参数删除不用或者改为<code>-Bsymbolic</code>后，编译生成的动态库均可以正常使用，这两个参数对程序编译存在什么影响？</p>
<span id="more"></span>

<h2 id="Bsymbolic"><a href="#Bsymbolic" class="headerlink" title="-Bsymbolic"></a>-Bsymbolic</h2><p>正常情况下，在linux平台上(不使用-Bsymbolic)，加载的目标文件中第一次出现的符号将在程序中一直被使用，不论是定义在静态可执行部分，还是在动态目标文件中。这是通过符号抢占(symbol preemption)来实现的。动态加载器构建符号表，所有的动态符号根据该符号表被决议。所以正常情况下，如果一个符号实例出现在动态库（DSO）中，但是已经在静态可执行文件或者之前加载的动态库中被定义，那么以前的定义也将被用于当前的动态库中。</p>
<blockquote>
<p>Binds references to all global symbols in a program to the definitions within a user’s shared library.</p>
</blockquote>
<p>链接器选项<code>-Bsymbolic</code>可以与<code>-shared</code>一起使用。 ld -shared -Bsymbolic与-pie非常相似。</p>
<p><code>-Bsymbolic</code>遵循ELF DF_SYMBOLIC语义：所有定义的符号都是不可抢占的，优先使用本地符号</p>
<h2 id="Wl-Bsymbolic"><a href="#Wl-Bsymbolic" class="headerlink" title="-Wl,-Bsymbolic"></a>-Wl,-Bsymbolic</h2><blockquote>
<p>-Wl,option<br>  Pass option as an option to the linker. If option contains commas, it is split into multiple options at the commas. You can use this syntax to pass an argument to the option. For example, -Wl,-Map,output.map passes -Map output.map to the linker. When using the GNU linker, you can also get the same effect with -Wl,-Map&#x3D;output.map.</p>
<blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9nY2MuZ251Lm9yZy9vbmxpbmVkb2NzL2djYy9MaW5rLU9wdGlvbnMuaHRtbCNMaW5rLU9wdGlvbnM=">https://gcc.gnu.org/onlinedocs/gcc/Link-Options.html#Link-Options<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
</blockquote>
<p><code>-Wl,-Bsymbolic</code>其中Wl表示将紧跟其后的参数，传递给连接器ld。<code>Bsymbolic</code>表示强制采用本地的全局变量定义，这样就不会出现动态链接库的全局变量定义被应用程序&#x2F;动态链接库中的同名定义给覆盖了</p>
<p>最开始的错误，可能是由于某一个全局对象生成相同的符号表后，在程序进行free时，多次free造成的。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9tYXNrcmF5Lm1lL2Jsb2cvMjAyMS0wNS0xNi1lbGYtaW50ZXJwb3NpdGlvbi1hbmQtYnN5bWJvbGlj">ELF interposition and -Bsymbolic<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9mbGFtZWV5ZXMuYmxvZy8yMDEyLzEwLzA3L3N5bWJvbGlzbS1hbmQtZWxmLWZpbGVzLW9yLXdoYXQtZG9lcy1ic3ltYm9saWMtZG8v">Symbolism and ELF files (or, what does -Bsymbolic do?)<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9zb2Z0d2FyZS5pbnRlbC5jb20vY29udGVudC93d3cvdXMvZW4vZGV2ZWxvcC9kb2N1bWVudGF0aW9uL2NwcC1jb21waWxlci1kZXZlbG9wZXItZ3VpZGUtYW5kLXJlZmVyZW5jZS90b3AvY29tcGlsZXItcmVmZXJlbmNlL2NvbXBpbGVyLW9wdGlvbnMvY29tcGlsZXItb3B0aW9uLWRldGFpbHMvbGlua2luZy1vci1saW5rZXItb3B0aW9ucy9ic3ltYm9saWMuaHRtbCNic3ltYm9saWM=">Bsymbolic<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTk2NDk2Mi9hcnRpY2xlL2RldGFpbHMvMTA3MjA5OTUw">Option -Bsymbolic 会导致严重副作用<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vdGN4YS9wLzE0ODEzMzcyLmh0bWw=">解决动态库的符号冲突<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>编译工具</category>
      </categories>
      <tags>
        <tag>gcc</tag>
        <tag>bsymbolic</tag>
      </tags>
  </entry>
  <entry>
    <title>`GLIBCXX_3.4.21&#39; not found</title>
    <url>/post/851846f4.html</url>
    <content><![CDATA[<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/lib64/libstdc++.so.6: version `GLIBCXX_3.4.21&#x27; not found (required by /usr/local/bin/a.out)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>程序运行是加载的<code>libstdc++</code>库版本低， 解决方法直接升级gcc版本</p>
</blockquote>
<span id="more"></span>

<h2 id="检查引用库GLIBCXX版本"><a href="#检查引用库GLIBCXX版本" class="headerlink" title="检查引用库GLIBCXX版本"></a>检查引用库GLIBCXX版本</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">strings /usr/lib64/libstdc++.so.6|grep GLIBCXX</span></span><br><span class="line">GLIBCXX_3.4</span><br><span class="line">GLIBCXX_3.4.1</span><br><span class="line">GLIBCXX_3.4.2</span><br><span class="line">GLIBCXX_3.4.3</span><br><span class="line">GLIBCXX_3.4.4</span><br><span class="line">GLIBCXX_3.4.5</span><br><span class="line">GLIBCXX_3.4.6</span><br><span class="line">GLIBCXX_3.4.7</span><br><span class="line">GLIBCXX_3.4.8</span><br><span class="line">GLIBCXX_3.4.9</span><br><span class="line">GLIBCXX_3.4.10</span><br><span class="line">GLIBCXX_3.4.11</span><br><span class="line">GLIBCXX_3.4.12</span><br><span class="line">GLIBCXX_3.4.13</span><br><span class="line">GLIBCXX_3.4.14</span><br><span class="line">GLIBCXX_3.4.15</span><br><span class="line">GLIBCXX_3.4.16</span><br><span class="line">GLIBCXX_3.4.17</span><br><span class="line">GLIBCXX_3.4.18</span><br><span class="line">GLIBCXX_3.4.19</span><br><span class="line">GLIBCXX_DEBUG_MESSAGE_LENGTH</span><br></pre></td></tr></table></figure>

<h2 id="CentOS升级gcc"><a href="#CentOS升级gcc" class="headerlink" title="CentOS升级gcc"></a>CentOS升级gcc</h2><h3 id="安装gcc9"><a href="#安装gcc9" class="headerlink" title="安装gcc9"></a>安装gcc9</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum -y install centos-release-scl</span><br><span class="line">yum -y install devtoolset-9-gcc devtoolset-9-gcc-c++</span><br></pre></td></tr></table></figure>
<blockquote>
<p>可以安装多个版本，使用时自由切换</p>
</blockquote>
<h3 id="切换gcc版本"><a href="#切换gcc版本" class="headerlink" title="切换gcc版本"></a>切换gcc版本</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scl enable devtoolset-9 bash</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">或</span></span><br><span class="line">source /opt/rh/devtoolset-3/enable</span><br></pre></td></tr></table></figure>

<h3 id="libstdc"><a href="#libstdc" class="headerlink" title="libstdc++"></a>libstdc++</h3><p>安装后的文件：<code>/opt/rh/devtoolset-9/root/usr/lib/gcc/x86_64-redhat-linux/9/libstdc++.so</code></p>
<h2 id="程序运行时加载库的流程"><a href="#程序运行时加载库的流程" class="headerlink" title="程序运行时加载库的流程"></a>程序运行时加载库的流程</h2><p>升级完成gcc后，切换到高版本进行编译后，可以正常运行，但是此时系统中存在多个<code>libstdc++</code>库，它是如何找到那个高版本库加载的？</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ldd /usr/local/bin/a.out | grep c++</span></span><br><span class="line">	libstdc++.so.6 =&gt; /lib64/libstdc++.so.6 (0x00007fab09a88000)</span><br></pre></td></tr></table></figure>
<p>ldd查看其依赖库依然是<code>/lib64/libstdc++.so.6</code>，这个gcc低版本库，正常应该是不能运行的，但是此时程序运行是正常的（使用系统默认gcc编译后无法正常运行）。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">strings /opt/rh/devtoolset-9/root/usr/lib/gcc/x86_64-redhat-linux/9/libstdc++.so</span><br><span class="line">/* GNU ld script</span><br><span class="line">   Use the shared library, but some functions are only in</span><br><span class="line">   the static library, so try that secondarily.  */</span><br><span class="line">OUTPUT_FORMAT(elf64-x86-64)</span><br><span class="line">INPUT ( /usr/lib64/libstdc++.so.6 -lstdc++_nonshared )</span><br></pre></td></tr></table></figure>
<p>通过<code>strings</code>查看该库时，发现以上信息。个人理解应该是再切换了编译器后，在编译时将部分代码结构，以静态的方式直接编译到了可执行程序中，这样在运行时即使加载旧的<code>libstdc++</code>库，也可以正常运行。</p>
]]></content>
      <categories>
        <category>编译工具</category>
      </categories>
      <tags>
        <tag>gcc</tag>
      </tags>
  </entry>
  <entry>
    <title>meson构建系统</title>
    <url>/post/28042.html</url>
    <content><![CDATA[<p>转载：<span class="exturl" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNTgzNzc2NC9hdXRvdG9vbHMtdnMtY21ha2UtZm9yLWJvdGgtd2luZG93cy1hbmQtbGludXgtY29tcGlsYXRpb24=">https://stackoverflow.com/questions/5837764/autotools-vs-cmake-for-both-windows-and-linux-compilation<i class="fa fa-external-link-alt"></i></span></p>
<span id="more"></span>

<p><strong>Meson</strong></p>
<p>Pros:</p>
<ul>
<li>The DSL does not get in the way at all. In fact, it is very nice and familiar, based in python.</li>
<li>Well-thought cross compilation support.</li>
<li>The objects are all strongly typed: you cannot make string  substitution mistakes easily, since objects are entities such as  ‘depencency’, ‘include directory’, etc.</li>
<li>It is very obviuos how to add a module for one of your tools.</li>
<li>Cross-compilation seems more straightforward to use.</li>
<li>Really well-thought. The designer and main writer of Meson knows what  he talks about very well when designing a build system.</li>
<li>Very, very fast, especially in incremental builds.</li>
<li>The documentation is 10 times better that what you can find in cmake. Go visit <span class="exturl" data-url="aHR0cDovL21lc29uYnVpbGQuY29tLw==">http://mesonbuild.com<i class="fa fa-external-link-alt"></i></span> and you will find tutorial, howtos and a good reference. It is not perfect but it is really discoverable.</li>
</ul>
<p>Cons:</p>
<ul>
<li>Not as mature as CMake, though, I consider it already fully usable for C++.</li>
<li>Not so many modules available, though, gnome, qt and the common ones are already there.</li>
<li>Project generators: seems VS generator is not working that well as of now. CMake project generators are far more mature.</li>
<li>Has a python3 + ninja dependency.</li>
</ul>
<p><strong>Cmake</strong></p>
<p>Pros:</p>
<ul>
<li>Generates projects for many different IDEs. This is a <em>very</em> nice feature for teams.</li>
<li>Plays well with windows tools, unlike autotools.</li>
<li>Mature, almost de-facto standard.</li>
<li>Microsoft is working on CMake integration for Visual Studio.</li>
</ul>
<p>Cons:</p>
<ul>
<li>It does not follow any well known standard or guidelines.</li>
<li>No uninstall target.</li>
<li>The DSL is weird, when you start to do comparisons and such, and the  strings vs list thing or escape chars, you will make many mistakes, I  am pretty sure.</li>
<li>Cross compilation sucks.</li>
</ul>
<p><strong>Autotools</strong></p>
<p>Pros:</p>
<ul>
<li>Most powerful system for cross-compilation, IMHO.</li>
<li>The generated scripts don’t need anything else than make, a shell and, if you need it to build, a compiler.</li>
<li>The command-line is really nice and consistent.</li>
<li>A standard in unix world, lots of docs.</li>
<li>Really powerful command-line: changing directories of installation, uninstall, renaming binaries…</li>
<li>If you target unix, packaging sources with this tool is really convenient.</li>
</ul>
<p>Cons:</p>
<ul>
<li>It won’t play well with microsoft tools. A real showstopper.</li>
<li>The learning curve is… well… But actually I can say that CMake was not that easy either.</li>
<li>The use of recursive make is pervasive in legacy projects. Automake <span class="exturl" data-url="aHR0cHM6Ly9hdXRvdG9vbHMuaW8vYXV0b21ha2Uvbm9ucmVjdXJzaXZlLmh0bWw=">supports non-recursive builds<i class="fa fa-external-link-alt"></i></span>, but it’s not a very widely used approach.</li>
</ul>
<p>About the learning curve, there are two very good sources to learn from:</p>
<ul>
<li>The website <span class="exturl" data-url="aHR0cHM6Ly93d3cuZmxhbWVleWVzLmV1L2F1dG90b29scy1teXRoYnVzdGVyLw==">here<i class="fa fa-external-link-alt"></i></span></li>
<li>The book <span class="exturl" data-url="aHR0cDovL3d3dy5ub3N0YXJjaC5jb20vYXV0b3Rvb2xzLmh0bQ==">here<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p>The first source will get you up and running faster. The book is a more in-depth discussion.</p>
<p>From Scons, waf and tup, Scons and tup are more like make. Waf is  more like CMake and the autotools. I tried waf instead of cmake at  first. I think it is overengineered in the sense that it has a full OOP  API. The scripts didn’t look short at all and it was really confusing  for me the working directory stuff and related things. At the end, I  found that autotools and CMake are a better choice. My favourite from  these 3 build systems is tup.</p>
<p><strong>Tup</strong></p>
<p>Pros</p>
<ul>
<li>Really correct.</li>
<li><strong>Insanely fast</strong>. You should try it to believe it.</li>
<li>The scripting language relies on a very easy idea that can be understood in 10 minutes.</li>
</ul>
<p>Cons</p>
<ul>
<li>It does not have a full-featured config framework.</li>
<li>I couldn’t find the way to make targets such as <code>doc</code>,  since  they generate files I don’t know of and they must be listed in the  output before being generated, or at least, that’s my conclusion for  now. This was a really annoying limitation, if it is, since I am not  sure.</li>
</ul>
<p>All in all, the only things I am considering right now for new  projects is are Cmake and Meson. When I have a chance I will try tup  also, but it lacks the config framework, which means that it makes  things more complex when you need all of that stuff. On the other hand,  it is really fast.</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9tZXNvbmJ1aWxkLmNvbS9Db21wYXJpc29ucy5odG1s">Comparing Meson with other build systems<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9tZXNvbmJ1aWxkLmNvbS9TaW1wbGUtY29tcGFyaXNvbi5odG1s">A simple comparison for meson<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>编译工具</category>
      </categories>
      <tags>
        <tag>meson</tag>
        <tag>build</tag>
      </tags>
  </entry>
  <entry>
    <title>meson编译规则</title>
    <url>/post/434f8def.html</url>
    <content><![CDATA[<p>在meson编译的项目中添加修改编译规则</p>
<span id="more"></span>


<h2 id="添加依赖库"><a href="#添加依赖库" class="headerlink" title="添加依赖库"></a>添加依赖库</h2><p>添加OpenGL依赖库示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">libgl_dep = dependency(&#x27;GL&#x27;)</span><br><span class="line"></span><br><span class="line">test_sources = [</span><br><span class="line">   &#x27;test.c&#x27;,</span><br><span class="line">   &#x27;test.h&#x27;,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">test = executable(</span><br><span class="line">   &#x27;test.out&#x27;,</span><br><span class="line">   test_sources,</span><br><span class="line">   dependencies : [libsdl_dep, libgl_dep],</span><br><span class="line">   install : true</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h2 id="Built-in-options"><a href="#Built-in-options" class="headerlink" title="Built-in options"></a>Built-in options</h2><blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9tZXNvbmJ1aWxkLmNvbS9CdWlsdGluLW9wdGlvbnMuaHRtbA==">https://mesonbuild.com/Builtin-options.html<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<ul>
<li><code>b_vscrt</code>: 为工程在window下通过mesa使用MSVC进行编译,如<code>-Db_vscrt=mtd</code></li>
</ul>
<h3 id="Base-options"><a href="#Base-options" class="headerlink" title="Base options"></a>Base options</h3><table>
<thead>
<tr>
<th>Option</th>
<th>Default value</th>
<th>Possible values</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>b_vscrt</td>
<td>from_buildtype</td>
<td>none, md, mdd, mt, mtd, from_buildtype</td>
<td>VS runtime library to use (since 0.48.0)</td>
</tr>
</tbody></table>
<h2 id="Native-file-properties"><a href="#Native-file-properties" class="headerlink" title="Native file properties"></a>Native file properties</h2><blockquote>
<p>As of Meson 0.54.0, the <code>--native-file nativefile.ini</code> can contain:</p>
<ul>
<li>binaries</li>
<li>paths</li>
<li>properties</li>
</ul>
</blockquote>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9tZXNvbmJ1aWxkLmNvbS9SZWxlYXNlLW5vdGVzLWZvci0wLTU0LTAuaHRtbCNwYWdlLWRlc2NyaXB0aW9u">https://mesonbuild.com/Release-notes-for-0-54-0.html#page-description<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9tZXNvbmJ1aWxkLmNvbS9Db250cmlidXRpbmcuaHRtbCNwYWdlLWRlc2NyaXB0aW9u">https://mesonbuild.com/Contributing.html#page-description<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p>本机文件属性,这里主要是指定meson在配置阶段加载本机的文件路径.用到它是因为本机的llvm存在多个版本,meson配置阶段总是加载最高版本的llvm-config-10,而我想用相对低版本(llvm-config-8),通过meson<span class="exturl" data-url="aHR0cHM6Ly9tZXNvbmJ1aWxkLmNvbS8=">手册<i class="fa fa-external-link-alt"></i></span>可以通过<code>--native-file nativefile.ini</code>进行指定</p>
<p>版本大于<code>0.54.0</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash"><span class="built_in">ls</span> -lsh /usr/bin/llvm-config-10</span></span><br><span class="line">0 lrwxrwxrwx 1 root root 30 4月  20 13:12 /usr/bin/llvm-config-10 -&gt; ../lib/llvm-10/bin/llvm-config</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash"><span class="built_in">ls</span> -lsh /usr/bin/llvm-config-8</span></span><br><span class="line">0 lrwxrwxrwx 1 root root 29 3月  19 16:50 /usr/bin/llvm-config-8 -&gt; ../lib/llvm-8/bin/llvm-config</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash"><span class="built_in">ls</span> -lsh /usr/bin/llvm-config-7</span></span><br><span class="line">0 lrwxrwxrwx 1 root root 29 3月  23 18:59 /usr/bin/llvm-config-7 -&gt; ../lib/llvm-7/bin/llvm-config</span><br></pre></td></tr></table></figure>

<p><del>使用软链接修改<code>llvm-config</code>的路径测试,配置是依旧加载<code>llvm-config-10</code>,软连接方式不行</del></p>
<h3 id="nativefile-ini"><a href="#nativefile-ini" class="headerlink" title="nativefile.ini"></a>nativefile.ini</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[binaries]</span><br><span class="line">llvm-config = &#x27;/usr/lib/llvm-8/bin/llvm-config&#x27;</span><br></pre></td></tr></table></figure>

<h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">meson builddir/ --native-file nativefile.ini</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>编译工具</category>
      </categories>
      <tags>
        <tag>meson</tag>
        <tag>build</tag>
      </tags>
  </entry>
  <entry>
    <title>IGMP snooping 查询器</title>
    <url>/post/51576.html</url>
    <content><![CDATA[<p>igmp在本地网络上的<code>主机</code>和<code>路由器</code>之间传达组成员信息，路由器定时向所有主机组多播igmp查询。主机多播igmp报告报文以响应查询。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00:43:16.580029 IP (tos 0x0, ttl 1, id 0, offset 0, flags [DF], proto IGMP (2), length 28)</span><br><span class="line">     192.168.99.112 &gt; 224.0.0.1: igmp query v1</span><br><span class="line">00:43:17.460173 IP (tos 0xc0, ttl 1, id 0, offset 0, flags [DF], proto IGMP (2), length 32, options (RA))</span><br><span class="line">     192.168.99.64 &gt; 239.0.0.11: igmp v1 report 239.0.0.11</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="IGMPv1报文格式"><a href="#IGMPv1报文格式" class="headerlink" title="IGMPv1报文格式"></a>IGMPv1报文格式</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><br><span class="line">+---------------------------------------------------------------</span><br><span class="line">|Version| Type  |    Unused     |           Checksum            |</span><br><span class="line">+---------------------------------------------------------------</span><br><span class="line">|                         Group Address                         |</span><br><span class="line">+---------------------------------------------------------------</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th align="center">字段</th>
<th align="center">长度</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Version</td>
<td align="center">4比特</td>
<td align="left">IGMP版本号，在IGMPv1中应为0x1。</td>
</tr>
<tr>
<td align="center">Type</td>
<td align="center">4比特</td>
<td align="left">即IGMP报文类型： 1 &#x3D; Host Membership Query 主机成员查询; 2 &#x3D; Host Membership Report 主机成员报告</td>
</tr>
<tr>
<td align="center">Unused</td>
<td align="center">8比特</td>
<td align="left">未使用的字段，发送时必须填0，接收时忽略。</td>
</tr>
<tr>
<td align="center">Checksum</td>
<td align="center">16比特</td>
<td align="left">IGMP消息的校验和。该字段在进行校验计算时设为0。当传送报文的时候，必须计算该校验字并插入到该字段中去。当接收包的时候，该校验字必须在处理该包之前进行检验。</td>
</tr>
<tr>
<td align="center">Group Address</td>
<td align="center">32比特</td>
<td align="left">组播地址。</td>
</tr>
</tbody></table>
<blockquote>
<p>IGMPv1协议主要基于查询和响应机制完成组播组管理，支持查询和加入报文，处理过程与IGMPv2相同。IGMPv1与IGMPv2的不同之处是：主机离开组播组时不主动发送离开报文，收到查询消息后不反馈Report消息，待维护组成员关系的定时器超时后，路由器删除组记录。</p>
</blockquote>
<h2 id="协议栈结构"><a href="#协议栈结构" class="headerlink" title="协议栈结构"></a>协议栈结构</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+-------------------------------+</span><br><span class="line">|             IGMPv1            |</span><br><span class="line">+-------------------------------+</span><br><span class="line">|      IP (Protocol = 0x02)     |</span><br><span class="line">+-------------------------------+</span><br><span class="line">|              L2               |</span><br><span class="line">+-------------------------------+</span><br><span class="line">|              L1               |</span><br><span class="line">+-------------------------------+</span><br></pre></td></tr></table></figure>
<p>IGMPv1消息封装在<code>IP报文</code>中。IP头部的Protocol字段值为0x02，用来<code>标识数据部分封装了IGMP消息</code>。</p>
<p>IP报文头的目的地址字段用来标识该IGMP消息的目的接收端。IP报文头的TTL字段值为1，表示IGMP消息只在本地网段传播。</p>
<p>格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">                            +---------------------+------------------------+</span><br><span class="line">                            |type|code|   cksum   |       group addr       |</span><br><span class="line">                            +---------------------+------------------------+</span><br><span class="line">                            ^                                              ^</span><br><span class="line">                            |                                              |</span><br><span class="line">                            |                                              |</span><br><span class="line">                            +-------+                          +----------+</span><br><span class="line">                                    |                          |</span><br><span class="line">                                    |                          |</span><br><span class="line">+--------------------------------------------------------------+</span><br><span class="line">|                                   |                          |</span><br><span class="line">|              IP首部                |                          |</span><br><span class="line">|                                   |                          |</span><br><span class="line">+-----------------------------------+--------------------------+</span><br><span class="line">&lt;------------------------ IP数据包     -------------------------&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">igmp</span> &#123;</span></span><br><span class="line">  <span class="type">uint8_t</span> igmp_type;             <span class="comment">/* IGMP type */</span></span><br><span class="line">  <span class="type">uint8_t</span> igmp_code;             <span class="comment">/* routing code */</span></span><br><span class="line">  <span class="type">uint16_t</span> igmp_cksum;           <span class="comment">/* checksum */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">igmp_group</span>;</span>     <span class="comment">/* group address */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Message types, including version number.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IGMP_MEMBERSHIP_QUERY       0x11    <span class="comment">/* membership query         */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IGMP_V1_MEMBERSHIP_REPORT   0x12    <span class="comment">/* Ver. 1 membership report */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IGMP_V2_MEMBERSHIP_REPORT   0x16    <span class="comment">/* Ver. 2 membership report */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IGMP_V2_LEAVE_GROUP     0x17    <span class="comment">/* Leave-group message      */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IGMP_DVMRP          0x13    <span class="comment">/* DVMRP routing message    */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IGMP_PIM            0x14    <span class="comment">/* PIM routing message      */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IGMP_TRACE          0x15</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IGMP_MTRACE_RESP        0x1e    <span class="comment">/* traceroute resp.(to sender)*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IGMP_MTRACE         0x1f    <span class="comment">/* mcast traceroute messages  */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IGMP_MAX_HOST_REPORT_DELAY  10  <span class="comment">/* max delay for response to     */</span></span></span><br><span class="line">                        <span class="comment">/*  query (in seconds) according */</span></span><br><span class="line">                        <span class="comment">/*  to RFC1112                   */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IGMP_TIMER_SCALE        10  <span class="comment">/* denotes that the igmp code field */</span></span></span><br><span class="line">                        <span class="comment">/* specifies time in 10th of seconds */</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>&#x2F;usr&#x2F;include&#x2F;netinet&#x2F;igmp.h</p>
</blockquote>
<p><strong>校验</strong>：<code>TCP</code>、<code>UDP</code>、<code>ICMP</code>、<code>IGMP</code>包首部中的检验和都是针对整个包（首部和数据部分）做检验的。</p>
<h3 id="IGMP-MEMBERSHIP-QUERY"><a href="#IGMP-MEMBERSHIP-QUERY" class="headerlink" title="IGMP_MEMBERSHIP_QUERY"></a>IGMP_MEMBERSHIP_QUERY</h3><p>成员关系查询，RFC1075推荐多播路由器每<code>120秒</code>至少发布一次IGMP成员关系查询。把查询发给224.0.0.1组（所有主机组）。</p>
<h3 id="IGMP-HOST-MEMEBER-REPORT-amp-amp-IGMP-V2-MEMBERSHIP-REPORT"><a href="#IGMP-HOST-MEMEBER-REPORT-amp-amp-IGMP-V2-MEMBERSHIP-REPORT" class="headerlink" title="IGMP_HOST_MEMEBER_REPORT &amp;&amp; IGMP_V2_MEMBERSHIP_REPORT"></a>IGMP_HOST_MEMEBER_REPORT &amp;&amp; IGMP_V2_MEMBERSHIP_REPORT</h3><p>成员关系报告</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">uint16_t</span> <span class="title function_">cksum</span><span class="params">(<span class="type">void</span> *buf, <span class="type">size_t</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span> cksum = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> short_len = len / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; short_len; i++) &#123;</span><br><span class="line">        cksum += ((<span class="type">uint16_t</span>*)buf)[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (len % <span class="number">2</span>) &#123;</span><br><span class="line">        cksum += ((<span class="type">uint8_t</span>*)buf)[len - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    cksum = (cksum &gt;&gt; <span class="number">16</span>) + (cksum &amp; <span class="number">0xFFFF</span>);</span><br><span class="line">    cksum = cksum + (cksum &gt;&gt; <span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (~cksum &amp; <span class="number">0xFFFF</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>IP数据报的检验和：</p>
<p>为了计算一份数据报的I P检验和，首先把检验和字段置为0。然后，对首部中每个16 bit进行二进制反码求和（整个首部看成是由一串16 bit的字组成），结果存在检验和字段中。当收到一份I P数据报后，同样对首部中每个16 bit进行二进制反码的求和。由于接收方在计算过程中包含了发送方存在首部中的检验和，因此，如果首部在传输过程中没有发生任何差错，那么接收方计算的结果应该为全1。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">igmp</span> <span class="title">igmp</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">mgroup</span>, <span class="title">allhosts</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">dst</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Create socket */</span></span><br><span class="line">sockfd = socket(PF_INET, SOCK_RAW, IPPROTO_IGMP);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Multicast groups */</span></span><br><span class="line">mgroup.s_addr = inet_addr(<span class="string">&quot;0.0.0.0&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (mgroup.s_addr == INADDR_NONE) &#123;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;Invalid multicast group &#x27;0.0.0.0&#x27;&quot;</span>);</span><br><span class="line">     <span class="keyword">goto</span> fail;</span><br><span class="line"> &#125;</span><br><span class="line"> allhosts.s_addr = inet_addr(<span class="string">&quot;224.0.0.1&quot;</span>);</span><br><span class="line"> <span class="keyword">if</span> (allhosts.s_addr == INADDR_NONE) &#123;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;Invalid multicast group &#x27;224.0.0.1&#x27;&quot;</span>);</span><br><span class="line">     <span class="keyword">goto</span> fail;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/* IGMPv1 query */</span></span><br><span class="line"> igmp.igmp_type = IGMP_MEMBERSHIP_QUERY;</span><br><span class="line"> igmp.igmp_code = <span class="number">0</span>;</span><br><span class="line"> igmp.igmp_cksum = <span class="number">0</span>;</span><br><span class="line"> igmp.igmp_group = mgroup;</span><br><span class="line"> igmp.igmp_cksum = cksum(&amp;igmp, <span class="keyword">sizeof</span>(igmp));</span><br><span class="line"></span><br><span class="line"> <span class="comment">/* Destination */</span></span><br><span class="line"> dst.sin_family = AF_INET;</span><br><span class="line"> dst.sin_port = htons(<span class="number">0</span>);</span><br><span class="line"> dst.sin_addr = allhosts;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/* Transmit loop */</span></span><br><span class="line"> <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">     <span class="keyword">if</span> (sendto(sockfd, &amp;igmp, <span class="keyword">sizeof</span>(igmp), <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr*)&amp;dst, <span class="keyword">sizeof</span>(dst)) == <span class="number">-1</span>) &#123;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;Could not send IGMP query: %s&quot;</span>, strerror(errno));</span><br><span class="line">     &#125;</span><br><span class="line">     sleep(options-&gt;interval);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
  </entry>
  <entry>
    <title>网络-ping命令</title>
    <url>/post/51638.html</url>
    <content><![CDATA[<p>判断网络的连通性和延时情况，通常使用<code>ping</code>命令。</p>
<p>ping发送一个<code>ICMP回声请求</code>消息给目的地并报告是否收到所希望的<code>ICMP回声应答</code>。它是用来检查网络是否通畅或者网络连接速度的命令</p>
<span id="more"></span>

<h2 id="ping"><a href="#ping" class="headerlink" title="ping"></a>ping</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ping -help</span><br><span class="line">Usage: ping [-aAbBdDfhLnOqrRUvV64] [-c count] [-i interval] [-I interface]</span><br><span class="line">            [-m mark] [-M pmtudisc_option] [-l preload] [-p pattern] [-Q tos]</span><br><span class="line">            [-s packetsize] [-S sndbuf] [-t ttl] [-T timestamp_option]</span><br><span class="line">            [-w deadline] [-W timeout] [hop1 ...] destination</span><br><span class="line">Usage: ping -6 [-aAbBdDfhLnOqrRUvV] [-c count] [-i interval] [-I interface]</span><br><span class="line">             [-l preload] [-m mark] [-M pmtudisc_option]</span><br><span class="line">             [-N nodeinfo_option] [-p pattern] [-Q tclass] [-s packetsize]</span><br><span class="line">             [-S sndbuf] [-t ttl] [-T timestamp_option] [-w deadline]</span><br><span class="line">             [-W timeout] destination</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th align="center">参数</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">-c</td>
<td align="left">ping的次数</td>
</tr>
<tr>
<td align="center">-W</td>
<td align="left">一次ping的超时时间</td>
</tr>
<tr>
<td align="center">-s</td>
<td align="left">发送数据包的大小，默认为32字节，最大可以定义到65500字节</td>
</tr>
</tbody></table>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>网络上的机器都有唯一确定的IP地址，我们给目标IP地址发送一个数据包，对方就要返回一个同样大小的数据包，根据返回的数据包我们可以确定目标主机的存在，可以初步判断目标主机的操作系统等。</p>
<h2 id="数据包"><a href="#数据包" class="headerlink" title="数据包"></a>数据包</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--&gt; 28	26.646884	192.168.100.3	192.168.100.2	ICMP	98	Echo (ping) request  id=0xdc04, seq=0/0, ttl=64 (reply in 29)</span><br><span class="line">&lt;-- 29	26.646957	192.168.100.2	192.168.100.3	ICMP	98	Echo (ping) reply    id=0xdc04, seq=0/0, ttl=64 (request in 28）</span><br></pre></td></tr></table></figure>

<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><ul>
<li>判断本地tcp&#x2F;ip协议是否正常<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ping 127.0.0.1</span><br></pre></td></tr></table></figure></li>
<li>程序中判断网络连接情况<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAX_S_CONNECT_NUM; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (rIpList[i].valid == <span class="number">1</span>) &#123;</span><br><span class="line">        retry_num = <span class="number">5</span>;</span><br><span class="line">        <span class="built_in">memset</span>(cmd, <span class="number">0</span>, <span class="number">120</span> * <span class="keyword">sizeof</span>(<span class="type">char</span>));</span><br><span class="line">        <span class="built_in">sprintf</span>(cmd, <span class="string">&quot;ping %s -c 1 -W 1 &gt; /dev/null&quot;</span>, rIpList[i].ipstr);</span><br><span class="line">retry:</span><br><span class="line">        ret = system(cmd);</span><br><span class="line">        <span class="keyword">if</span> (ret != <span class="number">0</span> &amp;&amp; retry_num) &#123;</span><br><span class="line">            retry_num--;</span><br><span class="line">            <span class="keyword">goto</span> retry;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ret != <span class="number">0</span> || !retry_num) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;ip: %s, disconnected retry:%d !!!\n&quot;</span>, rIpList[i].ipstr, retry_num);</span><br><span class="line">            VXLOG(<span class="string">&quot;ip: %s, disconnected retry:%d !!!\n&quot;</span>, rIpList[i].ipstr, retry_num);</span><br><span class="line">            rIpList[i].valid = <span class="number">0</span>;</span><br><span class="line">            alive--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
  </entry>
  <entry>
    <title>socket编程--网站</title>
    <url>/post/23509.html</url>
    <content><![CDATA[<p>一个有价值的网络编程的网站： <span class="exturl" data-url="aHR0cHM6Ly93d3cud2luc29ja2V0ZG90bmV0d29ya3Byb2dyYW1taW5nLmNvbS9jbGllbnRzZXJ2ZXJzb2NrZXRuZXR3b3JrY29tbXVuaWNhdGlvbjhjaGFwLmh0bWw=">https://www.winsocketdotnetworkprogramming.com/clientserversocketnetworkcommunication8chap.html<i class="fa fa-external-link-alt"></i></span></p>
<span id="more"></span>

<h2 id="The-Tenouk’s-Linux-Socket-network-programming-tutorial"><a href="#The-Tenouk’s-Linux-Socket-network-programming-tutorial" class="headerlink" title="The Tenouk’s Linux Socket (network) programming tutorial"></a>The Tenouk’s Linux Socket (network) programming tutorial</h2><p><span class="exturl" data-url="aHR0cHM6Ly93d3cudGVub3VrLmNvbS9jbmxpbnV4c29ja2V0dHV0b3JpYWxzLmh0bWw=">https://www.tenouk.com/cnlinuxsockettutorials.html<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="ORYX-embedded"><a href="#ORYX-embedded" class="headerlink" title="ORYX embedded"></a>ORYX embedded</h2><p><img data-src="/images/2018/08/net_layout.png" alt="net-layout"></p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cub3J5eC1lbWJlZGRlZC5jb20v">https://www.oryx-embedded.com<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<h3 id="相关协议源码"><a href="#相关协议源码" class="headerlink" title="相关协议源码"></a>相关协议源码</h3><blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cub3J5eC1lbWJlZGRlZC5jb20vZG9jL2ZpbGVzLmh0bWw=">源码目录<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<p><img data-src="/images/2018/08/net_protocol_code.png" alt="net-protocol-code"></p>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
  </entry>
  <entry>
    <title>RDMA的底层传输模式</title>
    <url>/post/53570e5e.html</url>
    <content><![CDATA[<p><img data-src="/images/2021/06/rdma_protocol.png" alt="rdma_protocol"></p>
<p>常见的RDMA实现有<code>InfiniBand (IB)</code>,<code>RDMA over Converged Etherent (RoCE)</code>以及<code>iWARP</code></p>
<span id="more"></span>

<h2 id="RDMA协议"><a href="#RDMA协议" class="headerlink" title="RDMA协议"></a>RDMA协议</h2><h3 id="InfiniBand"><a href="#InfiniBand" class="headerlink" title="InfiniBand"></a>InfiniBand</h3><p>InfiniBand (IB) 是一组高性能网络通信标准，由 InfiniBand Trade Association (IBTA) 制定并推动。InfiniBand 架构规范的 1.0 版本发布于 2000 年，其中原生地支持了 RDMA，大概也是最早的 RDMA 实现。然而，IB 架构并不兼容以太网，在部署时除了需要支持 IB 的网卡外，还需要购买相应的交换设备。</p>
<h3 id="RoCE"><a href="#RoCE" class="headerlink" title="RoCE"></a>RoCE</h3><p>RoCE 是基于以太网的 RDMA 标准，同样由 IBTA 制定，允许在以太网网络中实现远程直接内存访问。RoCE 有两个版本：<code>RoCE v1</code>与<code>RoCE v2</code>。RoCE v1 是链路层协议（L2），可以实现在同一广播域中任意两台主机之间的通信。RoCE v2 是网络层协议（L3），这意味着 RoCE v2 的数据包可以被路由，也就是说可以通过传统的以太网交换机来使用 RDMA。</p>
<p>RoCE v2 构筑于 UDP&#x2F;IP 协议之上，这种简单快乐的连接虽然保证了高性能与低 CPU 开销，但不能提供可靠传输。一种解决方案是，在 L2 对网络中的流传输进行控制，通过实现无损的以太网传输来保证数据传输的可靠性。另一种解决方案是增加 RoCE 协议的可靠性，向 RoCE 中添加握手，以牺牲性能为代价提供可靠性。业内似乎更倾向于第一种解决方案，即在不丢包的前提下，尽可能提高通信性能，或者说“拥塞控制”。随着大型企业将 RDMA 技术应用到数据中心，各种拥塞控制算法也在不断被提出，比如微软的 DCQCN，谷歌的 Swift，阿里的 HPCC… 其实有关数据中心的拥塞控制也是杀意已决一直想写的话题，不过我还是不给自己挖坑了（喂喂…</p>
<h3 id="iWARP"><a href="#iWARP" class="headerlink" title="iWARP"></a>iWARP</h3><p>iWARP 是基于 TCP&#x2F;IP 协议、面向连接的 RDMA 传输。由 IEFT 在 2007 年提出。与 RoCE v2 一样，iWARP 数据包可以路由，但在大规模数据中心或大规模应用程序中使用 iWARP 时，大量的 TCP 连接与可靠传输将导致凄惨的性能，在此也不打算过多介绍。牙膏厂曾写过一篇名为“Understanding iWARP”的文章，各位可以访问这里参详。</p>
<h2 id="协议对比"><a href="#协议对比" class="headerlink" title="协议对比"></a>协议对比</h2><h3 id="RoCEv2-vs-InfiniBand"><a href="#RoCEv2-vs-InfiniBand" class="headerlink" title="RoCEv2 vs InfiniBand"></a>RoCEv2 vs InfiniBand</h3><p>网络架构：InfiniBand 只能在 IB 架构规范中实现，RoCE 可以在以太网架构中实现。<br>链路级的流量控制：InfiniBand 使用一个积分算法（credit-based，不是 integral-based）来保证无损的 HCA-to-HCA 通信。RDMA 需要通过无损的 L2 网络（DCB: PFC + ECN）实现可靠的数据传输。<br>拥塞控制：InfiniBand 使用基于 FECN&#x2F;BECN 的拥塞控制，RoCE v2 定义了一个拥塞控制协议，通过 ECN 与 CNP 进行拥塞控制。</p>
<h3 id="RoCEv2-vs-RoCEv1"><a href="#RoCEv2-vs-RoCEv1" class="headerlink" title="RoCEv2 vs RoCEv1"></a>RoCEv2 vs RoCEv1</h3><p><img data-src="/images/2021/06/rdma_rocev1_vs_rocev2.png" alt="RDMA_rocev1_vs_rocev2"><br>路由：RoCE v1只能在广播域内通信，RoCE v2支持L3路由。</p>
<h3 id="iWARP-vs-RoCEv2"><a href="#iWARP-vs-RoCEv2" class="headerlink" title="iWARP vs RoCEv2"></a>iWARP vs RoCEv2</h3><p>底层：iWARP基于TCP&#x2F;IP协议，RoCE v2基于UDP&#x2F;IP协议。<br>iWARP 支持传输层的拥塞控制。<br>不需要无损的L2网络。<br>性能表现可能会比RoCE糟糕。</p>
<h2 id="链路层模式"><a href="#链路层模式" class="headerlink" title="链路层模式"></a>链路层模式</h2><p>链路层主要分为两类：<code>InfiniBand</code>和<code>Ethernet</code></p>
<p>查看链路类型</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># ibstat</span><br><span class="line">CA &#x27;mlx4_0&#x27;</span><br><span class="line">	CA type: MT4099</span><br><span class="line">	Number of ports: 1</span><br><span class="line">	Firmware version: 2.36.5000</span><br><span class="line">	Hardware version: 1</span><br><span class="line">	Node GUID: 0x001e670300bd84ec</span><br><span class="line">	System image GUID: 0x001e670300bd84ef</span><br><span class="line">	Port 1:</span><br><span class="line">		State: Down</span><br><span class="line">		Physical state: Disabled</span><br><span class="line">		Rate: 10</span><br><span class="line">		Base lid: 0</span><br><span class="line">		LMC: 0</span><br><span class="line">		SM lid: 0</span><br><span class="line">		Capability mask: 0x00010000</span><br><span class="line">		Port GUID: 0x021e67fffebd84ed</span><br><span class="line">		Link layer: Ethernet</span><br></pre></td></tr></table></figure>

<h2 id="InfiniBand与Ethernet之间的区别"><a href="#InfiniBand与Ethernet之间的区别" class="headerlink" title="InfiniBand与Ethernet之间的区别"></a>InfiniBand与Ethernet之间的区别</h2><ul>
<li>InfiniBand模式的延时更低，带宽更高<ul>
<li>ConnectX-4 Lx EN （Ethernet）提供 1、10、25、40 和50GbE带宽、<code>亚微秒级延迟</code></li>
<li>ConnectX-5 具备 Virtual Protocol Interconnect®,支持具有 100Gb&#x2F;s InfiniBand 和以太网连接、小于<code>600纳秒的延迟</code></li>
</ul>
</li>
<li>InfiniBand采用Cut-Through转发模式，减少转发时延，基于Credit流控机制，保证无丢包。RoCE性能与IB网络相当，DCB特性保证无丢包，需要网络支持DCB特性，但时延比IB交换机时延稍高一些</li>
<li>Ethernet模式可能存在丢包，而导致数据重传的延时</li>
</ul>
<h2 id="InfiniBand与Ethernet链路层切换"><a href="#InfiniBand与Ethernet链路层切换" class="headerlink" title="InfiniBand与Ethernet链路层切换"></a>InfiniBand与Ethernet链路层切换</h2><p>通过<code>ibstatus</code>命令可以查看当前网卡的工作模式</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Infiniband device &#x27;mlx5_1&#x27; port 1 status:</span><br><span class="line">	default gid:	 fe80:0000:0000:0000:0e42:a1ff:fe41:2d37</span><br><span class="line">	base lid:	 0x0</span><br><span class="line">	sm lid:		 0x0</span><br><span class="line">	state:		 4: ACTIVE</span><br><span class="line">	phys state:	 5: LinkUp</span><br><span class="line">	rate:		 25 Gb/sec (1X EDR)</span><br><span class="line">	link_layer:	 Ethernet    （工作模式：IP模式）</span><br></pre></td></tr></table></figure>
<blockquote>
<p>网卡现在处于<code>Ethernet</code>的工作模式，如果想要切换成<code>infiniband</code>模式</p>
</blockquote>
<p>参考：<span class="exturl" data-url="aHR0cHM6Ly9jb21tdW5pdHkubWVsbGFub3guY29tL3MvYXJ0aWNsZS9ob3d0by1jaGFuZ2UtcG9ydC10eXBlLWluLW1lbGxhbm94LWNvbm5lY3R4LTMtYWRhcHRlcg==">https://community.mellanox.com/s/article/howto-change-port-type-in-mellanox-connectx-3-adapter<i class="fa fa-external-link-alt"></i></span></p>
<p>ConnectX®-5 端口可以单独配置为用作<code>InfiniBand</code>或<code>Ethernet</code>端口，使用命令<code>mlxconfig</code></p>
<h3 id="启动mst工具"><a href="#启动mst工具" class="headerlink" title="启动mst工具"></a>启动mst工具</h3><p>需要安装官方驱动，以下配置用于ConnectX-4网卡。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl start mst</span><br></pre></td></tr></table></figure>
<p>查看mst设备</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">mst status</span></span><br><span class="line">MST modules:</span><br><span class="line">------------</span><br><span class="line">    MST PCI module is not loaded</span><br><span class="line">    MST PCI configuration module loaded</span><br><span class="line"></span><br><span class="line">MST devices:</span><br><span class="line">------------</span><br><span class="line">/dev/mst/mt4117_pciconf0         - PCI configuration cycles access.</span><br><span class="line">                                   domain:bus:dev.fn=0000:f7:00.0 addr.reg=88 data.reg=92 cr_bar.gw_offset=-1</span><br><span class="line">                                   Chip revision is: 00</span><br></pre></td></tr></table></figure>
<blockquote>
<p>MST devices: &#x2F;dev&#x2F;mst&#x2F;mt4117_pciconf0</p>
</blockquote>
<p>注：ConnectX-4网卡无法进行IB与eth模式之间切换，因为该网卡只支持Ethernet模式。只有VPI卡支持IB模式与以太网模式切换。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># lspci -s 02:00.0 -v</span><br><span class="line">02:00.0 Ethernet controller: Mellanox Technologies MT27710 Family [ConnectX-4 Lx]</span><br><span class="line">	Subsystem: Mellanox Technologies Stand-up ConnectX-4 Lx EN, 25GbE dual-port SFP28, PCIe3.0 x8, MCX4121A-ACAT</span><br><span class="line">	Physical Slot: 2</span><br><span class="line">	Flags: bus master, fast devsel, latency 0, IRQ 46, NUMA node 0</span><br><span class="line">	Memory at 38007a000000 (64-bit, prefetchable) [size=32M]</span><br><span class="line">	...</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code> ConnectX-4 Lx EN</code>:代表以太网卡，只支持Ethernet模式，ConnectX®-4 Lx EN 支持 RDMA、叠加 (Overlay) 网络封装&#x2F;解封等功能的1&#x2F;10&#x2F;25&#x2F;40&#x2F;50 Gb 以太网适配器卡<br> <span class="exturl" data-url="aHR0cHM6Ly93d3cubWVsbGFub3guY29tL2ZpbGVzL2RvYy0yMDIwL3BiLWNvbm5lY3R4LTQtbHgtZW4tY2FyZC5wZGY=">https://www.mellanox.com/files/doc-2020/pb-connectx-4-lx-en-card.pdf<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<h3 id="查看网卡的配置信息"><a href="#查看网卡的配置信息" class="headerlink" title="查看网卡的配置信息"></a>查看网卡的配置信息</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">mlxconfig -d /dev/mst/mt4117_pciconf0 q | grep <span class="string">&quot;LINK&quot;</span></span></span><br><span class="line">         KEEP_ETH_LINK_UP_P1                 True(1)</span><br><span class="line">         KEEP_IB_LINK_UP_P1                  False(0)</span><br><span class="line">         KEEP_LINK_UP_ON_BOOT_P1             False(0)</span><br><span class="line">         KEEP_LINK_UP_ON_STANDBY_P1          False(0)</span><br><span class="line">         AUTO_POWER_SAVE_LINK_DOWN_P1        False(0)</span><br><span class="line">         KEEP_ETH_LINK_UP_P2                 True(1)</span><br><span class="line">         KEEP_IB_LINK_UP_P2                  False(0)</span><br><span class="line">         KEEP_LINK_UP_ON_BOOT_P2             False(0)</span><br><span class="line">         KEEP_LINK_UP_ON_STANDBY_P2          False(0)</span><br><span class="line">         AUTO_POWER_SAVE_LINK_DOWN_P2        False(0)</span><br></pre></td></tr></table></figure>

<h3 id="ConnectX-5网卡"><a href="#ConnectX-5网卡" class="headerlink" title="ConnectX-5网卡"></a>ConnectX-5网卡</h3><blockquote>
<p>注： 以下命令适用于<code>ConnectX-5</code>，只有VPI卡支持模式切换</p>
</blockquote>
<p>例如：ConnectX®-5 VPI 卡 100Gb&#x2F;s InfiniBand 和以太网适配器卡</p>
<ul>
<li>Ethernet模式： <code>mlxconfig -d /dev/mst/mt4119_pciconf0 set LINK_TYPE_P1=2</code></li>
<li>IB模式： <code>mlxconfig -d /dev/mst/mt4119_pciconf0 set LINK_TYPE_P1=1</code></li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9wYy5uYW5vZy5vcmcvc3RhdGljL3B1Ymxpc2hlZC9tZWV0aW5ncy9OQU5PRzc2LzE5OTkvMjAxOTA2MTJfQ2FyZG9uYV9Ub3dhcmRzX0h5cGVyc2NhbGVfSGlnaF92MS5wZGY=">Towards Hyperscale High Performance Computing with RDMA<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuaW5maW5pYmFuZHRhLm9yZy9yb2NlLWFuZC1pbmZpbmliYW5kLXdoaWNoLXNob3VsZC1pLWNob29zZS8=">RoCE and InfiniBand: Which should I choose?<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dpdGh1Yl8zMzg3Mzk2OS9hcnRpY2xlL2RldGFpbHMvODMwMTc4MjA=">RDMA简介相关内容<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9teW1lbGxhbm94LmZvcmNlLmNvbS9tZWxsYW5veGNvbW11bml0eS9zL2FydGljbGUvaG93dG8tY29uZmlndXJlLXJvY2Utb24tY29ubmVjdHgtNA==">HowTo Configure RoCE on ConnectX-4<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLm1lbGxhbm94LmNvbS9wYWdlcy92aWV3cGFnZS5hY3Rpb24/cGFnZUlkPTM5Mjg0OTMw">RDMA over Converged Ethernet (RoCE)<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9jb21tdW5pdHkubWVsbGFub3guY29tL3MvYXJ0aWNsZS9yZG1hLXJvY2Utc29sdXRpb25z">RDMA&#x2F;RoCE Solutions<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9jb21tdW5pdHkubWVsbGFub3guY29tL3MvYXJ0aWNsZS9yZWNvbW1lbmRlZC1uZXR3b3JrLWNvbmZpZ3VyYXRpb24tZXhhbXBsZXMtZm9yLXJvY2UtZGVwbG95bWVudA==">Recommended Network Configuration Examples for RoCE Deployment<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9sZW5vdm9wcmVzcy5jb20vbHAwMDk4LnBkZg==">Mellanox ConnectX-4 Adapters<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
        <tag>rdma</tag>
      </tags>
  </entry>
  <entry>
    <title>RDMA编程——IBV Verbs</title>
    <url>/post/e0456c40.html</url>
    <content><![CDATA[<span id="more"></span>

<h2 id="libibverbs"><a href="#libibverbs" class="headerlink" title="libibverbs"></a>libibverbs</h2><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2xpbnV4LXJkbWEvcmRtYS1jb3Jl">https://github.com/linux-rdma/rdma-core<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="libibverbs-utils"><a href="#libibverbs-utils" class="headerlink" title="libibverbs-utils"></a>libibverbs-utils</h2><p><span class="exturl" data-url="aHR0cHM6Ly93d3cubWFua2llci5jb20vcGFja2FnZS9saWJpYnZlcmJzLXV0aWxz">https://www.mankier.com/package/libibverbs-utils<i class="fa fa-external-link-alt"></i></span></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ibv_</span></span><br><span class="line">ibv_asyncwatch     ibv_devices        ibv_devinfo        ibv_rc_pingpong    ibv_srq_pingpong   ibv_uc_pingpong    ibv_ud_pingpong    ibv_xsrq_pingpong</span><br></pre></td></tr></table></figure>





<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLm52aWRpYS5jb20vbmV0d29ya2luZy9kaXNwbGF5L1JETUFBd2FyZVByb2dyYW1taW5ndjE3L1Byb2dyYW1taW5nK0V4YW1wbGVzK1VzaW5nK0lCVitWZXJicw==">Programming Examples Using IBV Verbs<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC81MDc4OTYyNA==">infiniband概念空间分析<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8zMzc0NjEwMzc=">InfiniBand简介和简单编程接口<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
        <tag>rdma</tag>
      </tags>
  </entry>
  <entry>
    <title>socket错误号</title>
    <url>/post/54884.html</url>
    <content><![CDATA[<p>socket编程中的出现的错误号基本含义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line">...</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    ret = sendto(fd, msg, msgLen, <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr*)&amp;un, size);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d sendto errno:%d\n&quot;</span>, getpid(), errno);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="错误号—errno"><a href="#错误号—errno" class="headerlink" title="错误号—errno"></a>错误号—errno</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NUM 135</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NUM; i++) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d: %s\n&quot;</span>, i, strerror(i));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>结果：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0: Success</span><br><span class="line">1: Operation not permitted</span><br><span class="line">2: No such file or directory</span><br><span class="line">3: No such process</span><br><span class="line">4: Interrupted system call</span><br><span class="line">5: Input/output error</span><br><span class="line">6: No such device or address</span><br><span class="line">7: Argument list too long</span><br><span class="line">8: Exec format error</span><br><span class="line">9: Bad file descriptor</span><br><span class="line">10: No child processes</span><br><span class="line">11: Resource temporarily unavailable</span><br><span class="line">12: Cannot allocate memory</span><br><span class="line">13: Permission denied</span><br><span class="line">14: Bad address</span><br><span class="line">15: Block device required</span><br><span class="line">16: Device or resource busy</span><br><span class="line">17: File exists</span><br><span class="line">18: Invalid cross-device link</span><br><span class="line">19: No such device</span><br><span class="line">20: Not a directory</span><br><span class="line">21: Is a directory</span><br><span class="line">22: Invalid argument</span><br><span class="line">23: Too many open files in system</span><br><span class="line">24: Too many open files</span><br><span class="line">25: Inappropriate ioctl for device</span><br><span class="line">26: Text file busy</span><br><span class="line">27: File too large</span><br><span class="line">28: No space left on device</span><br><span class="line">29: Illegal seek</span><br><span class="line">30: Read-only file system</span><br><span class="line">31: Too many links</span><br><span class="line">32: Broken pipe</span><br><span class="line">33: Numerical argument out of domain</span><br><span class="line">34: Numerical result out of range</span><br><span class="line">35: Resource deadlock avoided</span><br><span class="line">36: File name too long</span><br><span class="line">37: No locks available</span><br><span class="line">38: Function not implemented</span><br><span class="line">39: Directory not empty</span><br><span class="line">40: Too many levels of symbolic links</span><br><span class="line">41: Unknown error 41</span><br><span class="line">42: No message of desired type</span><br><span class="line">43: Identifier removed</span><br><span class="line">44: Channel number out of range</span><br><span class="line">45: Level 2 not synchronized</span><br><span class="line">46: Level 3 halted</span><br><span class="line">47: Level 3 reset</span><br><span class="line">48: Link number out of range</span><br><span class="line">49: Protocol driver not attached</span><br><span class="line">50: No CSI structure available</span><br><span class="line">51: Level 2 halted</span><br><span class="line">52: Invalid exchange</span><br><span class="line">53: Invalid request descriptor</span><br><span class="line">54: Exchange full</span><br><span class="line">55: No anode</span><br><span class="line">56: Invalid request code</span><br><span class="line">57: Invalid slot</span><br><span class="line">58: Unknown error 58</span><br><span class="line">59: Bad font file format</span><br><span class="line">60: Device not a stream</span><br><span class="line">61: No data available</span><br><span class="line">62: Timer expired</span><br><span class="line">63: Out of streams resources</span><br><span class="line">64: Machine is not on the network</span><br><span class="line">65: Package not installed</span><br><span class="line">66: Object is remote</span><br><span class="line">67: Link has been severed</span><br><span class="line">68: Advertise error</span><br><span class="line">69: Srmount error</span><br><span class="line">70: Communication error on send</span><br><span class="line">71: Protocol error</span><br><span class="line">72: Multihop attempted</span><br><span class="line">73: RFS specific error</span><br><span class="line">74: Bad message</span><br><span class="line">75: Value too large for defined data type</span><br><span class="line">76: Name not unique on network</span><br><span class="line">77: File descriptor in bad state</span><br><span class="line">78: Remote address changed</span><br><span class="line">79: Can not access a needed shared library</span><br><span class="line">80: Accessing a corrupted shared library</span><br><span class="line">81: .lib section in a.out corrupted</span><br><span class="line">82: Attempting to link in too many shared libraries</span><br><span class="line">83: Cannot exec a shared library directly</span><br><span class="line">84: Invalid or incomplete multibyte or wide character</span><br><span class="line">85: Interrupted system call should be restarted</span><br><span class="line">86: Streams pipe error</span><br><span class="line">87: Too many users</span><br><span class="line">88: Socket operation on non-socket</span><br><span class="line">89: Destination address required</span><br><span class="line">90: Message too long</span><br><span class="line">91: Protocol wrong type for socket</span><br><span class="line">92: Protocol not available</span><br><span class="line">93: Protocol not supported</span><br><span class="line">94: Socket type not supported</span><br><span class="line">95: Operation not supported</span><br><span class="line">96: Protocol family not supported</span><br><span class="line">97: Address family not supported by protocol</span><br><span class="line">98: Address already in use</span><br><span class="line">99: Cannot assign requested address</span><br><span class="line">100: Network is down</span><br><span class="line">101: Network is unreachable</span><br><span class="line">102: Network dropped connection on reset</span><br><span class="line">103: Software caused connection abort</span><br><span class="line">104: Connection reset by peer</span><br><span class="line">105: No buffer space available</span><br><span class="line">106: Transport endpoint is already connected</span><br><span class="line">107: Transport endpoint is not connected</span><br><span class="line">108: Cannot send after transport endpoint shutdown</span><br><span class="line">109: Too many references: cannot splice</span><br><span class="line">110: Connection timed out</span><br><span class="line">111: Connection refused</span><br><span class="line">112: Host is down</span><br><span class="line">113: No route to host</span><br><span class="line">114: Operation already in progress</span><br><span class="line">115: Operation now in progress</span><br><span class="line">116: Stale file handle</span><br><span class="line">117: Structure needs cleaning</span><br><span class="line">118: Not a XENIX named type file</span><br><span class="line">119: No XENIX semaphores available</span><br><span class="line">120: Is a named type file</span><br><span class="line">121: Remote I/O error</span><br><span class="line">122: Disk quota exceeded</span><br><span class="line">123: No medium found</span><br><span class="line">124: Wrong medium type</span><br><span class="line">125: Operation canceled</span><br><span class="line">126: Required key not available</span><br><span class="line">127: Key has expired</span><br><span class="line">128: Key has been revoked</span><br><span class="line">129: Key was rejected by service</span><br><span class="line">130: Owner died</span><br><span class="line">131: State not recoverable</span><br><span class="line">132: Operation not possible due to RF-kill</span><br><span class="line">133: Memory page has hardware error</span><br><span class="line">134: Unknown error 134</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="宏定义"><a href="#宏定义" class="headerlink" title="宏定义"></a>宏定义</h2><ul>
<li>include&#x2F;uapi&#x2F;asm-generic&#x2F;errno-base.h&#x2F;<span class="exturl" data-url="aHR0cHM6Ly9lbGl4aXIuYm9vdGxpbi5jb20vbGludXgvbGF0ZXN0L3NvdXJjZS9pbmNsdWRlL3VhcGkvYXNtLWdlbmVyaWMvZXJybm8tYmFzZS5o">_ASM_GENERIC_ERRNO_BASE_H<i class="fa fa-external-link-alt"></i></span></li>
<li>include&#x2F;uapi&#x2F;asm-generic&#x2F;errno.h&#x2F;<span class="exturl" data-url="aHR0cHM6Ly9lbGl4aXIuYm9vdGxpbi5jb20vbGludXgvbGF0ZXN0L3NvdXJjZS9pbmNsdWRlL3VhcGkvYXNtLWdlbmVyaWMvZXJybm8uaA==">_ASM_GENERIC_ERRNO_H<i class="fa fa-external-link-alt"></i></span><blockquote>
<p>Linux内核中的位置</p>
</blockquote>
</li>
</ul>
<h3 id="111：-ECONNREFUSED"><a href="#111：-ECONNREFUSED" class="headerlink" title="111： ECONNREFUSED"></a>111： ECONNREFUSED</h3><blockquote>
<p>A connect() on a stream socket found no one listening on the remote address.</p>
</blockquote>
<blockquote>
<p>From: <code>man connect</code></p>
</blockquote>
<ol>
<li><p>拒绝连接。一般发生在连接建立时</p>
<ul>
<li>拔服务器端网线测试，客户端设置keep alive时，recv较快返回0， 先收到ECONNREFUSED (Connection refused)错误码，其后都是ETIMEOUT。</li>
</ul>
</li>
<li><p>an error returned from connect(), so it can only occur in a client(if a client is defined as the party that initiates the connection</p>
</li>
</ol>
<blockquote>
<p>场景：使用UDP在进程间socket通信，<code>sendto</code>发送消息时，返回错误，错误号为<code>111</code>.</p>
</blockquote>
<p>对端的socket没有进行接收所致。</p>
<h3 id="115-EINPROGRESS"><a href="#115-EINPROGRESS" class="headerlink" title="115: EINPROGRESS"></a>115: EINPROGRESS</h3><blockquote>
<p>The socket is <code>nonblocking</code> and the connection cannot be completed immediately. It is possible to <code>select(2)</code> or <code>poll(2)</code> for completion by selecting the socket for <code>writing</code>. After select(2) indicates writability, use getsockopt(2) to read the SO_ERROR option at level SOL_SOCKET to determine whether connect() completed successfully (SO_ERROR is zero) or unsuccessfully (SO_ERROR is one of the usual error codes listed here, explaining the reason for the failure).</p>
</blockquote>
<blockquote>
<p>From: <code>man connect</code></p>
</blockquote>
<ul>
<li>非阻塞的socket，connect调用后立即返回，连接过程还在执行</li>
</ul>
<blockquote>
<p>场景： TCP连接中进行<code>connect</code>错误后，返回值：<code>-1</code>，错误号：<code>115</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">connect_timeout</span><span class="params">(<span class="type">int</span> fd, <span class="keyword">struct</span> sockaddr_in *addr, <span class="type">unsigned</span> <span class="type">int</span> wait_seconds)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">	<span class="type">socklen_t</span> addrlen = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_in);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (wait_seconds &gt; <span class="number">0</span>)</span><br><span class="line">		activate_nonblock(fd);	<span class="comment">//设为非阻塞</span></span><br><span class="line"></span><br><span class="line">	ret = connect(fd, (<span class="keyword">struct</span> sockaddr*)addr, addrlen);</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span> &amp;&amp; errno == EINPROGRESS) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">timeout</span>;</span></span><br><span class="line">		fd_set write_fdset;</span><br><span class="line"></span><br><span class="line">		FD_ZERO(&amp;write_fdset);</span><br><span class="line">		FD_SET(fd, &amp;write_fdset);</span><br><span class="line"></span><br><span class="line">		timeout.tv_sec = wait_seconds;</span><br><span class="line">		timeout.tv_usec = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">do</span> &#123;</span><br><span class="line">			ret = select(fd + <span class="number">1</span>, <span class="literal">NULL</span>, &amp;write_fdset, <span class="literal">NULL</span>, &amp;timeout);</span><br><span class="line">		&#125; <span class="keyword">while</span> (ret &lt; <span class="number">0</span> &amp;&amp; errno == EINTR);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">			ret = <span class="number">-1</span>;</span><br><span class="line">			errno = ETIMEDOUT;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%s:%d, select error[%d]:%s, ret=%d\n&quot;</span>, __func__, __LINE__, errno, strerror(errno), ret);</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%s:%d, select error[%d]:%s, ret=%d\n&quot;</span>, __func__, __LINE__, errno, strerror(errno), ret);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret == <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="type">int</span> err;</span><br><span class="line">			<span class="type">socklen_t</span> socklen = <span class="keyword">sizeof</span>(err);</span><br><span class="line">			ret = getsockopt(fd, SOL_SOCKET, SO_ERROR, &amp;err, &amp;socklen);</span><br><span class="line">			<span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;%s:%d, getsockopt error[%d]:%s, ret=%d\n&quot;</span>, __func__, __LINE__, errno, strerror(errno), ret);</span><br><span class="line">				<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (err == <span class="number">0</span>) &#123;</span><br><span class="line">				ret = <span class="number">0</span>; <span class="comment">//success</span></span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				errno = err;</span><br><span class="line">				ret = <span class="number">-1</span>;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;%s:%d, getsockopt error[%d]:%s, ret=%d\n&quot;</span>, __func__, __LINE__, errno, strerror(errno), ret);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (wait_seconds &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		deactivate_nonblock(fd);	<span class="comment">//设回阻塞</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">net_set_nonblocking</span><span class="params">(<span class="type">int</span> sock)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> flags, res;</span><br><span class="line"></span><br><span class="line">    flags = fcntl(sock, F_GETFL, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (flags &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        flags = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    res = fcntl(sock, F_SETFL, flags | O_NONBLOCK);</span><br><span class="line">    <span class="keyword">if</span> (res &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;fcntl return err:%d!\n&quot;</span>, res);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="4-EINTR"><a href="#4-EINTR" class="headerlink" title="4: EINTR"></a>4: EINTR</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    n = recv(new_fd, buff, <span class="number">500</span>, <span class="number">0</span>);</span><br><span class="line">&#125; <span class="keyword">while</span> (n &lt; <span class="number">0</span> &amp;&amp; errno == EINTR);</span><br></pre></td></tr></table></figure>

<h3 id="34-ERANGE"><a href="#34-ERANGE" class="headerlink" title="34: ERANGE"></a>34: ERANGE</h3><blockquote>
<p>#define	ERANGE		34	&#x2F;* Math result not representable *&#x2F;  结果无法表示</p>
</blockquote>
<p>在socket连接中，server端关闭了该连接</p>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>错误号</tag>
      </tags>
  </entry>
  <entry>
    <title>基于bonding实现网卡聚合</title>
    <url>/post/c9919005.html</url>
    <content><![CDATA[<p><code>bonding</code>是一个linux kernel的driver，加载了它以后，linux支持将多个物理网卡捆绑成一个虚拟的bond网卡</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">lsmod | grep bond</span></span><br><span class="line">bonding               155648  0</span><br></pre></td></tr></table></figure>

<p>利用bonding技术与交换机的端口动态聚合实现双网口的绑定</p>
<p><img data-src="/images/2021/06/%E7%BD%91%E5%8F%A3%E8%81%9A%E5%90%88bond.png" alt="网口聚合bond"></p>
<span id="more"></span>

<h2 id="bond模式"><a href="#bond模式" class="headerlink" title="bond模式"></a>bond模式</h2><table>
<thead>
<tr>
<th align="center">mode</th>
<th align="left">别名</th>
<th align="left">描述</th>
<th align="left">参数</th>
<th align="left">交换机</th>
</tr>
</thead>
<tbody><tr>
<td align="center">mode&#x3D;0</td>
<td align="left">mode&#x3D;balance-rr</td>
<td align="left">平衡抡循环策略，传输数据包顺序是依次传输，此模式提供负载平衡和容错能力</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="center">mode&#x3D;1</td>
<td align="left">mode&#x3D;active-backup</td>
<td align="left">主-备份策略，只有一个设备处于活动状态，当一个宕掉另一个马上由备份转换为主设备，其中一条线若断线，其他线路将会自动备援</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="center">mode&#x3D;2</td>
<td align="left">mode&#x3D;balance-xor</td>
<td align="left">平衡策略，基于指定的传输HASH策略传输数据包。缺省的策略是：(源MAC地址 XOR 目标MAC地址)% slave数量</td>
<td align="left">传输策略可以通过xmit_hash_policy选项指定</td>
<td align="left"></td>
</tr>
<tr>
<td align="center">mode&#x3D;3</td>
<td align="left">mode&#x3D;broadcast</td>
<td align="left">广播策略，在每个slave接口上传输每个数据包，此模式提供了容错能力</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="center">mode&#x3D;4</td>
<td align="left">mode&#x3D;802.3ad</td>
<td align="left">IEEE802.3ad 动态链接聚合（LACP）</td>
<td align="left">xmit_hash_policy选项从缺省的XOR策略改变到其他策略</td>
<td align="left">交换机支持IEEE 802.3ad动态链路聚合，及开启LACP功能</td>
</tr>
<tr>
<td align="center">mode&#x3D;5</td>
<td align="left">mode&#x3D;balance-tlb</td>
<td align="left">适配器传输负载均衡</td>
<td align="left"></td>
<td align="left">不需要交换机支持</td>
</tr>
<tr>
<td align="center">mode&#x3D;6</td>
<td align="left">mode&#x3D;balance-alb</td>
<td align="left">适配器适应性负载均衡</td>
<td align="left"></td>
<td align="left"></td>
</tr>
</tbody></table>
<p>注： 除了<code>balance-rr</code>模式外的其它bonding负载均衡模式一样，任何连接都不能使用多于一个接口的带宽。</p>
<h2 id="配置实例（802-3ad-x2F-mode4）"><a href="#配置实例（802-3ad-x2F-mode4）" class="headerlink" title="配置实例（802.3ad&#x2F;mode4）"></a>配置实例（802.3ad&#x2F;mode4）</h2><blockquote>
<p>802.3ad or 4</p>
<p>   IEEE 802.3ad Dynamic link aggregation.  Creates<br>   aggregation groups that share the same speed and<br>   duplex settings.  Utilizes all slaves in the active<br>   aggregator according to the 802.3ad specification.</p>
<p>   Slave selection for outgoing traffic is done according<br>   to the transmit hash policy, which may be changed from<br>   the default simple XOR policy via the xmit_hash_policy<br>   option, documented below.  Note that not all transmit<br>   policies may be 802.3ad compliant, particularly in<br>   regards to the packet mis-ordering requirements of<br>   section 43.2.4 of the 802.3ad standard.  Differing<br>   peer implementations will have varying tolerances for<br>   noncompliance.</p>
<p>   Prerequisites:</p>
<ol>
<li><p>Ethtool support in the base drivers for retrieving<br>   the speed and duplex of each slave.</p>
</li>
<li><p>A switch that supports IEEE 802.3ad Dynamic link<br>   aggregation.</p>
</li>
</ol>
<p>   Most switches will require some type of configuration<br>   to enable 802.3ad mode.</p>
<p>来自内核文档： <span class="exturl" data-url="aHR0cHM6Ly9lbGl4aXIuYm9vdGxpbi5jb20vbGludXgvbGF0ZXN0L3NvdXJjZS9Eb2N1bWVudGF0aW9uL25ldHdvcmtpbmcvYm9uZGluZy5yc3Q=">Documentation&#x2F;networking&#x2F;bonding.rst<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<h3 id="bond0"><a href="#bond0" class="headerlink" title="bond0"></a>bond0</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat /etc/sysconfig/network-scripts/ifcfg-bond0</span><br><span class="line">DEVICE=bond0</span><br><span class="line">NAME=bond0</span><br><span class="line">TYPE=Bond</span><br><span class="line">BONDING_MASTER=yes</span><br><span class="line">IPADDR=192.168.1.1</span><br><span class="line">PREFIX=24</span><br><span class="line">BOOTPROTO=none</span><br><span class="line">ONBOOT=yes</span><br><span class="line">NM_CONTROLLED=&quot;no&quot;</span><br></pre></td></tr></table></figure>

<h3 id="网卡eth1"><a href="#网卡eth1" class="headerlink" title="网卡eth1"></a>网卡eth1</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">cat</span> /etc/sysconfig/network-scripts/ifcfg-eth1</span></span><br><span class="line">TYPE=Ethernet</span><br><span class="line">DEVICE=eth1</span><br><span class="line">NAME=eth1</span><br><span class="line">ONBOOT=yes</span><br><span class="line">MASTER=bond0</span><br><span class="line">SLAVE=yes</span><br><span class="line">BOOTPROTO=none</span><br><span class="line">NM_CONTROLLED=&quot;no&quot;</span><br></pre></td></tr></table></figure>

<h3 id="网卡eth2"><a href="#网卡eth2" class="headerlink" title="网卡eth2"></a>网卡eth2</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">cat</span> /etc/sysconfig/network-scripts/ifcfg-eth2</span></span><br><span class="line">TYPE=Ethernet</span><br><span class="line">DEVICE=eth2</span><br><span class="line">NAME=eth2</span><br><span class="line">ONBOOT=yes</span><br><span class="line">MASTER=bond0</span><br><span class="line">SLAVE=yes</span><br><span class="line">BOOTPROTO=none</span><br><span class="line">NM_CONTROLLED=&quot;no&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li>重启网络或者bond0虚拟机网卡</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ifdown bond0 &amp;&amp; ifup bond0</span><br></pre></td></tr></table></figure>

<ul>
<li>查看bond0虚拟网卡信息</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat /proc/net/bonding/bond0</span><br></pre></td></tr></table></figure>

<h2 id="RDMA网卡"><a href="#RDMA网卡" class="headerlink" title="RDMA网卡"></a>RDMA网卡</h2><p>RoCE LAG是一种用于模拟IB设备的以太网绑定的功能，仅适用于双端口卡。部分网卡支持一下3种模式</p>
<ul>
<li>active-backup (mode 1)</li>
<li>balance-xor (mode 2)</li>
<li>802.3ad (LACP) (mode 4)</li>
</ul>
<blockquote>
<p>在mode4模式下，进行数据传输的始终只有一个端口，带宽与一个端口传输一样，但是将其中任意一个端口拔掉后，数据传输切换到另一个端口，实际业务不受影响。也是一种主备模式，在IB模式下只支持主备模式</p>
</blockquote>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><span class="exturl" data-url="aHR0cDovL2Jsb2cuc2luYS5jb20uY24vcy9ibG9nX2Q4M2Y5ZmM1MDEwMnY4ZmUuaHRtbA==">七种网卡绑定模式详解<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLm1lbGxhbm94LmNvbS9wYWdlcy92aWV3cGFnZS5hY3Rpb24/cGFnZUlkPTM5Mjg0OTMw">RDMA over Converged Ethernet (RoCE)<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9hY2Nlc3MucmVkaGF0LmNvbS9kb2N1bWVudGF0aW9uL2VuLXVzL3JlZF9oYXRfZW50ZXJwcmlzZV9saW51eC83L2h0bWwvbmV0d29ya2luZ19ndWlkZS9zZWMtbmV0d29ya19ib25kaW5nX3VzaW5nX3RoZV9jb21tYW5kX2xpbmVfaW50ZXJmYWNl">7.4. USING THE COMMAND LINE INTERFACE (CLI)<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9jb21tdW5pdHkubWVsbGFub3guY29tL3MvYXJ0aWNsZS9Ib3ctdG8tQ29uZmlndXJlLVJvQ0Utb3Zlci1MQUctQ29ubmVjdFgtNC1Db25uZWN0WC01LUNvbm5lY3RYLTY=">How to Configure RoCE over LAG (ConnectX-4&#x2F;ConnectX-5-&#x2F;ConnectX-6)<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9iYnMuaHVhd2VpY2xvdWQuY29tL2ZvcnVtL3RocmVhZC00MjIzNC0xLTEuaHRtbA==">双25GE网卡做bond4测试，其中一个网口没有流量一个网口可以打满的问题分享<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9tLmxpbnV4aWRjLmNvbS9MaW51eC8yMDExLTA1LzM1MzI2Lmh0bQ==">链路层的网卡聚合-基于Linux bonding<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网卡</tag>
        <tag>bond</tag>
        <tag>聚合</tag>
      </tags>
  </entry>
  <entry>
    <title>网络配置</title>
    <url>/post/18692.html</url>
    <content><![CDATA[<p>Linux系统中的相关网络配置问题</p>
<span id="more"></span>


<h2 id="网线不识别，网卡灯不亮"><a href="#网线不识别，网卡灯不亮" class="headerlink" title="网线不识别，网卡灯不亮"></a>网线不识别，网卡灯不亮</h2><blockquote>
<p>关闭网卡的自动协商功能，手动配置网卡速度和工作模式</p>
</blockquote>
<p>解决命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo ethtool -s enahisic2i0 autoneg off speed 100 duplex full</span><br></pre></td></tr></table></figure>
<h3 id="ethtool"><a href="#ethtool" class="headerlink" title="ethtool"></a>ethtool</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ethtool [-s] ethX [speed 10|100|1000] [duplex half|full] [autoneg on|off] [port tp|aui|bnc|mii] [phyad N]</span><br></pre></td></tr></table></figure>

<ul>
<li><code>-s</code>: 修改网卡的部分配置，包括网卡速度、单工&#x2F;全双工模式、mac地址等</li>
<li><code>autoneg on|off</code>: 设置网口是否自协商</li>
<li><code>duplex half|full</code>: 设置网口半&#x2F;全双工</li>
<li><code>speed 10|100|1000</code>: 设置网口速率10&#x2F;100&#x2F;1000M</li>
</ul>
<h2 id="netplan配置"><a href="#netplan配置" class="headerlink" title="netplan配置"></a>netplan配置</h2><p><img data-src="/images/2020/03/network_netplan.png" alt="network_netplan"></p>
<h3 id="图形界面网络管理配置"><a href="#图形界面网络管理配置" class="headerlink" title="图形界面网络管理配置"></a>图形界面网络管理配置</h3><p><code>NetworkManager</code>主要用于在桌面系统上管理网络设备。如果您使用<code>NetworkManager</code>作为网络设备管理的系统守护程序，将会使用 NetworkManager 的图形程序来管理网络接口。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># This file describes the network interfaces available on your system</span><br><span class="line"># For more information, see netplan(5).</span><br><span class="line">network:</span><br><span class="line">  version: 2</span><br><span class="line">  renderer: NetworkManager</span><br></pre></td></tr></table></figure>
<blockquote>
<p>File: &#x2F;etc&#x2F;netplan&#x2F;01-netcfg.yaml</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo netplan generate</span><br><span class="line">sudo netplan apply</span><br></pre></td></tr></table></figure>


<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3M/X19iaXo9TXpJM01USTJOemt4TUE9PSZtaWQ9MjI0NzQ4NDA4MCZpZHg9MSZzbj0zYzVjYTY2YTJkYzYzYzI4NWNhNmQyZGIzOWY3ZTU1MyZtcHNoYXJlPTEmc2NlbmU9MjMmc3JjaWQ9MDYxM0JmNktvSUN3NFhWcEk5Q1p6a0dFJTIzcmQ=">YAML语言教程<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
        <tag>network</tag>
      </tags>
  </entry>
  <entry>
    <title>KVM实现原理</title>
    <url>/post/633d906.html</url>
    <content><![CDATA[<p>KVM是一个基于Linux内核的虚拟机，它属于完全虚拟化范畴.</p>
<p>X86架构下的KVM实现，分为AMD的虚拟化技术AMD-V（<code>svm</code>）,Intel的虚拟化技术Intel-VT(<code>vmx</code>)</p>
<span id="more"></span>

<h2 id="虚拟化技术"><a href="#虚拟化技术" class="headerlink" title="虚拟化技术"></a>虚拟化技术</h2><h3 id="完全虚拟化：Full-Virtualization，Native-Virtualization"><a href="#完全虚拟化：Full-Virtualization，Native-Virtualization" class="headerlink" title="完全虚拟化：Full Virtualization，Native Virtualization"></a>完全虚拟化：Full Virtualization，Native Virtualization</h3><ul>
<li>全虚拟化为客户机提供了完整的虚拟X86平台， 包括处理器、 内存和外设， 支持运行任何理论上可在真实物理平台上运行的操作系统， 为虚拟机的配置提供了最大程度的灵活性。</li>
<li>全虚拟化对于虚拟机是无感知的，不清楚自己运行在虚拟化环境中。</li>
<li>CPU如果不支持硬件虚拟化技术：那么所有指令都是通过VMM虚拟的，通过VMM内的BT动态翻译技术把虚拟机要运行的特权指令转换为物理指令集，然后到CPU上运行。</li>
<li>CPU如果支持硬件虚拟化技术：VMM运行ring -1，而GuestOS运行在ring 0。</li>
</ul>
<blockquote>
<p>虚拟机： VMWare Workstation, VirtualBox, VMWare Server, qemu(hvm), XEN(hvm),Qemu_kvm</p>
</blockquote>
<h3 id="半虚拟化：Para-Virutalization"><a href="#半虚拟化：Para-Virutalization" class="headerlink" title="半虚拟化：Para-Virutalization"></a>半虚拟化：Para-Virutalization</h3><ul>
<li>半虚拟化需要对运行在虚拟机上的客户机操作系统进行修改（这些客户机操作系统会意识到它们运行在虚拟环境里）并提供相近的性能，但半虚拟化的性能要比完全虚拟化更优越。</li>
<li>半虚拟化对于虚拟机知道自己运行在虚拟化环境中。</li>
<li>虚拟机内核明确知道自己是运行在虚拟化之上的，对于硬件资源的使用不再需要BT而是自己向VMM申请使用，如对于内存或CPU的使用是直接向VMM申请使用，直接调用而非翻译。</li>
</ul>
<blockquote>
<p>虚拟机：xen</p>
</blockquote>
<h2 id="Qemu-KVM"><a href="#Qemu-KVM" class="headerlink" title="Qemu+KVM"></a>Qemu+KVM</h2><p>KVM主要分：CPU虚拟化、CPU调度原理、KVM内存管理、KVM存储管理、KVM设备管理</p>
<p><img data-src="/images/2021/03/qemu_kvm.png" alt="qemu_kvm"></p>
<ul>
<li>kvm:是硬件辅助的虚拟化技术，主要负责比较繁琐的cpu虚拟化和内存虚拟化</li>
<li>QEMU:负责IO设备虚拟化</li>
<li>VMM:虚拟机管理器（virtual machine monitor）在底层对其上的虚拟机的管理,提供虚拟机的创建和删除</li>
</ul>
<h3 id="CPU虚拟化"><a href="#CPU虚拟化" class="headerlink" title="CPU虚拟化"></a>CPU虚拟化</h3><p>Intel在处理器级别提供了对虚拟化技术的支持，被称为<code>VMX</code>（virtual-machine extensions）</p>
<p>VMX引入了两个操作模式进行CPU虚拟化：<code>VMX根操作</code>（root operation） 与<code>VMX非根操作</code>（non-root operation）</p>
<h3 id="内存虚拟化"><a href="#内存虚拟化" class="headerlink" title="内存虚拟化"></a>内存虚拟化</h3><p>内存虚拟化的目的是给虚拟客户机操作系统提供一个从0地址开始的连续物理内存空间，同时在多个客户机之间实现隔离和调度。在虚拟化环境中，内存地址的访问会主要涉及以下4个基础概念，</p>
<ol>
<li>客户机虚拟地址，GVA（Guest Virtual Address）</li>
<li>客户机物理地址，GPA（Guest Physical Address）</li>
<li>宿主机虚拟地址，HVA（Host Virtual Address）</li>
<li>宿主机物理地址，HPA（Host Physical Address）</li>
</ol>
<blockquote>
<p>内存虚拟化就是要将客户机虚拟地址（GVA）转化为最终能够访问的宿主机上的物理地址（HPA）</p>
</blockquote>
<h3 id="I-x2F-O虚拟化"><a href="#I-x2F-O虚拟化" class="headerlink" title="I&#x2F;O虚拟化"></a>I&#x2F;O虚拟化</h3><p>在虚拟化的架构下，虚拟机监控器必须支持来自客户机的I&#x2F;O请求。通常情况下有以下4种I&#x2F;O虚拟化方式。</p>
<ol>
<li>设备模拟：在虚拟机监控器中模拟一个传统的I&#x2F;O设备的特性，比如在QEMU中模拟一个Intel的千兆网卡或者一个IDE硬盘驱动器，在客户机中就暴露为对应的硬件设备。客户机中的I&#x2F;O请求都由虚拟机监控器捕获并模拟执行后返回给客户机。</li>
<li>前后端驱动接口：在虚拟机监控器与客户机之间定义一种全新的适合于虚拟化环境的交互接口，比如常见的virtio协议就是在客户机中暴露为virtio-net、virtio-blk等网络和磁盘设备，在QEMU中实现相应的virtio后端驱动。</li>
<li>设备直接分配：将一个物理设备，如一个网卡或硬盘驱动器直接分配给客户机使用，这种情况下I&#x2F;O请求的链路中很少需要或基本不需要虚拟机监控器的参与，所以性能很好。</li>
<li>设备共享分配：其实是设备直接分配方式的一个扩展。在这种模式下，一个（具有特定特性的）物理设备可以支持多个虚拟机功能接口，可以将虚拟功能接口独立地分配给不同的客户机使用。如SR-IOV就是这种方式的一个标准协议。</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3llYXJuNTIwL2FydGljbGUvZGV0YWlscy82NDYxMDQ3">KVM实现机制<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dob3N0cGFudC9hcnRpY2xlL2RldGFpbHMvMTEwODI1NDcy">KVM虚拟化技术原理简介<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>虚拟化</category>
      </categories>
      <tags>
        <tag>qemu</tag>
        <tag>kvm</tag>
      </tags>
  </entry>
  <entry>
    <title>qemu kvm参数配置解析</title>
    <url>/post/d2c5077b.html</url>
    <content><![CDATA[<p>Qemu参数配置</p>
<blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cucWVtdS5vcmcvZG9jcy9tYXN0ZXIvc3lzdGVtL2luZGV4Lmh0bWwj">QEMU System Emulation User’s Guide<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<span id="more"></span>
<h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><h3 id="端口转发"><a href="#端口转发" class="headerlink" title="端口转发"></a>端口转发</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-netdev user,id=mynet,hostfwd=tcp::550-:5555</span><br><span class="line">或</span><br><span class="line">-netdev user,id=n0,hostfwd=::1020-:20,hostfwd=::1021-:21 #多端口映射,使用逗号分割</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>hostfwd=[tcp|udp]:[hostaddr]:hostport-[guestaddr]:guestport</code>将进入到主机端口的TCP或者UDP连接转发到客户机的某个地址和端口</p>
</blockquote>
<p>这种方法可以在主机的qemu进程监听一个端口，主机可通过这个端口与客户机对应的端口通讯,相当于将客户机的端口映射到主机端.</p>
<h2 id="外设"><a href="#外设" class="headerlink" title="外设"></a>外设</h2><h3 id="声卡"><a href="#声卡" class="headerlink" title="声卡"></a>声卡</h3><p>qemu支持的声卡类型</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">qemu-system-x86_64 -soundhw <span class="built_in">help</span></span></span><br><span class="line">Valid sound card names (comma separated):</span><br><span class="line">sb16        Creative Sound Blaster 16</span><br><span class="line">es1370      ENSONIQ AudioPCI ES1370</span><br><span class="line">ac97        Intel 82801AA AC97 Audio</span><br><span class="line">adlib       Yamaha YM3812 (OPL2)</span><br><span class="line">gus         Gravis Ultrasound GF1</span><br><span class="line">cs4231a     CS4231A</span><br><span class="line">hda         Intel HD Audio</span><br><span class="line">pcspk       PC speaker</span><br><span class="line"></span><br><span class="line">-soundhw all will enable all of the above</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>-soundhw</code> option is now available for all targets that have a PCI bus.</p>
</blockquote>
<ul>
<li>PCI声卡:<code>ac97</code>,<code>hda</code>,<code>es1370</code></li>
</ul>
<h3 id="虚拟GPU"><a href="#虚拟GPU" class="headerlink" title="虚拟GPU"></a>虚拟GPU</h3><p>详细的配置参数</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">qemu-system-x86_64 -device <span class="built_in">help</span> | grep gpu</span></span><br><span class="line">name &quot;vhost-user-gpu&quot;, bus virtio-bus</span><br><span class="line">name &quot;vhost-user-gpu-pci&quot;, bus PCI</span><br><span class="line">name &quot;virtio-gpu-device&quot;, bus virtio-bus</span><br><span class="line">name &quot;virtio-gpu-pci&quot;, bus PCI, alias &quot;virtio-gpu&quot;</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">qemu-system-x86_64 -device virtio-gpu-device,<span class="built_in">help</span></span></span><br><span class="line">virtio-gpu-device options:</span><br><span class="line">  indirect_desc=&lt;bool&gt;   - on/off</span><br><span class="line">  yres=&lt;uint32&gt;</span><br><span class="line">  iommu_platform=&lt;bool&gt;  - on/off</span><br><span class="line">  stats=&lt;bool&gt;           - on/off</span><br><span class="line">  event_idx=&lt;bool&gt;       - on/off</span><br><span class="line">  edid=&lt;bool&gt;            - on/off</span><br><span class="line">  any_layout=&lt;bool&gt;      - on/off</span><br><span class="line">  max_hostmem=&lt;size&gt;</span><br><span class="line">  notify_on_empty=&lt;bool&gt; - on/off</span><br><span class="line">  use-started=&lt;bool&gt;</span><br><span class="line">  packed=&lt;bool&gt;          - on/off</span><br><span class="line">  virgl=&lt;bool&gt;           - on/off</span><br><span class="line">  max_outputs=&lt;uint32&gt;</span><br><span class="line">  xres=&lt;uint32&gt;</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmd5ZXppMTk5MzA5MjgvYXJ0aWNsZS9kZXRhaWxzLzUzMTU2MDU3">qemu-kvm 参数设置（多屏显示、图像压缩、声音压缩、USB重定向、添加agent）<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9xZW11LndlaWxuZXR6LmRlL2RvYy9xZW11LWRvYy5odG1s">QEMU version 4.2.0 User Documentation<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL2Jsb2cubGVhbm90ZS5jb20vcG9zdC83d2xuazEzLyVFNSU4OCU5QiVFNSVCQiVCQUtWTSVFOCU5OSU5QSVFNiU4QiU5RiVFNiU5QyVCQQ==">qemu-system-x86_64命令总结<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>虚拟化</category>
      </categories>
      <tags>
        <tag>qemu</tag>
        <tag>kvm</tag>
        <tag>虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title>Qemu虚拟机pci设备透传——网卡</title>
    <url>/post/b3396e6f.html</url>
    <content><![CDATA[<p>在qemu虚拟机中为了提高网络的性能，将本地host端的多余网卡透传到虚拟机中使用。</p>
<p>设备的透传需要主机支持<code>Intel(VT-d)</code>或<code>AMD (IOMMU)</code>硬件虚拟化加速技术</p>
<span id="more"></span>

<p><img data-src="/images/2020/09/qemu_net_passthrough.png" alt="qemu_net_passthrough"></p>
<h2 id="查看是否开启IOMMU"><a href="#查看是否开启IOMMU" class="headerlink" title="查看是否开启IOMMU"></a>查看是否开启IOMMU</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">dmesg | grep -e DMAR -e IOMMU</span><br></pre></td></tr></table></figure>

<h3 id="开启IOMMU功能"><a href="#开启IOMMU功能" class="headerlink" title="开启IOMMU功能"></a>开启IOMMU功能</h3><blockquote>
<p>操作系统：Centos7,cpu: Intel(R) Xeon(R)</p>
</blockquote>
<p>编辑<code>/boot/efi/EFI/centos/grub.cfg</code>文件，在系统启动内核的选项<code>linuxefi</code>中追加<code>intel_iommu=on</code></p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">&lt;       linuxefi /vmlinuz-3.10.0-1127.18.2.el7.x86_64 root=/dev/mapper/centos-root ro crashkernel=auto spectre_v2=retpoline rd.lvm.lv=centos/root rd.lvm.lv=centos/swap rhgb quiet LANG=en_US.UTF-8 intel_iommu=on</span><br><span class="line"><span class="comment">---</span></span><br><span class="line">&gt;       linuxefi /vmlinuz-3.10.0-1127.18.2.el7.x86_64 root=/dev/mapper/centos-root ro crashkernel=auto spectre_v2=retpoline rd.lvm.lv=centos/root rd.lvm.lv=centos/swap rhgb quiet LANG=en_US.UTF-8</span><br></pre></td></tr></table></figure>

<p>系统重启后，查看支持IOMMU的设备：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">find /sys/kernel/iommu_groups/ -<span class="built_in">type</span> l</span></span><br><span class="line">/sys/kernel/iommu_groups/0/devices/0000:00:00.0</span><br><span class="line">/sys/kernel/iommu_groups/1/devices/0000:00:04.0</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h2 id="查看BIOS是否开启intel-vt-x-x2F-vt-d"><a href="#查看BIOS是否开启intel-vt-x-x2F-vt-d" class="headerlink" title="查看BIOS是否开启intel-vt-x&#x2F;vt-d"></a>查看BIOS是否开启intel-vt-x&#x2F;vt-d</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat /proc/cpuinfo | grep vmx</span><br></pre></td></tr></table></figure>

<p>如果没有开启需要在BOIS中使能<code>intel-vt-x/vt-d</code></p>
<h2 id="选择绑定网卡"><a href="#选择绑定网卡" class="headerlink" title="选择绑定网卡"></a>选择绑定网卡</h2><p>通过<code>ifconfig ethx down/up</code>开关相应的网络节点，获取相应的pci地址，该地址可以通过<code>dmesg</code>查看判断</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">dmesg -c</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ifconfig p1p1 down</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">dmesg</span></span><br><span class="line">[27244.804247] ixgbe 0000:3b:00.0: removed PHC on p1p1</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>p1p1</code>端口对应网卡的pci地址：0000:3b:00.0</p>
</blockquote>
<h2 id="加载vfio驱动"><a href="#加载vfio驱动" class="headerlink" title="加载vfio驱动"></a>加载vfio驱动</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">modprobe vfio</span><br><span class="line">modprobe vfio-pci</span><br></pre></td></tr></table></figure>

<h2 id="网卡透传"><a href="#网卡透传" class="headerlink" title="网卡透传"></a>网卡透传</h2><h3 id="Host端解绑网卡"><a href="#Host端解绑网卡" class="headerlink" title="Host端解绑网卡"></a>Host端解绑网卡</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo &quot;0000:3b:00.0&quot; &gt; /sys/bus/pci/devices/0000\:3b\:00.0/driver/unbind</span><br></pre></td></tr></table></figure>
<p>注意在解绑网卡是需要将该网卡下的所有端口设备全部解绑，比如</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls /sys/bus/pci/devices/0000\:18\:00.0/iommu_group/devices/</span><br><span class="line">0000:18:00.0  0000:18:00.1</span><br></pre></td></tr></table></figure>
<p>需要将<code>0000:18:00.0</code>，<code>0000:18:00.1</code>全部进行解绑</p>
<h3 id="生成vfio设备"><a href="#生成vfio设备" class="headerlink" title="生成vfio设备"></a>生成vfio设备</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">lspci -s 0000:3b:00.0 -n</span></span><br><span class="line">3b:00.0 0200: 8086:154d (rev 01)</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">echo</span> <span class="string">&quot;8086 154d&quot;</span> &gt; /sys/bus/pci/drivers/vfio-pci/new_id</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>在<code>/dev/vfio/</code>下面会有个以阿拉伯数字命名的文件，对应vfio设备组</p>
</blockquote>
<h3 id="绑定vfio总线驱动"><a href="#绑定vfio总线驱动" class="headerlink" title="绑定vfio总线驱动"></a>绑定vfio总线驱动</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo &quot;0000:3b:00.0&quot; &gt; /sys/bus/pci/drivers/vfio-pci/bind</span><br></pre></td></tr></table></figure>

<h2 id="虚拟机参数"><a href="#虚拟机参数" class="headerlink" title="虚拟机参数"></a>虚拟机参数</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-device vfio-pci,host=0000:3b:00.0</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在qemu的启动参数中添加上面参数，该物理网卡将被透传到虚拟机中。</p>
</blockquote>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>在进行网卡的透传过程中，出现以下错误：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2020-09-23T10:16:51.707664Z qemu-system-x86_64: -device vfio-pci,host=0000:3b:00.0,id=hostdev0,bus=pci.0,addr=0xa: vfio 0000:3b:00.0: group 25 is not viable</span><br><span class="line">Please ensure all devices within the iommu_group are bound to their vfio bus driver.</span><br></pre></td></tr></table></figure>
<p>该错误的原因：在进行网卡透传时，以上提到的pci地址（0000:3b:00.0）其实为一张物理网卡的一个端口地址，一般的网卡都是两个端口，而此时只绑定了一个端口，需要将两个端口设备都进行解绑并绑定到vfio总线驱动上</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">ls</span> /sys/bus/pci/devices/0000\:18\:00.0/iommu_group/devices/</span></span><br><span class="line">0000:18:00.0  0000:18:00.1</span><br></pre></td></tr></table></figure>

<h2 id="脚本处理"><a href="#脚本处理" class="headerlink" title="脚本处理"></a>脚本处理</h2><p>为了以后处理方便将host端的配置进行脚本处理</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">/bin/bash</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="built_in">set</span> -x</span></span><br><span class="line"></span><br><span class="line">PCI_ADDR=&quot;18:00.1&quot;</span><br><span class="line"></span><br><span class="line">modprobe vfio</span><br><span class="line">modprobe vfio-pci</span><br><span class="line">lsmod | grep vfio</span><br><span class="line"></span><br><span class="line">lspci -s $PCI_ADDR -n  #em2</span><br><span class="line"></span><br><span class="line">device_id=`lspci -s $PCI_ADDR -n | awk &#x27;&#123;print $3&#125;&#x27;`</span><br><span class="line">device_id=$&#123;device_id/:/ &#125; #去除：号</span><br><span class="line">echo &quot;PCI: $PCI_ADDR, Device ID:$device_id&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">生成vfio设备</span></span><br><span class="line">echo &quot;$device_id&quot; &gt; /sys/bus/pci/drivers/vfio-pci/new_id</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">pci设备绑定vfio总线驱动（解绑--绑定）</span></span><br><span class="line">pci_device=/sys/bus/pci/devices/0000:$PCI_ADDR/iommu_group/devices/</span><br><span class="line">pci_device=`echo $pci_device | sed &#x27;s/:/\\:/g&#x27;` #添加转移符，echo打印不出来</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="built_in">ls</span> <span class="variable">$pci_device</span></span></span><br><span class="line">for dev in `ls $pci_device`</span><br><span class="line">do</span><br><span class="line">    echo &quot;---dev:$dev&quot;</span><br><span class="line">    _pci_dev_unbind=&quot;/sys/bus/pci/devices/$dev/driver/unbind&quot;</span><br><span class="line">    _pci_dev_unbind=`echo $_pci_dev_unbind | sed &#x27;s/:/\\:/g&#x27;`</span><br><span class="line">    #ls $_pci_dev_unbind</span><br><span class="line">    echo &quot;$dev&quot; &gt; $_pci_dev_unbind</span><br><span class="line">    echo &quot;$dev&quot; &gt; /sys/bus/pci/drivers/vfio-pci/bind</span><br><span class="line">    lspci -s $dev -k</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">ls /dev/vfio/</span><br></pre></td></tr></table></figure>

<h2 id="virsh命令解除绑定"><a href="#virsh命令解除绑定" class="headerlink" title="virsh命令解除绑定"></a>virsh命令解除绑定</h2><blockquote>
<p>Host端的设备解除绑定（就是不被host系统所管理使用）后，通过给guest系统使用前的必备操作</p>
</blockquote>
<ul>
<li><p>列出设备ID</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">virsh nodedev-list | grep pci   | grep 18</span></span><br><span class="line">pci_0000_18_00_0</span><br><span class="line">pci_0000_18_00_1</span><br></pre></td></tr></table></figure>
</li>
<li><p>查询当前使用的驱动程序</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">virsh nodedev-dumpxml pci_0000_18_00_0</span></span><br><span class="line">&lt;device&gt;</span><br><span class="line">  &lt;name&gt;pci_0000_18_00_0&lt;/name&gt;</span><br><span class="line">  &lt;path&gt;/sys/devices/pci0000:17/0000:17:03.0/0000:18:00.0&lt;/path&gt;</span><br><span class="line">  &lt;parent&gt;pci_0000_17_03_0&lt;/parent&gt;</span><br><span class="line">  &lt;driver&gt;</span><br><span class="line">    &lt;name&gt;vfio-pci&lt;/name&gt;</span><br><span class="line">  &lt;/driver&gt;</span><br><span class="line">  &lt;capability type=&#x27;pci&#x27;&gt;</span><br><span class="line">    &lt;domain&gt;0&lt;/domain&gt;</span><br><span class="line">    &lt;bus&gt;24&lt;/bus&gt;</span><br><span class="line">    &lt;slot&gt;0&lt;/slot&gt;</span><br><span class="line">    &lt;function&gt;0&lt;/function&gt;</span><br><span class="line">    &lt;product id=&#x27;0x165f&#x27;&gt;NetXtreme BCM5720 2-port Gigabit Ethernet PCIe&lt;/product&gt;</span><br><span class="line">    &lt;vendor id=&#x27;0x14e4&#x27;&gt;Broadcom Inc. and subsidiaries&lt;/vendor&gt;</span><br><span class="line">    &lt;iommuGroup number=&#x27;26&#x27;&gt;</span><br><span class="line">      &lt;address domain=&#x27;0x0000&#x27; bus=&#x27;0x18&#x27; slot=&#x27;0x00&#x27; function=&#x27;0x0&#x27;/&gt;</span><br><span class="line">      &lt;address domain=&#x27;0x0000&#x27; bus=&#x27;0x18&#x27; slot=&#x27;0x00&#x27; function=&#x27;0x1&#x27;/&gt;</span><br><span class="line">    &lt;/iommuGroup&gt;</span><br><span class="line">    &lt;numa node=&#x27;0&#x27;/&gt;</span><br><span class="line">    &lt;pci-express&gt;</span><br><span class="line">      &lt;link validity=&#x27;cap&#x27; port=&#x27;0&#x27; speed=&#x27;5&#x27; width=&#x27;2&#x27;/&gt;</span><br><span class="line">      &lt;link validity=&#x27;sta&#x27; speed=&#x27;5&#x27; width=&#x27;1&#x27;/&gt;</span><br><span class="line">    &lt;/pci-express&gt;</span><br><span class="line">  &lt;/capability&gt;</span><br><span class="line">&lt;/device&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这是设备手动解除绑定后dump出的详细信息，如果没有解除绑定数据可能不同</p>
</blockquote>
</li>
<li><p>解绑当前设备</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">virsh nodedev-detach pci_0000_18_00_0</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">virsh nodedev-detach pci_0000_18_00_1</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cua2VybmVsLm9yZy9kb2MvRG9jdW1lbnRhdGlvbi92ZmlvLnR4dA==">https://www.kernel.org/doc/Documentation/vfio.txt<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93aWtpLmFyY2hsaW51eC5vcmcvaW5kZXgucGhwL1BDSV9wYXNzdGhyb3VnaF92aWFfT1ZNRg==">https://wiki.archlinux.org/index.php/PCI_passthrough_via_OVMF<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dlcnJ5bGVlOTMvYXJ0aWNsZS9kZXRhaWxzLzEwNjQ3NzA1NQ==">KVM网卡透传<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20veGlhLWRvbmcvcC8xMTU0Mjc3MS5odG1s">Qemu 虚拟机网卡透传（PCI Pass Through）<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>虚拟化</category>
      </categories>
      <tags>
        <tag>qemu</tag>
        <tag>pci</tag>
        <tag>网卡</tag>
      </tags>
  </entry>
  <entry>
    <title>虚拟机性能优化——qemu</title>
    <url>/post/7b57e643.html</url>
    <content><![CDATA[<p>虚拟机性能优化</p>
<span id="more"></span>

<h2 id="CPU-amp-vCPU"><a href="#CPU-amp-vCPU" class="headerlink" title="CPU&amp;vCPU"></a>CPU&amp;vCPU</h2><p><img data-src="/images/2020/10/cpu_and_vcpu.png" alt="CPU and vCPU"></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9hY2Nlc3MucmVkaGF0LmNvbS9kb2N1bWVudGF0aW9uL3poLWNuL3JlZF9oYXRfZW50ZXJwcmlzZV9saW51eC83L2h0bWwtc2luZ2xlL3ZpcnR1YWxpemF0aW9uX3R1bmluZ19hbmRfb3B0aW1pemF0aW9uX2d1aWRlL2luZGV4I3NlY3QtVmlydHVhbGl6YXRpb25fVHVuaW5nX09wdGltaXphdGlvbl9HdWlkZS1OVU1BLUF1dG9fTlVNQV9CYWxhbmNpbmc=">虚拟化调试和优化指南<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9mcmFua2Rlbm5lbWFuLm5sLzIwMTEvMDEvMTEvYmVhdGluZy1hLWRlYWQtaG9yc2UtdXNpbmctY3B1LWFmZmluaXR5Lw==">Beating a dead horse – using CPU affinity<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnBleGlwLmNvbS9zZXJ2ZXJfZGVzaWduL3Ztd2FyZV9udW1hX2FmZmluaXR5Lmh0bQ==">VMware NUMA affinity and hyperthreading<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9nbGVubmtsb2Nrd29vZC5jb20vaHBjLWhvd3Rvcy9wcm9jZXNzLWFmZmluaXR5Lmh0bWwjMi10eXBlcy1vZi10aHJlYWQtc2NoZWR1bGluZw==">Managing Process Affinity in Linux<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>虚拟化</category>
      </categories>
      <tags>
        <tag>qemu</tag>
        <tag>虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title>CPU流水线</title>
    <url>/post/34653.html</url>
    <content><![CDATA[<p>链接：Pipelining（流水线） <span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vZHJhZ29uaXIvcC82MTk2NjAyLmh0bWw=">https://www.cnblogs.com/dragonir/p/6196602.html<i class="fa fa-external-link-alt"></i></span></p>
<span id="more"></span>
]]></content>
      <categories>
        <category>计算机系统</category>
      </categories>
      <tags>
        <tag>cpu</tag>
      </tags>
  </entry>
  <entry>
    <title>[PDF]Qemu Libvirt &amp; KVM</title>
    <url>/post/7f314dbc.html</url>
    <content><![CDATA[<p>Qemu Libvirt &amp; KVM</p>
<span id="more"></span>

<div class="pdf-container" data-target="https://winddoing.gitee.io/docs/libvirt/LibvirtQemuKVM.pdf" data-height="500px"></div>
]]></content>
      <categories>
        <category>虚拟机</category>
      </categories>
      <tags>
        <tag>qemu</tag>
        <tag>kvm</tag>
        <tag>libvirt</tag>
      </tags>
  </entry>
  <entry>
    <title>MMU与Cache</title>
    <url>/post/53c48127.html</url>
    <content><![CDATA[<p>CPU通过地址来访问内存中的单元，地址有<code>虚拟地址</code>和<code>物理地址</code>之分，如果CPU没有<code>MMU</code>（Memory Management Unit，内存管理单元），或者有MMU但没有启用，CPU核在取指令或访问内存时发出的地址将直接传到CPU芯片的外部地址引脚上，直接被内存芯片（以下称为物理内存，以便与虚拟内存区分）接收，这称为物理地址（Physical Address，以下简称PA）</p>
<p><img data-src="/images/2022/01/%E6%97%A0mmu%E6%97%B6%EF%BC%8Ccpu%E7%9B%B4%E6%8E%A5%E9%80%9A%E8%BF%87%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E8%AE%BF%E9%97%AE.png" alt="无MMU时，CPU直接通过物理地址访问"></p>
<span id="more"></span>

<p>Memory Management Unit，内存管理单元，主要负责将虚拟地址（Virtual Address，以下简称VA）转换为物理地址。</p>
<p>CPU发出的虚拟地址到MMU，而MMU将这个地址翻译成物理地址发到CPU芯片的外部地址引脚（内存芯片地址引脚）上，进行内存的访问。</p>
<p><img data-src="/images/2022/01/mmu%E8%BD%AC%E6%8D%A2.png" alt="MMU转换"></p>
<p>MMU将虚拟地址映射到物理地址是以<code>页</code>（Page）为单位的，对于32位CPU通常一页为<code>4K</code>。例如，虚拟地址<code>0xb700 1000~0xb700 1fff</code>是一个页，可能被MMU映射到物理地址<code>0x2000~0x2fff</code>，物理内存中的一个物理页面也称为一个<code>页帧</code>（Page Frame）。</p>
<h2 id="虚拟内存管理"><a href="#虚拟内存管理" class="headerlink" title="虚拟内存管理"></a>虚拟内存管理</h2><p>现代操作系统充分利用MMU提供的VA到PA的映射机制来做内存管理，以下称为<code>虚拟内存管理</code>（Virtual Memory Management）。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">↪ =&gt;$ps</span><br><span class="line">    PID TTY          TIME CMD</span><br><span class="line">  12795 pts/0    00:00:00 bash</span><br><span class="line">  12825 pts/0    00:00:00 ps</span><br><span class="line"></span><br><span class="line">↪ =&gt;$pmap 12795</span><br><span class="line">12795:   bash</span><br><span class="line">00005642d3bea000    180K r---- bash</span><br><span class="line">00005642d3c17000    708K r-x-- bash</span><br><span class="line">00005642d3cc8000    220K r---- bash</span><br><span class="line">00005642d3cff000     16K r---- bash</span><br><span class="line">00005642d3d03000     36K rw--- bash</span><br><span class="line">00005642d3d0c000     40K rw---   [ anon ]</span><br><span class="line">00005642d57c1000   1568K rw---   [ anon ]</span><br><span class="line">00007f308a4be000   8644K r---- locale-archive</span><br><span class="line">00007f308ad2f000     12K rw---   [ anon ]</span><br><span class="line">00007f308ad32000    148K r---- libc-2.31.so</span><br><span class="line">00007f308ad57000   1504K r-x-- libc-2.31.so</span><br><span class="line">00007f308aecf000    296K r---- libc-2.31.so</span><br><span class="line">00007f308af19000      4K ----- libc-2.31.so</span><br><span class="line">00007f308af1a000     12K r---- libc-2.31.so</span><br><span class="line">00007f308af1d000     12K rw--- libc-2.31.so</span><br><span class="line">00007f308af20000     16K rw---   [ anon ]</span><br><span class="line">00007f308af24000      4K r---- libdl-2.31.so</span><br><span class="line">00007f308af25000      8K r-x-- libdl-2.31.so</span><br><span class="line">00007f308af27000      4K r---- libdl-2.31.so</span><br><span class="line">00007f308af28000      4K r---- libdl-2.31.so</span><br><span class="line">00007f308af29000      4K rw--- libdl-2.31.so</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">↪ =&gt;$readelf -S /usr/bin/bash</span><br><span class="line">There are 30 section headers, starting at offset 0x120758:</span><br><span class="line"></span><br><span class="line">Section Headers:</span><br><span class="line">  [Nr] Name              Type             Address           Offset</span><br><span class="line">       Size              EntSize          Flags  Link  Info  Align</span><br><span class="line">  [ 0]                   NULL             0000000000000000  00000000</span><br><span class="line">       0000000000000000  0000000000000000           0     0     0</span><br><span class="line">  [ 1] .interp           PROGBITS         0000000000000318  00000318</span><br><span class="line">       000000000000001c  0000000000000000   A       0     0     1</span><br><span class="line">  [ 2] .note.gnu.propert NOTE             0000000000000338  00000338</span><br><span class="line">       0000000000000020  0000000000000000   A       0     0     8</span><br><span class="line">  [ 3] .note.gnu.build-i NOTE             0000000000000358  00000358</span><br><span class="line">       0000000000000024  0000000000000000   A       0     0     4</span><br><span class="line">  [ 4] .note.ABI-tag     NOTE             000000000000037c  0000037c</span><br><span class="line">       0000000000000020  0000000000000000   A       0     0     4</span><br><span class="line">  [ 5] .gnu.hash         GNU_HASH         00000000000003a0  000003a0</span><br><span class="line">       0000000000004aac  0000000000000000   A       6     0     8</span><br><span class="line">  [ 6] .dynsym           DYNSYM           0000000000004e50  00004e50</span><br><span class="line">       000000000000e418  0000000000000018   A       7     1     8</span><br><span class="line">  [ 7] .dynstr           STRTAB           0000000000013268  00013268</span><br><span class="line">       0000000000009740  0000000000000000   A       0     0     1</span><br><span class="line">  [ 8] .gnu.version      VERSYM           000000000001c9a8  0001c9a8</span><br><span class="line">       0000000000001302  0000000000000002   A       6     0     2</span><br><span class="line">  [ 9] .gnu.version_r    VERNEED          000000000001dcb0  0001dcb0</span><br><span class="line">       00000000000000d0  0000000000000000   A       7     3     8</span><br><span class="line">  [10] .rela.dyn         RELA             000000000001dd80  0001dd80</span><br><span class="line">       000000000000dc80  0000000000000018   A       6     0     8</span><br><span class="line">  [11] .rela.plt         RELA             000000000002ba00  0002ba00</span><br><span class="line">       0000000000001470  0000000000000018  AI       6    25     8</span><br><span class="line">  [12] .init             PROGBITS         000000000002d000  0002d000</span><br><span class="line">       000000000000001b  0000000000000000  AX       0     0     4</span><br><span class="line">  [13] .plt              PROGBITS         000000000002d020  0002d020</span><br><span class="line">       0000000000000db0  0000000000000010  AX       0     0     16</span><br><span class="line">  [14] .plt.got          PROGBITS         000000000002ddd0  0002ddd0</span><br><span class="line">       0000000000000030  0000000000000010  AX       0     0     16</span><br><span class="line">  [15] .plt.sec          PROGBITS         000000000002de00  0002de00</span><br><span class="line">       0000000000000da0  0000000000000010  AX       0     0     16</span><br><span class="line">  [16] .text             PROGBITS         000000000002eba0  0002eba0</span><br><span class="line">       00000000000aeb55  0000000000000000  AX       0     0     16</span><br><span class="line">  [17] .fini             PROGBITS         00000000000dd6f8  000dd6f8</span><br><span class="line">       000000000000000d  0000000000000000  AX       0     0     4</span><br><span class="line">  [18] .rodata           PROGBITS         00000000000de000  000de000</span><br><span class="line">       000000000001a094  0000000000000000   A       0     0     32</span><br><span class="line">  [19] .eh_frame_hdr     PROGBITS         00000000000f8094  000f8094</span><br><span class="line">       00000000000044dc  0000000000000000   A       0     0     4</span><br><span class="line">  [20] .eh_frame         PROGBITS         00000000000fc570  000fc570</span><br><span class="line">       0000000000017c28  0000000000000000   A       0     0     8</span><br><span class="line">  [21] .init_array       INIT_ARRAY       0000000000115cf0  00114cf0</span><br><span class="line">       0000000000000008  0000000000000008  WA       0     0     8</span><br><span class="line">  [22] .fini_array       FINI_ARRAY       0000000000115cf8  00114cf8</span><br><span class="line">       0000000000000008  0000000000000008  WA       0     0     8</span><br><span class="line">  [23] .data.rel.ro      PROGBITS         0000000000115d00  00114d00</span><br><span class="line">       00000000000028f0  0000000000000000  WA       0     0     32</span><br><span class="line">  [24] .dynamic          DYNAMIC          00000000001185f0  001175f0</span><br><span class="line">       0000000000000210  0000000000000010  WA       7     0     8</span><br><span class="line">  [25] .got              PROGBITS         0000000000118800  00117800</span><br><span class="line">       00000000000007e8  0000000000000008  WA       0     0     8</span><br><span class="line">  [26] .data             PROGBITS         0000000000119000  00118000</span><br><span class="line">       0000000000008604  0000000000000000  WA       0     0     32</span><br><span class="line">  [27] .bss              NOBITS           0000000000121620  00120604</span><br><span class="line">       0000000000009c78  0000000000000000  WA       0     0     32</span><br><span class="line">  [28] .gnu_debuglink    PROGBITS         0000000000000000  00120604</span><br><span class="line">       0000000000000034  0000000000000000           0     0     4</span><br><span class="line">  [29] .shstrtab         STRTAB           0000000000000000  00120638</span><br><span class="line">       000000000000011d  0000000000000000           0     0     1</span><br><span class="line">Key to Flags:</span><br><span class="line">  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),</span><br><span class="line">  L (link order), O (extra OS processing required), G (group), T (TLS),</span><br><span class="line">  C (compressed), x (unknown), o (OS specific), E (exclude),</span><br><span class="line">  l (large), p (processor specific)</span><br></pre></td></tr></table></figure>

<p>在64位CPU上<code>0x0000 0000 0000 0000 ~ 0x0000 ffff ffff ffff</code>地址范围为用户空间地址。<br>bash进程的虚拟地址空间</p>
<ul>
<li>0x00005642d3bea000开始的180K，表示<code>init段</code></li>
<li>0x00005642d3c17000开始的708K，表示<code>text段</code>，因为权限是<code>r-x--</code></li>
<li>0x00005642d57c1000开始的1563K，表手<code>堆</code>，因为权限也是<code>rw---</code>，但是没有对应任何磁盘文件，而是用[ anon ]（anonymous，匿名）来表示</li>
</ul>
<blockquote>
<p>以上进程中的地址与程序各段的对应关系，可以通过地址长度与段的长度及相应权限确定</p>
</blockquote>
<p><img data-src="/images/2022/01/arm64_memory.png" alt="arm64_memory"></p>
<h2 id="为什么需要虚拟内存管理呢？"><a href="#为什么需要虚拟内存管理呢？" class="headerlink" title="为什么需要虚拟内存管理呢？"></a>为什么需要虚拟内存管理呢？</h2><ul>
<li><p>让每个进程有独立的地址空间是引入虚拟内存管理的最主要目的</p>
<p>所谓独立的地址空间是指，不同进程中的同一个VA被MMU映射到不同的PA，并且在某一个进程中访问任何地址都不可能访问到另外一个进程的数据，这样使得任何一个进程由于程序BUG或恶意代码所导致的非法内存访问都不会意外改写其它进程的数据，不会影响其它进程的运行，从而保证了整个系统的稳定性。另一方面，每个进程都认为自己独占4GB的地址空间，编写程序会比较方便，不必为每个进程分配一个地址范围，而是每个进程都可以使用一个完整的地址空间中的任何地址。</p>
</li>
<li><p>引入VA到PA的映射也会给分配和释放内存带来方便</p>
<p>物理上不连续的空间可以映射为逻辑上连续的虚拟地址空间。比如要malloc一块很大的内存空间，而物理内存虽然有足够的空闲内存，却没有足够大的连续空闲内存，这时就可以分配多个不连续的物理页面，而映射为连续的虚拟地址范围</p>
</li>
<li><p>一个系统如果同时运行着很多进程，为各进程分配的内存之和可能会大于实际可用的物理内存，虚拟内存管理使得这种情况下各进程仍然能够正常运行</p>
<p>各进程分配的只不过是虚拟内存的页，这个页的内容可以映射到物理内存的页帧，也可以临时保存到磁盘上而不占用物理内存的页帧，磁盘上这一部分称为交换设备（Swap Device），可能是一个磁盘分区，也可能是一个磁盘文件。当物理内存不够时将物理内存中不常用的页帧临时保存到磁盘上，而当用到这些页帧时再从磁盘加载回内存，这称为换页（Paging）因此：系统中可分配的内存总量 &#x3D; 物理内存的大小 + 交换设备的大小</p>
</li>
<li><p>虚拟内存管理可以控制物理页面的访问权限</p>
<p>物理内存本身是不限制访问的，任何地址都可以读写，而操作系统要求实现各种不同的访问权限，在先前的例子中我们已经看到，代码段要求是rx的，数据段要求是rw的，用户进程不能访问属于内核的地址空间，这些都是操作系统和MMU配合实现的</p>
</li>
</ul>
<h2 id="虚拟地址与物理地址之间的关系——页表"><a href="#虚拟地址与物理地址之间的关系——页表" class="headerlink" title="虚拟地址与物理地址之间的关系——页表"></a>虚拟地址与物理地址之间的关系——页表</h2><p><img data-src="/images/2022/01/arm64_vm_pm_translation.png" alt="arm64_vm_pm_translation"></p>
<p>页表用于建立用户进程的虚拟地址空间和系统物理内存(内存、页帧)之间的关联。</p>
<p><code>页表</code>用于向每个进程提供一致的虚拟地址空间。应用程序看到的地址空间是一个连续的内存区。该表也将虚拟内存页映射到物理内存,因而支持共享内存的实现(几个进程同时共享的内存),还可以在不额外增加物理内存的情况下,将页换出到块设备来增加有效的可用内存空间。</p>
<h2 id="CPU访问内存时的硬件操作顺序"><a href="#CPU访问内存时的硬件操作顺序" class="headerlink" title="CPU访问内存时的硬件操作顺序"></a>CPU访问内存时的硬件操作顺序</h2><p><img data-src="/images/2022/01/arm_cpu_mem.png" alt="arm_cpu_mem"></p>
<ol>
<li><p><code>CPU核</code>（图中的“ARM”框）发出VA请求读数据，TLB（Translation Lookaside Buffer）接收到该地址。<code>TLB是MMU中的一块高速缓存（也是一种Cache）</code>，它缓存最近查找过的VA对应的页表项，如果TLB里缓存了当前VA的页表项就不必做Translation Table Walk了，否则去物理内存中读出页表项保存在TLB中，TLB缓存可以减少访问物理内存的次数。</p>
</li>
<li><p>页表项中不仅保存着物理页面的基地址，还保存着权限位和是否允许Cache的标志。MMU首先检查权限位，如果没有访问权限，就引发一个异常给CPU核。然后检查是否允许Cache，如果允许Cache就启用Cache和CPU核互操作，图中的“C, B bits”可以理解为直写和回写线，后面再详细解释这两个位的作用。</p>
</li>
<li><p>如果不允许Cache，则直接发出PA从物理内存中读取数据到CPU核</p>
</li>
<li><p>如果允许Cache，则以VA为索引到Cache中查找是否缓存了要读取的数据，如果Cache中已经缓存了该数据（称为Cache Hit）则直接返回给CPU核，如果Cache中没有缓存该数据（称为Cache Miss），则发出PA从物理内存中读取数据并缓存到Cache中，同时返回给CPU核。然而Cache并不是只取CPU核所要的数据，而是把相邻的数据都取上来缓存，这称为一个<code>Cache Line</code></p>
</li>
</ol>
<h2 id="TLB"><a href="#TLB" class="headerlink" title="TLB"></a>TLB</h2><p><code>Translation Lookaside Buffer (TLB)</code>是MMU中最近访问的页面翻译的缓存。 对于处理器执行的每个内存访问，MMU都会检查翻译是否缓存在TLB中。 如果请求的地址转换在TLB内导致命中，则地址转换立即可用。</p>
<p>每个<code>TLB条目</code>通常不仅包含<code>物理地址</code>和<code>虚拟地址</code>，还包含<code>内存类型</code>、<code>缓存策略</code>、<code>访问权限</code>、<code>地址空间ID (ASID)</code>和<code>虚拟机ID(VMID)</code>等属性。 如果 TLB 不包含处理器发出的虚拟地址的有效转换，称为TLB未命中，则执行外部转换表遍历或查找。 MMU中的专用硬件使其能够读取内存中的转换表。 如果转换表遍历不会导致页面错误，则新加载的转换可以缓存在TLB中以供可能的重用。TLB的确切结构因ARM处理器的实现而异。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li>DEN0024A_v8_architecture_PG.pdf</li>
</ul>
]]></content>
      <categories>
        <category>计算机系统</category>
      </categories>
      <tags>
        <tag>cache</tag>
        <tag>mmu</tag>
      </tags>
  </entry>
  <entry>
    <title>加密解密</title>
    <url>/post/9a5cc3eb.html</url>
    <content><![CDATA[<p>加密技术是最常用的安全保密手段，利用技术手段把重要的数据变为乱码（加密）传送，到达目的地后再用相同或不同的手段还原（解密）。</p>
<p>加密技术包括两个元素：<code>算法</code>和<code>密钥</code>。算法是将普通的信息或者可以理解的信息与一串数字（密钥）结合，产生不可理解的密文的步骤，密钥是用来对数据进行编码和解密的一种算法。在安全保密中，可通过适当的钥加密技术和管理机制来保证网络的信息通信安全。</p>
<p>算法分类：</p>
<ul>
<li><code>对称加密</code>：密钥只有一个，解密、解密都是这个密码，加解密速度快，典型的对称加密有<strong>DES</strong>、<strong>AES</strong>、<strong>RC4</strong> 等.</li>
<li><code>非对称加密</code>:密钥成对出现，分别为公钥和私钥，从公钥无法推知私钥，反之，从私钥也无法推知公钥，加密和解密使用不同的密钥，公钥加密需要私钥解密，反之，私钥加密需要公钥解密。非对称加密速度较慢，典型的非对称算法有：<strong>RSA</strong>,<strong>DSA</strong>,<strong>DSS</strong>.</li>
<li><code>Hash算法</code>: 这是一种不可逆的算法，它常用于验证数据的完整性。</li>
</ul>
<span id="more"></span>

<h2 id="对称加密-——-ASE"><a href="#对称加密-——-ASE" class="headerlink" title="对称加密 —— ASE"></a>对称加密 —— ASE</h2><p><code>对称加密</code>（Symmetric Cryptography）算法、可逆的、保证私密信息不被泄露</p>
<ul>
<li>对称加密是最快速、最简单的一种加密方式，加密(encryption)与解密(decryption)用的是同样的密钥(secret key)。</li>
<li>对称加密通常使用的是相对较小的密钥，一般小于256 bit。因为密钥越大，加密越强，但加密与解密的过程越慢。</li>
<li>对称加密的一大缺点是密钥的管理与分配，换句话说，如何把密钥发送到需要解密你的消息的人的手里是一个问题。在发送密钥的过程中，密钥有很大的风险会被黑客们拦截。现实中通常的做法是将对称加密的密钥进行非对称加密，然后传送给需要它的人。</li>
<li>对称加密，加密速度非常快，适合经常发送数据的场合。缺点是密钥的传输比较麻烦</li>
</ul>
<p><code>AES</code>的全称是<code>Advanced Encryption Standard</code>，意思是高级加密标准。 AES为<code>分组密码</code>，分组密码也就是把明文分成一组一组的，每组长度相等，每次加密一组数据，直到加密完整个明文。在AES标准规范中，分组长度只能是<code>128bit</code>，也就是说，每个分组为16个字节（每个字节8位）。密钥的长度可以使用<code>128位</code>、<code>192位</code>或<code>256位</code>。密钥的长度不同，推荐加密轮数也不同。</p>
<table>
<thead>
<tr>
<th align="center">AES</th>
<th align="center">密钥长度</th>
<th align="center">分组长度</th>
<th align="center">加密轮数</th>
</tr>
</thead>
<tbody><tr>
<td align="center">AES-128</td>
<td align="center">128bit</td>
<td align="center">128bit</td>
<td align="center">10</td>
</tr>
<tr>
<td align="center">AES-192</td>
<td align="center">192bit</td>
<td align="center">128bit</td>
<td align="center">12</td>
</tr>
<tr>
<td align="center">AES-256</td>
<td align="center">256bit</td>
<td align="center">128bit</td>
<td align="center">14</td>
</tr>
</tbody></table>
<p>AES算法使用逻辑就是：发送方将要发送的<code>明文数据X</code>使用<code>秘钥K</code>进行AES加密后会得到<code>密文Y</code>，将密文进行网络传输，接受方在收到<code>密文Y</code>后使用<code>秘钥K</code>进行AES解密后技能得到<code>明文X</code>,这样即使密文Y在网络上传输时被截获了，没有秘钥也难以破解其真实意思。</p>
<p><img data-src="/images/2022/10/ase%E5%8A%A0%E5%AF%86%E6%B5%81%E7%A8%8B.png" alt="ASE加密流程"></p>
<h2 id="非对称加密-——-RSA"><a href="#非对称加密-——-RSA" class="headerlink" title="非对称加密 —— RSA"></a>非对称加密 —— RSA</h2><p><code>非对称加密</code>(Asymmetric Cryptography)算法、可逆的、保证私密信息不被泄露</p>
<ul>
<li>非对称加密之所以不对称，指的就是加密用一个密钥，而解密的时候用的是另外一个密钥。</li>
<li>非对称加密为数据的加密与解密提供了一个非常安全的方法，它使用了一对密钥，公钥(public key)和私钥(private key)。<code>私钥</code>只能由一方安全保管，不能外泄，而<code>公钥</code>则可以发给任何请求它的人。非对称加密使用这对密钥中的一个进行加密，而解密则需要另一个密钥。</li>
<li>非对称算法，加密解密的速度比较慢，适合偶尔发送数据的场合。优点是密钥传输方便。常见的非对称加密算法为RSA、ECC和EIGamal</li>
</ul>
<h3 id="RSA"><a href="#RSA" class="headerlink" title="RSA"></a>RSA</h3><p><img data-src="/images/2022/10/rsa%E5%8A%A0%E8%A7%A3%E5%AF%86.png" alt="RSA加解密"></p>
<p><code>RSA</code>算法过程：</p>
<ol>
<li>选择一对不同的、足够大的素数p，q。</li>
<li>计算n&#x3D;pq。</li>
<li>计算f(n)&#x3D;(p-1)(q-1)，同时对p, q严加保密，不让任何人知道。</li>
<li>找一个与f(n)互质的数e，且1&lt;e&lt;f(n)。</li>
<li>计算d，使得de≡1 mod f(n)。</li>
<li>公钥KU&#x3D;(e,n)，私钥KR&#x3D;(d,n)。</li>
<li>加密时，先将明文变换成0至n-1的一个整数M。若明文较长，可先分割成适当的组，然后再进行交换。设密文为C，则加密过程为：C≡Me(mod n)。</li>
<li>解密过程为：M≡Cd(mod n)。</li>
</ol>
<blockquote>
<p>MOD，是一个数学运算符号。指求余运算符，例如a mod b&#x3D;c，表明a除以b余数为c。两个整数a，b，若它们除以正整数m所得的余数相等，则称a，b对于模m同余，记作: a ≡ b (mod m)；</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">关键字</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">公钥 KU</td>
<td align="center">n: 两素数p和q的乘积(p和q必须保密)； e: 与(p-1)(q-1)互质</td>
</tr>
<tr>
<td align="center">私钥 KR</td>
<td align="center">d：e^-1 (mod(p-1)(q-1))  n：</td>
</tr>
<tr>
<td align="center">加密</td>
<td align="center">c &#x3D; m^e mod n</td>
</tr>
<tr>
<td align="center">解密</td>
<td align="center">m &#x3D; c^d mod n</td>
</tr>
</tbody></table>
<p>RSA的安全基于<code>大数分解</code>的难度。其公钥和私钥是一对大素数（100到200位十进制数或更大）的函数。从一个公钥和密文恢复出明文的难度，等价于分解两个大素数之积（这是公认的数学难题）。</p>
<h3 id="RSA密钥"><a href="#RSA密钥" class="headerlink" title="RSA密钥"></a>RSA密钥</h3><p>openssl生成密钥：</p>
<ul>
<li>生成RSA私钥（KU）  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">openssl genrsa -out private.pem 2048</span><br></pre></td></tr></table></figure></li>
<li>以RSA私钥生成公钥  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">openssl rsa -in private.pem -outform PEM -pubout -out public.pem</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="数组签名"><a href="#数组签名" class="headerlink" title="数组签名"></a>数组签名</h2><p>数字签名技术其实是非对称加密的一种逆向应用,它采用私钥加密,公钥解密</p>
<p><img data-src="/images/2022/10/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D.png" alt="数字签名"></p>
<blockquote>
<p>A使用hash算法生成文件摘要Z1,并用私钥加密该文件的摘要Z1生成数字签名，将数字签名、公钥和文件一起发送给B，B拿到文件后使用相同的hash算法生成文件摘要Z2,调试使用公钥解密数字签名得到文件摘要Z1,对比两个摘要，如果Z1和Z2相等，则认为这个文件时A发送过来的。</p>
</blockquote>
<h3 id="认证与加密"><a href="#认证与加密" class="headerlink" title="认证与加密"></a>认证与加密</h3><ul>
<li>加密是为了防止数据被别人截取，重点在于数据的安全性，防止窃听</li>
<li>认证是为了验证，确认信息的完整性和用户身份的真实性，换个角度就是公钥可以给任何人，而私钥必须自己安全保存不能给别人。</li>
</ul>
<h2 id="哈希算法-——-MD5"><a href="#哈希算法-——-MD5" class="headerlink" title="哈希算法 —— MD5"></a>哈希算法 —— MD5</h2><p>哈希摘要算法、不可逆的、对信息一致性和完整性的校验。</p>
<p>Message Digest Algorithm MD5（中文名为消息摘要算法第五版）为计算机安全领域广泛使用的一种散列函数，用以提供消息的完整性保护,用于生成信息摘要.</p>
<h2 id="国密算法对比"><a href="#国密算法对比" class="headerlink" title="国密算法对比"></a>国密算法对比</h2><table>
<thead>
<tr>
<th align="center">密码分类</th>
<th align="center">实现方式</th>
<th align="center">国产商用密码</th>
<th align="center">国际商用密码</th>
</tr>
</thead>
<tbody><tr>
<td align="center">对称加密</td>
<td align="center">分组加密&#x2F;块加密</td>
<td align="center">SM1&#x2F;SCB2 SM4&#x2F;SMS4 SM7</td>
<td align="center">AES DES IDEA RC5 RC6</td>
</tr>
<tr>
<td align="center">对称加密</td>
<td align="center">序列解密&#x2F;流加密</td>
<td align="center">ZUC（祖冲之算法） SSF46</td>
<td align="center">RC4</td>
</tr>
<tr>
<td align="center">非对称加密</td>
<td align="center">大数分解</td>
<td align="center"></td>
<td align="center">RSA DSA ECDSA Rabin</td>
</tr>
<tr>
<td align="center">非对称加密</td>
<td align="center">离散对数</td>
<td align="center">SM2 SM9</td>
<td align="center">DH DSA ECC ECDH</td>
</tr>
<tr>
<td align="center">密码杂凑&#x2F;散列</td>
<td align="center">hash算法</td>
<td align="center">SM3</td>
<td align="center">MD5 SHA-1 SHA-2</td>
</tr>
</tbody></table>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8xMzIzNTIxNjA=">国密算法介绍<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vamlmdGxlL3AvNzkwMzc2Mi5odG1s">RSA加密算法<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>计算机系统</category>
      </categories>
      <tags>
        <tag>加密</tag>
        <tag>解密</tag>
      </tags>
  </entry>
  <entry>
    <title>汇编伪指令—.word</title>
    <url>/post/16d994f4.html</url>
    <content><![CDATA[<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.word</span><br><span class="line">Syntax: .word expressions</span><br></pre></td></tr></table></figure>
<blockquote>
<p>This directive expects zero or more expressions, of any section, separatedby commas. For each expression, as emits a 16-bit number for thistarget.</p>
</blockquote>
<span id="more"></span>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">7.92 .word expressions</span><br><span class="line"></span><br><span class="line">This directive expects zero or more expressions, of any section, separated by commas.</span><br><span class="line">The size of the number emitted, and its byte order, depend on what target computer the assembly is for.</span><br><span class="line">Warning: Special Treatment to support Compilers Machines with a 32-bit address space,</span><br><span class="line">but that do less than 32-bit addressing, require the following special treatment.</span><br><span class="line">If the machine of interest to you does 32-bit addressing (or doesn’t require it;</span><br><span class="line">see Chapter 8 [Machine Dependencies], page 61), you can ignore this issue.</span><br><span class="line">In order to assemble compiler output into something that works,</span><br><span class="line">as occasionally does strange things to ‘.word’ directives.</span><br><span class="line">Directives of the form ‘.word sym1-sym2’ are often emitted by compilers as part of jump tables.</span><br><span class="line">Therefore, when as assembles a directive of the form ‘.word sym1-sym2’,</span><br><span class="line">and the difference between sym1 and sym2 does not fit in 16 bits,</span><br><span class="line">as creates a secondary jump table, immediately before the next label.</span><br><span class="line">This secondary jump table is preceded by a short-jump to the first byte after the secondary table.</span><br><span class="line">This short-jump prevents the flow of control from accidentally falling into the new table.</span><br><span class="line">Inside the table is a long-jump to sym2. The original ‘.word’ contains sym1 minus the address of the long-jump to sym2.</span><br><span class="line">If there were several occurrences of ‘.word sym1-sym2’ before the secondary jump table,</span><br><span class="line">all of them are adjusted. If there was a ‘.word sym3-sym4’, that also did not fit in sixteen bits,</span><br><span class="line">a long-jump to sym4 is included in the secondary jump table,</span><br><span class="line">and the .word directives are adjusted to contain sym3 minus the address of the long-jump to sym4;</span><br><span class="line">and so on, for as many entries in the original jump table as necessary.</span><br></pre></td></tr></table></figure>
<blockquote>
<p>as.info文档</p>
</blockquote>
<p><code>.word expression</code>就是在当前位置放一个word型的值，这个值就是expression</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_rWTCON:</span><br><span class="line">.word 0x15300000</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在当前地址，即_rWTCON处放一个值0x15300000</p>
</blockquote>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzMzk2NDgxL2FydGljbGUvZGV0YWlscy83ODk1MzU4Mw==">【转载】ARM汇编伪指令.word<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL3RpZ2NjLnRpY2FsYy5vcmcvZG9jL2dudWFzbS5odG1sI1NFQzQ5">The GNU Assembler<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9jcy5sbXUuZWR1L35yYXkvbm90ZXMvZ2FzZXhhbXBsZXMv">GNU Assembler Examples<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cudHV0b3JpYWxzcG9pbnQuY29tL2Fzc2VtYmx5X3Byb2dyYW1taW5nL2Fzc2VtYmx5X3R1dG9yaWFsLnBkZg==">Assembly Programming Tutorial<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>计算机系统</category>
      </categories>
      <tags>
        <tag>汇编</tag>
        <tag>指令</tag>
      </tags>
  </entry>
  <entry>
    <title>CRTC for drm</title>
    <url>/post/e15c0180.html</url>
    <content><![CDATA[<p><code>DRM</code>是linux下的图形渲染架构(Direct Render Manager),具体的说是显卡驱动的一种架构，为了给上层应用提供操作接口。而显卡，最基本的功能就是把用户的绘图渲染后输出到显示屏上，DRM主要是为了在软件层面实现这一目标。这里主要就包括两部分，<code>硬件设备</code>、<code>软件模块</code></p>
<p><img data-src="/images/2020/10/drm.png" alt="drm"></p>
<blockquote>
<p><code>CRTC</code>主要负责从Framebuffer中读出待显示的图像，并按照相应的格式输出给Encoder</p>
</blockquote>
<p><code>CRTC</code>是阴极射线显像管上下文（Cathode Ray Tube Context）,作用是读取当前Framebuffer的像素数据并借助于PLL电路从其生成视频模式定时信号。</p>
<span id="more"></span>

<p><img data-src="/images/2020/10/drm_layer.png" alt="drm_layer"></p>
<p>DRM中<code>CRTC</code>模块主要的作用：</p>
<ul>
<li>配置适合显示器的分辨率（kernel）并输出相应时序（hardware logic）</li>
<li>扫描framebuffer送显到一个或多个显示设备中</li>
<li>更新framebuffer</li>
</ul>
<p>CRTC模块产生vbank信号进行场同步刷新</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9lbGludXgub3JnL2ltYWdlcy83LzcxL0VsY2UxMV9kYWUucGRm">DRM Driver Development For Embedded Systems<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RlYXJzcS9hcnRpY2xlL2RldGFpbHMvNzgzOTQzODg=">Linux DRM（二）基本概念和特性<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JveWVtYWNoYW8vYXJ0aWNsZS9kZXRhaWxzLzgzNTc2Njg0">linux drm 架构及linux drm 架构 之代码分析<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hleGlhb2xvbmcyMDA5L2FydGljbGUvZGV0YWlscy8xMDU5NjExOTI=">关于 DRM 中 DUMB 和 PRIME 名字的由来<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hleGlhb2xvbmcyMDA5L2FydGljbGUvZGV0YWlscy84OTgxMDM1NQ==">DRM 驱动程序开发（开篇）<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL3RpbnlsYWIub3JnL2xpbnV4LWdyYXBoaWNzLXN0YWNrLW92ZXJ2aWV3IyVFOCU4MyU4QyVFNiU5OSVBRmRybS0tYnVmZmVyLW1hbmFnZW1lbnRmcmFtZS1idWZmZXItLXBsYW5la2VybmVsLW1vZGUtc2V0dGluZw==">Linux 图形栈一览：基于 DRM 和 Wayland<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>设备驱动</category>
      </categories>
      <tags>
        <tag>gpu</tag>
        <tag>drm</tag>
        <tag>crtc</tag>
      </tags>
  </entry>
  <entry>
    <title>DRM</title>
    <url>/post/16573.html</url>
    <content><![CDATA[<p>显卡驱动相关：</p>
<span id="more"></span>

<h2 id="GEM-Graphics-Execution-Manager"><a href="#GEM-Graphics-Execution-Manager" class="headerlink" title="GEM (Graphics Execution Manager)"></a>GEM (Graphics Execution Manager)</h2><h2 id="TTM-Translation-Table-Manager"><a href="#TTM-Translation-Table-Manager" class="headerlink" title="TTM (Translation Table Manager)"></a>TTM (Translation Table Manager)</h2><blockquote>
<p> To this end, the TTM layer provides “fence” objects. A fence is a special operation which is placed into the GPU’s command FIFO. When the fence is executed, it raises a signal to indicate that all instructions enqueued before the fence have now been executed, and that the GPU will no longer be accessing any associated buffers. How the signaling works is very much dependent on the GPU; it could raise an interrupt or simply write a value to a special memory location. When a fence signals, any associated buffers are marked as no longer being referenced by the GPU, and any interested user-space processes are notified.<br><span class="exturl" data-url="aHR0cHM6Ly9sd24ubmV0L0FydGljbGVzLzI1NzQxNy8=">https://lwn.net/Articles/257417/<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<p>TTM层提供“fence”对象。fence是一种特殊的操作，被放置在GPU的命令FIFO中。当执行fence时，它会发出一个信号，指示现已执行fence之前排队的所有指令，并且GPU将不再访问任何关联的缓冲区。信号的工作方式在很大程度上取决于GPU。它可能会引发中断，或者只是将值写入特殊的存储位置。当fenc发出信号时，所有关联的缓冲区都将标记为不再被GPU引用，并且会通知任何感兴趣的用户空间进程。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><span class="exturl" data-url="aHR0cDovL3d3dy5sYW5kbGV5Lm5ldC9rZG9jcy9odG1sZG9jcy9kcm0uaHRtbCNkcm1JbnRyb2R1Y3Rpb24=">Linux DRM Developer’s Guide<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9sd24ubmV0L0FydGljbGVzLzI4Mzc5My8=">GEM v. TTM<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>设备驱动</category>
      </categories>
      <tags>
        <tag>drm</tag>
      </tags>
  </entry>
  <entry>
    <title>DRM笔记——驱动初始化</title>
    <url>/post/53854910.html</url>
    <content><![CDATA[<p>drm的驱动加载主要是为了实现各种回调函数的注册，初始化时主要实现的数据结构是<code>struct drm_driver</code></p>
<p>这里以virtio-gpu为例，了解drm驱动的初始化</p>
<span id="more"></span>


<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">module_virtio_driver(virtio_gpu_driver);</span><br><span class="line">  \-&gt;.probe = virtio_gpu_probe (driver与devices匹配后的入口函数)</span><br><span class="line">    \-&gt; drm_dev_alloc(&amp;driver, &amp;vdev-&gt;dev); -- 申请和初始化struct drm_driver结构体</span><br></pre></td></tr></table></figure>

<h2 id="struct-drm-driver初始化"><a href="#struct-drm-driver初始化" class="headerlink" title="struct drm_driver初始化"></a><code>struct drm_driver</code>初始化</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">drm_driver</span> <span class="title">driver</span> =</span> &#123;</span><br><span class="line">    <span class="comment">//drm驱动的功能特性</span></span><br><span class="line">    .driver_features = DRIVER_MODESET | DRIVER_GEM | DRIVER_RENDER | DRIVER_ATOMI</span><br><span class="line">    <span class="comment">//用于设置驱动程序-私有数据结构，如缓冲区分配器、执行上下文（上下文ID）或类似内容</span></span><br><span class="line">    .open = virtio_gpu_driver_open,</span><br><span class="line">    <span class="comment">//与open相对应，用于open接口申请资源的释放</span></span><br><span class="line">    .postclose = virtio_gpu_driver_postclose,</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建dumb buffer （用户通过 ioctl 调用）</span></span><br><span class="line">    .dumb_create = virtio_gpu_mode_dumb_create,</span><br><span class="line">    <span class="comment">//在drm设备节点的地址空间中分配偏移量，以便能够存储映射一个dumb buffer  （用户通过 ioctl 调用）</span></span><br><span class="line">    .dumb_map_offset = virtio_gpu_mode_dumb_mmap,</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_DEBUG_FS)</span></span><br><span class="line">    .debugfs_init = virtio_gpu_debugfs_init,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">//Main PRIME export function（输出）</span></span><br><span class="line">    .prime_handle_to_fd = drm_gem_prime_handle_to_fd,</span><br><span class="line">    <span class="comment">//Main PRIME import function（输入）</span></span><br><span class="line">    .prime_fd_to_handle = drm_gem_prime_fd_to_handle,</span><br><span class="line">    <span class="comment">//用于实现dma-buf mmap</span></span><br><span class="line">    .gem_prime_mmap = drm_gem_prime_mmap,</span><br><span class="line">    <span class="comment">//export接口钩子GEM驱动</span></span><br><span class="line">    .gem_prime_export = virtgpu_gem_prime_export,</span><br><span class="line">    <span class="comment">//import接口钩子GEM驱动</span></span><br><span class="line">    .gem_prime_import = virtgpu_gem_prime_import,</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    .gem_prime_import_sg_table = virtgpu_gem_prime_import_sg_table,</span><br><span class="line"></span><br><span class="line">    <span class="comment">//GEM对象的构造函数</span></span><br><span class="line">    .gem_create_object = virtio_gpu_create_object,</span><br><span class="line">    <span class="comment">//DRM 设备节点的文件操作</span></span><br><span class="line">    .fops = &amp;virtio_gpu_driver_fops,</span><br><span class="line"></span><br><span class="line">    <span class="comment">//驱动私有的IOCTL描述条目数组</span></span><br><span class="line">    .ioctls = virtio_gpu_ioctls,</span><br><span class="line">    .num_ioctls = DRM_VIRTIO_NUM_IOCTLS,</span><br><span class="line"></span><br><span class="line">    .name = DRIVER_NAME,</span><br><span class="line">    .desc = DRIVER_DESC,</span><br><span class="line">    .date = DRIVER_DATE,</span><br><span class="line">    .major = DRIVER_MAJOR,</span><br><span class="line">    .minor = DRIVER_MINOR,</span><br><span class="line">    .patchlevel = DRIVER_PATCHLEVEL,</span><br><span class="line">    <span class="comment">//用于在释放最终引用后销毁设备数据</span></span><br><span class="line">    .release = virtio_gpu_release,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>设备驱动</category>
      </categories>
      <tags>
        <tag>gpu</tag>
        <tag>kernel</tag>
        <tag>drm</tag>
        <tag>driver</tag>
      </tags>
  </entry>
  <entry>
    <title>GPU page fault</title>
    <url>/post/793.html</url>
    <content><![CDATA[<p>尽管许多GPU都支持页面错误，但并非所有都支持。 一些GPU使用下列方式响应内存错误：</p>
<ul>
<li>位存储桶写入(bit-bucket writes)</li>
<li>读取模拟数据（如零）(reading simulated data (for example, zeros))</li>
<li>或仅挂起(by simply hanging)</li>
</ul>
<span id="more"></span>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[  712.873530] amdgpu 0001:01:00.0: GPU fault detected: 146 0x0218082c</span><br><span class="line">[  712.878462] pcieport 0001:00:00.0: AER: Multiple Corrected error received: id=0000</span><br><span class="line">[  712.878469] pcieport 0001:00:00.0: PCIe Bus Error: severity=Corrected, type=Physical Layer, id=0000(Receiver ID)</span><br><span class="line">[  712.878471] pcieport 0001:00:00.0:   device [1def:e006] error status/mask=00000001/00002000</span><br><span class="line">[  712.878472] pcieport 0001:00:00.0:    [ 0] Receiver Error         (First)</span><br><span class="line">[  712.912617] amdgpu 0001:01:00.0:   VM_CONTEXT1_PROTECTION_FAULT_ADDR   0x00101043</span><br><span class="line">[  712.920085] amdgpu 0001:01:00.0:   VM_CONTEXT1_PROTECTION_FAULT_STATUS 0x0400802C</span><br><span class="line">[  712.927554] amdgpu 0001:01:00.0: VM fault (0x2c, vmid 2) at page 1052739, read from &#x27;TC2&#x27; (0x54433200) (8)</span><br><span class="line">[  712.937273] amdgpu 0001:01:00.0: GPU fault detected: 146 0x03403d0c</span><br><span class="line">[  712.943527] amdgpu 0001:01:00.0:   VM_CONTEXT1_PROTECTION_FAULT_ADDR   0x00101468</span><br><span class="line">[  712.950995] amdgpu 0001:01:00.0:   VM_CONTEXT1_PROTECTION_FAULT_STATUS 0x0403D00C</span><br><span class="line">[  712.958463] amdgpu 0001:01:00.0: VM fault (0x0c, vmid 2) at page 1053800, read from &#x27;SDM1&#x27; (0x53444d31) (61)</span><br><span class="line">[  712.968329] amdgpu 0001:01:00.0: GPU fault detected: 146 0x03a0770c</span><br><span class="line">[  712.974582] amdgpu 0001:01:00.0:   VM_CONTEXT1_PROTECTION_FAULT_ADDR   0x00101474</span><br><span class="line">[  712.982050] amdgpu 0001:01:00.0:   VM_CONTEXT1_PROTECTION_FAULT_STATUS 0x0A07700C</span><br><span class="line">[  712.989519] amdgpu 0001:01:00.0: VM fault (0x0c, vmid 5) at page 1053812, read from &#x27;SDM0&#x27; (0x53444d30) (119)</span><br></pre></td></tr></table></figure>

<h2 id="造成的现象"><a href="#造成的现象" class="headerlink" title="造成的现象"></a>造成的现象</h2><p>系统整体卡住，有时鼠标键盘无响应，但是可以通过ssh登录系统，并且测试无法kill掉xorg</p>
<h2 id="GPU页错误"><a href="#GPU页错误" class="headerlink" title="GPU页错误"></a>GPU页错误</h2><blockquote>
<p>A GPU page fault commonly occurs under one of these conditions. An application mistakenly executes work on the GPU that references a deleted object. This is one of the top reasons for an unexpected device removal. An application mistakenly executes work on the GPU that accesses an evicted resource, or a non-resident tile.</p>
</blockquote>
<p> GPU 页面错误通常在下列情况之一下发生：</p>
<ul>
<li>应用程序在 GPU 上错误地执行了应用已删除的对象的作业。 这是意外删除设备的主要原因之一。</li>
<li>应用程序错误地在 GPU 上执行了访问已逐出的资源或非驻留磁贴的作业。</li>
<li>着色器引用未初始化的或过时的描述符。</li>
<li>着色器索引超出根绑定末尾。</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLm1pY3Jvc29mdC5jb20vZW4tdXMvd2luZG93cy93aW4zMi9kaXJlY3QzZDEyL3VzZS1kcmVk">Use DRED to diagnose GPU faults<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLm1pY3Jvc29mdC5jb20vemgtY24vd2luZG93cy93aW4zMi9kaXJlY3QzZDEyL3VzZS1kcmVk">使用 DRED 诊断 GPU 错误<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9idWdzLmZyZWVkZXNrdG9wLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTA1MjUx">[Vega10] GPU lockup on boot: VMC page fault<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL29uLWRlbWFuZC5ncHV0ZWNoY29uZi5jb20vZ3RjLzIwMTYvcHJlc2VudGF0aW9uL3M2NTE3LXNhbWFuLWFzaGtpYW5pLWd0Yy1tdWx0aXNwbGl0LnBkZg==">GPU Multisplit<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9idWdzLmZyZWVkZXNrdG9wLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTA1NzMz">Bug 105733 - Amdgpu randomly hangs and only ssh works. Mouse cursor moves sometimes but does nothing. Keyboard stops working. <i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL2JhbGxtZXJwZWFrLndlYi5lbHRlLmh1L2RldmJsb2cvZGVidWdnaW5nLW1lc2EtYW5kLXRoZS1saW51eC0zZC1ncmFwaGljcy1zdGFjay5odG1s">Debugging mesa and the linux 3D graphics stack <i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL2JhbGxtZXJwZWFrLndlYi5lbHRlLmh1L2RldmJsb2cvZGVidWdnaW5nLWh5cGVyei1hbmQtZml4aW5nLWEtcmFkZW9uLWRybS1saW51eC1rZXJuZWwtbW9kdWxlLmh0bWw=">Debugging HyperZ and fixing a radeon drm linux kernel module <i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>设备驱动</category>
      </categories>
      <tags>
        <tag>gpu</tag>
      </tags>
  </entry>
  <entry>
    <title>DRM笔记——基本概念</title>
    <url>/post/195f15d1.html</url>
    <content><![CDATA[<p><code>DRM</code>（Direct Rendering Manager）是linux中主流的图形显示框架，它将GPU的管理驱动和Display驱动，使得软件架构更为统一，方便管理和维护</p>
<p><img data-src="/images/2020/11/drm.png" alt="DRM"></p>
<p>DRM主要可以分为3部分：<code>libdrm</code>、<code>KMS</code>、<code>GEM</code></p>
<span id="more"></span>

<h2 id="libdrm"><a href="#libdrm" class="headerlink" title="libdrm"></a>libdrm</h2><p>对linux系统底层接口进行了封装，向上层通过统一的API接口，主要是将驱动的各种ioctl接口的封装</p>
<h2 id="KMS"><a href="#KMS" class="headerlink" title="KMS"></a>KMS</h2><blockquote>
<p>目的：将不同的像素缓冲区渲染到屏幕上或内存中。</p>
</blockquote>
<p>Kernel Mode Setting，所谓Mode setting，其实说白了就两件事：<code>更新画面</code>和<code>设置显示参数</code>。</p>
<ul>
<li>更新画面：显示buffer的切换，多图层的合成方式，以及每个图层的显示位置。</li>
<li>设置显示参数：包括分辨率、刷新率、电源状态（休眠唤醒）等。</li>
</ul>
<h2 id="GEM"><a href="#GEM" class="headerlink" title="GEM"></a>GEM</h2><p>Graphic Execution Manager，主要负责显示buffer的分配和释放，也是GPU唯一用到DRM的地方。</p>
<h2 id="基本元素"><a href="#基本元素" class="headerlink" title="基本元素"></a>基本元素</h2><p>DRM框架涉及到的元素很多，大致如下：<br>KMS：<code>CRTC</code>，<code>ENCODER</code>，<code>CONNECTOR</code>，<code>PLANE</code>，<code>FB</code>，<code>VBLANK</code>，<code>property</code><br>GEM：<code>DUMB</code>、<code>PRIME</code>、<code>fence</code></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><span class="exturl" data-url="aHR0cDovL3d3dy5sYW5kbGV5Lm5ldC9rZG9jcy9odG1sZG9jcy9kcm0uaHRtbCNkcm1JbnRyb2R1Y3Rpb24=">Linux DRM Developer’s Guide<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hleGlhb2xvbmcyMDA5L2FydGljbGUvZGV0YWlscy84MzcyMDk0MA==">DRM（Direct Rendering Manager）学习简介<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>设备驱动</category>
      </categories>
      <tags>
        <tag>gpu</tag>
        <tag>kernel</tag>
        <tag>drm</tag>
        <tag>driver</tag>
      </tags>
  </entry>
  <entry>
    <title>linux驱动——DMA</title>
    <url>/post/2cf26afe.html</url>
    <content><![CDATA[<p><code>DMA</code>（Direct Memory Access），直接内存访问，这里的直接是和需要CPU参与的内存访问相对的概念。</p>
<p>主要使用场景：</p>
<ul>
<li>将数据从一片内存搬到另一片内存</li>
<li>从IO设备读取数据到内存</li>
<li>将内存数据写入IO设备</li>
</ul>
<span id="more"></span>

<h2 id="DMA控制器"><a href="#DMA控制器" class="headerlink" title="DMA控制器"></a>DMA控制器</h2><h3 id="相关寄存器"><a href="#相关寄存器" class="headerlink" title="相关寄存器"></a>相关寄存器</h3><p>DMA控制器 一般都会包含以下寄存器：</p>
<ul>
<li>DMA硬件描述符地址寄存器：存放DMA描述符的地址。</li>
<li>DMA配置寄存器：配置DMA的burst、width、传输方向等属性。</li>
<li>DMA使能寄存器：使能DMA通道</li>
<li>DMA中断状态寄存器：获取DMA传输中断状态</li>
<li>DMA中断使能寄存器：使能DMA通道中断</li>
</ul>
<h3 id="DMA描述符"><a href="#DMA描述符" class="headerlink" title="DMA描述符"></a>DMA描述符</h3><p><img data-src="/images/2021/11/dma_desc_llp.png" alt="dma_desc_llp"></p>
<ul>
<li><code>DSTATx</code>： 目的地址</li>
<li><code>SSTATx</code>： 源地址</li>
<li><code>CTLx</code>： 描述符配置信息，数据宽度、burst、传输方向、数据大小等</li>
<li><code>LLPx</code>： 下一个dma描述符地址（内存的物理地址）</li>
<li><code>DARx</code>&#x2F;<code>SARx</code>： 目标分散寄存器&#x2F;源收集寄存器（这两个配置没有使用）</li>
</ul>
<p>DMA控制器进行数据传输时，我们需要申请一块内存（必须保证物理地址连续）用于存在dma描述符。当dma控制器进行工作时，需要将dma描述符的首地址配置到dma描述符地址寄存器中，这样当dma控制器使能正常工作时，会根据dma描述符地址寄存器中的地址读取相应的dma描述符，再根据dma描述符中的相关配置对dma控制器进行配置并进行数据传输，数据传输完成后使能dma传输完成的相应中断。</p>
<h3 id="DMA-request"><a href="#DMA-request" class="headerlink" title="DMA request"></a>DMA request</h3><p>一般情况下，当外设驱动准备好传输数据及任务配置后，需要向DMA控制器发送<code>DRQ信号</code>(DMA request)。所以需要有<code>物理线</code>连接DMA控制器和外设，这条物理线称为<code>DMA request line</code>。发送这个信号往往是向 DMA配置寄存器中写入DRQ值。每种外设驱动都有自己的DRQ值，当启动DMA传输后，会查询DRQ值，如果当前的DRQ值 能够进行传输，则启动DMA传输。</p>
<p>有时<code>DMA request (line)</code>又称为<code>DMA port</code>。</p>
<h3 id="DMA-channel"><a href="#DMA-channel" class="headerlink" title="DMA channel"></a>DMA channel</h3><p>DMA控制器可以<code>同时</code>进行的传输个数是有限的，每一个传输都需要使用到DMA物理通道。<code>DMA物理通道</code>的数量决定了DMA控制器能够同时传输的任务量。<br>在软件上，DMA控制器会为外设分配一个DMA虚拟通道，这个虚拟通道是根据<code>DMA request信号</code>来区分。<br>通常来讲，DMA物理通道是DMA控制器提供的服务，外设通过申请DMA通道 ，如果申请成功将返回DMA虚拟通道，该DMA虚拟通道绑定了一个DMA物理通道。这样DMA控制器为外设提供了DMA服务，当外设需要传输数据时，对虚拟通道进行操作即可，但本质上的工作由物理通道来完成。</p>
<h3 id="DMA-burst"><a href="#DMA-burst" class="headerlink" title="DMA burst"></a>DMA burst</h3><p>dma实际上是一次一次的申请总线，把要传的数据总量分成一个一个小的数据块。比如要传64个字节，那么dma内部可能分为2次，一次传64&#x2F;2&#x3D;32个字节，这个2(a)次呢，就叫做<code>burst</code>。这个burst是可以设置的,这32个字节又可以分为32bit<em>8 或者 16bit</em>16来传输</p>
<ul>
<li><code>transfer size</code>(data width): 数据宽度，比如8位、32位，一般跟外设的FIFO相同</li>
<li><code>burst size</code>: 一次传几个transfer size (一般是外设FIFO深度的一半)</li>
</ul>
<p>也就是说DMA一次申请总线传输的数据量是(burst_size*data_width)位</p>
<h2 id="DMA-engine"><a href="#DMA-engine" class="headerlink" title="DMA engine"></a>DMA engine</h2><p>Linux内核里把DMA分为<code>provider</code>和<code>client</code>两种角色：</p>
<ul>
<li><code>provider</code>: DMA控制器驱动，它直接访问寄存器，提供DMA通道，但并不提供用户态可用的系统调用或设备文件</li>
<li><code>client</code>: 申请使用DMA通道，结合具体外设实现真正的驱动功能</li>
</ul>
<p><img data-src="/images/2021/11/dma_engine.png" alt="dma_engine"><br>头文件：<code>include/linux/dmaengine.h</code></p>
<p>在DMA Client驱动中粗略的讲要做下面的事情：</p>
<ol>
<li>申请一个DMA channel——dma_request_chan。</li>
<li>根据设备（slave）的特性，配置DMA channel的参数——dmaengine_slave_config。</li>
<li>要进行DMA传输的时候，获取一个用于识别本次传输（transaction）的描述符（descriptor）—— dmaengine_prep_slave_sg。</li>
<li>将本次传输（transaction）提交给dma engine并启动传输 —— dmaengine_submit。</li>
<li>等待传输（transaction）结束 —— wait_for_completion_timeout。</li>
</ol>
<h2 id="Synopsys-Designware-DMA-Controller"><a href="#Synopsys-Designware-DMA-Controller" class="headerlink" title="Synopsys Designware DMA Controller"></a>Synopsys Designware DMA Controller</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">properties:</span><br><span class="line">  compatible:</span><br><span class="line">    const: snps,dma-spear1340</span><br><span class="line"></span><br><span class="line">  &quot;#dma-cells&quot;:</span><br><span class="line">    minimum: 3</span><br><span class="line">    maximum: 4</span><br><span class="line">    description: |</span><br><span class="line">      First cell is a phandle pointing to the DMA controller. Second one is</span><br><span class="line">      the DMA request line number. Third cell is the memory master identifier</span><br><span class="line">      for transfers on dynamically allocated channel. Fourth cell is the</span><br><span class="line">      peripheral master identifier for transfers on an allocated channel. Fifth</span><br><span class="line">      cell is an optional mask of the DMA channels permitted to be allocated</span><br><span class="line">      for the corresponding client device.</span><br><span class="line">  reg:</span><br><span class="line">    maxItems: 1</span><br><span class="line"></span><br><span class="line">  interrupts:</span><br><span class="line">    maxItems: 1</span><br><span class="line"></span><br><span class="line">  clocks:</span><br><span class="line">    maxItems: 1</span><br><span class="line"></span><br><span class="line">  clock-names:</span><br><span class="line">    description: AHB interface reference clock.</span><br><span class="line">    const: hclk</span><br><span class="line"></span><br><span class="line">  dma-channels:</span><br><span class="line">    description: |</span><br><span class="line">      Number of DMA channels supported by the controller. In case if</span><br><span class="line">      not specified the driver will try to auto-detect this and</span><br><span class="line">      the rest of the optional parameters.</span><br><span class="line">    minimum: 1</span><br><span class="line">    maximum: 8</span><br><span class="line"></span><br><span class="line">  dma-requests:</span><br><span class="line">    minimum: 1</span><br><span class="line">    maximum: 16</span><br><span class="line"></span><br><span class="line">  dma-masters:</span><br><span class="line">    $ref: /schemas/types.yaml#definitions/uint32</span><br><span class="line">    description: |</span><br><span class="line">      Number of DMA masters supported by the controller. In case if</span><br><span class="line">      not specified the driver will try to auto-detect this and</span><br><span class="line">      the rest of the optional parameters.</span><br><span class="line">    minimum: 1</span><br><span class="line">    maximum: 4</span><br><span class="line"></span><br><span class="line">  chan_allocation_order:</span><br><span class="line">    $ref: /schemas/types.yaml#definitions/uint32</span><br><span class="line">    description: |</span><br><span class="line">      DMA channels allocation order specifier. Zero means ascending order</span><br><span class="line">      (first free allocated), while one - descending (last free allocated).</span><br><span class="line">    default: 0</span><br><span class="line">    enum: [0, 1]</span><br><span class="line"></span><br><span class="line">  chan_priority:</span><br><span class="line">    $ref: /schemas/types.yaml#definitions/uint32</span><br><span class="line">    description: |</span><br><span class="line">      DMA channels priority order. Zero means ascending channels priority</span><br><span class="line">      so the very first channel has the highest priority. While 1 means</span><br><span class="line">      descending priority (the last channel has the highest priority).</span><br><span class="line">    default: 0</span><br><span class="line">    enum: [0, 1]</span><br><span class="line"></span><br><span class="line">  block_size:</span><br><span class="line">    $ref: /schemas/types.yaml#definitions/uint32</span><br><span class="line">    description: Maximum block size supported by the DMA controller.</span><br><span class="line">    enum: [3, 7, 15, 31, 63, 127, 255, 511, 1023, 2047, 4095]</span><br><span class="line"></span><br><span class="line">  data-width:</span><br><span class="line">    $ref: /schemas/types.yaml#/definitions/uint32-array</span><br><span class="line">    description: Data bus width per each DMA master in bytes.</span><br><span class="line">    items:</span><br><span class="line">      maxItems: 4</span><br><span class="line">      items:</span><br><span class="line">        enum: [4, 8, 16, 32]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1hpbGlueC9saW51eC14bG54L2Jsb2IvbWFzdGVyL0RvY3VtZW50YXRpb24vZGV2aWNldHJlZS9iaW5kaW5ncy9kbWEvc25wcyUyQ2RtYS1zcGVhcjEzNDAueWFtbA==">https://github.com/Xilinx/linux-xlnx/blob/master/Documentation/devicetree/bindings/dma/snps%2Cdma-spear1340.yaml<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC9lMWI2MjIyMzRkMTM=">linux驱动之DMA<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>设备驱动</category>
      </categories>
      <tags>
        <tag>dma</tag>
      </tags>
  </entry>
  <entry>
    <title>pcieport报错分析--网络间隔断掉</title>
    <url>/post/7a90000d.html</url>
    <content><![CDATA[<p>有线网络间隔断开,查看系统日志pcie端口存在错误打印</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kernel: pcieport 0000:00:1c.0: AER: Multiple Corrected error received: 0000:00:1c.0</span><br><span class="line">kernel: pcieport 0000:00:1c.0: AER: PCIe Bus Error: severity=Corrected, type=Data Link Layer, (Transmitter ID)</span><br><span class="line">kernel: pcieport 0000:00:1c.0: AER:   device [8086:a115] error status/mask=00001000/00002000</span><br><span class="line">kernel: pcieport 0000:00:1c.0: AER:    [12] Timeout</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="错误信息"><a href="#错误信息" class="headerlink" title="错误信息"></a>错误信息</h2><p>在错误信息中指出PCIE总线<code>0000:00:1c.0</code>的设备<code>[8086:a115]</code>存在错误</p>
<h2 id="确定出错设备"><a href="#确定出错设备" class="headerlink" title="确定出错设备"></a>确定出错设备</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">lspci -nn | grep <span class="string">&quot;8086:a115&quot;</span></span></span><br><span class="line">00:1c.0 PCI bridge [0604]: Intel Corporation 100 Series/C230 Series Chipset Family PCI Express Root Port #6 [8086:a115] (rev f1)</span><br></pre></td></tr></table></figure>
<p>获取出错总线的具体信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">lspci -s 00:1c.0 -v</span></span><br><span class="line">00:1c.0 PCI bridge: Intel Corporation 100 Series/C230 Series Chipset Family PCI Express Root Port #6 (rev f1) (prog-if 00 [Normal decode])</span><br><span class="line">	Flags: bus master, fast devsel, latency 0, IRQ 121</span><br><span class="line">	Bus: primary=00, secondary=02, subordinate=02, sec-latency=0</span><br><span class="line">	I/O behind bridge: 0000d000-0000dfff [size=4K]</span><br><span class="line">	Memory behind bridge: dfd00000-dfdfffff [size=1M]</span><br><span class="line">	Prefetchable memory behind bridge: 00000000d0000000-00000000d00fffff [size=1M]</span><br><span class="line">	Capabilities: &lt;access denied&gt;</span><br><span class="line">	Kernel driver in use: pcieport</span><br></pre></td></tr></table></figure>

<h2 id="跟踪端口"><a href="#跟踪端口" class="headerlink" title="跟踪端口"></a>跟踪端口</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">lspci -t</span></span><br><span class="line">-[0000:00]-+-00.0</span><br><span class="line">           +-01.0-[01]--+-00.0</span><br><span class="line">           |            \-00.1</span><br><span class="line">           +-14.0</span><br><span class="line">           +-16.0</span><br><span class="line">           +-17.0</span><br><span class="line">           +-1c.0-[02]----00.0</span><br><span class="line">           +-1f.0</span><br><span class="line">           +-1f.2</span><br><span class="line">           +-1f.3</span><br><span class="line">           \-1f.4</span><br></pre></td></tr></table></figure>
<p>pci的树状接口图，这里可以看到<code>1c.0</code>接到<code>02</code>设备</p>
<h2 id="查找设备"><a href="#查找设备" class="headerlink" title="查找设备"></a>查找设备</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">=====&gt;$lspci -nn | grep &quot;02&quot;</span><br><span class="line">02:00.0 Ethernet controller [0200]: Realtek Semiconductor Co., Ltd. RTL8111/8168/8411 PCI Express Gigabit Ethernet Controller [10ec:8168] (rev 0c)</span><br></pre></td></tr></table></figure>
<p>出错设备应该是网卡,设备型号<code>RTL8111/8168/8411</code></p>
<h2 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h2><p>其实类型的错误都可以分析为cpu寻址错误，<br>部分类型设备可以通过在grub.cfg里面给引导内核时添加参数<code>pci=nocer</code>, <code>pci=nomsi</code>之类解决，<br>实际上在正式运行的系统里面不应该有此错误，因为理论上驱动都是经测试正常的<br>那我们就只能得出一个结论，驱动不适合此设备</p>
<blockquote>
<p>一般情况下得先确认设备驱动是否合适</p>
</blockquote>
<h2 id="查看网卡驱动"><a href="#查看网卡驱动" class="headerlink" title="查看网卡驱动"></a>查看网卡驱动</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">sudo lshw -C network</span></span><br><span class="line">  *-network</span><br><span class="line">       description: Ethernet interface</span><br><span class="line">       product: RTL8111/8168/8411 PCI Express Gigabit Ethernet Controller</span><br><span class="line">       vendor: Realtek Semiconductor Co., Ltd.</span><br><span class="line">       physical id: 0</span><br><span class="line">       bus info: pci@0000:02:00.0</span><br><span class="line">       logical name: enp2s0</span><br><span class="line">       version: 0c</span><br><span class="line">       serial: c8:5b:76:dc:a4:80</span><br><span class="line">       size: 1Gbit/s</span><br><span class="line">       capacity: 1Gbit/s</span><br><span class="line">       width: 64 bits</span><br><span class="line">       clock: 33MHz</span><br><span class="line">       capabilities: pm msi pciexpress msix vpd bus_master cap_list ethernet physical tp 10bt 10bt-fd 100bt 100bt-fd 1000bt-fd autonegotiation</span><br><span class="line">       configuration: autonegotiation=on broadcast=yes driver=r8168 driverversion=8.048.02-NAPI duplex=full ip=172.16.200.52 latency=0 link=yes multicast=yes port=twisted pair speed=1Gbit/s</span><br><span class="line">       resources: irq:124 ioport:d000(size=256) memory:dfd00000-dfd00fff memory:d0000000-d0003fff</span><br></pre></td></tr></table></figure>

<p><strong>网卡驱动为<code>r8168</code>,但是网卡设备是<code>RTL8111/8168/8411</code>,出现的错误应该是设备驱动不匹配造成的</strong></p>
<h2 id="更换网卡驱动"><a href="#更换网卡驱动" class="headerlink" title="更换网卡驱动"></a>更换网卡驱动</h2><h3 id="apt安装"><a href="#apt安装" class="headerlink" title="apt安装"></a>apt安装</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install r8168-dkms</span><br></pre></td></tr></table></figure>

<h3 id="源码手动安装"><a href="#源码手动安装" class="headerlink" title="源码手动安装"></a>源码手动安装</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://codeload.github.com/mtorromeo/r8168/tar.gz/8.048.02</span><br><span class="line">tar zxvf r8168-8.048.02.tar.gz &amp;&amp; r8168-8.048.02</span><br><span class="line">sudo ./autorun.sh</span><br></pre></td></tr></table></figure>
<blockquote>
<p>更新完设备驱动后,网络连接正常,系统日志不再出现pcie错误打印</p>
</blockquote>
<h2 id="r8169驱动模块加入黑名单"><a href="#r8169驱动模块加入黑名单" class="headerlink" title="r8169驱动模块加入黑名单"></a>r8169驱动模块加入黑名单</h2><p>在<code>/etc/modprobe.d/</code>下添加文件<code>blacklist-r8169.conf</code>内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">blacklist r8169</span><br></pre></td></tr></table></figure>

<ul>
<li><p>备份当前initrd文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo cp /boot/initrd.img-`uname -r` /boot/initrd.img-`uname -r`.bak</span><br></pre></td></tr></table></figure>
</li>
<li><p>重新生成initrd文件,根据<code>/etc/modprobe.d/</code>下的文件规则</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo update-initramfs -u</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>设备驱动</category>
      </categories>
      <tags>
        <tag>网络</tag>
        <tag>网卡</tag>
        <tag>pcie</tag>
      </tags>
  </entry>
  <entry>
    <title>Virtio GPU</title>
    <url>/post/56420.html</url>
    <content><![CDATA[<blockquote>
<p>For containers in virtualized environments, they are working on accelerated OpenGL ES 2.0 support with that being the lowest common denominator for many mobile platforms. This virtual GPU access they are pursuing is making use of Red Hat’s work on Virgil3D as the Gallium3D-based solution for graphics pass-through to the host. Then for the kernel bits are VirtIO-GPU and on the host is the Virgl Renderer with QEMU.</p>
</blockquote>
<p><img data-src="/images/2019/08/virtio_gpu_qemu_layer.png" alt="virtio-gpu-qemu-layer"></p>
<span id="more"></span>

<h2 id="OpenGL"><a href="#OpenGL" class="headerlink" title="OpenGL"></a>OpenGL</h2><p>OpenGL, OpenGL ES, and OpenGL ES-SC API and Extension Registry</p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0tocm9ub3NHcm91cC9PcGVuR0wtUmVnaXN0cnkv">OpenGL-Registry<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<h2 id="EGL"><a href="#EGL" class="headerlink" title="EGL"></a>EGL</h2><p><code>EGL</code>是图形渲染API（如OpenGL ES）与本地平台窗口系统的一层接口，保证了OpenGL ES的平台独立性。EGL提供了若干功能：创建rendering surface、创建graphics context、同步应用程序和本地平台渲染API、提供对显示设备的访问、提供对渲染配置的管理等。</p>
<p>egl是一个管理者的功能。包括管理所有的display ， context， surface，config。可能有很多的display ，每个display有很多的configs，这个display上可以创建很多的context和surface</p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cua2hyb25vcy5vcmcvcmVnaXN0cnkvRUdML3Nkay9kb2NzL21hbi8=">EGL Reference Pages<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cua2hyb25vcy5vcmcvZmlsZXMvZWdsLTEtNC1xdWljay1yZWZlcmVuY2UtY2FyZC5wZGY=">1EGL 1.4 API Quick Reference Card<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<h2 id="GLX"><a href="#GLX" class="headerlink" title="GLX"></a>GLX</h2><p><code>GLX</code>是OpenGL Extension to the X Window System的缩写。它作为x的扩展，是x协议和X server的一部分，已经包含在X server的代码中了。GLX提供了X window system使用的OpenGL接口，允许通过x调用OpenGL库。OpenGL 在使用时，需要与一个实际的窗口系统关联起来。</p>
<h2 id="GLX、EGL与OpenGL-ES之间的关系？？"><a href="#GLX、EGL与OpenGL-ES之间的关系？？" class="headerlink" title="GLX、EGL与OpenGL ES之间的关系？？"></a>GLX、EGL与OpenGL ES之间的关系？？</h2><blockquote>
<p>一般EGL和OpenGL ES使用时都会先利用egl函数(egl开头)创建opengl本地环境，然后再利用opengl函数(gl开头)去画图。</p>
</blockquote>
<p><strong>EGL代替的是原先WGL&#x2F;GLX那套context管理，跟图形API用的什么没关系</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">EGLBoolean <span class="title function_">eglBindAPI</span><span class="params">( 	EGLenum api)</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Parameters api:<br>   Specifies the client API to bind, one of <code>EGL_OPENGL_API</code>, <code>EGL_OPENGL_ES_API</code>, or <code>EGL_OPENVG_API</code>.</p>
</blockquote>
<h2 id="mesa"><a href="#mesa" class="headerlink" title="mesa"></a>mesa</h2><h3 id="Gallium"><a href="#Gallium" class="headerlink" title="Gallium"></a>Gallium</h3><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9nYWxsaXVtLnJlYWR0aGVkb2NzLmlvL2VuL2xhdGVzdC8=">Gallium’s documentation<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9kcmkuZnJlZWRlc2t0b3Aub3JnL2RveHlnZW4vZ2FsbGl1bS9pbmRleC5odG1s">Gallium3D Documentation doxygen<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<h2 id="DRI"><a href="#DRI" class="headerlink" title="DRI"></a>DRI</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cueC5vcmcvd2lraS9FdmVudHMvWERDMjAxMy9YREMyMDEzRXJpY0FuaG9sdERSSU1lZ2Fkcml2ZXJzL3hkYy0yMDEzLW1lZ2Fkcml2ZXJzLnBkZg==">DRI megadrivers<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<h2 id="Virgil"><a href="#Virgil" class="headerlink" title="Virgil"></a>Virgil</h2><blockquote>
<p>Virgil is an effort to provide 3D acceleration using <code>Gallium3D</code> for QEMU+KVM virtual machine guests.</p>
</blockquote>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cucGhvcm9uaXguY29tL3NjYW4ucGhwP3BhZ2U9c2VhcmNoJnE9VmlyZ2ls">Virgil Linux News<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly94ZGMyMDE4Lngub3JnL3NsaWRlcy9WaXJnbF9QcmVzZW50YXRpb24ucGRm">What’s new in the virtual world?(pdf)<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9zdHVkaW9waXhsLmNvbS8yMDE4LTA3LTEyL3Z1bGthbi1pemUtdmlyZ2wuaHRtbA==">GSoC 2018 - Vulkan-ize Virglrenderer<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9zdHVkaW9waXhsLmNvbS8yMDE3LTA4LTI3LzNkLWFjY2VsZXJhdGlvbi11c2luZy12aXJ0aW8uaHRtbA==">GSoC 2017 - 3D acceleration using VirtIOGPU<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<h3 id="virgl-protocol"><a href="#virgl-protocol" class="headerlink" title="virgl_protocol"></a>virgl_protocol</h3><p>It is composed of several components:</p>
<ul>
<li>a MESA driver, on the guest, which generates <code>Virgl commands</code></li>
<li>a lib, on the host, which takes virgl commands and generated OpenGL calls from it.</li>
</ul>
<h2 id="GPU-Driver"><a href="#GPU-Driver" class="headerlink" title="GPU Driver"></a>GPU Driver</h2><h3 id="DRM"><a href="#DRM" class="headerlink" title="DRM"></a>DRM</h3><blockquote>
<p>he DRM core includes two memory managers, namely Translation Table Maps (TTM) and Graphics Execution Manager (GEM).</p>
</blockquote>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTI4MzkxODcvYXJ0aWNsZS9kZXRhaWxzLzg5ODc1ODAw">Linux GPU Driver Developer’s Guide<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL2p1Lm91dG9mbWVtb3J5LmNuL2VudHJ5LzE1ODkwOQ==">DRM memory management - 最好的GEM&#x2F;TTM&#x2F;PRIME解释<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<h2 id="piglit"><a href="#piglit" class="headerlink" title="piglit"></a>piglit</h2><h2 id="GLSL"><a href="#GLSL" class="headerlink" title="GLSL"></a>GLSL</h2><blockquote>
<p>OpenGL着色语言（OpenGL Shading Language）是用来在OpenGL中着色编程的语言，也即开发人员写的短小的自定义程序，他们是在图形卡的GPU （Graphic Processor Unit图形处理单元）上执行的，代替了固定的渲染管线的一部分，使渲染管线中不同层次具有可编程性。</p>
</blockquote>
<h2 id="X-org"><a href="#X-org" class="headerlink" title="X.org"></a>X.org</h2><p>2018年X.Org开发者大会相关文档和视频（网络原因视频看不了）</p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cueC5vcmcvd2lraS9FdmVudHMvWERDMjAxOC8=">https://www.x.org/wiki/Events/XDC2018/<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<h2 id="graphics-pipeline"><a href="#graphics-pipeline" class="headerlink" title="graphics pipeline"></a>graphics pipeline</h2><p><img data-src="/images/2020/07/graphics_pipeline.png" alt="graphics_pipeline"></p>
<blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cuc2Vhcy51cGVubi5lZHUvfmNpczU2NS9MRUNUVVJFUy9MZWN0dXJlMg==">https://www.seas.upenn.edu/~cis565/LECTURES/Lecture2<i class="fa fa-external-link-alt"></i></span> New.pdf</p>
</blockquote>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRsYWIuY29tL3NwaWNlL3dpbjMyL3ZpcnRpby1ncHUtd2RkbS1kb2Q=">virtio-gpu-wddm-dod<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0tlZW51dHMvdmlydGlvLWdwdS13aW4taWNk">OpenGL ICD for Virtio-GPU Windows driver(Github)<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLm9hc2lzLW9wZW4ub3JnL3ZpcnRpby92aXJ0aW8vdjEuMS9jczAxL3ZpcnRpby12MS4xLWNzMDEuaHRtbA==">Virtual I&#x2F;O Device (VIRTIO) Version 1.1<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9zdHVkaW9waXhsLmNvbS8yMDE3LTA4LTI3LzNkLWFjY2VsZXJhdGlvbi11c2luZy12aXJ0aW8uaHRtbA==">GSoC 2017 - 3D acceleration using VirtIOGPU<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9zdHVkaW9waXhsLmNvbS8yMDE4LTA3LTEyL3Z1bGthbi1pemUtdmlyZ2wuaHRtbA==">GSoC 2018 - Vulkan-ize Virglrenderer<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9tZXNhbWF0cml4Lm5ldC8=">The OpenGL vs Mesa matrix<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9tZW1jcHkuaW8vdmlydHVhbGl6aW5nLWdwdS1hY2Nlc3MuaHRtbA==">Virtualizing GPU Access<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cua3JheGVsLm9yZy9ibG9nLw==">kraxel’s news<i class="fa fa-external-link-alt"></i></span> — virgl and qemu</li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1YW5nOTg3MjQ2NTEwL2FydGljbGUvZGV0YWlscy8xMDc3Mjk4ODE=">VirtIO GPU基本原理<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>设备驱动</category>
      </categories>
      <tags>
        <tag>gpu</tag>
        <tag>virtio</tag>
      </tags>
  </entry>
  <entry>
    <title>ubuntu20_04系统桌面卡死</title>
    <url>/post/17750668.html</url>
    <content><![CDATA[<p>ubuntu20.04在使用过程中桌面出现莫名其妙的卡死现象，但是系统正常没有死，可以通过<code>CTRL+ALT+Fn</code>切换不同的终端，并登录进行操作。这种卡死现象在之前使用的ubuntu18.04中也出现过，根据网上很多解决方法尝试后均无法解决，最后重装新系统ubuntu20.04该问题还是存在，这次就将其在这里简单记录一下。</p>
<span id="more"></span>

<h2 id="桌面卡死后的日志："><a href="#桌面卡死后的日志：" class="headerlink" title="桌面卡死后的日志："></a>桌面卡死后的日志：</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">17:01:55 QTM4600-pc dnsmasq[1009]: reading /etc/resolv.conf</span><br><span class="line">17:01:55 QTM4600-pc dnsmasq[1009]: using nameserver 127.0.0.53#53</span><br><span class="line">17:02:34 QTM4600-pc /usr/lib/gdm3/gdm-x-session[2129]: (**) Option &quot;fd&quot; &quot;25&quot;</span><br><span class="line">17:02:34 QTM4600-pc /usr/lib/gdm3/gdm-x-session[2129]: (II) event2  - Power Button: device removed</span><br><span class="line">17:02:34 QTM4600-pc /usr/lib/gdm3/gdm-x-session[2129]: (**) Option &quot;fd&quot; &quot;28&quot;</span><br><span class="line">17:02:34 QTM4600-pc /usr/lib/gdm3/gdm-x-session[2129]: (II) event1  - Power Button: device removed</span><br><span class="line">17:02:34 QTM4600-pc /usr/lib/gdm3/gdm-x-session[2129]: (**) Option &quot;fd&quot; &quot;29&quot;</span><br><span class="line">17:02:34 QTM4600-pc /usr/lib/gdm3/gdm-x-session[2129]: (II) event0  - Sleep Button: device removed</span><br><span class="line">17:02:34 QTM4600-pc /usr/lib/gdm3/gdm-x-session[2129]: (**) Option &quot;fd&quot; &quot;33&quot;</span><br><span class="line">17:02:34 QTM4600-pc /usr/lib/gdm3/gdm-x-session[2129]: (II) event12 - Logitech USB Optical Mouse: device removed</span><br><span class="line">17:02:34 QTM4600-pc /usr/lib/gdm3/gdm-x-session[2129]: (**) Option &quot;fd&quot; &quot;31&quot;</span><br><span class="line">17:02:34 QTM4600-pc /usr/lib/gdm3/gdm-x-session[2129]: (II) event4  - USB USB Keykoard: device removed</span><br><span class="line">17:02:34 QTM4600-pc /usr/lib/gdm3/gdm-x-session[2129]: (**) Option &quot;fd&quot; &quot;32&quot;</span><br><span class="line">17:02:34 QTM4600-pc /usr/lib/gdm3/gdm-x-session[2129]: (II) event9  - USB USB Keykoard System Control: device removed</span><br><span class="line">17:02:34 QTM4600-pc /usr/lib/gdm3/gdm-x-session[2129]: (**) Option &quot;fd&quot; &quot;48&quot;</span><br><span class="line">17:02:34 QTM4600-pc /usr/lib/gdm3/gdm-x-session[2129]: (**) Option &quot;fd&quot; &quot;48&quot;</span><br><span class="line">17:02:34 QTM4600-pc /usr/lib/gdm3/gdm-x-session[2129]: (II) event8  - USB USB Keykoard Consumer Control: device removed</span><br><span class="line">17:02:34 QTM4600-pc /usr/lib/gdm3/gdm-x-session[2129]: (II) AIGLX: Suspending AIGLX clients for VT switch</span><br><span class="line">17:02:34 QTM4600-pc /usr/lib/gdm3/gdm-x-session[2129]: (II) systemd-logind: got pause for 13:73</span><br><span class="line">17:02:34 QTM4600-pc /usr/lib/gdm3/gdm-x-session[2129]: (II) systemd-logind: got pause for 13:72</span><br><span class="line">17:02:34 QTM4600-pc /usr/lib/gdm3/gdm-x-session[2129]: (II) systemd-logind: got pause for 13:65</span><br><span class="line">17:02:34 QTM4600-pc /usr/lib/gdm3/gdm-x-session[2129]: (II) systemd-logind: got pause for 226:0</span><br><span class="line">17:02:34 QTM4600-pc /usr/lib/gdm3/gdm-x-session[2129]: (II) systemd-logind: got pause for 13:66</span><br><span class="line">17:02:34 QTM4600-pc /usr/lib/gdm3/gdm-x-session[2129]: (II) systemd-logind: got pause for 13:64</span><br><span class="line">17:02:34 QTM4600-pc /usr/lib/gdm3/gdm-x-session[2129]: (II) systemd-logind: got pause for 13:76</span><br><span class="line">17:02:34 QTM4600-pc /usr/lib/gdm3/gdm-x-session[2129]: (II) systemd-logind: got pause for 13:68</span><br><span class="line">17:02:34 QTM4600-pc systemd[1]: Started Getty on tty4.</span><br></pre></td></tr></table></figure>

<p>初步怀疑与gdm3有关，将其换为<code>lightdm</code>看是否会出现卡死现象</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install lightdm</span><br></pre></td></tr></table></figure>

<p><strong>后来又出现了一次界面卡死现象，不过每一次的卡死界面都是在firefox浏览器，后面改用chrome浏览器后情况好了点，暂时没有出现卡死现象</strong></p>
]]></content>
      <categories>
        <category>软件使用</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
        <tag>gdm</tag>
      </tags>
  </entry>
  <entry>
    <title>Graphics driver for Linux</title>
    <url>/post/2caf5a45.html</url>
    <content><![CDATA[<p>Graphics driver for Linux</p>
<span id="more"></span>


<h2 id="NVIDIA-for-Centos7"><a href="#NVIDIA-for-Centos7" class="headerlink" title="NVIDIA for Centos7"></a>NVIDIA for Centos7</h2><blockquote>
<p>为centos7安装<span class="exturl" data-url="aHR0cHM6Ly93d3cubnZpZGlhLmNuL0Rvd25sb2FkL2luZGV4LmFzcHg/bGFuZz1jbg==">NVIDIA<i class="fa fa-external-link-alt"></i></span>驱动程序</p>
</blockquote>
<h3 id="屏蔽系统自带的Nouveau显卡驱动"><a href="#屏蔽系统自带的Nouveau显卡驱动" class="headerlink" title="屏蔽系统自带的Nouveau显卡驱动"></a>屏蔽系统自带的Nouveau显卡驱动</h3><ol>
<li>通过vim编辑器更改配置文件，按照以下内容进行修改</li>
</ol>
<blockquote>
<p>vim &#x2F;lib&#x2F;modprobe.d&#x2F;dist-blacklist.conf</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">blacklist nouveau               #添加此行</span><br><span class="line">options nouveau modeset=0       #添加此行</span><br><span class="line"># blacklist nvidiafb            #将nvidiafb的这一行注释掉</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>重建 initramfs image</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 备份</span><br><span class="line"># mv /boot/initramfs-$(uname -r).img /boot/initramfs-$(uname -r).img.bak</span><br><span class="line"></span><br><span class="line"># 重建</span><br><span class="line"># dracut /boot/initramfs-$(uname -r).img $(uname -r)</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>重启系统确认nouveau驱动没有被加载</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 修改系统运行级别为纯文本模式</span><br><span class="line"># systemctl set-default multi-user.target</span><br><span class="line"></span><br><span class="line"># 重启系统</span><br><span class="line"># reboot</span><br><span class="line"></span><br><span class="line"># 系统重启完成后，在纯文本模式下使用root用户登录进系统</span><br><span class="line"></span><br><span class="line"># 查看nouveau显卡驱动是否已经被禁用，若此命令执行完之后没有输出相关信息，则说明已经被禁用</span><br><span class="line"># lsmod | grep nouveau</span><br></pre></td></tr></table></figure>

<h3 id="安装NVIDIA驱动"><a href="#安装NVIDIA驱动" class="headerlink" title="安装NVIDIA驱动"></a>安装NVIDIA驱动</h3><p>设置下载的驱动文件可执行权限后,直接运行,安装过程中，选择accept；如果提示是否编译DKMS模块，选择yes（方便以后升级系统内核）；如果提示要修改xorg.conf，选择yes</p>
<p>在安装完后使用<code>nvidia-smi</code>测试查看显卡状态,并通过<code>startx</code>确认是否可以启动xorg进入桌面,有时可能需要在生成的<code>xorg.conf</code>中配置显卡驱动的PCI总线地址(注意:地址以十进制表示,需要将lspci的十六进制转换为十进制)</p>
<ul>
<li>修改系统运行级别为图形模式<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl set-default graphical.target</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>软件使用</category>
      </categories>
      <tags>
        <tag>显卡</tag>
        <tag>驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>Android自动化测试工具——Appium</title>
    <url>/post/2b439260.html</url>
    <content><![CDATA[<blockquote>
<p>官网： <span class="exturl" data-url="aHR0cDovL2FwcGl1bS5pby8=">http://appium.io<i class="fa fa-external-link-alt"></i></span><br>Github： <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FwcGl1bQ==">https://github.com/appium<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<p><code>Appium</code>是一个开源工具，用于自动化<code>iOS手机</code>、 <code>Android手机</code>和<code>Windows桌面平台</code>上的原生、移动 Web 和混合应用。「原生应用」指那些用 iOS、 Android 或者 Windows SDKs 编写的应用。「移动 Web 应用」是用移动端浏览器访问的应用（ Appium 支持 iOS 上的 Safari 、Chrome 和 Android 上的内置浏览器）。「混合应用」带有一个「webview」的包装器——用来和 Web 内容交互的原生控件。类似于 Apache Cordova 或 Phonegap 项目，创建一个混合应用使得用 Web 技术开发然后打包进原生包装器创建一个混合应用变得容易了。</p>
<p>重要的是，Appium 是跨平台的：它允许你用同样的 API 对多平台（iOS、Android、Windows）写测试。做到在 iOS、Android 和 Windows 测试套件之间复用代码。</p>
<span id="more"></span>
]]></content>
      <categories>
        <category>软件测试</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>appium</tag>
        <tag>测试</tag>
      </tags>
  </entry>
  <entry>
    <title>CPU与GPU的Benchmark测试</title>
    <url>/post/30b31d51.html</url>
    <content><![CDATA[<p>测试CPU与GPU性能的测试工具</p>
<span id="more"></span>

<h1 id="CPU性能测试"><a href="#CPU性能测试" class="headerlink" title="CPU性能测试"></a>CPU性能测试</h1><h2 id="geekbench"><a href="#geekbench" class="headerlink" title="geekbench"></a>geekbench</h2><ul>
<li>支持macOS，windows，linux，android，iOS</li>
</ul>
<blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9icm93c2VyLmdlZWtiZW5jaC5jb20v">https://browser.geekbench.com<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<h1 id="GPU性能测试"><a href="#GPU性能测试" class="headerlink" title="GPU性能测试"></a>GPU性能测试</h1><h2 id="specviewperf13"><a href="#specviewperf13" class="headerlink" title="specviewperf13"></a>specviewperf13</h2><ul>
<li>支持linux,windows<blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cuc3BlYy5vcmcvZ3dwZy9ncGMuc3RhdGljL3ZwMTNpbmZvLmh0bWw=">https://www.spec.org/gwpg/gpc.static/vp13info.html<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
</li>
</ul>
<p><strong>Running the SPECviewperf 13 Linux Edition benchmark</strong></p>
<p>The benchmark has the following minimum system requirements:</p>
<ul>
<li>Ubuntu Linux 16.04 and 18.04</li>
<li><code>OpenGL 4.0</code></li>
<li>2GB of video memory</li>
<li>8GB of installed system memory</li>
<li>80GB available disk space</li>
<li>1920x1080 screen resolution for submissions published on the SPEC website</li>
</ul>
<blockquote>
<p><span class="exturl" data-url="aHR0cDovL3NwZWMuY3MubWlhbWkuZWR1L2d3cGcvZ3BjLnN0YXRpYy92cDEzbGludXhpbmZvLmh0bWw=">http://spec.cs.miami.edu/gwpg/gpc.static/vp13linuxinfo.html<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<h3 id="软件依赖"><a href="#软件依赖" class="headerlink" title="软件依赖"></a>软件依赖</h3><blockquote>
<p>os: ubuntu20.04</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install xterm libgconf2-dev</span><br></pre></td></tr></table></figure>


<h2 id="gfxbench"><a href="#gfxbench" class="headerlink" title="gfxbench"></a>gfxbench</h2><ul>
<li>gfxbench 4.0 — Android, iOS, OSX, Windows 7,8,10, <code>Linux</code></li>
<li>gfxbench 5.0 — Android, iOS, OSX, Windows</li>
</ul>
<h2 id="3Dmark"><a href="#3Dmark" class="headerlink" title="3Dmark"></a>3Dmark</h2><ul>
<li>只支持windows,android和apple<blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cuM2RtYXJrLmNvbS8=">https://www.3dmark.com<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
</li>
</ul>
<blockquote>
<p>基准测试具有自然寿命，若不再能针对现代硬件提供有意义的结果，其自然寿命将终止。此页面上的基准测试不再受 UL 支持，在此仅供娱乐之用。它们可能不适用于最新的操作系统，并且在线服务可能也已经停止。我们建议您使用最新版本的 3DMark 和 PCMark 测试现代硬件和设备。</p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9iZW5jaG1hcmtzLnVsLmNvbS96aC1oYW5zL2xlZ2FjeS1iZW5jaG1hcmtzP3JlZGlyZWN0ZWQ9dHJ1ZSM=">不受支持的基准测试<i class="fa fa-external-link-alt"></i></span></li>
</ul>
</blockquote>
<h2 id="unigine-benchmark"><a href="#unigine-benchmark" class="headerlink" title="unigine benchmark"></a>unigine benchmark</h2><ul>
<li>支持linux, windows<blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9iZW5jaG1hcmsudW5pZ2luZS5jb20v">https://benchmark.unigine.com/<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
</li>
</ul>
<h3 id="Superposition-2017"><a href="#Superposition-2017" class="headerlink" title="Superposition 2017"></a>Superposition 2017</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Hardware</span><br><span class="line">    GPU:</span><br><span class="line">        AMD Radeon HD 7xxx and higher</span><br><span class="line">        Intel HD 5xxx and higher</span><br><span class="line">        NVIDIA GeForce GTX 6xx and higher</span><br><span class="line">    Video memory: 2 GB</span><br><span class="line">    Disk space: 5 GB</span><br></pre></td></tr></table></figure>

<p>Unigine Superposition Benchmark只提供<code>DirectX 11</code>和<code>OpenGL 4.5 API</code></p>
<h3 id="Valley-2013-ok"><a href="#Valley-2013-ok" class="headerlink" title="Valley 2013  (ok)"></a>Valley 2013  (ok)</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Hardware</span><br><span class="line">    GPU:</span><br><span class="line">        ATI Radeon HD 4xxx and higher</span><br><span class="line">        Intel HD 3000 and higher</span><br><span class="line">        NVIDIA GeForce 8xxx and higher</span><br><span class="line">    Video memory: 512 MB</span><br><span class="line">    Disk space: 1.5 GB</span><br></pre></td></tr></table></figure>

<h2 id="glmark2"><a href="#glmark2" class="headerlink" title="glmark2"></a>glmark2</h2><ul>
<li>支持linux<blockquote>
<p><code>glmark2</code> is an OpenGL 2.0 and ES 2.0 benchmark.</p>
</blockquote>
</li>
</ul>
<p>glmark提供了一系列涉及图形单元性能各个方面（缓冲，建筑物，照明，纹理等）的测试，从而可以进行更全面，更有意义的测试。每次测试进行10秒钟，并分别计算帧频。最后，用户会根据之前的所有测试获得性能得分。此工具具备简单性和完美的操作。</p>
<h2 id="Cinebench"><a href="#Cinebench" class="headerlink" title="Cinebench"></a>Cinebench</h2><ul>
<li>只支持windows和apple<blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cubWF4b24ubmV0L2VuL2NpbmViZW5jaA==">https://www.maxon.net/en/cinebench<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
</li>
</ul>
<p>Cinebench is a real-world cross-platform test suite that evaluates your computer’s hardware capabilities. Improvements to Cinebench Release 23 reflect the overall advancements to CPU and rendering technology in recent years, providing a more accurate measurement of Cinema 4D’s ability to take advantage of multiple CPU cores and modern processor features available to the average user. Best of all: It’s free</p>
<h2 id="ShaderToyMark"><a href="#ShaderToyMark" class="headerlink" title="ShaderToyMark"></a>ShaderToyMark</h2><ul>
<li>只支持windows<blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cuZ2Vla3MzZC5jb20vMjAxMTEyMTUvc2hhZGVydG95bWFyay0wLTMtMC1vcGVuZ2wtcGl4ZWwtc2hhZGVyLWJlbmNobWFyay11cGRhdGVkLw==">https://www.geeks3d.com/20111215/shadertoymark-0-3-0-opengl-pixel-shader-benchmark-updated/<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
</li>
</ul>
<p><code>ShaderToyMark</code> is an OpenGL benchmark, developed with GeeXLab, and focused on pixel shaders only. Why ShaderToyMark? Simply because I recently played with the pixel shaders available with Shader Toy, a great WebGL tool for testing GLSL shaders. And I said to myself: that would be nice to see several of these shaders running at the same time in the same 3D window… ShaderToyMark was born.</p>
<h2 id="Geeks3D-TessMark"><a href="#Geeks3D-TessMark" class="headerlink" title="Geeks3D TessMark"></a>Geeks3D TessMark</h2><ul>
<li>只支持windows<blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cuZ2Vla3MzZC5jb20vMjAxMTA0MDgvZG93bmxvYWQtdGVzc21hcmstMC0zLTAtcmVsZWFzZWQv">https://www.geeks3d.com/20110408/download-tessmark-0-3-0-released/<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
</li>
</ul>
<p>TessMark is a graphics benchmark focused on the GPU tessellation, one of the killer feature of OpenGL 4 capable cards (GeForce GTX 400, GTX 500, Radeon HD 5000, HD 6000).</p>
<h2 id="V-Ray-Benchmark"><a href="#V-Ray-Benchmark" class="headerlink" title="V-Ray Benchmark"></a>V-Ray Benchmark</h2><ul>
<li>支持windows、linux和Mac OS<blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cuY2hhb3Nncm91cC5jb20vdnJheS9iZW5jaG1hcms=">https://www.chaosgroup.com/vray/benchmark<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
</li>
</ul>
<p>V-Ray Benchmark是一个免费的独立应用程序（不需要安装V-Ray），可以帮助用户测试其硬件的性能。 该基准测试包括两个测试场景，一个场景用于GPU，另一个场景用于CPU，具体取决于您要衡量的性能类型。</p>
<p>V-Ray Benchmark是一个免费的独立应用程序，用于测试系统渲染的速度。 简单，快速，并包含三个渲染引擎测试：</p>
<ul>
<li>V-Ray — CPU compatible</li>
<li>V-Ray GPU CUDA — GPU and CPU compatible</li>
<li>V-Ray GPU RTX — RTX GPU compatible</li>
</ul>
<h2 id="OctaneBench"><a href="#OctaneBench" class="headerlink" title="OctaneBench"></a>OctaneBench</h2><ul>
<li>支持windows、linux和Mac OS<blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9yZW5kZXIub3RveS5jb20vb2N0YW5lYmVuY2gv">https://render.otoy.com/octanebench/<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
</li>
</ul>
<p>OctaneBench®允许您使用OctaneRender基准测试GPU。 通过确保每个人使用相同的版本以及相同的场景和设置来提供一个公平的竞争环境。 没有这些限制，基准测试结果可能会有很大差异，无法进行比较。</p>
<ul>
<li>nvidia GPU (cuda)，在linux下运行测试，需要cuda库的支持</li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9hbHRlcm5hdGl2ZXRvLm5ldC9zb2Z0d2FyZS8zZG1hcmstdmFudGFnZS8/cGxhdGZvcm09bGludXg=">https://alternativeto.net/software/3dmark-vantage/?platform=linux<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC82MTE2NzA0NQ==">https://zhuanlan.zhihu.com/p/61167045<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>软件测试</category>
      </categories>
      <tags>
        <tag>gpu</tag>
        <tag>cpu</tag>
        <tag>benchmark</tag>
      </tags>
  </entry>
  <entry>
    <title>Smoke Testing（冒烟测试）</title>
    <url>/post/27818.html</url>
    <content><![CDATA[<p>最近接到测试组的测试报告，写的<code>冒烟测试</code>。由于第一次遇到，便百度搜索一番，在这里进行简单记录。</p>
<span id="more"></span>

<blockquote>
<p>Smoke Testing 的概念最早源于制造业，用于测试管道。测试时，用鼓风机往管道里灌烟，看管壁外面是否有烟冒出来，以便检验管道是否有缝隙。这一测试显然比较初级，更深层一点的测试至少要进行渗油测试、带压测试等等。Smoke Testing 只是一种初级、直观的测试。</p>
</blockquote>
<p>Smoke Testing 在软件测试中的意义，应该说取的是其原始概念中的目的而非手段。通过 Smoke Testing，在软件代码正式编译并交付测试之前，<code>先尽量消除其“表面的”错误，减少后期测试的负担</code>。因此可以说，Smoke Testing 是预测试。</p>
<p><strong>冒烟测试的执行对象一般是程序的开发者，可以建议在开发人员的 自测报告中加入冒烟测试的情况反馈，因为只有通过冒烟测试才能进行更深入的系统测试，如果连冒烟测试都没有通过的版本，交给测试人员，很有可能因为环境、部署等问题回退。</strong></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTI0NjAwODQvYXJ0aWNsZS9kZXRhaWxzLzQ1ODY4OTkz">详细介绍一下 Smoke Testing（冒烟测试）<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3podXNvbmd6aXllL2FydGljbGUvZGV0YWlscy83ODY3MDAzNA==">冒烟测试浅谈<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>软件测试</category>
      </categories>
      <tags>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title>Xvfb —— 虚拟X server</title>
    <url>/post/64072.html</url>
    <content><![CDATA[<blockquote>
<p>Xvfb − virtual framebuffer X server for X Version 11</p>
</blockquote>
<p><code>Xvfb</code>是一个X server，主要用于在没有显示设备的主机上，进行拥有图形界面程序的运行。比如自动化测试</p>
<blockquote>
<p>Xvfb is an X server that can run on machines with no display hardware and no physical input devices. It emulates a dumb framebuffer using virtual memory.</p>
</blockquote>
<span id="more"></span>

<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install xvfb</span><br></pre></td></tr></table></figure>

<h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Xvfb -ac :3 -screen 0 1280x1024x24 &gt; /dev/null 2&gt;&amp;1</span><br><span class="line">export DISPLAY=:3</span><br></pre></td></tr></table></figure>

<h2 id="VNC测试"><a href="#VNC测试" class="headerlink" title="VNC测试"></a>VNC测试</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">x11vnc -display :3 -N -forever -shared -reopen -passwd 123456 -desktop 1 -bg -q</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">The VNC desktop is:      xxx-pc:3</span><br><span class="line">PORT=5903</span><br></pre></td></tr></table></figure>

<p>由于是本地测试，通过<code>remmina</code>登录VNC<code>127.0.0.1:5903</code>，将获取到<code>DISPLAY=:3</code>窗口的所有屏幕输出。比如此时在终端执行glxgears，将在vnc远端获取到图像。</p>
<p>测试脚本：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">killall x11vnc</span><br><span class="line">killall glxgears</span><br><span class="line"></span><br><span class="line">Xvfb -ac :3 -screen 0 1280x1024x24 &gt; /dev/null 2&gt;&amp;1</span><br><span class="line">export DISPLAY=:3</span><br><span class="line"></span><br><span class="line">x11vnc -display :3 -N -forever -shared -reopen -passwd 123456 -desktop 1 -bg -q</span><br><span class="line">echo &quot;Password: 123456&quot;</span><br><span class="line"></span><br><span class="line">glxgears &amp;</span><br></pre></td></tr></table></figure>

<p>VNC登录：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vncviewer 127.0.0.1:5903</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>软件测试</category>
      </categories>
      <tags>
        <tag>x11</tag>
        <tag>xvfb</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux中进程的状态</title>
    <url>/post/a4fafb29.html</url>
    <content><![CDATA[<p>Linux进程一共有<code>6</code>种状态，分别是：<code>R</code>、<code>S</code>、<code>D</code>、<code>T</code>、<code>Z</code>、<code>X</code></p>
<span id="more"></span>

<h2 id="进程状态值"><a href="#进程状态值" class="headerlink" title="进程状态值"></a>进程状态值</h2><h3 id="R-正在运行或处于就绪状态（Running）——-TASK-RUNNING"><a href="#R-正在运行或处于就绪状态（Running）——-TASK-RUNNING" class="headerlink" title="R:正在运行或处于就绪状态（Running）—— TASK_RUNNING"></a>R:正在运行或处于就绪状态（Running）—— TASK_RUNNING</h3><p><code>R状态</code>，表示该进程（任务）可以被CPU执行，但是不一定被CPU正在执行中，因为系统中同一时刻可能存在多个进程在可运行状态。</p>
<p>所有R状态的进程，都在<code>运行队列</code>中，由于一个CPU核关联了一个运行队列，因此一个进程只能出现在一个运行队列中。而何时被所属CPU执行取决于调度器。</p>
<h3 id="S-可中断的睡眠状态（Sleeping-——-TASK-INTERRUPTIBLE"><a href="#S-可中断的睡眠状态（Sleeping-——-TASK-INTERRUPTIBLE" class="headerlink" title="S:可中断的睡眠状态（Sleeping) —— TASK_INTERRUPTIBLE"></a>S:可中断的睡眠状态（Sleeping) —— TASK_INTERRUPTIBLE</h3><p><code>S状态</code>，表示该进程由于等待某一事件（比如socket连接，等待信号量），而被挂起。</p>
<p>所有S状态的进行，将被放入对应事件的<code>等待队列</code>（等待队列可能存在很多,因为CPU是有限的，因此系统中的大多数进程处于睡眠状态，被放入相应的等待队列）中，当这些事件发生（由外部中断触发或其他进程触发）时，对应的等待队列中的一个或多个进程将被唤醒。</p>
<h3 id="D-不可中断的睡眠状态（Disk-sleep）——-TASK-UNINTERRUPTIBLE"><a href="#D-不可中断的睡眠状态（Disk-sleep）——-TASK-UNINTERRUPTIBLE" class="headerlink" title="D:不可中断的睡眠状态（Disk sleep）—— TASK_UNINTERRUPTIBLE"></a>D:不可中断的睡眠状态（Disk sleep）—— TASK_UNINTERRUPTIBLE</h3><p>与<code>S状态</code>类似，进程处于睡眠状态，但是此时进程是<code>不可中断的</code>。</p>
<p><code>不可中断</code>：指的是该进程不响应异步信号，而不是CPU不响应外部信号。比如有些进程处于<code>D状态</code>时，我们无法通过kill -9将其杀死，也就是在ps中看到的进程状态几乎没有<code>D状态</code>。</p>
<p><code>D状态</code>（TASK_UNINTERRUPTIBLE）存在的意义： 内核中某些处理流程是不能被打断的，比如进程（任务）对某些硬件进行操作时（比如：I&#x2F;O读写操作等），可能需要使用TASK_UNINTERRUPTIBLE状态对进程进行保护，避免进程与外设交互的过程别打断，造成外设陷入不可控状态。</p>
<h4 id="vfork"><a href="#vfork" class="headerlink" title="vfork"></a>vfork</h4><p>linux系统中也存在容易捕捉的<code>TASK_UNINTERRUPTIBLE</code>状态。执行vfork系统调用后，父进程将进入TASK_UNINTERRUPTIBLE状态，直到子进程调用exit或exec（参见《神奇的vfork》）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (!vfork()) sleep(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ps aux | grep &quot;a\.out&quot;</span><br><span class="line">xx    396037  0.0  0.0   2364   508 pts/1    D+   17:10   0:00 ./a.out</span><br><span class="line">xx    396038  0.0  0.0   2364   508 pts/1    S+   17:10   0:00 ./a.out</span><br></pre></td></tr></table></figure>


<h3 id="T-暂停或跟踪状态（stopped）——-TASK-STOPPED-x2F-TASK-TRACED"><a href="#T-暂停或跟踪状态（stopped）——-TASK-STOPPED-x2F-TASK-TRACED" class="headerlink" title="T:暂停或跟踪状态（stopped）—— TASK_STOPPED&#x2F;TASK_TRACED"></a>T:暂停或跟踪状态（stopped）—— TASK_STOPPED&#x2F;TASK_TRACED</h3><p>向进程发送一个<code>SIGSTOP</code>信号，它就会因响应该信号而进入<code>TASK_STOPPED</code>状态（除非该进程本身处于<code>TASK_UNINTERRUPTIBLE</code>状态而不响应信号）。（SIGSTOP与SIGKILL信号一样，是强制的。不允许用户进程通过signal系列的系统调用重新设置对应的信号处理函数。）</p>
<p>向进程发送一个<code>SIGCONT</code>信号，可以让其从<code>TASK_STOPPED</code>状态恢复到<code>TASK_RUNNING</code>状态。</p>
<p>当进程正在被跟踪时，它处于<code>TASK_TRACED</code>这个特殊的状态。“正在被跟踪”指的是进程暂停下来，等待跟踪它的进程对它进行操作。比如在gdb中对被跟踪的进程下一个断点，进程在断点处停下来的时候就处于TASK_TRACED状态。而在其他时候，被跟踪的进程还是处于前面提到的那些状态。</p>
<p>对于进程本身来说，<code>TASK_STOPPED</code>和<code>TASK_TRACED</code>状态很类似，都是表示进程暂停下来。而<code>TASK_TRACED</code>状态相当于在<code>TASK_STOPPED</code>之上多了一层保护，处于<code>TASK_TRACED</code>状态的进程不能响应SIGCONT信号而被唤醒。只能等到调试进程通过<code>ptrace</code>系统调用执行PTRACE_CONT、PTRACE_DETACH等操作（通过ptrace系统调用的参数指定操作），或调试进程退出，被调试的进程才能恢复<code>TASK_RUNNING</code>状态。</p>
<h3 id="Z-僵尸状态（Zombies）——-TASK-DEAD-EXIT-ZOMBIE"><a href="#Z-僵尸状态（Zombies）——-TASK-DEAD-EXIT-ZOMBIE" class="headerlink" title="Z:僵尸状态（Zombies）—— TASK_DEAD-EXIT_ZOMBIE"></a>Z:僵尸状态（Zombies）—— TASK_DEAD-EXIT_ZOMBIE</h3><p>进程在退出的过程中，处于<code>TASK_DEAD</code>状态。</p>
<p>在这个退出过程中，进程占有的所有资源将被回收，除了task_struct结构（以及少数资源）以外。于是进程就只剩下task_struct这么个空壳，故称为<code>僵尸</code>。</p>
<p>之所以保留task_struct，是因为task_struct里面保存了进程的<code>退出码</code>、以及一些统计信息。而其父进程很可能会关心这些信息。比如在shell中，$?变量就保存了最后一个退出的前台进程的退出码，而这个退出码往往被作为if语句的判断条件。</p>
<p>当然，内核也可以将这些信息保存在别的地方，而将task_struct结构释放掉，以节省一些空间。但是使用task_struct结构更为方便，因为在内核中已经建立了从pid到task_struct查找关系，还有进程间的父子关系。释放掉task_struct，则需要建立一些新的数据结构，以便让父进程找到它的子进程的退出信息。</p>
<p>父进程可以通过wait系列的系统调用（如wait4、waitid）来等待某个或某些子进程的退出，并获取它的退出信息。然后wait系列的系统调用会顺便将子进程的尸体（task_struct）也释放掉。</p>
<p>子进程在退出的过程中，内核会给其父进程发送一个信号，通知父进程来“收尸”。这个信号默认是<code>SIGCHLD</code>，但是在通过clone系统调用创建子进程时，可以设置这个信号。</p>
<p>只要父进程不退出，这个僵尸状态的子进程就一直存在。那么如果父进程退出了呢，谁又来给子进程“收尸”？</p>
<ul>
<li>当进程退出的时候，会将它的所有子进程都托管给别的进程（使之成为别的进程的子进程）。托管给谁呢？可能是退出进程所在进程组的下一个进程（如果存在的话），或者是1号进程。所以每个进程、每时每刻都有父进程存在。除非它是1号进程。</li>
</ul>
<blockquote>
<p><code>1号进程</code>（init进程）的作用：</p>
<ol>
<li>执行系统初始化脚本，创建一系列进程</li>
<li>在一个死循环中等待子进程的退出事件，并通过调用waitid系统调用来完成“收尸”工作。<br>init进程不会被暂停、也不会被杀死（这是由内核来保证的）。它在等待子进程退出的过程中处于TASK_INTERRUPTIBLE状态，“收尸”过程中则处于TASK_RUNNING状态。</li>
</ol>
</blockquote>
<h4 id="制作一个僵尸进程"><a href="#制作一个僵尸进程" class="headerlink" title="制作一个僵尸进程"></a>制作一个僵尸进程</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (fork())</span><br><span class="line">		<span class="keyword">while</span>(<span class="number">1</span>) sleep(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ps aux | grep &quot;a\.out&quot;</span><br><span class="line">xx    399198  0.0  0.0   2364   508 pts/1    S    17:35   0:00 ./a.out</span><br><span class="line">xx    399201  0.0  0.0      0     0 pts/1    Z    17:35   0:00 [a.out] &lt;defunct&gt;</span><br></pre></td></tr></table></figure>
<p>杀死僵尸进程时，必须杀死其父进程，让父进程回收僵尸进程。</p>
<h3 id="X-退出状态（dead）——-TASK-DEAD-EXIT-DEAD"><a href="#X-退出状态（dead）——-TASK-DEAD-EXIT-DEAD" class="headerlink" title="X:退出状态（dead）—— TASK_DEAD-EXIT_DEAD"></a>X:退出状态（dead）—— TASK_DEAD-EXIT_DEAD</h3><p>进程在退出过程中也可能不会保留它的task_struct。比如这个进程是多线程程序中被detach过的进程</p>
<p>此时，进程将被置于<code>EXIT_DEAD</code>退出状态，这意味着接下来的代码立即就会将该进程彻底释放。所以EXIT_DEAD状态是非常短暂的，几乎不可能通过ps命令捕捉到。</p>
<h2 id="进程的初始状态"><a href="#进程的初始状态" class="headerlink" title="进程的初始状态"></a>进程的初始状态</h2><p>进程是通过<code>fork</code>系列的系统调用（fork、clone、vfork）来创建的，内核（或内核模块）也可以通过<code>kernel_thread</code>函数创建内核进程。这些创建子进程的函数本质上都完成了相同的功能——将调用进程复制一份，得到子进程。（可以通过选项参数来决定各种资源是共享、还是私有）</p>
<p>那么既然调用进程处于<code>TASK_RUNNING</code>状态（否则，它若不是正在运行，又怎么进行调用？），则子进程默认也处于<code>TASK_RUNNING</code>状态。</p>
<p>另外，在系统调用调用clone和内核函数kernel_thread也接受CLONE_STOPPED选项，从而将子进程的初始状态置为 TASK_STOPPED。</p>
<h2 id="进程状态变迁"><a href="#进程状态变迁" class="headerlink" title="进程状态变迁"></a>进程状态变迁</h2><p>原则：进程状态的变迁却只有两个方向</p>
<ul>
<li><strong>从<code>TASK_RUNNING</code>状态变为<code>非TASK_RUNNING</code>状态</strong></li>
<li><strong>从<code>非TASK_RUNNING</code>状态变为<code>TASK_RUNNING</code>状态</strong></li>
</ul>
<p>也就是说，如果给一个<code>TASK_INTERRUPTIBLE</code>状态的进程发送SIGKILL信号，这个进程将先被唤醒（进入<code>TASK_RUNNING</code>状态），然后再响应SIGKILL信号而退出（变为<code>TASK_DEAD</code>状态）; 并不会从<code>TASK_INTERRUPTIBLE</code>状态直接退出。</p>
<p>进程从<code>非TASK_RUNNING</code>状态变为<code>TASK_RUNNING</code>状态，是由别的进程（也可能是中断处理程序）执行唤醒操作来实现的。执行唤醒的进程设置被唤醒进程的状态为TASK_RUNNING，然后将其task_struct结构加入到某个CPU的可执行队列中。于是被唤醒的进程将有机会被调度执行。</p>
<p>而进程从<code>TASK_RUNNING</code>状态变为<code>非TASK_RUNNING</code>状态，则有两种途径：</p>
<ul>
<li>响应信号而进入TASK_STOPED状态、或TASK_DEAD状态；</li>
<li>执行系统调用主动进入TASK_INTERRUPTIBLE状态（如nanosleep系统调用）、或TASK_DEAD状态（如exit系统调用）；或由于执行系统调用需要的资源得不到满足，而进入TASK_INTERRUPTIBLE状态或TASK_UNINTERRUPTIBLE状态（如select系统调用）</li>
</ul>
<h3 id="状态转换"><a href="#状态转换" class="headerlink" title="状态转换"></a>状态转换</h3><p><img data-src="/images/2022/08/%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2%E5%9B%BE.png" alt="进程状态转换图"></p>
<h2 id="查看进程状态"><a href="#查看进程状态" class="headerlink" title="查看进程状态"></a>查看进程状态</h2><p>我们可以通过<code>ps</code>命令查看系统中各个进程的状态</p>
<ul>
<li>在busybox中可以使用以下命令参数：<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ps -o comm,pid,ppid,pgid,vsz,sid,stat,rss</span><br></pre></td></tr></table></figure></li>
<li>在正常系统中可以使用：<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ps -elf</span><br></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># ps -o comm,pid,ppid,pgid,vsz,sid,stat,rss</span><br><span class="line">COMMAND          PID   PPID  PGID  VSZ  SID   STAT RSS</span><br><span class="line">init                 1     0     1 2792     1 S     456</span><br><span class="line">kthreadd             2     0     0    0     0 SW      0</span><br><span class="line">rcu_gp               3     2     0    0     0 IW&lt;     0</span><br><span class="line">rcu_par_gp           4     2     0    0     0 IW&lt;     0</span><br><span class="line">kworker/u4:0-ev      7     2     0    0     0 IW      0</span><br><span class="line">mm_percpu_wq         8     2     0    0     0 IW&lt;     0</span><br><span class="line">ksoftirqd/0          9     2     0    0     0 SW      0</span><br><span class="line">rcu_sched           10     2     0    0     0 IW      0</span><br><span class="line">migration/0         11     2     0    0     0 SW      0</span><br><span class="line">kworker/0:1-eve     12     2     0    0     0 IW      0</span><br><span class="line">cpuhp/0             13     2     0    0     0 SW      0</span><br><span class="line">cpuhp/1             14     2     0    0     0 SW      0</span><br><span class="line">migration/1         15     2     0    0     0 SW      0</span><br><span class="line">ksoftirqd/1         16     2     0    0     0 SW      0</span><br><span class="line">kdevtmpfs           19     2     0    0     0 SW      0</span><br><span class="line">netns               20     2     0    0     0 IW&lt;     0</span><br><span class="line">khungtaskd          21     2     0    0     0 SW      0</span><br><span class="line">oom_reaper          22     2     0    0     0 SW      0</span><br><span class="line">writeback           23     2     0    0     0 IW&lt;     0</span><br></pre></td></tr></table></figure>

<h3 id="STAT状态位"><a href="#STAT状态位" class="headerlink" title="STAT状态位"></a>STAT状态位</h3><table>
<thead>
<tr>
<th align="center">STAT</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>I</code></td>
<td align="left">空闲内核线程（idle）</td>
</tr>
<tr>
<td align="center"><code>R</code></td>
<td align="left">运行或可运行（在运行队列上）</td>
</tr>
<tr>
<td align="center"><code>S</code></td>
<td align="left">可中断睡眠（等待事件完成）</td>
</tr>
<tr>
<td align="center"><code>D</code></td>
<td align="left">不可中断睡眠（通常是IO）</td>
</tr>
<tr>
<td align="center"><code>T</code></td>
<td align="left">由job控制信号停止</td>
</tr>
<tr>
<td align="center"><code>Z</code></td>
<td align="left">僵尸进程，终止但未被其父进程收割</td>
</tr>
<tr>
<td align="center"><code>X</code></td>
<td align="left">进程死了（永远不应该被看到）</td>
</tr>
<tr>
<td align="center"><code>W</code></td>
<td align="left">分页（自 2.6.xx 内核起无效）</td>
</tr>
<tr>
<td align="center"><code>t</code></td>
<td align="left">在跟踪（tracing）期间被调试器停止</td>
</tr>
<tr>
<td align="center"><code>&lt;</code></td>
<td align="left">高优先级</td>
</tr>
<tr>
<td align="center"><code>N</code></td>
<td align="left">低优先级</td>
</tr>
<tr>
<td align="center"><code>L </code></td>
<td align="left">将页面锁定到内存中（用于实时和自定义IO）</td>
</tr>
<tr>
<td align="center"><code>s</code></td>
<td align="left">会话负责</td>
</tr>
<tr>
<td align="center"><code>|</code></td>
<td align="left">多线程（使用 CLONE_THREAD，就像 NPTL pthreads 一样）</td>
</tr>
<tr>
<td align="center"><code>+</code></td>
<td align="left">在前台进程组中</td>
</tr>
</tbody></table>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="孤儿进程"><a href="#孤儿进程" class="headerlink" title="孤儿进程"></a>孤儿进程</h3><p>所谓孤儿进程，顾名思义，跟现实中的孤儿类似，当一个进程的父进程结束时，但是他自己还没有结束，那么该进程就变为孤儿进程。</p>
<p>孤儿进程会被init进程（1号进程）的进程收养，当然在子进程结束时也会由init进程完成对它的状态收集工作，因此一般来说，孤儿进程并不会有什么危害。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ5NjEzNTU3L2FydGljbGUvZGV0YWlscy8xMjAyOTQ5MDg=">Linux中进程的六种状态<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20veWZjZXNoaS9wLzY4MDAwNjkuaHRtbCM6fjp0ZXh0PVRBU0tfU1RPLE5JTkclRTclOEElQjYlRTYlODAlODElRUYlQkMlODklRTMlODAlODI=">进程资源和进程状态 TASK_RUNNING TASK_INTERRUPTIBLE TASK_UNINTERRUPTIBLE <i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vcHJvZ3JhbW1lci10bGgvcC8xMTU5MzMzMC5odG1s">Linux进程状态(ps stat)详解<i class="fa fa-external-link-alt"></i></span></li>
</ol>
]]></content>
      <categories>
        <category>进程</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>进程</tag>
      </tags>
  </entry>
  <entry>
    <title>进程退出的exitcode</title>
    <url>/post/7653.html</url>
    <content><![CDATA[<h2 id="错误信息"><a href="#错误信息" class="headerlink" title="错误信息"></a>错误信息</h2><p>内核打印</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Kernel panic - not syncing: Attempted to kill init! exitcode=0x0000000b</span><br></pre></td></tr></table></figure>
<!---more--->
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><h3 id="出错位置"><a href="#出错位置" class="headerlink" title="出错位置"></a>出错位置</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">panic(<span class="string">&quot;Attempted to kill init! exitcode=0x%08x\n&quot;</span>,</span><br><span class="line">    father-&gt;signal-&gt;group_exit_code ?:</span><br><span class="line">        father-&gt;exit_code);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>kernel&#x2F;exit.c</p>
</blockquote>
<h3 id="exit-cede赋值"><a href="#exit-cede赋值" class="headerlink" title="exit_cede赋值"></a>exit_cede赋值</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">do_exit</span><span class="params">(<span class="type">long</span> code)</span></span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">	 tsk-&gt;exit_code = code;</span><br><span class="line">	...</span><br><span class="line">	exit_notify(tsk, group_dead);</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数调用关系:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">exit_notify</span><br><span class="line">	|-&gt; forget_original_parent(tsk);</span><br><span class="line">				|-&gt; find_new_reaper(father);</span><br><span class="line">							|-&gt; &quot;Attempted to kill init! exitcode=0x%08x\n&quot;</span><br></pre></td></tr></table></figure>

<h2 id="错误来源"><a href="#错误来源" class="headerlink" title="错误来源"></a>错误来源</h2><p>在Android系统中,linux内核启动过程中,进入<code>用户空间</code>后,init进程执行过程中出现该错误</p>
<p><strong>由于在用户空间引起的内核错误,因此只能通过系统调用产生</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SYSCALL_DEFINE1(<span class="built_in">exit</span>, <span class="type">int</span>, error_code)</span><br><span class="line">&#123;</span><br><span class="line">    do_exit((error_code&amp;<span class="number">0xff</span>)&lt;&lt;<span class="number">8</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在进入内核是do_exit取了用户空间传入的错误码的<code>低8位</code></p>
<h2 id="进程退出的错误码"><a href="#进程退出的错误码" class="headerlink" title="进程退出的错误码"></a>进程退出的错误码</h2><p>在系统中的进程在正常和非正常退出时，都有一个表示当前进程退出状态的标识，即<code>退出码</code></p>
<h3 id="查看进程退出码"><a href="#查看进程退出码" class="headerlink" title="查看进程退出码"></a>查看进程退出码</h3><p>退出码代表的是一个进程退出的状态码, 可以使用wait函数进行查看。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> _exit(<span class="type">int</span> status)，</span><br></pre></td></tr></table></figure>
<blockquote>
<p>status表明了进程终止时的状态。当子进程使用_exit()后，父进程如果在用wait()等待子进程，那么wait()将会返回status状态，注意只有status的低8位（0~255）会返回给父进程</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> pid;</span><br><span class="line">    <span class="type">int</span> status;</span><br><span class="line"></span><br><span class="line">    pid = fork( );</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pid=%d\n&quot;</span>, pid);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;fork error : &quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;This is son, his count is: %d (%p). and his pid is: %d\n&quot;</span>,</span><br><span class="line">                ++count, &amp;count, getpid());</span><br><span class="line">        sleep(<span class="number">3</span>);</span><br><span class="line">        _exit(<span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        pid = wait(&amp;status);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;This is father, his count is: %d (%p), his pid is: %d, son exit status: %d[%08x]\n&quot;</span>,</span><br><span class="line">                count, &amp;count, getpid(), status, status);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>正常退出结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">=====&gt;$./a.out</span><br><span class="line">pid=4018</span><br><span class="line">pid=0</span><br><span class="line">This is son, his count is: 2 (0x7fff19658714). and his pid is: 4018</span><br><span class="line">This is father, his count is: 1 (0x7fff19658714), his pid is: 4017, son exit status: 0[00000000]</span><br></pre></td></tr></table></figure>
<p>在子进程sleep时将其kill掉的结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">=====&gt;$./a.out &amp;</span><br><span class="line">[1] 4066</span><br><span class="line">00:11 [xxx@machine]~/work/MyCode/systemcall/test</span><br><span class="line">=====&gt;$pid=4067</span><br><span class="line">pid=0</span><br><span class="line">This is son, his count is: 2 (0x7ffe19987d04). and his pid is: 4067</span><br><span class="line"></span><br><span class="line">00:11 [xxx@machine]~/work/MyCode/systemcall/test</span><br><span class="line">=====&gt;$kill 4067</span><br><span class="line">This is father, his count is: 1 (0x7ffe19987d04), his pid is: 4066, son exit status: 15[0000000f]</span><br></pre></td></tr></table></figure>
<p>在进程正常退出时，子进程的状态码是<code>0</code>，而kill掉后变为了<code>15</code>.</p>
<blockquote>
<p>注：此时如果在linux终端下使用<code>echo $?</code>,获取的仅仅该进程的main函数的返回值。</p>
</blockquote>
<h3 id="退出码的含义"><a href="#退出码的含义" class="headerlink" title="退出码的含义"></a>退出码的含义</h3><p>根据前面分析，在进程调用_exit退出时,是通过exit系统调用实现的，而这里的<code>0</code>和<code>15</code>,就是系统调用exit的参数<code>error_code</code></p>
<p><strong>进程的退出状态不等于退出码，程退出时候的状态码是8位，高4位存储退出码，低4位存储导致进程退出的信号标志位</strong></p>
<blockquote>
<p>网上有人说16位，分别是高八位和低八位，还需确认</p>
</blockquote>
<p>根据这段话的描述，之前测试中子进程的退出状态<code>0</code>和<code>15</code>中，退出码均为<code>0</code>,而退出时的singal不同，正常退出时为0，kill掉后变为15</p>
<h3 id="制造段错误"><a href="#制造段错误" class="headerlink" title="制造段错误"></a>制造段错误</h3><p>在测试case中的子进程中，制造一个段错误，根据此时的分析子进程退出的状态码中的signal应该代表段错误<br>子进程中添加：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *a;</span><br><span class="line">*a = <span class="number">3</span>;</span><br></pre></td></tr></table></figure>
<p>测试结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">=====&gt;$./a.out</span><br><span class="line">pid=4500</span><br><span class="line">pid=0</span><br><span class="line">This is son, his count is: 2 (0x7fff54e86d1c). and his pid is: 4500</span><br><span class="line">This is father, his count is: 1 (0x7fff54e86d1c), his pid is: 4499, son exit status: 139[0000008b]</span><br></pre></td></tr></table></figure>
<p>此时子进程的<code>退出码=8</code>，而<code>signal=b</code></p>
<h3 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h3><p>linux内核中x86的信号列表：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SIGSEGV     11</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIGTERM     15</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>arch&#x2F;x86&#x2F;include&#x2F;uapi&#x2F;asm&#x2F;signal.h</p>
</blockquote>
<table>
<thead>
<tr>
<th>信号</th>
<th>行为</th>
<th>产生原因</th>
</tr>
</thead>
<tbody><tr>
<td>SIGTERM</td>
<td>请求中断</td>
<td>kill() 可以发 SIGTERM 过去；kill 命令默认也使用 SIGTERM 信号</td>
</tr>
<tr>
<td>SIGSEGV</td>
<td>无效内存引用</td>
<td>段错误</td>
</tr>
</tbody></table>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>进程在退出时都会将自己当前的状态告诉内核，而此时的<code>状态码</code>包含两种含义：</p>
<ul>
<li>高4位代表当前进程的退出码</li>
<li>低4位代表使当前进程退出所使用的信号</li>
</ul>
<p><strong>在本文最开始提到的错误也是由于<code>SIGSEGV</code>无效内存引用引起的。</strong></p>
<p>mips架构下的信号列表：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SIGTERM     15  <span class="comment">/* Termination (ANSI).  */</span></span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>arch&#x2F;mips&#x2F;include&#x2F;uapi&#x2F;asm&#x2F;signal.h</p>
</blockquote>
<h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><ol>
<li><span class="exturl" data-url="aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZXFpYW5nODI3MS9hcnRpY2xlL2RldGFpbHMvODIyNTQ2OA=="> linux子进程退出状态值解析：waitpid() status意义解析<i class="fa fa-external-link-alt"></i></span></li>
</ol>
]]></content>
      <categories>
        <category>进程</category>
      </categories>
      <tags>
        <tag>进程</tag>
        <tag>exit_code</tag>
      </tags>
  </entry>
  <entry>
    <title>Example</title>
    <url>/post/10323.html</url>
    <content><![CDATA[<h2 id="Test"><a href="#Test" class="headerlink" title="Test"></a>Test</h2><p>This is a test page!</p>
<span id="more"></span>

<p><img data-src="/images/code_c++.jpg" alt="test"></p>
<h3 id="站点构建："><a href="#站点构建：" class="headerlink" title="站点构建："></a>站点构建：<a href="https://travis-ci.org/Winddoing/Winddoing.github.io"><img data-src="https://travis-ci.org/Winddoing/Winddoing.github.io.svg?branch=web_source" alt="Build Status"></a></h3><h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Hello World!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="shell"><a href="#shell" class="headerlink" title="shell"></a>shell</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">pwd</span></span><br></pre></td></tr></table></figure>

<h3 id="站点设置"><a href="#站点设置" class="headerlink" title="站点设置"></a>站点设置</h3><p><span class="exturl" data-url="aHR0cDovL3RoZW1lLW5leHQuaWlzc25hbi5jb20v">配置：<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cDovL2ZvbnRhd2Vzb21lLmlvL2ljb25zLw==">图标选择：<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>travis-ci</tag>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/post/16107.html</url>
    <content><![CDATA[<p>welcome to <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvLw==">hexo<i class="fa fa-external-link-alt"></i></span>! this is your very first post. check <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL2RvY3Mv">documentation<i class="fa fa-external-link-alt"></i></span> for more info. if you get any problems when using hexo, you can find the answer in <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL2RvY3MvdHJvdWJsZXNob290aW5nLmh0bWw=">troubleshooting<i class="fa fa-external-link-alt"></i></span> or you can ask me on <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2hleG9qcy9oZXhvL2lzc3Vlcw==">github<i class="fa fa-external-link-alt"></i></span>.</p>
<span id="more"></span>

<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvd3JpdGluZy5odG1s">Writing<i class="fa fa-external-link-alt"></i></span></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvc2VydmVyLmh0bWw=">Server<i class="fa fa-external-link-alt"></i></span></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL2RvY3MvZ2VuZXJhdGluZy5odG1s">Generating<i class="fa fa-external-link-alt"></i></span></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL2RvY3MvZGVwbG95bWVudC5odG1s">Deployment<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title>WIFEXITED WEXITSTATUS WIFSIGNALED</title>
    <url>/post/647daf2a.html</url>
    <content><![CDATA[<p>子进程退出状态</p>
<span id="more"></span>

<p>If the exit status value (*note Program Termination::) of the child process is zero, then the status value reported by <code>waitpid</code> or <code>wait</code> is also zero. You can test for other kinds of information encoded in the returned status value using the following macros. These macros are defined in the header file <code>sys/wait.h</code></p>
<h2 id="Macro-int-WIFEXITED-int-STATUS"><a href="#Macro-int-WIFEXITED-int-STATUS" class="headerlink" title="Macro: int WIFEXITED (int STATUS)"></a>Macro: int WIFEXITED (int STATUS)</h2><p>This macro returns a nonzero value if the child process terminated normally with <code>exit&#39; or </code>_exit’.</p>
<h2 id="Macro-int-WEXITSTATUS-int-STATUS"><a href="#Macro-int-WEXITSTATUS-int-STATUS" class="headerlink" title="Macro: int WEXITSTATUS (int STATUS)"></a>Macro: int WEXITSTATUS (int STATUS)</h2><p>If <code>WIFEXITED&#39; is true of STATUS, this macro returns the low-order 8 bits of the exit status value from the child process.</code>Note Exit Status&#96;</p>
<h2 id="Macro-int-WIFSIGNALED-int-STATUS"><a href="#Macro-int-WIFSIGNALED-int-STATUS" class="headerlink" title="Macro: int WIFSIGNALED (int STATUS)"></a>Macro: int WIFSIGNALED (int STATUS)</h2><p>This macro returns a nonzero value if the child process terminated because it received a signal that was not handled. <code>Note Signal Handling</code></p>
<blockquote>
<p><a href="https://winddoing.github.io/post/7653.html">进程退出的 exitcode</a></p>
</blockquote>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cubWFuNy5vcmcvbGludXgvbWFuLXBhZ2VzL21hbjIvd2FpdHBpZC4yLmh0bWw=">wait(2) — Linux manual page<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL2Jsb2cuc2luYS5jb20uY24vcy9ibG9nXzYzNmE1NTA3MDEwMXd0cDUuaHRtbA==">WIFEXITED WEXITSTATUS WIFSIGNALED<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>进程</category>
      </categories>
      <tags>
        <tag>进程</tag>
        <tag>wait</tag>
      </tags>
  </entry>
  <entry>
    <title>van_xum</title>
    <url>/post/4813.html</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="5bb3060780ac2146389f53672dbe43f7d5434df27cd3f4c407b6703a6af1aac6">6c23b893ba1818c68218343bb61b29437f9b6810a78d0f75b0e6e4fac8421348</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题</title>
    <url>/post/27055.html</url>
    <content><![CDATA[<span id="more"></span>


<h2 id="union"><a href="#union" class="headerlink" title="union"></a>union</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">aa</span>&#123;</span></span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="type">char</span> a[<span class="number">2</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">union</span> <span class="title">aa</span> <span class="title">b</span>;</span></span><br><span class="line">        b.i = <span class="number">0</span>; <span class="comment">//初始化内存空间，如果不清最后的b.i为随机值</span></span><br><span class="line">        b.a[<span class="number">0</span>] = <span class="number">10</span>;</span><br><span class="line">        b.a[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, b.i);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, (<span class="number">1</span> &lt;&lt; <span class="number">8</span>) | (<span class="number">10</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>结果： 266(256+10)</p>
</blockquote>
<ol>
<li>union 类型的特点是不同类型的数据共享同一段内存，union 结构体的大小为其所含占内存<code>最大成员大小</code>，但在同一时刻只能有一类成员存储于其中</li>
<li>计算机存储的大小端不同，最后的输出结果不一定。</li>
</ol>
<h2 id="大小端"><a href="#大小端" class="headerlink" title="大小端"></a>大小端</h2><ol>
<li><code>Little endian</code>和<code>Big endian</code>是CPU存放数据的两种不同顺序</li>
<li><code>Big endian</code>第一个字节是最高位字节（按照从低地址到高地址的顺序存放数据的高位字节到低位字节）</li>
<li><code>Little endian</code>第一个字节是最低位字节（按照从低地址到高地址的顺序存放数据的低位字节到高位字节）</li>
</ol>
<ul>
<li><p>共同体所有数据共用同一块地址空间</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">aa</span>&#123;</span></span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="type">char</span> j;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">union</span> <span class="title">aa</span> <span class="title">a</span>;</span></span><br><span class="line">        a.i = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ( a.j == <span class="number">1</span> )</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;little-endian\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;big-endian\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>指针强制类型转换</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span> * p = (<span class="type">char</span>*)&amp;a;</span><br><span class="line">    <span class="keyword">if</span> (*p == <span class="number">1</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;little-endian\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;big-endian\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h2><h3 id="取最大值"><a href="#取最大值" class="headerlink" title="取最大值"></a>取最大值</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define PAD(v, p)  ((v + (p) - 1) &amp; (~((p) - 1)))</span><br></pre></td></tr></table></figure>

<h3 id="判断奇偶"><a href="#判断奇偶" class="headerlink" title="判断奇偶"></a>判断奇偶</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define IS_POW2(x)  (((x) &amp; (x - 1)) == 0)</span><br></pre></td></tr></table></figure>


<h2 id="内存对齐"><a href="#内存对齐" class="headerlink" title="内存对齐"></a>内存对齐</h2><ol>
<li>数据类型自身的对齐值：char型数据自身对齐值为1字节，short型数据为2字节，int&#x2F;float型为4字节，double型为8字节</li>
<li>结构体或类的自身对齐值：其成员中自身对齐值<code>最大</code>的那个值</li>
<li>指定对齐值：<code>#pragma pack (value)</code>时的指定对齐值value。</li>
<li>数据成员、结构体和类的有效对齐值：自身对齐值和指定对齐值中较小者，即有效对齐值&#x3D;min{自身对齐值，当前指定的pack值}</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">std1</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> a;     <span class="comment">//4</span></span><br><span class="line">	<span class="type">char</span> b;   <span class="comment">//1</span></span><br><span class="line">			  <span class="comment">//占空3</span></span><br><span class="line">	<span class="type">float</span> c;   <span class="comment">//4</span></span><br><span class="line">	<span class="type">char</span> d;   <span class="comment">//1</span></span><br><span class="line">			  <span class="comment">//占空3</span></span><br><span class="line">	<span class="type">double</span> e; <span class="comment">//8</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">sizeof</span>(std1) = <span class="number">24</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> std2&#123;</span><br><span class="line">	<span class="type">char</span> c;  <span class="comment">//1</span></span><br><span class="line">			 <span class="comment">//占空1</span></span><br><span class="line">	<span class="type">short</span> s;  <span class="comment">//2</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">sizeof</span>(std2) = <span class="number">4</span></span><br></pre></td></tr></table></figure>

<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> *p = <span class="number">0</span>;</span><br><span class="line">        p += <span class="number">6</span>; <span class="comment">/*累加的是p指针类型的宽度(4*6)*/</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, p);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>输出： 0x18[24]</p>
</blockquote>
<h2 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h2><ol>
<li>管道</li>
<li>消息队列：消息队列是由消息的链表，存放在内核中并由消息队列标识符标识，消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点</li>
<li>共享内存</li>
<li>信号量：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。</li>
<li>socket</li>
<li>信号（sinal）：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生</li>
</ol>
<blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vTFVPNzcvcC81ODE2MzI2Lmh0bWw=">进程间通信的方式——信号、管道、消息队列、共享内存<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<h2 id="字符串反转"><a href="#字符串反转" class="headerlink" title="字符串反转"></a>字符串反转</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span>* <span class="title function_">revstr</span><span class="params">(<span class="type">char</span> *str)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span>    *start = str;</span><br><span class="line">    <span class="type">char</span>    *end = str + <span class="built_in">strlen</span>(str) - <span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span>    ch;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (str != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">            ch = *start;</span><br><span class="line">            *start++ = *end;</span><br><span class="line">            *end-- = ch;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">my_strlen</span><span class="params">(<span class="type">char</span> *str)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">if</span>(*str == <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> my_strlen(str+<span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">reverse_string</span><span class="params">(<span class="type">char</span> *<span class="built_in">string</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> len = my_strlen(<span class="built_in">string</span>);</span><br><span class="line">        <span class="keyword">if</span>(len &lt;= <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> ;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">char</span> temp = <span class="built_in">string</span>[<span class="number">0</span>];</span><br><span class="line">                <span class="built_in">string</span>[<span class="number">0</span>] = <span class="built_in">string</span>[len<span class="number">-1</span>];</span><br><span class="line">                <span class="built_in">string</span>[len<span class="number">-1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">                reverse_string(<span class="built_in">string</span>+<span class="number">1</span>);</span><br><span class="line">                <span class="built_in">string</span>[len<span class="number">-1</span>] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">char</span> ch[] = <span class="string">&quot;abcdefghijklmno&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;0:%s\n&quot;</span>,ch);</span><br><span class="line">        reverse_string(ch);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;1:%s\n&quot;</span>,ch);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="指针与引用"><a href="#指针与引用" class="headerlink" title="指针与引用"></a>指针与引用</h2><blockquote>
<p><code>C++</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">change</span><span class="params">(<span class="type">int</span>*a, <span class="type">int</span> &amp;b, <span class="type">int</span> c)</span></span><br><span class="line">&#123;</span><br><span class="line">        c=*a;</span><br><span class="line">        b=<span class="number">30</span>;</span><br><span class="line">        *a=<span class="number">20</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> a=<span class="number">10</span>, b=<span class="number">20</span>, c=<span class="number">30</span>;</span><br><span class="line">        <span class="comment">/*指针与引用*/</span></span><br><span class="line">        change(&amp;a,b,c);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d,%d,%d\n&quot;</span>,a,b,c);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>结果：20,30,30</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> &amp;a)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;&amp;a&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;a&lt;&lt;<span class="built_in">endl</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> a=<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;&amp;a&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;a&lt;&lt;<span class="built_in">endl</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        test(a);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>0x7fffc646494c 1<br>0x7fffc646494c 1</p>
</blockquote>
<ol>
<li>指针传递是一种<code>值传递</code>的方式，他<code>传递的只是地址值</code>，值传递的时候中我们可以知道被调函数的形参会被当做一个局部变量来出来，会在栈中去给其分配空间用 来存储主调函数传输过来的值，该值只不过是主调函数中实参值的一个拷贝，所以在被调函数中去修改传输过来的值并不会去影响主调函数中的实参值。</li>
<li>引用作为函数参数进行传递时，实质上<code>传递的是实参本身</code>，即传递进来的不是实参的一个拷贝，因此对形参的修改其实是对实参的修改，所以在用引用进行参数传递时，不仅节约时间，而且可以节约空间。</li>
<li>指针是一个实体，而引用仅是个别名；</li>
<li>引用不可以为空，当被创建的时候，必须初始化，而指针可以是空值，可以在任何时候被初始化。</li>
<li>可以有const指针，但是没有const引用；</li>
<li>指针可以有多级，但是引用只能是一级（int **p；合法 而 int &amp;&amp;a是不合法的）</li>
<li>指针和引用的自增(++)运算意义不一样；</li>
<li>如果返回动态内存分配的对象或者内存，必须使用指针，引用可能引起内存泄漏；</li>
</ol>
<h2 id="指针与数组"><a href="#指针与数组" class="headerlink" title="指针与数组"></a>指针与数组</h2><h2 id="关键字static"><a href="#关键字static" class="headerlink" title="关键字static"></a>关键字static</h2><ol>
<li>在函数体，一个被声明为静态的变量在这一函数被调用过程中维持其值不变， 内存中的位置：<code>静态存储区</code>（<strong>静态存储区在整个程序运行期间都存在</strong>）</li>
<li>在模块内（但在函数体外），一个被声明为静态的变量可以被模块内所用函数访问，但不能被模块外其它函数访问。它是一个本地的全局变量。</li>
<li>在模块内，一个被声明为静态的函数只可被这一模块内的其它函数调用。那就是，这个函数被限制在声明它的模块的本地范围内使用。</li>
</ol>
<h2 id="关键字const"><a href="#关键字const" class="headerlink" title="关键字const"></a>关键字const</h2><blockquote>
<p>左<code>数</code>右<code>指</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> a;    <span class="comment">//a：只读</span></span><br><span class="line"><span class="type">int</span> <span class="type">const</span> a;    <span class="comment">//a：只读</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *a;   <span class="comment">//&quot;左&quot;，指针a，数据不能变，数据只读</span></span><br><span class="line"><span class="type">int</span> * <span class="type">const</span> a;  <span class="comment">//&quot;右&quot;，指针a，指针不能变，地址只读</span></span><br><span class="line"><span class="type">int</span> <span class="type">const</span> * a <span class="type">const</span>;    <span class="comment">//数据指针均只读</span></span><br></pre></td></tr></table></figure>
<ol>
<li>关键字const的 作用是为给读你代码的人传达非常有用的信息，实际上，声明一个参数为常量是为了告诉了用户这个参数的应用目的。</li>
<li>通过给编译器一些附加的信息，使用关键字const也许能产生更紧凑的代码。</li>
<li>合理地使用关键字const可以使编译器很自然地保护那些不希望被改变的参数，防止其被无意的代码修改。简而言之，这样可以减少bug的出现。</li>
</ol>
<h2 id="关键字volatile"><a href="#关键字volatile" class="headerlink" title="关键字volatile"></a>关键字volatile</h2><ol>
<li>并行设备的硬件寄存器（如：状态寄存器），防止编译器的优化</li>
<li>一个中断服务子程序中会访问到的非自动变量(Non-automatic variables),(即，变量会在程序外被改变,每次都必须从内存中读取，而不能把他放在cache或寄存器中重复使用)</li>
<li>多线程应用中被几个任务共享的变量</li>
</ol>
<h2 id="float类型和0比较大小"><a href="#float类型和0比较大小" class="headerlink" title="float类型和0比较大小"></a>float类型和0比较大小</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const float EPSINON= 0.00001;</span><br><span class="line">if((x &gt;= -EPSINON) &amp;&amp; (x &lt;= EPSINON))&gt;))</span><br></pre></td></tr></table></figure>
<blockquote>
<p>不能直接用float类型的值与0进行“&#x3D;&#x3D;”或“!&#x3D;”比较</p>
</blockquote>
<p><strong>标准C语言中:</strong><br>单精度float浮点格式的符号位&#x3D;1，有效位&#x3D;23，指数未&#x3D;8，产生一个32位的表示。<br>双精度double浮点格式的符号位&#x3D;1，有效位&#x3D;52，指数位&#x3D;11，产生一个64位的表示。</p>
<p>转成数值即为:V&#x3D;(-1)^S * 1.M * 2^(E-127)</p>
<p>对于16.5转成二进制为00010000.1&#x3D;&#x3D;&gt;1.00001*2^4,<br>那么在内存的表示为:<br>符号位    指数4+127 &#x3D; 131      尾数<br>0          10000011         00001 000000000000000000</p>
<p>在转换过程中由于需要往右移位, 可见对于float数整数部分越大,小数部分的精度就越低<br>对float数来说有效数字约为7位(2^23约等于10^7),所以整数部分占的位数越多,小数部分<br>的精度就越低,当整数部分超过9999999后小数部分已经完全无精度了</p>
<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><h3 id="B-树-B-树"><a href="#B-树-B-树" class="headerlink" title="B-树(B+树)"></a>B-树(B+树)</h3><h3 id="红黑树和AVL树"><a href="#红黑树和AVL树" class="headerlink" title="红黑树和AVL树"></a>红黑树和AVL树</h3><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20veF93dWtvbmcvcC81NzEyMzQ1Lmh0bWw=">传指针和传指针引用的区别&#x2F;指针和引用的区别（本质）<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL2Jsb2cuY2hpbmF1bml4Lm5ldC91aWQtMjQ2MTEzNDYtaWQtMzE5Mzg1Mi5odG1s">C语言中static变量详解 <i class="fa fa-external-link-alt"></i></span></li>
</ol>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>面试总结</title>
    <url>/post/42863.html</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="3ff5ba7f3dfe455aaac9423d15d7b796e76bdf107c26844c59769a212d8a9fee">a23c4023a6c38e7bca2dcd538d6ba9c65c3ae666782fc0cff267484a04e77d6bc58d9928dfbd67027fb2caf124b20391ed873751affc9175230cfa20c6765be6ee5b1f84130e2c13272ce5c6c492a01e18183a60794b786293ec2f9caa6d6e602193e3a3fafdf60c91d1a240cfd3ae1ce5920a3e3788f5b2fe55c879eaa65e622a6b74f679bef998ede0dc85d61748ecc0528bbb2638d57fd71d41c180bf3ef8f97f078b297e4b183976d3f88992d9f21b8a94aa90ce6012d8c3f5dc79608110bb8f4d424fd4ea95c48253726a7e88b10a363e8149c6266d42baaabe4f578df33f9667b8aaf5cfd45ca6b70fb5e114b598647e513298241a9fd0068062d509ccc9b211d15973caba52d464b2400bb18da165666d758b5a950975f51d99291ebea5fc3ea3ad72a6bd9a5c5470084488a3a9c7cfb5f4e1b43a1a10de6856c3d2938c95e5c3935e7ed1ec6be023aabb5f60a37ebe3019dae4a57d70223cd1a9eb88bee9939734eccab452c99b8cdb4967678f72dd6b05dbd99b51b836681181ccd20cca7ae638d70e8ea3f4dc937cb03b4340b8d57d4680820d86c2f474f3c43a844dd90e9f96391abaf2e88967d2b424db4cff7e00528adc7bb006c19b6c83739123aab957a5ccb9b1739b85a3becd79b4b861922eb4478d38c06230f406bbb1386cdb596e1ed7a35ee78f81d56ebfed7ca82f27116001c117455e1f5aa793237f1bd32db1dc44c7e296ba0bfed22aca71b84828e1a83a638a76059e7b637572d82f1bb13a874faaf9b9af53274ea23cbd72b2d34a243d133fac694a4c520f38eac503150370460c92c2b2c8873d7a58ce5f0ca303cf73a60c25136826484026074b8ac876d31e496827d137f4282dc765b123520fa509e7df89f6e8d2da1547c0797a30e1e60bb801cd8bc350f8a2a63752f302749ae1b808fd3429e9089b694daa36e32a489e2dfaf1f9377437ee073dce192cb49fabf791b606d4fc205d1cb1c164b8fe8154c850be929e5be24d006ff4305f773f84fda95df3917191f502c1b34f3f0f876918c09d273350a4bab5dd03a2f2ab45b3aafef241f02a6ba1fec02c7f766d72d1ddac92cb167ea2810c0941528274de4c407dc3465a7e9cc115d0fd63e7a93e4ee193e4747b61dd9b4c864497b0fdc6c0a5293b1e6eaeef9cc25511adf1284762853a245607bf2617660872e784de31e3be96683d14a8c43464c9a08033dcca29a9866bdce7f9b062783adb69d859d63b750e32258df91fbc87caa642597baf10d5edc55f2991e2928456782ae1eca22f7d0d6c9ef2428cc34a2316604e5186413b79d54cd9e65f5c88d9dd010d60c392cf96a87443d31c20220d5c3388c742ff228a9437e445164fb02714b94df891d25a55f0070a06efa4ece7602f6bb4fb4ce72508d45cda7e4962d0ca2290c18591af5dc4bbf467682e79795905bf9bc50f624552ef14d1fc042ed336c42964a7446b11d42d17f824d1094cd33182519be8d655a587ac6e1c9dabb2526e0fb07e52d8d333b15dcbae9852623d43caaada7031354f37cb091d148576ce32f57461abdc77d1a31160af1bab90926e33923e4edc47f2fa358b531c36ef6595a8d3539234325db33c7a29f36bb31f62e768b03647182af6e3cab9fb937df3c13ce85b4587b721daa12b82ebebec50fef598cbacd5606e792206fb0ca6ee3409c19d5c2ef2e1c8ba66e3003a8be5cc2def727db6270645d25ebcf45af97bc3c353166946ce79dc8c68b72c23b5306f2f7b73924b3c65c6b32a939608b64ece209c512e11362d01e24d3bc0500b2555d921703b445f30de39fcd28f9d3fa6f2f0b61095ad3cdb50db96c46c4f7b290fd2d8ca42b1da8fa01af72c1aeaadc2b27ed6be4faa8ba4f9a80d037057fd7038235a1b12f7d36b6a10ace21915ce4c9b46d1ec0f490b573f6367d5271c2cfbf28dd329bc8f187cb0a25aa837ad5d73aca61c696d05f64c4b7e873ef8b2f4faaaddb2637f52ee1479bb36bba9bfc2c89fb0de2cd9e0f36662fd64538d6895557882458f449568b05ad70e3e3ea0a3716ac8dd6e1bfed49915354391d6b820b5ea7be39273f7f7a6b6055d1b701426326b4ae2ded82e3f5ab29b6acf0cf78f7bc45b3cfdcd21d166d686cb57b6662199a5f561b7dab10839a79152e50ef71d0a290c42e990e5880f36499f26fd84de69c04894797e19afe43d64ecfa96b86a66c12b58201ccd4228f82bba62b1114fd581da0537638be7674a2a068f9054d46228aa894314042325ea3f9d5aeb849277fa505887ebadb96f5942a62ab7f2d06543aac44c83476682e117da11cc11e946913f21b4f99f9a9a9069d2ab8a8570c084fbb5c7481d501d79ed51458c0611d85139c92ffd72aa44a01783ff8cea63d5050124e305a7d04a35a795f483807fa5ae83a520ef21ff5bf72f3937cc7d14184aeac0c8f20fa5f7d7d40d0b04f7cc71fa7296d4b5726d6663a3d7d58b6ce00e74771523edee3eeff605fda601fdfc4f62f5bfaa18685634d3a3d21f11ff4f9d421d74757a6c8115ec948ac04e78a6941beeea258b6f9c5121a6202300631d57f6d3cbc8ed25047f1d7591a3a41279fe65bed19828f37fe8ccc623977d5f391fe7d8576a65feeff325e79d3d6a3a800b98eead22f8fe3d1e24cc4d7f467f19d930c22e00b08206f7014d240779b5142b58112d809b626b84d0c8ca401d7354373987994131b6011f44947009e1dc4de3eeb5b20912f12c19f5874a2d17423628a327649d577d4a2b81995e6dc385c8ff6fc11576604c7a584e5b4f718302c38dc4086b2af7131aa013ea4cf7871b133a32a757e2944ccbeff860eb71d7b0c5f1d605648c974c3df476e3b1f0f5209ae35f3da6327e8b3f9d0656f5f3fad51d2bbab19ada988028530dcd108c8a17b6632fbf692087852fd1cc29dd4788cfdf1831832e46b4f5011601ccf05078456456d3584ef8432db257dd60cafbf8094253e56a1b35ef68b88f0a7a652e5d54861e97c5f5d075812686f6b09aeb322193b61b47d459bdccb4945bf34b5084d26df5d7b5c3640d74337ee96e608ff8e119da5663bc895b4a6203bf0ecb1c89b57bf0569d4f9179a265eb5065cbd2c96754ffbca3cb2bbb733d53c976cda078ee93c09358333a6f29193c559e84c63bc9d2ccb203c4c867355b813792b23612163d50f9525baa497c9dd0ee3b4affcee365763395933cdafe96741f8b44202207dc0963eff0e56d03e7d79e6bf1e029860596e3f3b1dc86a741878bd09c532e9e383f127570d0238c2f21164b5dc2491d179877b0da61d10931a2495ab605b86f4b87f8bd29c3954beda0517ee0cb07b911ddf21770e32052f032f86ea9fcbe17cbbc831c159c8f07b53485eaba4ee0fd18988142d0257cb40f482c7bc16ed06e9ec1d645fc3c318073e578a286288ceb8cdb1ed8e8e28464d6f2f0e191e02c521fc24786048f3fcdc6dafe423fdaad1a23393327018291894ce9957813246fc40e3cf11a5093c9b538d0430ec469d644b4af4d8acbc2080c9a3091a92205c288c5a791347c1a15d67e2499fe46bc692e6cf70610a5da1375d5f2ba6b801b7aee76213c753857cf7e5b6109a8e5b4de05466def7ee7899ccc0ed9cfcabce620a9b055decc3f6891dbc55e15c1d40f3ffa1372e085732f18af5401abf59da3e2ce4ee715e6e72d80b36c15b38b8c1a6a52f84a2fc8b5b438e8d686bba7c719b48c9b0c0fde0b72b2a8474f3f04904a0d539d31e902406fc492f4f51b2af324cd8b2eff02560522f2f386aa377472c5204a1e8031d63d9fee213bd280758667087d9ef4084bf937e33aafd318256333bcaf079d152abc2e855e4867cbc7122b6fd58caa7d9bcbdeff5ce21101eb4dde3c7ba690574da074b2659187fbb57488039a28202c5066445c18686c9e98ce020372b8f0378f33b7a5594391417cc56e5c075c6179265b8d640134940c4d5ef0e3cd43a3015368a5e34c7d60f77e35fa50232b9e774eac858c1a958526efae3e29673abc3fa386d73bec390c113e251c9655c8ca</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>很久没有更新过了</title>
    <url>/post/20021.html</url>
    <content><![CDATA[<p>今天看看已经很久没有更新过博客了，最开始的时候想自己搭建一个小窝写一写自己的所思所想。</p>
<p>经过这段时间的培训，笔记做了很多的整理，可是总感觉少了点什么？</p>
<p>或许是对某写问题得到深入思索吧，在这里以后不仅记录对技术的实现更应该写写背后思索</p>
<p>继续开始做吧，我的无线网卡驱动移植难吗，下次就是分析一下无线网卡的移植和方法</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>一行代码的作用</title>
    <url>/post/c6279e60.html</url>
    <content><![CDATA[<h2 id="网页自由编辑"><a href="#网页自由编辑" class="headerlink" title="网页自由编辑"></a>网页自由编辑</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">document.body.contentEditable=`true`</span><br></pre></td></tr></table></figure>

<blockquote>
<ol>
<li>在任意需要编辑的网页中点击<code>F12</code></li>
<li>在调试面板选中<code>Console</code>，然后输入上面的这行代码，回车。</li>
<li>现在当前整个网页可以随便编辑了</li>
</ol>
</blockquote>
<h2 id="CSDN复制代码"><a href="#CSDN复制代码" class="headerlink" title="CSDN复制代码"></a>CSDN复制代码</h2><ul>
<li>添加一个书签，名称随意设置，比如CSDN复制</li>
<li>设置URL为:  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javascript:document.body.contentEditable=&#x27;true&#x27;;document.designMode=&#x27;on&#x27;; void 0</span><br></pre></td></tr></table></figure></li>
<li>在CSDN中遇到无法复制的代码，点击该书签后进行再复制即可</li>
</ul>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>code</tag>
      </tags>
  </entry>
  <entry>
    <title>方向</title>
    <url>/post/7367.html</url>
    <content><![CDATA[<p><img data-src="/images/2018/08/way.png" alt="way"></p>
<blockquote>
<p><strong>想升高。有两样东西，那就必须作鹰，或者作爬行动物。</strong>  ——巴尔扎克</p>
</blockquote>
<span id="more"></span>

<p>新工作已经按个月了，与之前的工作方式和工作内容都有很大的差别。但是没有排斥的感觉，会有烦恼和抱怨，可是也有充实吧。</p>
<p>从底层到上层的工作，与之前设想的基本一致，上一份工作中对驱动的理解和对音频方面的工作，与新工作中视频的工作方向，打算以后的主要针对音视频方面发展。</p>
<h2 id="优势："><a href="#优势：" class="headerlink" title="优势："></a>优势：</h2><ul>
<li>底层驱动（存储，音频）</li>
<li>对linux系统和CPU的了解</li>
<li>底层程序的执行原理的认识[C和汇报（mips）了解]</li>
</ul>
<h2 id="劣势："><a href="#劣势：" class="headerlink" title="劣势："></a>劣势：</h2><ul>
<li>网络编程欠缺</li>
<li>应用层的软件开发欠缺</li>
<li>视频相关知识欠缺</li>
</ul>
<h2 id="方向：【音视频】"><a href="#方向：【音视频】" class="headerlink" title="方向：【音视频】"></a>方向：【音视频】</h2><ul>
<li>视频相关知识</li>
<li>视频的采集（V4L2）</li>
<li>视频编解码</li>
</ul>
<h2 id="设想："><a href="#设想：" class="headerlink" title="设想："></a>设想：</h2><p>以底层为基础自下而上的接触和学习相关技能，完善自己的知识体系。</p>
<p><img data-src="/images/2018/08/knowledge_struct.png" alt="知识体系"></p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title>回顾2018的点滴</title>
    <url>/post/22139.html</url>
    <content><![CDATA[<span id="more"></span>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>对目前学习的简单回顾与规划</title>
    <url>/post/16809.html</url>
    <content><![CDATA[<h3 id="我的大学"><a href="#我的大学" class="headerlink" title="我的大学"></a>我的大学</h3><ul>
<li>现在回想起来，已经来到沈阳快有两年了。在他乡的我应该算是很幸运了，有亲人、朋友的照顾，谢谢你们。同时，遇到了我的室友，是我和他们一起度过这段时光。我们在一起二过，呵呵呵。也许在大学的每一个宿舍里都有一群，可以陪你一起二的人。他们使你的大学生活有了不一样的记忆。我真是太不争气了，想着想着就不知道，怎么写了。其实今天也没有想着，写一些琐碎的事。可是当写下了标题后，就想说点啥。可是又不知道从何写起，等以后准备好了以后再写一篇“我的大学”。<!---more---></li>
</ul>
<h3 id="我的学习"><a href="#我的学习" class="headerlink" title="我的学习"></a>我的学习</h3><ul>
<li><p>在高中的时候，听别人说在大学就可以轻松了。可是，现在真的“轻松”了吗？想学点东西有时可真是累，不知道学的有没有用。可是当你知道自己学的东西，是自己以后的可能从业方向时，有一次一次的坚持不下来。而有开始反问自己，呵呵呵，想着想着我都感到自己好笑了。我记得好像有人说过“人本身就是一个矛盾体”，是不是我这个矛盾体太大了。</p>
</li>
<li><p>还记得我在大一的时候，由于没有电脑上网时间不多。对一些专业方面的事，不大了解，只是听老师给我们讲的一些。那时周末没事干就去图书馆找一些小说看，现在想来那时抱着一本喜欢的小说还是挺不错的。记得看过的第一本小说是《伏藏》作者现在已经忘了，主要是通过西藏活佛仓央嘉措和他的情人与情歌的故事，写出了活佛与他的大爱，“伏藏”伏下的不是对世人的愤怒，而是大爱。现在已经很久没看过小说了，去年快放寒假的时候，在当当网买了一本《失控》，最坑人的是它从北京邮到沈阳整整用了八天时间。那时听说这本书不错，所以就买了。现在有时间了看看，实在是太难消化了，里面存在着大量的专业知识。不过是非常不错的一本书。</p>
</li>
<li><p>说了这么半天废话，写点正事。给自己一个总结，一个方向</p>
</li>
</ul>
<ol>
<li>一直想学一些Linux方面的知识，想继续走下去。从以前的一些简单操作与日常管理和Gcc、makefile等，到现在想学习的shell、网络编程、与嵌入式Linux。</li>
<li>上学期学习完C++后，感觉对面向对象编程理解不深，想通过学习Qt编程加以巩固。</li>
<li>好好学习操作系统、微机原理，同时也希望这学期不在挂科</li>
</ol>
<h3 id="随想"><a href="#随想" class="headerlink" title="随想"></a>随想</h3><ul>
<li>上面的一点东西都是自己，的一些简单想法和愿望吧。已经很久没写过东西了，现在都不会写了。用了一个下午才写了这篇随笔吧，也只能说是随笔了。可是让人想了很多，这也许是写博客的一个好处吧，给自己一个思考的时间。我一直在思考学习技术层次的东西到底有用吗，在大学我们到底学的是什么。技术这个东西只要你肯花时间和精力，一定会学会成为高手。在自己以后的工作中可以独挡一面吧。我现在还是一名学生，没有工作过可能有些观点不正确。</li>
<li>技术的学习可能就像是学功夫（我也是个功夫迷，喜欢成龙、李连杰），学功夫只会一些招式，成不了大师。它们都有一些内功心法提高自己的修为与功夫。我想学技术也应该差不多，我们应该思考一个命令、一个算法、一种模式背后所存在的方法和哲学吧。今天无意中看到这篇<span class="exturl" data-url="aHR0cDovL3d3dy5jbmJsb2dzLmNvbS90Y2ppYWFuL3AvMzUyOTM1OC5odG1sIyFjb21tZW50cw==">文章<i class="fa fa-external-link-alt"></i></span>感触很深。就像里面说的我们认识了解一个事物，应该深入到它所存在的价值和背后的哲学，而不是简单的理解一些表象的东西。这样才可以真正提高自身的能力。</li>
</ul>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>居然是日记</title>
    <url>/post/19ef3eed.html</url>
    <content><![CDATA[<p>偶然翻出学生时期收藏的一些代码，其中一个看不懂是啥意思，想着编译可能都过不去。没想到的是简单修改几个中文字符后，居然编译过了，运行时发现是一篇日记。</p>
<p>在这里把这段代码记录一下，有机会了再慢慢研究，生成的日记字符比代码本身字符多好几倍</p>
<span id="more"></span>

<p>C源码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">main(t,_,a)<span class="type">char</span> *a;&#123;</span><br><span class="line">	<span class="keyword">return</span>!<span class="number">0</span>&lt;t?t&lt;<span class="number">3</span>?main(<span class="number">-79</span>,<span class="number">-13</span>,a+main(<span class="number">-87</span>,<span class="number">1</span>-_,main(<span class="number">-86</span>,<span class="number">0</span>,a+<span class="number">1</span>)+a)):<span class="number">1</span>,t&lt;_?</span><br><span class="line">	main(t+<span class="number">1</span>,_,a):<span class="number">3</span>,main(<span class="number">-94</span>,<span class="number">-27</span>+t,a)&amp;&amp;t==<span class="number">2</span>?_&lt;<span class="number">13</span>?</span><br><span class="line">	main(<span class="number">2</span>,_+<span class="number">1</span>,<span class="string">&quot;%s %d %d\n&quot;</span>):<span class="number">9</span>:<span class="number">16</span>:t&lt;<span class="number">0</span>?t&lt;<span class="number">-72</span>?</span><br><span class="line">	main(_,t,<span class="string">&quot;@n&#x27;+,#&#x27;/*&#123;&#125;w+/w#cdnr/+,&#123;&#125;r/*de&#125;+,/*&#123;*+,/w&#123;%+,/w#q#n+,/#&#123;l+,/n&#123;n+,/+#n+,/#\;#q#n+,/+k#;*+,/&#x27;r :&#x27;d*&#x27;3,&#125;&#123;w+Kw&#x27;K:&#x27;+&#125;e#&#x27;;dq#&#x27;lq#&#x27;+d&#x27;K#!/+k#;q#&#x27;r&#125;eKK#&#125;w&#x27;r&#125;eKK&#123;nl]&#x27;/#;#q#n&#x27;)&#123;)#&#125;w&#x27;)&#123;)&#123;nl]&#x27;/+#n&#x27;;d&#125;rw&#x27; i;# \)&#123;nl]!/n&#123;n#&#x27;; r&#123;#w&#x27;r nc&#123;nl]&#x27;/#&#123;l,+&#x27;K &#123;rw&#x27; iK&#123;;[&#123;nl]&#x27;/w#q#n&#x27;wk nw&#x27; \iwk&#123;KK&#123;nl]!/w&#123;%&#x27;l##w#&#x27;:&#123;nl]&#x27;/*&#123;q#&#x27;ld;r&#x27;&#125;&#123;nlwb!/*de&#125;&#x27;c;;&#123;nl&#x27;-&#123;&#125;rw]&#x27;/+,&#125;##&#x27;*&#125;#nc,&#x27;,#nw]&#x27;/+kd&#x27;+e&#125;+;#&#x27;rdq#w! nr&#x27;/ &#x27;) &#125;+&#125;&#123;rl#&#x27;&#123;n&#x27; &#x27;)# \&#125;&#x27;+&#125;##(!!/&quot;</span>):t&lt;<span class="number">-50</span>?_==*a?<span class="built_in">putchar</span>(<span class="number">31</span>[a]):</span><br><span class="line">	main(<span class="number">-65</span>,_,a+<span class="number">1</span>):main((*a==<span class="string">&#x27;/&#x27;</span>)+t,_,a+<span class="number">1</span>):<span class="number">0</span>&lt;t?main(<span class="number">2</span>,<span class="number">2</span>,<span class="string">&quot;%s&quot;</span>):*a==<span class="string">&#x27;/&#x27;</span>||</span><br><span class="line">	main(<span class="number">0</span>,main(<span class="number">-61</span>,*a,<span class="string">&quot;!ek;dc i@bK&#x27;(q)-[w]*%n+r3#l,&#123;&#125;:\nuwloca-O;m .vpbks,fxntdCeghiry&quot;</span>),a+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">↪ =&gt;$./a.out</span><br><span class="line">On the first day of Christms my true love gve to me</span><br><span class="line">a partridge in a pear tree.</span><br><span class="line"></span><br><span class="line">On the second day of Christms my true love gve to me</span><br><span class="line">two turtle doves</span><br><span class="line">and a partridge in a pear tree.</span><br><span class="line"></span><br><span class="line">On the third day of Christms my true love gve to me</span><br><span class="line">three french hens, two turtle doves</span><br><span class="line">and a partridge in a pear tree.</span><br><span class="line"></span><br><span class="line">On the fourth day of Christms my true love gve to me</span><br><span class="line">four clling birds, three french hens, two turtle doves</span><br><span class="line">and a partridge in a pear tree.</span><br><span class="line"></span><br><span class="line">On the fifth day of Christms my true love gve to me</span><br><span class="line">five gold rings;</span><br><span class="line">four clling birds, three french hens, two turtle doves</span><br><span class="line">and a partridge in a pear tree.</span><br><span class="line"></span><br><span class="line">On the sixth day of Christms my true love gve to me</span><br><span class="line">six geese ying, five gold rings;</span><br><span class="line">four clling birds, three french hens, two turtle doves</span><br><span class="line">and a partridge in a pear tree.</span><br><span class="line"></span><br><span class="line">On the seventh day of Christms my true love gve to me</span><br><span class="line">seven swans a-swimming,</span><br><span class="line">six geese ying, five gold rings;</span><br><span class="line">four clling birds, three french hens, two turtle doves</span><br><span class="line">and a partridge in a pear tree.</span><br><span class="line"></span><br><span class="line">On the eigth day of Christms my true love gve to me</span><br><span class="line">eight maids a-milking, seven swans a-swimming,</span><br><span class="line">six geese ying, five gold rings;</span><br><span class="line">four clling birds, three french hens, two turtle doves</span><br><span class="line">and a partridge in a pear tree.</span><br><span class="line"></span><br><span class="line">On the ninth day of Christms my true love gve to me</span><br><span class="line">nine ladies dancing, eight maids a-milking, seven swans a-swimming,</span><br><span class="line">six geese ying, five gold rings;</span><br><span class="line">four clling birds, three french hens, two turtle doves</span><br><span class="line">and a partridge in a pear tree.</span><br><span class="line"></span><br><span class="line">On the tenth day of Christms my true love gve to me</span><br><span class="line">ten lords a-leaping,</span><br><span class="line">nine ladies dancing, eight maids a-milking, seven swans a-swimming,</span><br><span class="line">six geese ying, five gold rings;</span><br><span class="line">four clling birds, three french hens, two turtle doves</span><br><span class="line">and a partridge in a pear tree.</span><br><span class="line"></span><br><span class="line">On the eleventh day of Christms my true love gve to me</span><br><span class="line">eleven pipers piping, ten lords a-leaping,</span><br><span class="line">nine ladies dancing, eight maids a-milking, seven swans a-swimming,</span><br><span class="line">six geese ying, five gold rings;</span><br><span class="line">four clling birds, three french hens, two turtle doves</span><br><span class="line">and a partridge in a pear tree.</span><br><span class="line"></span><br><span class="line">On the twelfth day of Christms my true love gve to me</span><br><span class="line">twelve drummers drumming, eleven pipers piping, ten lords a-leaping,</span><br><span class="line">nine ladies dancing, eight maids a-milking, seven swans a-swimming,</span><br><span class="line">six geese ying, five gold rings;</span><br><span class="line">four clling birds, three french hens, two turtle doves</span><br><span class="line">and a partridge in a pear tree.</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>c</tag>
        <tag>日记</tag>
      </tags>
  </entry>
  <entry>
    <title>ARMv8中的SIMD运算</title>
    <url>/post/13631.html</url>
    <content><![CDATA[<p><code>NEON</code>是一种压缩的SIMD架构，主要是给多媒体使用，结果并行计算的问题。</p>
<blockquote>
<p>NEON是ARMv7-A和ARMv7-R引入的特性，在后面的ARMv8-A和ARMv8-R中也扩展其功能.1288bit的向量运算</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">ARMv7-A&#x2F;R</th>
<th align="center">ARMv8-A&#x2F;R</th>
<th align="center">ARMv8-A</th>
</tr>
</thead>
<tbody><tr>
<td align="center"></td>
<td align="center"></td>
<td align="center">AArch32</td>
<td align="center">AArch64</td>
</tr>
<tr>
<td align="center">Floating-point</td>
<td align="center">32-bit</td>
<td align="center">16-bit*&#x2F;32-bit</td>
<td align="center">16-bit*&#x2F;32-bit</td>
</tr>
<tr>
<td align="center">Integer</td>
<td align="center">8-bit&#x2F;16-bit&#x2F;32-bit</td>
<td align="center">8-bit&#x2F;16-bit&#x2F;32-bit&#x2F;64-bit</td>
<td align="center">8-bit&#x2F;16-bit&#x2F;32-bit&#x2F;64-bit</td>
</tr>
</tbody></table>
<span id="more"></span>

<h2 id="ARMv8与ARMv7的区别"><a href="#ARMv8与ARMv7的区别" class="headerlink" title="ARMv8与ARMv7的区别"></a>ARMv8与ARMv7的区别</h2><ul>
<li>1.与<code>通用寄存器</code>相同的助记符</li>
</ul>
<table>
<thead>
<tr>
<th align="center">CPU</th>
<th align="center">通用</th>
<th align="center">SIMD</th>
</tr>
</thead>
<tbody><tr>
<td align="center">ARMv7</td>
<td align="center">mul, r0, r0, r1</td>
<td align="center">vmul d0, d0, d1</td>
</tr>
<tr>
<td align="center">ARMv8</td>
<td align="center">mul x0, x0, x1</td>
<td align="center">mul v0.u8, v0.u8, v1.u8</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>注意：在ARMv7中所有的SIMD汇编的操作码如<code>mul</code>的前缀都有<code>v</code>如vml</strong></p>
</blockquote>
<ul>
<li><p>2.ARMv8的寄存器是ARMv7的两倍</p>
<ul>
<li>ARMv8拥有<code>32</code>个128-bit寄存器</li>
<li>ARMv7拥有<code>16</code>个128-bit寄存器</li>
</ul>
</li>
<li><p>3.不同的指令语法</p>
</li>
</ul>
<h2 id="SIMD寄存器"><a href="#SIMD寄存器" class="headerlink" title="SIMD寄存器"></a>SIMD寄存器</h2><p><img data-src="/images/2019/03/armv8simd%E5%AF%84%E5%AD%98%E5%99%A8.png" alt="armv8SIMD寄存器"></p>
<table>
<thead>
<tr>
<th align="center">寄存器</th>
<th align="center">个数</th>
<th align="center">位宽</th>
<th align="center">数据类型</th>
</tr>
</thead>
<tbody><tr>
<td align="center">D寄存器（<code>D0-D31</code>）</td>
<td align="center">32个</td>
<td align="center">64-bit</td>
<td align="center">双字（double word）</td>
</tr>
<tr>
<td align="center">Q寄存器（<code>Q0-Q15</code>）</td>
<td align="center">16个</td>
<td align="center">128-bit</td>
<td align="center">四字</td>
</tr>
</tbody></table>
<h2 id="矢量寄存器V0-V31：包装"><a href="#矢量寄存器V0-V31：包装" class="headerlink" title="矢量寄存器V0-V31：包装"></a>矢量寄存器V0-V31：包装</h2><p><img data-src="/images/2019/03/armv8simd%E5%AF%84%E5%AD%98%E5%99%A8%E6%A0%87%E8%AF%86vx.png" alt="armv8SIMD寄存器标识vx"></p>
<p>打包V0-V31中的数据，方便数据操作</p>
<p><img data-src="/images/2019/03/armv8simd%E5%AF%84%E5%AD%98%E5%99%A8%E6%89%93%E5%8C%85.png" alt="ARMv8SIMD寄存器打包"></p>
<h2 id="矢量包装"><a href="#矢量包装" class="headerlink" title="矢量包装"></a>矢量包装</h2><p><img data-src="/images/2019/03/armvc8.png" alt="ARMvc8"></p>
<p><strong>主要定义每一个矢量Vn的数据位宽</strong></p>
<table>
<thead>
<tr>
<th align="center">标识</th>
<th align="center">位宽</th>
<th align="center">数据类型</th>
<th align="left">示例</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>b</code></td>
<td align="center">8bit</td>
<td align="center">char</td>
<td align="left">v0.8b,v0.16b: 8个bit16个bit</td>
</tr>
<tr>
<td align="center"><code>h</code></td>
<td align="center">16bit</td>
<td align="center">short</td>
<td align="left">v0.4h，v0.8h： 4或8个半字（short类型）</td>
</tr>
<tr>
<td align="center"><code>s</code></td>
<td align="center">32bit</td>
<td align="center">int</td>
<td align="left">v0.2s，v0.4s：2或4个字</td>
</tr>
<tr>
<td align="center"><code>d</code></td>
<td align="center">64bit</td>
<td align="center">long long</td>
<td align="left">v0.2d：2个double word</td>
</tr>
</tbody></table>
<h2 id="指令语法"><a href="#指令语法" class="headerlink" title="指令语法"></a>指令语法</h2><p><img data-src="/images/2019/03/armv8simd%E6%8C%87%E4%BB%A4op.png" alt="ARMv8SIMD指令op"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ld4 &#123;v0.4h-v3.4h&#125;, [%0]</span><br></pre></td></tr></table></figure>
<p>等同于：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ld4 &#123;v0.4h, v1.4h, v2.4h, v3.4h&#125;, [%0]</span><br></pre></td></tr></table></figure>

<h2 id="内联函数编程"><a href="#内联函数编程" class="headerlink" title="内联函数编程"></a>内联函数编程</h2><p>NEON 内在函数在头文件<code>arm_neon.h</code>中定义。头文件既定义内在函数，也定义一组向量类型</p>
<blockquote>
<p><span class="exturl" data-url="aHR0cDovL2luZm9jZW50ZXIuYXJtLmNvbS9oZWxwL3RvcGljL2NvbS5hcm0uZG9jLmR1aTAzNDhiYy9EVUkwMzQ4QkNfcnZjdF9jb21wX3JlZl9ndWlkZS5wZGY=">NEON操作函数<i class="fa fa-external-link-alt"></i></span></p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL0VtRGVwVGVhbS9hcm0tbGludXgtZ251ZWFiaWhmL21hc3Rlci9saWIvZ2NjL2FybS1saW51eC1nbnVlYWJpaGYvNy4zLjEvaW5jbHVkZS9hcm1fbmVvbi5o">arm_neon.h
<i class="fa fa-external-link-alt"></i></span></li>
</ul>
</blockquote>
<h2 id="内嵌汇编编程"><a href="#内嵌汇编编程" class="headerlink" title="内嵌汇编编程"></a>内嵌汇编编程</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">asm volatile(</span><br><span class="line">    &quot;mnemonic+operand \n\t&quot;</span><br><span class="line">    &quot;mnemonic+operand \n\t&quot;</span><br><span class="line">    &quot;mnemonic+operand \n\t&quot;</span><br><span class="line"></span><br><span class="line">    : //output operand list  /*输出操作数列表*/</span><br><span class="line">    : //input operand list   /*输入操作数列表*/</span><br><span class="line">    : //Dirty registers etc  /*被改变资源列表*/</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h3 id="操作符-amp-修饰符"><a href="#操作符-amp-修饰符" class="headerlink" title="操作符&amp;修饰符"></a>操作符&amp;修饰符</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">asm volatile(</span><br><span class="line">        &quot;add %0, %1, %2&quot;</span><br><span class="line"></span><br><span class="line">        : &quot;=r&quot; (ret)</span><br><span class="line">        : &quot;r&quot; (a), &quot;r&quot; (b)</span><br><span class="line">        );</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center"><strong>操作符</strong></th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>r</code></td>
<td align="center">通用寄存器</td>
</tr>
<tr>
<td align="center"><code>m</code></td>
<td align="center">一个有效的内存地址</td>
</tr>
<tr>
<td align="center"><code>I</code></td>
<td align="center">数据处理中的立即数</td>
</tr>
<tr>
<td align="center"><code>X</code></td>
<td align="center">被修饰的操作符只能作为输出</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="center"><strong>修饰符</strong></th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>无</code></td>
<td align="center">只读</td>
</tr>
<tr>
<td align="center"><code>=</code></td>
<td align="center">只写</td>
</tr>
<tr>
<td align="center"><code>+</code></td>
<td align="center">可读可写</td>
</tr>
<tr>
<td align="center"><code>&amp;</code></td>
<td align="center">只能作为输出</td>
</tr>
</tbody></table>
<h3 id="传参"><a href="#传参" class="headerlink" title="传参"></a>传参</h3><h4 id="参数序列"><a href="#参数序列" class="headerlink" title="参数序列"></a>参数序列</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">asm volatile(</span><br><span class="line">        &quot;add %0, %1, %2&quot;</span><br><span class="line"></span><br><span class="line">        : &quot;=r&quot; (ret)</span><br><span class="line">        : &quot;r&quot; (a), &quot;r&quot; (b)</span><br><span class="line">        );</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li><code>ret</code>: <code>%0</code>, 第一个参数</li>
<li><code>a</code>  : <code>%1</code>, 第二个参数</li>
<li><code>b</code>  : <code>%2</code>, 第三个参数</li>
</ul>
</blockquote>
<h4 id="参数名"><a href="#参数名" class="headerlink" title="参数名"></a>参数名</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">asm volatile(</span><br><span class="line">        &quot;add %[result], %[a], %[b]&quot;</span><br><span class="line"></span><br><span class="line">        : [result] &quot;=r&quot; (ret)</span><br><span class="line">        : [a] &quot;r&quot; (a), [b] &quot;r&quot; (b)</span><br><span class="line">        );</span><br></pre></td></tr></table></figure>
<blockquote>
<p>传入参数不依赖参数序列</p>
</blockquote>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="4x4矩阵乘法"><a href="#4x4矩阵乘法" class="headerlink" title="4x4矩阵乘法"></a>4x4矩阵乘法</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __aarch64__</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arm_neon.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">dump</span><span class="params">(<span class="type">uint16_t</span> **x)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="type">uint16_t</span> *xx = (<span class="type">uint16_t</span> *)x;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s:\n&quot;</span>, __func__);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%3d &quot;</span>, *(xx + (i &lt;&lt; <span class="number">2</span>) + j));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">matrix_mul_c</span><span class="params">(<span class="type">uint16_t</span> aa[][<span class="number">4</span>], <span class="type">uint16_t</span> bb[][<span class="number">4</span>], <span class="type">uint16_t</span> cc[][<span class="number">4</span>])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;===&gt; func: %s, line: %d\n&quot;</span>, __func__, __LINE__);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++) &#123;</span><br><span class="line">            cc[i][j] = aa[i][j] * bb[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __aarch64__</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">matrix_mul_neon</span><span class="params">(<span class="type">uint16_t</span> **aa, <span class="type">uint16_t</span> **bb, <span class="type">uint16_t</span> **cc)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;===&gt; func: %s, line: %d\n&quot;</span>, __func__, __LINE__);</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 1</span></span><br><span class="line">    <span class="type">uint16_t</span> (*a)[<span class="number">4</span>] = (<span class="type">uint16_t</span> (*)[<span class="number">4</span>])aa;</span><br><span class="line">    <span class="type">uint16_t</span> (*b)[<span class="number">4</span>] = (<span class="type">uint16_t</span> (*)[<span class="number">4</span>])bb;</span><br><span class="line">    <span class="type">uint16_t</span> (*c)[<span class="number">4</span>] = (<span class="type">uint16_t</span> (*)[<span class="number">4</span>])cc;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;aaaaaaaa\n&quot;</span>);</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">&quot;nop&quot;</span>);</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">&quot;nop&quot;</span>);</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">&quot;nop&quot;</span>);</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">&quot;nop&quot;</span>);</span><br><span class="line">    <span class="type">uint16x4_t</span> _cc0;</span><br><span class="line">    <span class="type">uint16x4_t</span> _cc1;</span><br><span class="line">    <span class="type">uint16x4_t</span> _cc2;</span><br><span class="line">    <span class="type">uint16x4_t</span> _cc3;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint16x4_t</span> _aa0 = vld1_u16((<span class="type">uint16_t</span>*)a[<span class="number">0</span>]);</span><br><span class="line">    <span class="type">uint16x4_t</span> _aa1 = vld1_u16((<span class="type">uint16_t</span>*)a[<span class="number">1</span>]);</span><br><span class="line">    <span class="type">uint16x4_t</span> _aa2 = vld1_u16((<span class="type">uint16_t</span>*)a[<span class="number">2</span>]);</span><br><span class="line">    <span class="type">uint16x4_t</span> _aa3 = vld1_u16((<span class="type">uint16_t</span>*)a[<span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="type">uint16x4_t</span> _bb0 = vld1_u16((<span class="type">uint16_t</span>*)b[<span class="number">0</span>]);</span><br><span class="line">    <span class="type">uint16x4_t</span> _bb1 = vld1_u16((<span class="type">uint16_t</span>*)b[<span class="number">1</span>]);</span><br><span class="line">    <span class="type">uint16x4_t</span> _bb2 = vld1_u16((<span class="type">uint16_t</span>*)b[<span class="number">2</span>]);</span><br><span class="line">    <span class="type">uint16x4_t</span> _bb3 = vld1_u16((<span class="type">uint16_t</span>*)b[<span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line">    _cc0 = vmul_u16(_aa0, _bb0);</span><br><span class="line">    _cc1 = vmul_u16(_aa1, _bb1);</span><br><span class="line">    _cc2 = vmul_u16(_aa2, _bb2);</span><br><span class="line">    _cc3 = vmul_u16(_aa3, _bb3);</span><br><span class="line"></span><br><span class="line">    vst1_u16((<span class="type">uint16_t</span>*)c[<span class="number">0</span>], _cc0);</span><br><span class="line">    vst1_u16((<span class="type">uint16_t</span>*)c[<span class="number">1</span>], _cc1);</span><br><span class="line">    vst1_u16((<span class="type">uint16_t</span>*)c[<span class="number">2</span>], _cc2);</span><br><span class="line">    vst1_u16((<span class="type">uint16_t</span>*)c[<span class="number">3</span>], _cc3);</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">&quot;nop&quot;</span>);</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">&quot;nop&quot;</span>);</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">&quot;nop&quot;</span>);</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">&quot;nop&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;bbbbbbbb\n&quot;</span>);</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">uint16x4_t</span> _aa[<span class="number">4</span>], _bb[<span class="number">4</span>], _cc[<span class="number">4</span>];</span><br><span class="line">    <span class="type">uint16_t</span> *a = (<span class="type">uint16_t</span>*)aa;</span><br><span class="line">    <span class="type">uint16_t</span> *b = (<span class="type">uint16_t</span>*)bb;</span><br><span class="line">    <span class="type">uint16_t</span> *c = (<span class="type">uint16_t</span>*)cc;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        _aa[i] = vld1_u16(a + (i &lt;&lt; <span class="number">2</span>));</span><br><span class="line">        _bb[i] = vld1_u16(b + (i &lt;&lt; <span class="number">2</span>));</span><br><span class="line">        _cc[i] = vmul_u16(_aa[i], _bb[i]);</span><br><span class="line">        vst1_u16(c + (i &lt;&lt; <span class="number">2</span>), _cc[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">matrix_mul_asm</span><span class="params">(<span class="type">uint16_t</span> **aa, <span class="type">uint16_t</span> **bb, <span class="type">uint16_t</span> **cc)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;===&gt; func: %s, line: %d\n&quot;</span>, __func__, __LINE__);</span><br><span class="line"></span><br><span class="line">    <span class="type">uint16_t</span> *a = (<span class="type">uint16_t</span>*)aa;</span><br><span class="line">    <span class="type">uint16_t</span> *b = (<span class="type">uint16_t</span>*)bb;</span><br><span class="line">    <span class="type">uint16_t</span> *c = (<span class="type">uint16_t</span>*)cc;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(</span></span><br><span class="line"><span class="params">        <span class="string">&quot;ldr d3, [%0, #0]           \n\t&quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;ldr d2, [%0, #8]           \n\t&quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;ldr d1, [%0, #16]          \n\t&quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;ldr d0, [%0, #24]          \n\t&quot;</span></span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">        <span class="string">&quot;ldr d7, [%1, #0]           \n\t&quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;ldr d6, [%1, #8]           \n\t&quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;ldr d5, [%1, #16]          \n\t&quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;ldr d4, [%1, #24]          \n\t&quot;</span></span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">        <span class="string">&quot;mul v3.4h, v3.4h, v7.4h    \n\t&quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;mul v2.4h, v2.4h, v6.4h    \n\t&quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;mul v1.4h, v1.4h, v5.4h    \n\t&quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;mul v0.4h, v0.4h, v4.4h    \n\t&quot;</span></span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">        <span class="comment">//&quot;add v3.4h, v3.4h, v7.4h    \n\t&quot;</span></span></span><br><span class="line"><span class="params">        <span class="comment">//&quot;add v2.4h, v2.4h, v6.4h    \n\t&quot;</span></span></span><br><span class="line"><span class="params">        <span class="comment">//&quot;add v1.4h, v1.4h, v5.4h    \n\t&quot;</span></span></span><br><span class="line"><span class="params">        <span class="comment">//&quot;add v0.4h, v0.4h, v4.4h    \n\t&quot;</span></span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">        <span class="string">&quot;str d3, [%2,#0]            \n\t&quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;str d2, [%2,#8]            \n\t&quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;str d1, [%2,#16]           \n\t&quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;str d0, [%2,#24]           \n\t&quot;</span></span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">        : <span class="string">&quot;+r&quot;</span>(a),   <span class="comment">//%0</span></span></span><br><span class="line"><span class="params">          <span class="string">&quot;+r&quot;</span>(b),   <span class="comment">//%1</span></span></span><br><span class="line"><span class="params">          <span class="string">&quot;+r&quot;</span>(c)    <span class="comment">//%2</span></span></span><br><span class="line"><span class="params">        :</span></span><br><span class="line"><span class="params">        : <span class="string">&quot;cc&quot;</span>, <span class="string">&quot;memory&quot;</span>, <span class="string">&quot;d0&quot;</span>, <span class="string">&quot;d1&quot;</span>, <span class="string">&quot;d2&quot;</span>, <span class="string">&quot;d3&quot;</span>, <span class="string">&quot;d4&quot;</span>, <span class="string">&quot;d5&quot;</span>, <span class="string">&quot;d6&quot;</span>, <span class="string">&quot;d7&quot;</span></span></span><br><span class="line"><span class="params">    )</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="comment">// test, OK</span></span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">&quot;nop&quot;</span>);</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">&quot;nop&quot;</span>);</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">&quot;nop&quot;</span>);</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">&quot;nop&quot;</span>);</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">&quot;nop&quot;</span>);</span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(</span></span><br><span class="line"><span class="params">        <span class="comment">//&quot;ld4 &#123;v0.4h, v1.4h, v2.4h, v3.4h&#125;, [%0] \n\t&quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;ld4 &#123;v0.4h-v3.4h&#125;, [%0]                \n\t&quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;ld4 &#123;v4.4h, v5.4h, v6.4h, v7.4h&#125;, [%1] \n\t&quot;</span></span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">        <span class="string">&quot;mul v3.4h, v3.4h, v7.4h                \n\t&quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;mul v2.4h, v2.4h, v6.4h                \n\t&quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;mul v1.4h, v1.4h, v5.4h                \n\t&quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;mul v0.4h, v0.4h, v4.4h                \n\t&quot;</span></span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">        <span class="string">&quot;st4 &#123;v0.4h, v1.4h, v2.4h, v3.4h&#125;, [%2] \n\t&quot;</span></span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">        : <span class="string">&quot;+r&quot;</span>(a),   <span class="comment">//%0</span></span></span><br><span class="line"><span class="params">          <span class="string">&quot;+r&quot;</span>(b),   <span class="comment">//%1</span></span></span><br><span class="line"><span class="params">          <span class="string">&quot;+r&quot;</span>(c)    <span class="comment">//%2</span></span></span><br><span class="line"><span class="params">        :</span></span><br><span class="line"><span class="params">        : <span class="string">&quot;cc&quot;</span>, <span class="string">&quot;memory&quot;</span>, <span class="string">&quot;v0&quot;</span>, <span class="string">&quot;v1&quot;</span>, <span class="string">&quot;v2&quot;</span>, <span class="string">&quot;v3&quot;</span>, <span class="string">&quot;v4&quot;</span>, <span class="string">&quot;v5&quot;</span>, <span class="string">&quot;v6&quot;</span>, <span class="string">&quot;v7&quot;</span></span></span><br><span class="line"><span class="params">    )</span>;</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">&quot;nop&quot;</span>);</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">&quot;nop&quot;</span>);</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">&quot;nop&quot;</span>);</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">&quot;nop&quot;</span>);</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">&quot;nop&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint16_t</span> aa[<span class="number">4</span>][<span class="number">4</span>] = &#123;</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;,</span><br><span class="line">        &#123;<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;,</span><br><span class="line">        &#123;<span class="number">3</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">2</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">1</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint16_t</span> bb[<span class="number">4</span>][<span class="number">4</span>] = &#123;</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>&#125;,</span><br><span class="line">        &#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>&#125;,</span><br><span class="line">        &#123;<span class="number">2</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>&#125;,</span><br><span class="line">        &#123;<span class="number">5</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">1</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint16_t</span> cc[<span class="number">4</span>][<span class="number">4</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> start_us = <span class="number">0</span>, end_us = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    dump((<span class="type">uint16_t</span> **)aa);</span><br><span class="line">    dump((<span class="type">uint16_t</span> **)bb);</span><br><span class="line">    dump((<span class="type">uint16_t</span> **)cc);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ******** C **********/</span></span><br><span class="line">    gettimeofday(&amp;tv, <span class="literal">NULL</span>);</span><br><span class="line">    start_us = tv.tv_sec + tv.tv_usec;</span><br><span class="line"></span><br><span class="line">    matrix_mul_c(aa, bb, cc);</span><br><span class="line"></span><br><span class="line">    gettimeofday(&amp;tv, <span class="literal">NULL</span>);</span><br><span class="line">    end_us = tv.tv_sec + tv.tv_usec;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;aa[][]*bb[][] C time %lld us\n&quot;</span>, end_us - start_us);</span><br><span class="line">    dump((<span class="type">uint16_t</span> **)cc);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __aarch64__</span></span><br><span class="line">    <span class="comment">/* ******** NEON **********/</span></span><br><span class="line">    <span class="built_in">memset</span>(cc, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="type">uint16_t</span>) * <span class="number">4</span> * <span class="number">4</span>);</span><br><span class="line">    gettimeofday(&amp;tv, <span class="literal">NULL</span>);</span><br><span class="line">    start_us = tv.tv_sec + tv.tv_usec;</span><br><span class="line"></span><br><span class="line">    matrix_mul_neon((<span class="type">uint16_t</span> **)aa, (<span class="type">uint16_t</span> **)bb, (<span class="type">uint16_t</span> **)cc);</span><br><span class="line"></span><br><span class="line">    gettimeofday(&amp;tv, <span class="literal">NULL</span>);</span><br><span class="line">    end_us = tv.tv_sec + tv.tv_usec;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;aa[][]*bb[][] neon time %lld us\n&quot;</span>, end_us - start_us);</span><br><span class="line">    dump((<span class="type">uint16_t</span> **)cc);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ******** asm **********/</span></span><br><span class="line">    <span class="built_in">memset</span>(cc, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="type">uint16_t</span>) * <span class="number">4</span> * <span class="number">4</span>);</span><br><span class="line">    gettimeofday(&amp;tv, <span class="literal">NULL</span>);</span><br><span class="line">    start_us = tv.tv_sec + tv.tv_usec;</span><br><span class="line"></span><br><span class="line">    matrix_mul_asm((<span class="type">uint16_t</span> **)aa, (<span class="type">uint16_t</span> **)bb, (<span class="type">uint16_t</span> **)cc);</span><br><span class="line"></span><br><span class="line">    gettimeofday(&amp;tv, <span class="literal">NULL</span>);</span><br><span class="line">    end_us = tv.tv_sec + tv.tv_usec;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;aa[][]*bb[][] asm time %lld us\n&quot;</span>, end_us - start_us);</span><br><span class="line">    dump((<span class="type">uint16_t</span> **)cc);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">aarch64-linux-gcc -O3  matrix_4x4_mul.c</span><br></pre></td></tr></table></figure>

<blockquote>
<p>gcc –march&#x3D;armv8-a [input file] -o [output file]</p>
</blockquote>
<h3 id="8x8矩阵乘法"><a href="#8x8矩阵乘法" class="headerlink" title="8x8矩阵乘法"></a>8x8矩阵乘法</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">matrix_mul_asm</span><span class="params">(<span class="type">uint16_t</span> **aa, <span class="type">uint16_t</span> **bb, <span class="type">uint16_t</span> **cc)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;===&gt; func: %s, line: %d\n&quot;</span>, __func__, __LINE__);</span><br><span class="line"></span><br><span class="line">    <span class="type">uint16_t</span> *a = (<span class="type">uint16_t</span>*)aa;</span><br><span class="line">    <span class="type">uint16_t</span> *b = (<span class="type">uint16_t</span>*)bb;</span><br><span class="line">    <span class="type">uint16_t</span> *c = (<span class="type">uint16_t</span>*)cc;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(</span></span><br><span class="line"><span class="params">        <span class="string">&quot;ld4 &#123;v0.8h, v1.8h, v2.8h, v3.8h&#125;, [%0]     \n\t&quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;ld4 &#123;v8.8h, v9.8h, v10.8h, v11.8h&#125;, [%1]   \n\t&quot;</span></span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">        <span class="string">&quot;mul v0.8h, v0.8h, v8.8h                    \n\t&quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;mul v1.8h, v1.8h, v9.8h                    \n\t&quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;mul v2.8h, v2.8h, v10.8h                   \n\t&quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;mul v3.8h, v3.8h, v11.8h                   \n\t&quot;</span></span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">        <span class="string">&quot;st4 &#123;v0.8h, v1.8h, v2.8h, v3.8h&#125;, [%2]     \n\t&quot;</span></span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">        <span class="string">&quot;add x1, %0, #64                            \n\t&quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;add x2, %1, #64                            \n\t&quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;add x3, %2, #64                            \n\t&quot;</span></span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">        <span class="comment">//&quot;ld4 &#123;v4.8h-v7.8h&#125;, [x1]                    \n\t&quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;ld4 &#123;v4.8h, v5.8h, v6.8h, v7.8h&#125;, [x1]     \n\t&quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;ld4 &#123;v12.8h, v13.8h, v14.8h, v15.8h&#125;, [x2] \n\t&quot;</span></span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">        <span class="string">&quot;mul v4.8h, v4.8h, v12.8h                   \n\t&quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;mul v5.8h, v5.8h, v13.8h                   \n\t&quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;mul v6.8h, v6.8h, v14.8h                   \n\t&quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;mul v7.8h, v7.8h, v15.8h                   \n\t&quot;</span></span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">        <span class="string">&quot;st4 &#123;v4.8h, v5.8h, v6.8h, v7.8h&#125;, [x3]     \n\t&quot;</span></span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">        : <span class="string">&quot;+r&quot;</span>(a),   <span class="comment">//%0</span></span></span><br><span class="line"><span class="params">          <span class="string">&quot;+r&quot;</span>(b),   <span class="comment">//%1</span></span></span><br><span class="line"><span class="params">          <span class="string">&quot;+r&quot;</span>(c)    <span class="comment">//%2</span></span></span><br><span class="line"><span class="params">        :</span></span><br><span class="line"><span class="params">        : <span class="string">&quot;cc&quot;</span>, <span class="string">&quot;memory&quot;</span>, <span class="string">&quot;x1&quot;</span>, <span class="string">&quot;x2&quot;</span>, <span class="string">&quot;x3&quot;</span>, <span class="string">&quot;v0&quot;</span>, <span class="string">&quot;v1&quot;</span>, <span class="string">&quot;v2&quot;</span>, <span class="string">&quot;v3&quot;</span>, <span class="string">&quot;v4&quot;</span>, <span class="string">&quot;v5&quot;</span>, <span class="string">&quot;v6&quot;</span>, <span class="string">&quot;v7&quot;</span>,</span></span><br><span class="line"><span class="params">            <span class="string">&quot;v8&quot;</span>, <span class="string">&quot;v9&quot;</span>, <span class="string">&quot;v10&quot;</span>, <span class="string">&quot;v11&quot;</span>, <span class="string">&quot;v12&quot;</span>, <span class="string">&quot;v13&quot;</span>, <span class="string">&quot;v14&quot;</span>, <span class="string">&quot;v15&quot;</span></span></span><br><span class="line"><span class="params">      )</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>内嵌汇编实现方式<code>8x8</code></p>
</blockquote>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cudWlvLm5vL3N0dWRpZXIvZW1uZXIvbWF0bmF0L2lmaS9JTkY1MDYzL2gxNi9wZW5zdW1saXN0ZS9hcm12OC1uZW9uLXByb2dyYW1taW5nLnBkZg==">ARMv8 Neon Programming<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL2luZm9jZW50ZXIuYXJtLmNvbS9oZWxwL3RvcGljL2NvbS5hcm0uZG9jLmRodDAwMDJhL0RIVDAwMDJBX2ludHJvZHVjaW5nX25lb24ucGRm">Introducing NEON<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9jb21tdW5pdHkuYXJtLmNvbS9wcm9jZXNzb3JzL2IvYmxvZy9wb3N0cy9jb2RpbmctZm9yLW5lb24tLS1wYXJ0LTEtbG9hZC1hbmQtc3RvcmVz">Coding for NEON - Part 1: Load and Stores<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9jb21tdW5pdHkuYXJtLmNvbS9wcm9jZXNzb3JzL2IvYmxvZy9wb3N0cy9jb2RpbmctZm9yLW5lb24tLS1wYXJ0LTItZGVhbGluZy13aXRoLWxlZnRvdmVycw==">Coding for NEON - Part 2: Dealing With Leftovers<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9jb21tdW5pdHkuYXJtLmNvbS9wcm9jZXNzb3JzL2IvYmxvZy9wb3N0cy9jb2RpbmctZm9yLW5lb24tLS1wYXJ0LTMtbWF0cml4LW11bHRpcGxpY2F0aW9u">Coding for NEON - Part 3: Matrix Multiplication<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9jb21tdW5pdHkuYXJtLmNvbS9wcm9jZXNzb3JzL2IvYmxvZy9wb3N0cy9jb2RpbmctZm9yLW5lb24tLS1wYXJ0LTQtc2hpZnRpbmctbGVmdC1hbmQtcmlnaHQ=">Coding for NEON - Part 4: Shifting Left and Right<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9jb21tdW5pdHkuYXJtLmNvbS9wcm9jZXNzb3JzL2IvYmxvZy9wb3N0cy9jb2RpbmctZm9yLW5lb24tLS1wYXJ0LTUtcmVhcnJhbmdpbmctdmVjdG9ycw==">Coding for NEON - Part 5: Rearranging Vectors<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL2luZm9jZW50ZXIuYXJtLmNvbS9oZWxwL3RvcGljL2NvbS5hcm0uZG9jLjEwMDA5NV8wMDAzXzA2X2VuL2NvcnRleF9hNzJfbXBjb3JlX3RybV8xMDAwOTVfMDAwM18wNl9lbi5wZGY=">ARM® Cortex®-A72 MPCore Processor Technical Reference Manual<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>ARM</category>
        <category>simd</category>
      </categories>
      <tags>
        <tag>arm</tag>
        <tag>simd</tag>
      </tags>
  </entry>
  <entry>
    <title>ARM64基本的汇编语法</title>
    <url>/post/5543.html</url>
    <content><![CDATA[<p>记录常用到的arm64汇编语法，参考<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2xpYmpwZWctdHVyYm8vbGlianBlZy10dXJiby9ibG9iL21hc3Rlci9zaW1kL2FybTY0L2pzaW1kX25lb24uUw==">libjpeg-turbo<i class="fa fa-external-link-alt"></i></span></p>
<span id="more"></span>

<h2 id="常见语法"><a href="#常见语法" class="headerlink" title="常见语法"></a>常见语法</h2><table>
<thead>
<tr>
<th align="center">语法</th>
<th align="left">说明</th>
<th align="left">备注&#x2F;示例</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>.req</code></td>
<td align="left">寄存器重命名</td>
<td align="left">DATA .req x0： DATA是寄存器x0的别名</td>
</tr>
<tr>
<td align="center"><code>.unreq</code></td>
<td align="left">取消重命名定义</td>
<td align="left">.unreq DATA</td>
</tr>
<tr>
<td align="center"><code>.balign</code></td>
<td align="left">字节对其</td>
<td align="left">.balign 16 ：十六字节对其</td>
</tr>
<tr>
<td align="center"><code>b</code></td>
<td align="left">跳转到标号处执行</td>
<td align="left">b   40 &lt;main+0x40&gt;</td>
</tr>
<tr>
<td align="center"><code>cmp</code></td>
<td align="left">比较</td>
<td align="left">cmp w0, #0x6e， 不会改变两个寄存器的值即两个寄存器不会变化，但是其结果会影响cpsr状态寄存器的标记值（nzcv）</td>
</tr>
<tr>
<td align="center"><code>b.le</code></td>
<td align="left">小于等于（less than or equal to），执行标号，否则不跳转</td>
<td align="left">b.le    24 &lt;main+0x24&gt;</td>
</tr>
<tr>
<td align="center"><code>b.ge</code></td>
<td align="left">大于等于（great than or equal to），执行标号，否则不跳转</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><code>b.gt</code></td>
<td align="left">大于（greater than），执行标号，否则不跳转</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><code>b.lt</code></td>
<td align="left">小于（less than），执行标号，否则不跳转</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><code>b.eq</code></td>
<td align="left">等于（equal to），执行标号，否则不跳转</td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><code>b.hi</code></td>
<td align="left">无符号大于，执行标号，否则不跳转</td>
<td align="left"></td>
</tr>
</tbody></table>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><span class="exturl" data-url="aHR0cDovL3NvdXJjZXdhcmUub3JnL2JpbnV0aWxzL2RvY3MvYXMv">GNU AS汇编器官方文档<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>ARM</category>
        <category>汇编</category>
      </categories>
      <tags>
        <tag>arm</tag>
      </tags>
  </entry>
  <entry>
    <title>ARM--GCC内嵌汇编</title>
    <url>/post/4526.html</url>
    <content><![CDATA[<p>记录ARM平台中相关的汇编操作和总结</p>
<span id="more"></span>

<h2 id="空指令–nop"><a href="#空指令–nop" class="headerlink" title="空指令–nop"></a>空指令–nop</h2><p>NOP指令<code>不产生任何意义的操作</code>,只占用一个机器周期,可以用于简单的延时操作</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">asm</span>(<span class="string">&quot;nop&quot;</span>);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在C代码中可以通过前后使用<code>nop</code>定位反汇编后代码所在的位置.</p>
</blockquote>
<p>实际编程的用途:</p>
<ol>
<li>需要短暂延时</li>
<li>需要精确控制延时,如控制驱动器步进电机的延时</li>
<li>通过在写NOP指令处填写相应代码实现分支跳转或分支调用???</li>
<li>解密时用???</li>
<li>在控制系统中插入NOP指令防止系统飞程???</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2VyYXp5MC9hcnRpY2xlL2RldGFpbHMvNjA3MTI4MQ==">NOP 指令作用<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>ARM</category>
        <category>汇编</category>
      </categories>
      <tags>
        <tag>汇编</tag>
        <tag>arm</tag>
      </tags>
  </entry>
  <entry>
    <title>ARM处理器寄存器和汇编指令</title>
    <url>/post/25025.html</url>
    <content><![CDATA[<p>ARM体系结构支持<code>7种</code>处理器模式，分别是：<code>用户</code>、<code>FIQ </code>、<code>IRQ</code>、<code>管理</code>、<code>中止（abort）</code>、<code>未定义</code>和<code>系统</code>模式。除了用户模式外，其余都称之为特权模式。除了用户和系统模式外，其余都称之为异常模式</p>
<span id="more"></span>

<h2 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h2><p>ARM的寄存器分为两类, <code>普通寄存器</code>和<code>状态寄存器</code></p>
<p>普通寄存器总共16个，分别为R0-R15；状态寄存器共2个，分别为<code>CPSR</code>和<code>SPSR</code></p>
<table>
<thead>
<tr>
<th align="center">寄存器(Reg)</th>
<th align="center">寄存器(APCS)</th>
<th align="left">作用域</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">R0</td>
<td align="center">a1</td>
<td align="left">所有7种模式</td>
<td align="left">工作寄存器</td>
</tr>
<tr>
<td align="center">R1</td>
<td align="center">a2</td>
<td align="left">所有7种模式</td>
<td align="left">..</td>
</tr>
<tr>
<td align="center">R2</td>
<td align="center">a3</td>
<td align="left">所有7种模式</td>
<td align="left">..</td>
</tr>
<tr>
<td align="center">R3</td>
<td align="center">a4</td>
<td align="left">所有7种模式</td>
<td align="left">..</td>
</tr>
<tr>
<td align="center">R4</td>
<td align="center">v1</td>
<td align="left">所有7种模式</td>
<td align="left">必须保护</td>
</tr>
<tr>
<td align="center">R5</td>
<td align="center">v2</td>
<td align="left">所有7种模式</td>
<td align="left">..</td>
</tr>
<tr>
<td align="center">R6</td>
<td align="center">v3</td>
<td align="left">所有7种模式</td>
<td align="left">..</td>
</tr>
<tr>
<td align="center">R7</td>
<td align="center">v4</td>
<td align="left">所有7种模式</td>
<td align="left">..</td>
</tr>
<tr>
<td align="center">R8</td>
<td align="center">v5</td>
<td align="left">除FIQ模式</td>
<td align="left">..</td>
</tr>
<tr>
<td align="center">R9</td>
<td align="center">v6</td>
<td align="left">除FIQ模式</td>
<td align="left">..</td>
</tr>
<tr>
<td align="center">R10</td>
<td align="center">sl</td>
<td align="left">除FIQ模式</td>
<td align="left">栈限制</td>
</tr>
<tr>
<td align="center">R11</td>
<td align="center">fp</td>
<td align="left">除FIQ模式</td>
<td align="left">帧指针</td>
</tr>
<tr>
<td align="center">R12</td>
<td align="center">ip</td>
<td align="left">除FIQ模式</td>
<td align="left">内部过程调用寄存器</td>
</tr>
<tr>
<td align="center">R13</td>
<td align="center">sp</td>
<td align="left">用户和系统模式</td>
<td align="left">栈指针</td>
</tr>
<tr>
<td align="center">R14</td>
<td align="center">lr</td>
<td align="left">用户和系统模式</td>
<td align="left">连接寄存器</td>
</tr>
<tr>
<td align="center">R15</td>
<td align="center">pc</td>
<td align="left">所有7种模式</td>
<td align="left">程序计数器</td>
</tr>
<tr>
<td align="center">CPSR</td>
<td align="center">-</td>
<td align="left">-</td>
<td align="left"></td>
</tr>
<tr>
<td align="center">SPSR</td>
<td align="center">-</td>
<td align="left">除用户和系统模式</td>
<td align="left">-</td>
</tr>
</tbody></table>
<ul>
<li><code>R13(sp)</code>: 每一种异常模式都有其自己独立的r13，它通常指向异常模式所专用的堆栈，也就是说五种异常模式、非异常模式（用户模式和系统模式），都有各自独立的堆栈，用不同的堆栈指针来索引。这样当ARM进入异常模式的时候，程序就可以把一般通用寄存器压入堆栈，返回时再出栈，保证了各种模式下程序的状态的完整性。</li>
<li><code>R14(lr)</code>: 每种模式下r14都有自身版组，它有两个特殊功能。<ul>
<li>保存子程序返回地址。使用BL或BLX时，跳转指令自动把返回地址放入r14中；子程序通过把r14复制到PC来实现返回，通常用下列指令之一：</li>
<li>当异常发生时，异常模式的r14用来保存异常返回地址，将r14如栈可以处理嵌套中断。</li>
</ul>
</li>
</ul>
<h3 id="PS"><a href="#PS" class="headerlink" title="PS"></a>PS</h3><p>ARM处理器中通常将寄存器R13作为堆栈指针（SP）。ARM处理器针对不同的模式，共有<strong>6个堆栈指针SP</strong>, 其中用户模式和系统模式共用一个SP，每种异常模式都有各自专用的R13寄存器（SP）。它们通常指向各模式所对应的专用堆栈，也就是ARM处理器允许用户程序有六个不同的堆栈空间。这些堆栈指针分别为R13、R13_svc、R13_abt、R13_und、R13_irq、R13_fiq.</p>
<p><img data-src="/images/2018/12/arm_asm_reg_sp.png" alt="arm_asm_reg_sp"></p>
<h2 id="汇编指令"><a href="#汇编指令" class="headerlink" title="汇编指令"></a>汇编指令</h2><h3 id="存储器访问指令"><a href="#存储器访问指令" class="headerlink" title="存储器访问指令"></a>存储器访问指令</h3><p>ARM 处理是加载&#x2F;存储体系结构的典型的RISC处理器，对存储器的访问只能使用<code>加载</code>和<code>存储</code>指令实现。ARM 的加载&#x2F;存储指令是可以实现字、半字、无符&#x2F;有符字节操作；批量加载&#x2F;存储指令可实现一条指令加载&#x2F;存储多个寄存器的内容，大大提高效率；SWP指令是一条寄存器和存储器内容交换的指令，可用于信号量操作等。</p>
<h4 id="LDR和STR"><a href="#LDR和STR" class="headerlink" title="LDR和STR"></a>LDR和STR</h4><p>加载&#x2F;存储字和无符号字节指令。使用单一数据传送指令(STR 和LDR)来装载和存储单一字节或字的数据从&#x2F;到内存。</p>
<ul>
<li><code>LDR</code> 指令用于从内存中读取数据放入寄存器中；</li>
<li><code>STR</code> 指令用于将寄存器中的数据保存到内存。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LDR&#123;cond&#125;&#123;T&#125; Rd,&lt;地址&gt;    ;加载指定地址上的数据(字)，放入Rd中</span><br><span class="line">STR&#123;cond&#125;&#123;T&#125; Rd,&lt;地址&gt;    ;存储数据(字)到指定地址的存储单元，要存储的数据在Rd中</span><br><span class="line">LDR&#123;cond&#125;B&#123;T&#125; Rd,&lt;地址&gt;   ;加载字节数据，放入Rd中，即Rd最低字节有效，高24位清零</span><br><span class="line">STR&#123;cond&#125;B&#123;T&#125; Rd,&lt;地址&gt;   ;存储字节数据，要存储的数据在Rd，最低字节有效</span><br></pre></td></tr></table></figure>
<blockquote>
<p>其中，T 为可选后缀，若指令有T，那么即使处理器是在特权模式下，存储系统也将访问看成是处理器是在用户模式下。T在用户模式下无效，不能与前索引偏移一起使用T</p>
</blockquote>
<ul>
<li>立即数<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LDR R1,[R0,#0x12]   ;将R0+0x12 地址处的数据读出，保存到R1中(R0 的值不变)</span><br><span class="line">LDR R1,[R0,#-0x12]  ;将R0-0x12 地址处的数据读出，保存到R1中(R0 的值不变)</span><br><span class="line">LDR R1,[R0]         ;将R0 地址处的数据读出，保存到R1 中(零偏移)</span><br></pre></td></tr></table></figure></li>
<li>寄存器<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LDR R1,[R0,R2]      ;将R0+R2 地址的数据计读出，保存到R1中(R0 的值不变)</span><br><span class="line">LDR R1,[R0,-R2]     ;将R0-R2 地址处的数据计读出，保存到R1中(R0 的值不变)</span><br></pre></td></tr></table></figure></li>
<li>寄存器及移位常数<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LDR R1,[R0,R2,LSL #2]   ;将R0+R2*4地址处的数据读出，保存到R1中（R0，R2的值不变）</span><br><span class="line">LDR R1,[R0,-R2,LSL #2]  ;将R0-R2*4地址处的数据计读出，保存到R1中(R0，R2的值不变)</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="数据处理指令"><a href="#数据处理指令" class="headerlink" title="数据处理指令"></a>数据处理指令</h3><h3 id="跳转指令"><a href="#跳转指令" class="headerlink" title="跳转指令"></a>跳转指令</h3><h3 id="状态寄存器指令"><a href="#状态寄存器指令" class="headerlink" title="状态寄存器指令"></a>状态寄存器指令</h3><h3 id="ARM协处理器指令"><a href="#ARM协处理器指令" class="headerlink" title="ARM协处理器指令"></a>ARM协处理器指令</h3><h2 id="示例分析"><a href="#示例分析" class="headerlink" title="示例分析"></a>示例分析</h2><h3 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> b, c;</span><br><span class="line"></span><br><span class="line">    b = <span class="number">3</span>;</span><br><span class="line">    c = a + b;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello c=%d!\n&quot;</span>, c);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">arm-linux-gnueabihf-gcc hello.c -o hello --save-temp</span><br></pre></td></tr></table></figure>
<h3 id="汇编代码"><a href="#汇编代码" class="headerlink" title="汇编代码"></a>汇编代码</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.arch armv7-a</span><br><span class="line">.eabi_attribute 28, 1</span><br><span class="line">.eabi_attribute 20, 1</span><br><span class="line">.eabi_attribute 21, 1</span><br><span class="line">.eabi_attribute 23, 3</span><br><span class="line">.eabi_attribute 24, 1</span><br><span class="line">.eabi_attribute 25, 1</span><br><span class="line">.eabi_attribute 26, 2</span><br><span class="line">.eabi_attribute 30, 6</span><br><span class="line">.eabi_attribute 34, 1</span><br><span class="line">.eabi_attribute 18, 4</span><br><span class="line">.file	&quot;hello.c&quot;</span><br><span class="line">.text</span><br><span class="line">.section	.rodata</span><br><span class="line">.align	2</span><br><span class="line">.LC0:</span><br><span class="line">.ascii	&quot;Hello c=%d!\012\000&quot;</span><br><span class="line">.text</span><br><span class="line">.align	1</span><br><span class="line">.global	main</span><br><span class="line">.syntax unified</span><br><span class="line">.thumb</span><br><span class="line">.thumb_func</span><br><span class="line">.fpu vfpv3-d16</span><br><span class="line">.type	main, %function</span><br><span class="line">main:</span><br><span class="line">@ args = 0, pretend = 0, frame = 24</span><br><span class="line">@ frame_needed = 1, uses_anonymous_args = 0</span><br><span class="line">push	&#123;r7, lr&#125;</span><br><span class="line">sub	sp, sp, #24</span><br><span class="line">add	r7, sp, #0</span><br><span class="line">str	r0, [r7, #4]</span><br><span class="line">str	r1, [r7]</span><br><span class="line">movs	r3, #1</span><br><span class="line">str	r3, [r7, #20]</span><br><span class="line">movs	r3, #3</span><br><span class="line">str	r3, [r7, #16]</span><br><span class="line">ldr	r2, [r7, #20]</span><br><span class="line">ldr	r3, [r7, #16]</span><br><span class="line">add	r3, r3, r2</span><br><span class="line">str	r3, [r7, #12]</span><br><span class="line">ldr	r1, [r7, #12]</span><br><span class="line">movw	r0, #:lower16:.LC0</span><br><span class="line">movt	r0, #:upper16:.LC0</span><br><span class="line">bl	printf</span><br><span class="line">movs	r3, #0</span><br><span class="line">mov	r0, r3</span><br><span class="line">adds	r7, r7, #24</span><br><span class="line">mov	sp, r7</span><br><span class="line">@ sp needed</span><br><span class="line">pop	&#123;r7, pc&#125;</span><br><span class="line">.size	main, .-main</span><br><span class="line">.ident	&quot;GCC: (Linaro GCC 7.3-2018.05) 7.3.1 20180425 [linaro-7.3-2018.05 revision d29120a424ecfbc167ef90065c0eeb7f91977701]&quot;</span><br><span class="line">.section	.note.GNU-stack,&quot;&quot;,%progbits</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>@</code>: 单行注释</p>
</blockquote>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vdWVzdGNidXRjaGVyL3AvNzI0NDc5OS5odG1s">ARM指令集详解<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTM3MzY3MjQvYXJ0aWNsZS9kZXRhaWxzLzUzMjAwNTM5">ARM汇编语言学习笔记（一）—ARM汇编的程序结构<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>ARM</category>
        <category>汇编</category>
      </categories>
      <tags>
        <tag>arm</tag>
        <tag>寄存器</tag>
      </tags>
  </entry>
  <entry>
    <title>GBM for EGL (Linux)</title>
    <url>/post/62365.html</url>
    <content><![CDATA[<blockquote>
<p>Mesa GBM (<code>Generic Buffer Manager</code>) basically provides a EGL native window type (just like Wayland and X11), so one could obtain a real EGL surface and create render target buffers. With that then, GL can be used to render into these buffers, which will be shown to the display by queuing a page flip via KMS&#x2F;DRM API.</p>
</blockquote>
<p>用户应用程序直接对内存进行管理，通过EGL可以获取真实的EGL表面并创建渲染目标缓冲区</p>
<p><code>gbm</code>（通用缓冲区管理），它提供了一种为Mesa绑定的图形渲染分配缓冲区的机制。GBM旨在被当做一个本地平台为了工作在DRM上的EGL或者openwfd。它创建的句柄可用于初始化EGL和创建渲染目标缓冲区。</p>
<span id="more"></span>

<h2 id="MESA-platform-gbm"><a href="#MESA-platform-gbm" class="headerlink" title="MESA_platform_gbm"></a>MESA_platform_gbm</h2><blockquote>
<p>This extension defines how to create EGL resources from native GBM resources using the functions defined by EGL_EXT_platform_base. (GBM is a <code>Generic Buffer Manager</code> for Linux).</p>
</blockquote>
<h2 id="离屏渲染–简单示例"><a href="#离屏渲染–简单示例" class="headerlink" title="离屏渲染–简单示例"></a>离屏渲染–简单示例</h2><blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2VsaW1hL2dwdS1wbGF5Z3JvdW5kL3RyZWUvbWFzdGVyL3JlbmRlci1ub2Rlcy1taW5pbWFs">https://github.com/elima/gpu-playground/tree/master/render-nodes-minimal<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;EGL/egl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;EGL/eglext.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GLES3/gl31.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;gbm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* a dummy compute shader that does nothing */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COMPUTE_SHADER_SRC <span class="string">&quot;          \</span></span></span><br><span class="line"><span class="string"><span class="meta">#version 310 es\n                                                       \</span></span></span><br><span class="line"><span class="string"><span class="meta">                                                                        \</span></span></span><br><span class="line"><span class="string"><span class="meta">layout (local_size_x = 1, local_size_y = 1, local_size_z = 1) in;       \</span></span></span><br><span class="line"><span class="string"><span class="meta">                                                                        \</span></span></span><br><span class="line"><span class="string"><span class="meta">void main(void) &#123;                                                       \</span></span></span><br><span class="line"><span class="string"><span class="meta">   /* awesome compute code here */                                      \</span></span></span><br><span class="line"><span class="string"><span class="meta">&#125;                                                                       \</span></span></span><br><span class="line"><span class="string"><span class="meta">&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int32_t</span></span><br><span class="line"><span class="title function_">main</span> <span class="params">(<span class="type">int32_t</span> argc, <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">bool</span> res;</span><br><span class="line"></span><br><span class="line">   <span class="type">int32_t</span> fd = open (<span class="string">&quot;/dev/dri/renderD128&quot;</span>, O_RDWR);</span><br><span class="line">   assert (fd &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">gbm_device</span> *<span class="title">gbm</span> =</span> gbm_create_device (fd);</span><br><span class="line">   assert (gbm != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* setup EGL from the GBM device */</span></span><br><span class="line">   EGLDisplay egl_dpy = eglGetPlatformDisplay (EGL_PLATFORM_GBM_MESA, gbm, <span class="literal">NULL</span>);</span><br><span class="line">   assert (egl_dpy != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">   res = eglInitialize (egl_dpy, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">   assert (res);</span><br><span class="line"></span><br><span class="line">   <span class="type">const</span> <span class="type">char</span> *egl_extension_st = eglQueryString (egl_dpy, EGL_EXTENSIONS);</span><br><span class="line">   assert (<span class="built_in">strstr</span> (egl_extension_st, <span class="string">&quot;EGL_KHR_create_context&quot;</span>) != <span class="literal">NULL</span>);</span><br><span class="line">   assert (<span class="built_in">strstr</span> (egl_extension_st, <span class="string">&quot;EGL_KHR_surfaceless_context&quot;</span>) != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">   <span class="type">static</span> <span class="type">const</span> EGLint config_attribs[] = &#123;</span><br><span class="line">      EGL_RENDERABLE_TYPE, EGL_OPENGL_ES3_BIT_KHR,</span><br><span class="line">      EGL_NONE</span><br><span class="line">   &#125;;</span><br><span class="line">   EGLConfig cfg;</span><br><span class="line">   EGLint count;</span><br><span class="line"></span><br><span class="line">   res = eglChooseConfig (egl_dpy, config_attribs, &amp;cfg, <span class="number">1</span>, &amp;count);</span><br><span class="line">   assert (res);</span><br><span class="line"></span><br><span class="line">   res = eglBindAPI (EGL_OPENGL_ES_API);</span><br><span class="line">   assert (res);</span><br><span class="line"></span><br><span class="line">   <span class="type">static</span> <span class="type">const</span> EGLint attribs[] = &#123;</span><br><span class="line">      EGL_CONTEXT_CLIENT_VERSION, <span class="number">3</span>,</span><br><span class="line">      EGL_NONE</span><br><span class="line">   &#125;;</span><br><span class="line">   EGLContext core_ctx = eglCreateContext (egl_dpy,</span><br><span class="line">                                           cfg,</span><br><span class="line">                                           EGL_NO_CONTEXT,</span><br><span class="line">                                           attribs);</span><br><span class="line">   assert (core_ctx != EGL_NO_CONTEXT);</span><br><span class="line"></span><br><span class="line">   res = eglMakeCurrent (egl_dpy, EGL_NO_SURFACE, EGL_NO_SURFACE, core_ctx);</span><br><span class="line">   assert (res);</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* print some compute limits (not strictly necessary) */</span></span><br><span class="line">   GLint work_group_count[<span class="number">3</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">unsigned</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">      glGetIntegeri_v (GL_MAX_COMPUTE_WORK_GROUP_COUNT,</span><br><span class="line">                       i,</span><br><span class="line">                       &amp;work_group_count[i]);</span><br><span class="line">   <span class="built_in">printf</span> (<span class="string">&quot;GL_MAX_COMPUTE_WORK_GROUP_COUNT: %d, %d, %d\n&quot;</span>,</span><br><span class="line">           work_group_count[<span class="number">0</span>],</span><br><span class="line">           work_group_count[<span class="number">1</span>],</span><br><span class="line">           work_group_count[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">   GLint work_group_size[<span class="number">3</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">unsigned</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">      glGetIntegeri_v (GL_MAX_COMPUTE_WORK_GROUP_SIZE, i, &amp;work_group_size[i]);</span><br><span class="line">   <span class="built_in">printf</span> (<span class="string">&quot;GL_MAX_COMPUTE_WORK_GROUP_SIZE: %d, %d, %d\n&quot;</span>,</span><br><span class="line">           work_group_size[<span class="number">0</span>],</span><br><span class="line">           work_group_size[<span class="number">1</span>],</span><br><span class="line">           work_group_size[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">   GLint max_invocations;</span><br><span class="line">   glGetIntegerv (GL_MAX_COMPUTE_WORK_GROUP_INVOCATIONS, &amp;max_invocations);</span><br><span class="line">   <span class="built_in">printf</span> (<span class="string">&quot;GL_MAX_COMPUTE_WORK_GROUP_INVOCATIONS: %d\n&quot;</span>, max_invocations);</span><br><span class="line"></span><br><span class="line">   GLint mem_size;</span><br><span class="line">   glGetIntegerv (GL_MAX_COMPUTE_SHARED_MEMORY_SIZE, &amp;mem_size);</span><br><span class="line">   <span class="built_in">printf</span> (<span class="string">&quot;GL_MAX_COMPUTE_SHARED_MEMORY_SIZE: %d\n&quot;</span>, mem_size);</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* setup a compute shader */</span></span><br><span class="line">   GLuint compute_shader = glCreateShader (GL_COMPUTE_SHADER);</span><br><span class="line"></span><br><span class="line">   assert (glGetError () == GL_NO_ERROR);</span><br><span class="line">   <span class="type">const</span> <span class="type">char</span> *shader_source = COMPUTE_SHADER_SRC;</span><br><span class="line"></span><br><span class="line">   glShaderSource (compute_shader, <span class="number">1</span>, &amp;shader_source, <span class="literal">NULL</span>);</span><br><span class="line">   assert (glGetError () == GL_NO_ERROR);</span><br><span class="line"></span><br><span class="line">   glCompileShader (compute_shader);</span><br><span class="line">   assert (glGetError () == GL_NO_ERROR);</span><br><span class="line"></span><br><span class="line">   GLuint shader_program = glCreateProgram ();</span><br><span class="line"></span><br><span class="line">   glAttachShader (shader_program, compute_shader);</span><br><span class="line">   assert (glGetError () == GL_NO_ERROR);</span><br><span class="line"></span><br><span class="line">   glLinkProgram (shader_program);</span><br><span class="line">   assert (glGetError () == GL_NO_ERROR);</span><br><span class="line"></span><br><span class="line">   glDeleteShader (compute_shader);</span><br><span class="line"></span><br><span class="line">   glUseProgram (shader_program);</span><br><span class="line">   assert (glGetError () == GL_NO_ERROR);</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* dispatch computation */</span></span><br><span class="line">   glDispatchCompute (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">   assert (glGetError () == GL_NO_ERROR);</span><br><span class="line"></span><br><span class="line">   <span class="built_in">printf</span> (<span class="string">&quot;Compute shader dispatched and finished successfully\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* free stuff */</span></span><br><span class="line">   glDeleteProgram (shader_program);</span><br><span class="line">   eglDestroyContext (egl_dpy, core_ctx);</span><br><span class="line">   eglTerminate (egl_dpy);</span><br><span class="line">   gbm_device_destroy (gbm);</span><br><span class="line">   close (fd);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gcc main.c `pkg-config --libs --cflags egl gbm gl`</span><br></pre></td></tr></table></figure>

<p>主要分4部分：</p>
<ul>
<li>从渲染节点创建GBM设备</li>
<li>设置（无表面的）EGL &#x2F; OpenGL-ES上下文</li>
<li>创建一个计算着色器程序</li>
<li>调度计算着色器</li>
</ul>
<h2 id="GBM-EGL-OPENGL-render"><a href="#GBM-EGL-OPENGL-render" class="headerlink" title="GBM+EGL+OPENGL+render"></a>GBM+EGL+OPENGL+render</h2><p>利用GBM进行图像的离屏渲染</p>
<blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL1dpbmRkb2luZy9Db2RlV2hlZWwvbWFzdGVyL2VnbC9lZ2xfZ2JtX3JlbmRlci5j">https://raw.githubusercontent.com/Winddoing/CodeWheel/master/egl/egl_gbm_render.c<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cua2hyb25vcy5vcmcvcmVnaXN0cnkvRUdML2V4dGVuc2lvbnMvTUVTQS9FR0xfTUVTQV9wbGF0Zm9ybV9nYm0udHh0">MESA_platform_gbm<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2V5ZWxhc2gvdHV0b3JpYWxzL2Jsb2IvbWFzdGVyL2RybS1nYm0uYw==">drm gbm demo<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMjA4MTY4NDQvZWdsZGlzcGxheS1vbi1nYm0=">EGLDisplay on GBM<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9ncy5pZ2FsaWEuY29tL2VsaW1hLzIwMTYvMTAvMDYvZXhhbXBsZS1ydW4tYW4tb3BlbmdsLWVzLWNvbXB1dGUtc2hhZGVyLW9uLWEtZHJtLXJlbmRlci1ub2RlLw==">Example: Run a headless OpenGL (ES) compute shader via DRM render-nodes<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>多媒体</category>
        <category>EGL</category>
      </categories>
      <tags>
        <tag>gbm</tag>
        <tag>egl</tag>
      </tags>
  </entry>
  <entry>
    <title> H264码流格式</title>
    <url>/post/35564.html</url>
    <content><![CDATA[<p>H264的两种码流格式，它们分别为：<code>字节流格式</code>和<code>RTP包格式</code>。</p>
<ul>
<li><code>字节流格式</code>: 默认的输出格式。它的基本数据单位为NAL单元，也即NALU。为了从字节流中提取出NALU，协议规定，在每个NALU的前面加上起始码：0x000001或0x00000001（0x代表十六进制）</li>
<li>RTP包格式: 一种数据传输格式,主要用于网络传送</li>
</ul>
<blockquote>
<p>字节流格式,由于它没有经过传输协议封装，所以也可以称之为<code>裸流</code></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">H264比特流 = Start_Code_Prefix + NALU + Start_Code_Prefix + NALU + ...</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p><img data-src="/images/2019/02/h264_struct.png" alt="H264_struct"></p>
<h2 id="起始码与NALU"><a href="#起始码与NALU" class="headerlink" title="起始码与NALU"></a>起始码与NALU</h2><blockquote>
<p>起始码（Start_Code_Prefix）: <code>0x00 00 01</code>或<code>0x00 00 00 01</code></p>
</blockquote>
<p>在两个起始码之间的数据，称为<code>NALU</code></p>
<h2 id="NALU"><a href="#NALU" class="headerlink" title="NALU"></a>NALU</h2><blockquote>
<p>NAL Unit: Network Abstract Layer Unit</p>
</blockquote>
<p>每个NAL单元包括一个原始字节序列负荷(RBSP, Raw Byte Sequence Payload)、一组对应于视频编码的NAL头信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NALU = NALU Header + RBSP</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li><code>SODB</code>:最原始的编码数据，无任何附加数据。<ul>
<li><code>S</code>tring <code>O</code>f <code>D</code>ata <code>B</code>its</li>
</ul>
</li>
<li><code>RBSP</code>:在SODB的基础上增加了rbsp_stop_ont_bit(bit值为1)并用0按字节补位对齐。<ul>
<li>A NALU contains a <code>R</code>aw <code>B</code>yte <code>S</code>equence <code>P</code>ayload, a sequence of bytes containing syntax elements.</li>
</ul>
</li>
<li><code>EBSP</code>:(Encapsulation Byte Sequence Packets)在RBSP的基础上增加了防止伪起始码字节(0x03)。</li>
</ul>
</blockquote>
<h3 id="NALU-Header"><a href="#NALU-Header" class="headerlink" title="NALU Header"></a>NALU Header</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NAL Header： forbidden_bit， nal_reference_bit（优先级）， nal_unit_type（类型）</span><br><span class="line">                  1bit            2bit                        5bit</span><br></pre></td></tr></table></figure>

<h2 id="SPS-Seq-Parameter-Set-–-序列参数集"><a href="#SPS-Seq-Parameter-Set-–-序列参数集" class="headerlink" title="SPS(Seq_Parameter_Set) – 序列参数集"></a>SPS(Seq_Parameter_Set) – 序列参数集</h2><blockquote>
<p>H.264码流<code>第一个</code>NALU是<code>SPS</code></p>
</blockquote>
<p>nal_unit_type &#x3D; 7， 包含H.264的<code>profile_idc</code>和<code>level_idc</code>等信息.还有图像的宽高:<code>pic_width_in_mbs_minus1</code>、<code>pic_height_in_map_units_minus1</code></p>
<p>图像的宽和高，以宏块（16x16）为单位的值减1， 如果<code>pic_width_in_mbs_minus1 = 21</code>， 图像宽为（21+1）* 16 &#x3D; 352</p>
<p>SPS即Sequence Paramater Set，又称作序列参数集。SPS中保存了一组<code>编码视频序列(Coded video sequence)</code>的全局参数。所谓的编码视频序列即原始视频的一帧一帧的像素数据经过编码之后的结构组成的序列。而每一帧的编码后数据所依赖的参数保存于图像参数集中。</p>
<h2 id="PPS-Pic-Parameter-Set-–-图像参数集"><a href="#PPS-Pic-Parameter-Set-–-图像参数集" class="headerlink" title="PPS(Pic_Parameter_Set) – 图像参数集"></a>PPS(Pic_Parameter_Set) – 图像参数集</h2><blockquote>
<p>H.264码流<code>第二个</code>NALU是<code>PPS</code></p>
</blockquote>
<p>nal_unit_type &#x3D; 8</p>
<h2 id="Slice"><a href="#Slice" class="headerlink" title="Slice"></a>Slice</h2><p>一个视频图像可编码成一个或更多个条带，每个条带包含整数个宏块（MB），即每个条带至少一个MB，最多时每个条带包含整个图像的宏块。总之，一幅图像中每个条带的宏块数不一定固定。设条带的目的是为了限制误码的扩散和传输，应使编码条带相互间是独立的。某个条带的预测不能以其它条带中的宏块为参考图像，这样某一条带中的预测误差才不会传播到其它条带中去。</p>
<h2 id="Tile"><a href="#Tile" class="headerlink" title="Tile"></a>Tile</h2><h2 id="GOP"><a href="#GOP" class="headerlink" title="GOP"></a>GOP</h2><p>在视频编码序列中，<code>GOP</code>即Group of picture（图像组），指<code>两个I帧之间的距离</code>，<code>Reference</code>（参考周期）指<code>两个P帧之间的距离</code>。一个I帧所占用的字节数大于一个P帧，一个P帧所占用的字节数大于一个B帧。</p>
<p><img data-src="/images/2020/12/h264_gop.png" alt="H264_GOP"></p>
<blockquote>
<p>GOP说白了就是两个<code>I帧</code>之间的间隔.比较说GOP为120,如果是720p60的话,那就是2s一次I帧</p>
</blockquote>
<h2 id="视频渐近刷新"><a href="#视频渐近刷新" class="headerlink" title="视频渐近刷新"></a>视频渐近刷新</h2><p>视频渐近刷新<code>GDR</code>(Gradual decoder refresh)是相对一帧完整刷新而来。传统IDR(Instantaneous Decoding Refresh:即时解码刷新)刷新的缺点是IDR帧大小相比图像质量相近的P帧更大，这样会对网络有冲击，导致网络抖动和拥塞。而GDR会带来更优的网络适应性。<br><code>GDR</code>是通过<code>P帧</code>内包括<code>I帧块</code>组的方法来实现渐近刷新。</p>
<p><img data-src="/images/2020/11/h264_gdr.png" alt="h264 GDR"></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3doOF8yMDExL2FydGljbGUvZGV0YWlscy81MTE2MzM2OA==">H.264的Slice及Slice类型<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93aW5kZG9pbmcuY29kaW5nLm5ldC9wL2Jsb2cvZC9kb2NzL2dpdC9yYXcvbWFzdGVyL211bHRpbWVkaWEvSC4yNjQlRTUlQUUlOTglRTYlOTYlQjklRTQlQjglQUQlRTYlOTYlODclRTclODklODgucGRm">H.264官方中文版.pdf<i class="fa fa-external-link-alt"></i></span>–下载</li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vaHV4aWFvcGVuZy9wLzU2NTM4MTYuaHRtbA==">TI的H264 SOC方案<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW95aWRhMTEvYXJ0aWNsZS9kZXRhaWxzLzUyODUyMzk4">H264编码之GOP含义<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>多媒体</category>
        <category>H264</category>
      </categories>
      <tags>
        <tag>h264</tag>
      </tags>
  </entry>
  <entry>
    <title>H264编码—profile和level</title>
    <url>/post/e114a1a8.html</url>
    <content><![CDATA[<p>H.264有四种画质级别,分别是<code>baseline</code>, <code>extended</code>, <code>main</code>, <code>high</code>：</p>
<ul>
<li>baseline profile：基本画质。支持I&#x2F;P 帧，只支持无交错（Progressive）和CAVLC</li>
<li>extended profile：进阶画质。支持I&#x2F;P&#x2F;B&#x2F;SP&#x2F;SI 帧，只支持无交错（Progressive）和CAVLC；(用的少)</li>
<li>main profile：主流画质。提供I&#x2F;P&#x2F;B 帧，支持无交错（Progressive）和交错（Interlaced），也支持CAVLC和CABAC的支持</li>
<li>high profile：高级画质。在main profile的基础上增加了8x8内部预测、自定义量化、无损视频编码和更多的YUV格式</li>
</ul>
<p>H.264 baseline profile、extended profile和main profile都是针对<code>8位</code>样本数据、4:2:0格式(YUV)的视频序列。在相同配置情况下，high profile（HP）可以比main profile（MP降低10%的码率</p>
<span id="more"></span>

<ul>
<li><code>profile</code>: 规定了一个算法特征和限制的子集，任何遵守某个profile的解码器都应该支持与其相应的子集,是对<em>视频压缩特性的描述</em>（CABAC、颜色采样数等）</li>
<li><code>level</code>: 规定了一组对标准中语法成员（syntax element）所采用的各种参数值的限制，对<em>视频本身特性的描述</em>(fps(帧率)、码率、分辨率)<blockquote>
<p>总的来说就是，profile越高，说明采用了越高级的压缩特性；level越高，说明视频的帧率、码率、分辨率越高</p>
</blockquote>
</li>
</ul>
<h2 id="profile"><a href="#profile" class="headerlink" title="profile"></a>profile</h2><p><img data-src="/images/2022/09/h264_profile.png" alt="h264 profile"></p>
<ul>
<li>Baseline Profile (BP)：主要用于计算资源有限的低成本应用程序，此配置文件广泛用于视频会议和移动应用程序。</li>
<li>Main Profile (MP)：最初打算作为广播和存储应用程序的主流消费者配置文件，当为这些应用程序开发 High profile 时，此配置文件的重要性逐渐消失。</li>
<li>Extended Profile (XP)：旨在作为流视频配置文件，此配置文件具有相对较高的压缩能力和一些额外的技巧，以提高数据丢失和服务器流切换的鲁棒性。</li>
<li>High Profile (HiP)：广播和光盘存储应用程序的主要配置文件，尤其是高清电视应用程序（例如，HD DVD 和蓝光光盘采用的配置文件）。</li>
<li>High 10 Profile (Hi10P)： 超越当今的主流消费产品功能，此配置文件建立在 High Profile 之上——增加了对解码图像精度的每个样本高达10位的支持。</li>
<li>High 4:2:2 Profile (Hi422P)：主要针对使用隔行视频的专业应用程序，此配置文件建立在High 10 Profile之上——增加了对4:2:2色度子采样格式的支持，同时使用多达10位每个解码图像精度的样本。</li>
<li>High 4:4:4 Predictive Profile (Hi444PP)：此配置文件建立在高 4:2:2 配置文件之上——支持高达 4:4:4 色度采样，每个样本高达 14 位，此外还支持高效无损区域编码和将每张图片编码为三个独立的颜色平面。</li>
</ul>
<h2 id="level"><a href="#level" class="headerlink" title="level"></a>level</h2><p><img data-src="/images/2022/09/h264_level.png" alt="h264 level"></p>
<p>level的计算方法：<br>比如分辨率:<code>1920x1080</code>, 参考帧率:<code>60</code> 的h264码流是哪个level呢</p>
<p>H.264的宏块大小为<code>16×16</code> in H.264,每帧宏块的个数为分辨率除以16</p>
<ul>
<li>max-fs &#x3D; ceil( width &#x2F; 16.0 ) * ceil( height &#x2F; 16.0 )</li>
</ul>
<p>计算得:8100</p>
<p>每秒宏块数量为每帧宏块数乘以帧率.</p>
<ul>
<li>max-mbps &#x3D;max-fs*参考帧率(60)</li>
</ul>
<p>计算得:486000</p>
<p><img data-src="/images/2022/09/h264_level_limits.png" alt="h264 level limits"></p>
<blockquote>
<p>T-REC-H.264-202108-I!!PDF-E.pdf</p>
</blockquote>
<p>因此对比表上的数据<code>1920x1080@60fps</code>，level应该选择<code>4.2</code></p>
<h2 id="编解码"><a href="#编解码" class="headerlink" title="编解码"></a>编解码</h2><p>在编解码的过程中，level的值直接关系到编解码器内部buffer的申请大小，因此不同的level关系到内存空间的申请大小和消耗时间。</p>
<p>在相同的profile下，不同的level配置，level越大码流越大，也就跟耗资源。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><span class="exturl" data-url="aHR0cDovL2Jsb2cubWVkaWFjb2RlcmhxLmNvbS9oMjY0LXByb2ZpbGVzLWFuZC1sZXZlbHMv">H.264 profiles and levels<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuaXR1LmludC9yZWMvZG9sb2dpbl9wdWIuYXNwP2xhbmc9ZSZpZD1ULVJFQy1ILjI2NC0yMDIxMDgtSSEhUERGLUUmdHlwZT1pdGVtcw==">T-REC-H.264-202108-I!!PDF-E.pdf<i class="fa fa-external-link-alt"></i></span> — pdf</li>
</ul>
]]></content>
      <categories>
        <category>多媒体</category>
        <category>H264</category>
      </categories>
      <tags>
        <tag>h264</tag>
      </tags>
  </entry>
  <entry>
    <title>H264编码—slice</title>
    <url>/post/f593e51a.html</url>
    <content><![CDATA[<p>一个视频图像可编码成一个或更多个条带（slice），每个条带（slice）包含整数个宏块（MB），即每个条带至少一个MB，最多时每个条带包含整个图像的宏块。总之，一幅图像中每个条带的宏块数不一定固定。<br>设条带的目的是<strong>为了限制误码的扩散和传输</strong>，每个编码条带相互间是独立的。某个条带的预测不能以其它条带中的宏块为参考图像，这样某一条带中的预测误差才不会传播到其它条带中去。</p>
<span id="more"></span>

<h2 id="slice类型"><a href="#slice类型" class="headerlink" title="slice类型"></a>slice类型</h2><p>根据码流中<u>不同的数据类型</u>，H264中定义了5中slice类型：</p>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">含义</th>
<th align="left">描述</th>
<th align="center">Profile</th>
</tr>
</thead>
<tbody><tr>
<td align="center">I(I slice)</td>
<td align="center">帧内编码条带</td>
<td align="left">仅包含I宏块</td>
<td align="center">ALL</td>
</tr>
<tr>
<td align="center">P(P slice)</td>
<td align="center">单向帧间编码条带</td>
<td align="left">包含P宏块或I宏块</td>
<td align="center">ALL</td>
</tr>
<tr>
<td align="center">B(B slice)</td>
<td align="center">双向帧间编码条带</td>
<td align="left">包含B宏块或I宏块</td>
<td align="center">Extended and Main</td>
</tr>
<tr>
<td align="center">SP(SP slice)</td>
<td align="center">切换I条带</td>
<td align="left">包含P宏块或I宏块</td>
<td align="center">Exteded</td>
</tr>
<tr>
<td align="center">SI(SI slcie)</td>
<td align="center">切换P条带</td>
<td align="left">仅包含SI宏块</td>
<td align="center">Exteded</td>
</tr>
</tbody></table>
<ul>
<li><code>I宏块</code>是指每个块或宏块是通过其所在的Slice中的之前的已经编码过的数据进行预测的；</li>
<li><code>P宏块</code>是指宏快或宏块分割是通过List0中的一个参考图像来进行预测的；</li>
<li><code>B宏块</code>是指宏快或宏块分割是通过List0和&#x2F;或List1中的参考图像来进行预测的；</li>
<li><code>SI和SP</code>：即Switch I和Switch P，是一种特殊的编解码条带，可以保证在视频流之间进行有效的切换，并且解码器可以任意的访问。比如，同一个视频源被编码成各种码率的码流，在传输的过程中可以根据网络环境进行实时的切换；</li>
<li><code>SI宏块</code>是一种特殊类型的内部编码宏块，按Intra_4x4预测宏块编码。</li>
</ul>
<h2 id="slice的划分方式"><a href="#slice的划分方式" class="headerlink" title="slice的划分方式"></a>slice的划分方式</h2><p>在<code>垂直方向</code>上将一帧数据，平均分为几个区域，每个区域就是一个slice。如果不定义slice的个数，默认为1个slice，也就是整帧画面就是一个slice</p>
<h3 id="4个slice"><a href="#4个slice" class="headerlink" title="4个slice"></a>4个slice</h3><p>比如将一帧图像，分为4个条带（slice）的划分方式如下：</p>
<p><img data-src="/images/2022/08/h264_4%E4%B8%AAslice.png" alt="H264 4个slice"></p>
<p>当前帧图像尺寸<code>1920x1080</code>,每个宏块大小<code>16x16</code></p>
<p>因此，每个slice的大小：<code>1920xS</code>,<code>S</code>的计算方法：</p>
<ul>
<li>计算1080与16的最小公倍数：8</li>
<li>实际处理高度将是1080+8 &#x3D; 1088</li>
<li>因此每个slice高度S &#x3D; 1088 &#x2F; 4 &#x3D; 272像素，272&#x2F;16&#x3D;17个宏块</li>
</ul>
<p>码流解析：</p>
<p><img data-src="/images/2022/08/h264_4%E4%B8%AAslice%E7%A0%81%E6%B5%81.png" alt="H264 4个slice码流"></p>
<h3 id="默认一个slice"><a href="#默认一个slice" class="headerlink" title="默认一个slice"></a>默认一个slice</h3><p>码流解析：</p>
<p><img data-src="/images/2022/08/h264%E9%BB%98%E8%AE%A4%E4%B8%80%E4%B8%AAslice.png" alt="H264默认一个slice"></p>
<h2 id="slice组成"><a href="#slice组成" class="headerlink" title="slice组成"></a>slice组成</h2><p>每一个条带(slice)总体来看都由两部分组成，一部分作为Slice header，用于保存Slice的总体信息（如当前Slice的类型等），另一部分为Slice body，通常是一组连续的宏块结构（或者宏块跳过信息），如下图所示：</p>
<p><img data-src="/images/2022/08/slice%E7%BB%84%E6%88%90%E7%BB%93%E6%9E%84.png" alt="slice组成结构"></p>
<h2 id="条带头语法元素slice-type"><a href="#条带头语法元素slice-type" class="headerlink" title="条带头语法元素slice_type"></a>条带头语法元素slice_type</h2><table>
<thead>
<tr>
<th align="center">slice_type</th>
<th align="center">Name of slice_type</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">P(P slice)</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">B(B slice)</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">I(I slice)</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">SP(SP slice)</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">SI(SI slice)</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">P(P slice)</td>
</tr>
<tr>
<td align="center">6</td>
<td align="center">B(B slice)</td>
</tr>
<tr>
<td align="center">7</td>
<td align="center">I(I slice)</td>
</tr>
<tr>
<td align="center">8</td>
<td align="center">SP(SP slice)</td>
</tr>
<tr>
<td align="center">9</td>
<td align="center">SI(SI slice)</td>
</tr>
</tbody></table>
<blockquote>
<p>IDR图像时, slice_type 等于 2, 4, 7, 9。</p>
</blockquote>
<p>slice_type的值在<code>5~9</code>的范围内表示，除了当前条带的编码类型，所有当前编码图像的其他条带的slice_type的值应与当前条带的slice_type的值一样，或者等于当前条带的slice_type的值减5。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>每个条带（slice）可以进行独立的编解码</li>
<li>h264编码以macroblock为最小单位（简称MB），多个连续的MB组成一个slice，每个slice编码输出一个NALU</li>
<li>划分slice的方式可以按照固定个数MB的方式； 也可以对MB编码后累计的字节数为依据进行划分。在图像上体现为一个连续区域块，区域块的长度（以MB为单位）可以变化。</li>
<li>一帧图像中每个条带的宏块数不一定固定</li>
<li>每个slice的编码过程是相互独立的。分多slice之后，可以<strong>并发地对多个slice进行编解码</strong>，加快编码速度。同时分多slice之后，后续若slice内部出错，错误可以被限制在该slice内部，而不扩散到slice外部，在解码时花屏的面积就比较小。</li>
<li>分多slice之后，对应若在解码器端出错，那么若实施纠错机制，对应所需要处理的区域就可以较小，减少消耗。</li>
<li>分多slice之后，由于每个slice都需要自己专有的元信息，并且编码过程中slice内部可参考的信息就减少了很多，最终编码输出的码流体积会相对变大。</li>
<li>当然一幅图像编码可以放在一个slice里进行；具体需要根据业务场景进行综合选择slice模式，比如对带宽的要求、对容错要求等。</li>
</ul>
<p>编解码时图像序列的整体结构：</p>
<p><img data-src="/images/2022/08/h264%E5%9B%BE%E5%83%8F%E5%BA%8F%E5%88%97.png" alt="H264图像序列"></p>
<blockquote>
<p>像素点： 像素点是最小的图像单元，一张图片由好多的像素点组成。图片尺寸是500×338的，表示图片是由一个500×338的像素点矩阵构成的，这张图片的宽度是500个像素点的长度，高度是338个像素点的长度，共有500×338 &#x3D; 149000个像素点。<br>RGB格式的图片，一个像素点的大小就是rgb所占的空间，比如rgb888,像素大小3×8&#x3D;24bit</p>
</blockquote>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3doOF8yMDExL2FydGljbGUvZGV0YWlscy81MTE2MzM2OA==">H.264的Slice及Slice类型<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NyeXN0YWxTaGF3L2FydGljbGUvZGV0YWlscy84NDE0MzAyNg==">h264编码概述五（slice定义）<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>多媒体</category>
        <category>H264</category>
      </categories>
      <tags>
        <tag>h264</tag>
        <tag>slice</tag>
      </tags>
  </entry>
  <entry>
    <title>H264编码——DPB</title>
    <url>/post/6766163f.html</url>
    <content><![CDATA[<p><code>DPB</code>全称 Decoded Picture Buffer，即解码图片缓存区。</p>
<p>在做视频解码时，需要将最近的若干幅<code>参考帧</code>缓存起来，这个缓冲区就叫做<code>DPB</code>。解码已经完成的图像被缓存在DPB中，供后续帧用作参考图像，因此，解码器需要按照一定的规则对DPB中的图像进行管理。</p>
<p>在H264中参考帧最多可以存储<code>16帧</code>参考帧。</p>
<span id="more"></span>

<p>H.264中，已编码图像存储在编码器和解码器的参考缓冲区（DPB，解码图像缓冲区），并有相应的参考图像列表list0，以供帧间宏块的运动补偿预测使用。对B切片预测而言，参考帧包含当前图像的前面和后面两个方向的图像，保存在list0和list1；也可同时包含<code>短期</code>和<code>长期</code>参考图像。</p>
<h2 id="参考帧——reference-frame"><a href="#参考帧——reference-frame" class="headerlink" title="参考帧——reference frame"></a>参考帧——reference frame</h2><p>目的：参考帧在帧间编码时，每个宏块（MB）的运动补偿预测使用，因此根据编码帧的不同主要分为两类。</p>
<ol>
<li><code>P slice</code>: 在编解码P帧时，相应的参考帧全部保存在<code>list0</code>中.</li>
<li><code>B slice</code>: 在编解码B帧时，由于B帧存在前向和后向两个方向对图像的参考，因此参考帧分别保存在<code>list0</code>和<code>list1</code>中</li>
</ol>
<h3 id="P-slice参考帧存储"><a href="#P-slice参考帧存储" class="headerlink" title="P slice参考帧存储"></a>P slice参考帧存储</h3><p>P帧的参考帧存储比较简单，就是将当前帧后面的图像利用frame_num来进行索引，并按照<code>降序</code>排列（即离当前图像最近的前向图像排在第0位）。</p>
<h3 id="B-slice参考帧存储"><a href="#B-slice参考帧存储" class="headerlink" title="B slice参考帧存储"></a>B slice参考帧存储</h3><ul>
<li><code>list0</code>：最近<code>前向</code>图像（基于POC）标为index0，接着是其余前向图像（ POC递增顺序），及<code>后向</code>图像（从当前图像POC递增顺序）。</li>
<li><code>list1</code>：最近<code>后向</code>图像（基于POC）标为index0，接着是其余后向图像（ POC递增顺序），及<code>前向</code>图像（从当前图像POC递增顺序）。</li>
</ul>
<p>举例：一个H.264解码器存储了6幅短期参考图像。其POC分别为：123，125，126，128，129和130。当前图像为<code>127</code>。所有6幅短期参考图像在list0和list1中都标为“用作参考”。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+-------------------------------+</span><br><span class="line">| 123 125 126 |127| 128 129 130 |</span><br><span class="line">+-------------------------------+</span><br><span class="line">前向                          后向</span><br><span class="line"></span><br><span class="line">+-------------------------------+</span><br><span class="line">  Index       List0       list1</span><br><span class="line">+-------------------------------+</span><br><span class="line">    0          126         128</span><br><span class="line">    1          125         129</span><br><span class="line">    2          123         130</span><br><span class="line">    3          128         126</span><br><span class="line">    4          129         125</span><br><span class="line">    5          130         123</span><br><span class="line">+-------------------------------+</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>IDR帧</strong>：会将list0和list1中的次序全部清零</p>
</blockquote>
<h3 id="短期参考帧——short-term-reference"><a href="#短期参考帧——short-term-reference" class="headerlink" title="短期参考帧——short term reference"></a>短期参考帧——short term reference</h3><p>短期参考帧：已编码图像由编码器重建的标为短期图像，并由其帧号标定。</p>
<h3 id="长期参考帧——long-term-reference"><a href="#长期参考帧——long-term-reference" class="headerlink" title="长期参考帧——long term reference"></a>长期参考帧——long term reference</h3><p>长期参考帧是较早的图像，由<code>LongTermPicNum</code>标定，保存在DPB中，直到被代替或删除。</p>
<h2 id="DPB管理"><a href="#DPB管理" class="headerlink" title="DPB管理"></a>DPB管理</h2><p>当一幅图像在编码器被编码重建或在解码器被解码时，它存放在DPB并标定为以四种：</p>
<ul>
<li>“非参考”，不用于进一步的预测（Unused for reference）</li>
<li>短期参考图像（Used for short-term reference）</li>
<li>长期参考图像（Used for long-term reference）</li>
<li>直接输出显示（display）</li>
</ul>
<p>4种状态之间的转化，是通过解码图像标记过程进行控制的，H.264&#x2F;AVC 中采用了<code>滑动窗</code>和<code>MMCO</code>两种方式。</p>
<h3 id="滑动窗"><a href="#滑动窗" class="headerlink" title="滑动窗"></a>滑动窗</h3><p>list0中短期参考帧是按<code>PicNum</code>（由帧号推出的变量）从高到低的顺序排列，长期参考帧按<code>LongTermPicNum</code>从低到高的顺序排列。</p>
<ul>
<li>当新的图像加在短期列表的位置index0时，剩余的短期图像索引号依次增加。</li>
<li>当短期和长期图像号达到参考帧最大数时，最高索引号的图像被移出缓冲区，即实行<code>滑动窗内存控制</code>。该操作使得编码器和解码器保持N幅短期参考帧，包括一幅当前图像和（N-1）幅已编码图像。</li>
</ul>
<p>简单来说就是，最多只缓存refs个数的参考帧，多了就扔掉。</p>
<h3 id="MMCO"><a href="#MMCO" class="headerlink" title="MMCO"></a>MMCO</h3><p>由编码器发送的<code>自适应内存控制命令</code>用来管理短期和长期参考帧索引。这样，短期图像才可能被指定长期帧索引，短期或长期图像才可能标定为“非参考”。编码器从list0中选择参考图像，进行帧间宏块编码。而该参考图像的选择由索引号标志，索引0对应于短期部分的第一帧，<code>长期帧索引开始于最后一个短期帧</code>。</p>
<p><strong>参考图像缓冲区通常由编码器发送的IDR（瞬时解码器刷新）编码图像刷新，IDR图像一般为I片或SI片</strong>。当接受到IDR图像时，解码器立即将缓冲区中的图像标为“非参考”。后继的片进行无图像参考编码。通常，编码视频序列的第一幅图像都是IDR图像。</p>
<h2 id="DPB大小"><a href="#DPB大小" class="headerlink" title="DPB大小"></a>DPB大小</h2><p>DPB一般以<code>宏块</code>(MB)数为单位，计算公式为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DpbInMbs = ref * PicWidthInMbs * FrameHeightInMbs</span><br></pre></td></tr></table></figure>
<ul>
<li>ref（参考帧数）</li>
<li>PicWidthInMbs（水平宏块数）</li>
<li>FrameHeightInMbs（垂直宏块数）</li>
</ul>
<p>H.264协议规定，在不同的级别（Level）下，最大的解码图片缓存区宏块数（MaxDpbMbs）是不同的：</p>
<p><img data-src="/images/2022/10/h264_level_limits_dpb.png" alt="H264 Level limits DPB"></p>
<h2 id="DPB的行为"><a href="#DPB的行为" class="headerlink" title="DPB的行为"></a>DPB的行为</h2><h3 id="清空机制"><a href="#清空机制" class="headerlink" title="清空机制"></a>清空机制</h3><p>当解码器收到一个IDR帧时会立即将<code>DPB清空</code>，因为H.264协议规定一个IDR帧之后的任何帧都不会引用该IDR之前的任何帧，所以DPB中的数据已失效，可以清空。这也是IDR帧名称的来源，即 Instantaneous Decoding Refresh – 解码立即重置。</p>
<h3 id="内存分配过大"><a href="#内存分配过大" class="headerlink" title="内存分配过大"></a>内存分配过大</h3><p>H.264 bitstream 语法结构(SPS)中定义了一个参数用于通知<code>解码器最大参考帧数</code>。有些社会责任感不是特别强的编码器会随便报告一个安全余量很大的参数，实际上可能根本用不到。比如为了图方便在结构体中报告最大参考帧数&#x3D;16，但实际上最多只用到2帧，如果解码器按照16分配内存则会造成大量的浪费。</p>
<p>对于资源紧张的场合，解码器的设计通常会要求最大参考帧数不能超过某个值，编码器输出的码流必须满足同样的限制才能顺利解码。显然，如果这个限制定为6帧，应该可以解大多数编码器的码流。但是如果定为2帧，则遇到不兼容码流的概率就会显著增加。</p>
<h3 id="内存分配不足"><a href="#内存分配不足" class="headerlink" title="内存分配不足"></a>内存分配不足</h3><p>如果编码器报告一个不恰当的level，在解码器解析出该level后，并依据该值进行内存的申请，可能会导致内存不足。</p>
<p>比如：</p>
<p>一帧4K分辨率的图像， 宏块数 &#x3D; (3840&#x2F;16)*(2160)&#x2F;16 &#x3D; 32400</p>
<ul>
<li>按照level4.1准备DPB只能存一个参考帧。</li>
</ul>
<p>一帧1000万像素分辨率的图像， 宏块数 &#x3D; (3872&#x2F;16)*(2592)&#x2F;16 &#x3D; 39204</p>
<ul>
<li>按照 level 5.0 准备 DPB 能存2个参考帧，</li>
<li>按照 level 5.1 则可以存4个参考帧。</li>
<li>按照 level 4.1 则一帧也放不下</li>
</ul>
<h2 id="H-265中的DPB"><a href="#H-265中的DPB" class="headerlink" title="H.265中的DPB"></a>H.265中的DPB</h2><p>HEVC 规定解一帧所需的参考帧数目不能超过<code>8</code>。具体从DPB中哪些帧用来解当前帧，是由RPS定义的。</p>
<p>RPS也就是Reference Picture Set，即参考帧集。也就是可以选用的参考帧的集合。集合的每个元素是一种参考帧的排队方案。按照参考帧POC与当前帧POC的大小的相对关系排成一队。然后按照RPS的语法，来选出对应的reference_list_x。</p>
<p>对参考帧队列中的图像（即DPB中的图像帧）可分为三类：前向参考帧、后向参考帧和非参考帧。与H.264相似，前向、后向参考帧与list_0、list_1有关系，但不是对应关系。在构造参考帧列表时，会对DPB中的所有帧作遍历，将POC小于当前帧的作为前向参考帧备选，将POC大于当前帧的作为后向参考帧备选。这时，可以通过指定RPS中的ID值来选择用哪些帧来形成真正的参考帧列表。在即时RPS中，通过（与参考帧POC差，是否选入参考列表）两个参数对备选参考帧序列再作筛选，选出真正用于参考的参考帧序列。是不是其中标记为非参考帧的图像就可以被剔除出DPB了呢？当然不是，只是在当前RPS中的指定ID被选中时，这个图像不作为参考帧而已。</p>
<p>为了支持即时参考帧与长时参考帧，RPS分为两种，即时RPS与长时RPS</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8xMDAyOTg2NjY=">H.264 概念解析 - DPB<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lhbmNleXhpbi9hcnRpY2xlL2RldGFpbHMvODE5NDg0NDk=">H264 DPB管理<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0theXNvbjEyMzQ1L2FydGljbGUvZGV0YWlscy8xMDU2NDY5NDc=">H.264多参考帧管理<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>多媒体</category>
        <category>H264</category>
      </categories>
      <tags>
        <tag>h264</tag>
      </tags>
  </entry>
  <entry>
    <title>H264编码——POC</title>
    <url>/post/c614239b.html</url>
    <content><![CDATA[<p>POC（picture order count）:图像播放顺序号,在编解码中<code>视频编码顺序</code>与<code>视频的播放顺序</code>，并不完全相同.</p>
<p>视频编码时，如果采用了B帧编码，由于B帧很多时候都是双向预测得来的，这时会先编码B帧的后向预测图像（P帧），然后再进行B帧编码，因此会把视频原来的播放顺序打乱，以新的编码顺序输出码流而在解码断接收到码流后，需要把顺序还原成原本的播放顺序，以输出正确的视频。</p>
<blockquote>
<p>B帧的存在导致播放顺序POC和解码顺序frame_num不一致</p>
</blockquote>
<span id="more"></span>

<h2 id="编码顺序、frame-num和POC"><a href="#编码顺序、frame-num和POC" class="headerlink" title="编码顺序、frame_num和POC"></a>编码顺序、frame_num和POC</h2><h3 id="编码顺序"><a href="#编码顺序" class="headerlink" title="编码顺序"></a>编码顺序</h3><p>H.264的<code>码流输出顺序</code>便是<code>编码顺序</code>，所以在编码B帧的时候，由于B是双向预测，需要先编码后面编码帧P&#x2F;I，这时候先输出I&#x2F;P，后面才有B帧，我们在解码段拿到相应的I&#x2F;P帧后，不能马上丢到buffer list里面，还需要等待后面的B帧，解码B帧后再reorder。</p>
<h3 id="frame-num"><a href="#frame-num" class="headerlink" title="frame_num"></a>frame_num</h3><p>每个参考帧都有一个依次连续的<code>frame_num</code>作为它们的标识,这指明了各图像的解码顺序。在非参考帧的slice header中也会出现frame_num，不过该语法元素只有在参考帧才有意义。</p>
<p>H.264 对frame_num的值作了如下规定：<br>当参数集中的句法元素<code>gaps_in_frame_num_value_allowed_flag</code>不为1时，每个图像的frame_num值是它前一个参考帧的frame_num值增加1。这句话包含有两层意思。</p>
<ul>
<li>当gaps_in_frame_num_value_allowed_flag等于<code>0</code>，即frame_num连续的情况下，每个图像的frame_num由前一个参考帧图像对应的值加1，着重点是“前一个参考帧”。</li>
<li>当gaps_in_frame_num_value_allowed_flag等于<code>1</code>，这时若网络阻塞，编码器可以将编码后的若干图像丢弃，而不用另行通知解码器。在这种情况下，解码器必须有机制将缺失的frame_num及所对应的图像填补，否则后续图像若将运动矢量指向缺失的图像将会产生解码错误。</li>
</ul>
<p><code>frame_num</code>是循环计数的，即当它到达MaxFrameNum后又从0 重新开始新一轮的计数。解码器必须要有机制检测这种循环，</p>
<h3 id="POC"><a href="#POC" class="headerlink" title="POC"></a>POC</h3><p>Picture Order Count，即图像顺序号，主要用于标识图象的播放顺序，同时还用于在对帧间预测片解码时，标记参考图像的初始图像序号，表明下列情况下帧或场之间的图像序号差别：</p>
<ol>
<li>使用时间直接预测模式的运动矢量推算时；</li>
<li>B片中使用固有模式加权预测时；</li>
<li>解码器一致性检测时。</li>
</ol>
<h2 id="POC用途"><a href="#POC用途" class="headerlink" title="POC用途"></a>POC用途</h2><ul>
<li><p>主要用于标识图像的播放顺序</p>
<ul>
<li>在标识图像的播放顺序时，POC&#x3D;<code>高位Msb</code>+<code>低位Lsb</code>(按值相加，而非按位相加)<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POC低位：pic_order_cnt_lsb = POC % MaxPicOrderCntLsb</span><br><span class="line">　　　　		所占长度：log2_max_pic_order_cnt_lsb_minus4 + 4 个比特</span><br><span class="line">　　　　		大小范围：[0 ， MaxPicOrderCntLsb – 1]</span><br><span class="line">　　　　		注：MaxPicOrderCntLsb = 2^（log2_max_pic_order_cnt_lsb_minus4 + 4）</span><br><span class="line">POC高位：pic_order_cnt_msb = POC - pic_order_cnt_lsb 【是MaxPicOrderCntLsb的整数倍】</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>在对帧间预测片解码时，标记参考图像的初始图像序号，表明下列情况下帧或场之间的图像序号差别：</p>
<ul>
<li>使用时间直接预测模式的运动矢量推算时；</li>
<li>B片中使用固有模式加权预测时；</li>
<li>解码器一致性检测时；</li>
</ul>
</li>
</ul>
<h2 id="POC有三类种类型"><a href="#POC有三类种类型" class="headerlink" title="POC有三类种类型"></a>POC有三类种类型</h2><ul>
<li>pic_order_cnt_type &#x3D; 0，把POC的低位（LSB）编进码流内  </li>
<li>pic_order_cnt_type &#x3D; 1，依赖frame_num求解POC  </li>
<li>pic_order_cnt_type &#x3D; 2，显示顺序与解码顺序一致，不能出现B帧</li>
</ul>
<p>区别：</p>
<table>
<thead>
<tr>
<th align="center">pic_order_cnt_type</th>
<th align="left">bit消耗</th>
<th align="left">序列要求</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="left">最多(大量的lsb)</td>
<td align="left">无要求</td>
</tr>
<tr>
<td align="center">1</td>
<td align="left">在sps和slice_header传递bit</td>
<td align="left">POC周期变化</td>
</tr>
<tr>
<td align="center">2</td>
<td align="left">无需消耗bit</td>
<td align="left">限制最大(直接从frame_num获取，POC和frmae_num必须一致，不能有B帧，可以有非参考P帧)</td>
</tr>
</tbody></table>
<h2 id="POC值的计算"><a href="#POC值的计算" class="headerlink" title="POC值的计算"></a>POC值的计算</h2><p>这里只计算<code>pic_order_cnt_type=2</code>的情况，因为目前解码码流中使用的是该方法，并且也是计算最简单的。<br>这种方式<code>不能出现连续的非参考帧</code>并且<code>解码输出顺序和显示顺序一致</code>，也就是不能出现B帧，但可以出现不做参考的P场。</p>
<p>计算方法：直接通过frame_num推导，应用在没有连续的非参考帧的情况下（即一个间隔最多只能包含一个非参考帧）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int iFrameNumOffset;</span><br><span class="line">uint32_t uMaxFrameNum = 1 &lt;&lt; (pSlice-&gt;pSPS-&gt;log2_max_frame_num_minus4 + 4);</span><br><span class="line"></span><br><span class="line">if(bIsIDR)</span><br><span class="line">  iFrameNumOffset = 0;</span><br><span class="line">else if(pCtx-&gt;iPrevFrameNum &gt; pSlice-&gt;frame_num)</span><br><span class="line">  iFrameNumOffset = pCtx-&gt;iPrevFrameNumOffset + uMaxFrameNum;</span><br><span class="line">else</span><br><span class="line">  iFrameNumOffset = pCtx-&gt;iPrevFrameNumOffset;</span><br><span class="line"></span><br><span class="line">int iTempPicOrderCnt;</span><br><span class="line"></span><br><span class="line">if(bIsIDR)</span><br><span class="line">  iTempPicOrderCnt = 0;</span><br><span class="line">else if(!pSlice-&gt;nal_ref_idc)</span><br><span class="line">  iTempPicOrderCnt = 2 * (iFrameNumOffset + pSlice-&gt;frame_num) - 1;</span><br><span class="line">else</span><br><span class="line">  iTempPicOrderCnt = 2 * (iFrameNumOffset + pSlice-&gt;frame_num);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>H264中pic_order_cnt_type&#x3D;2时对POC的计算</p>
</blockquote>
<p>也就是每一帧的POC值是不同的，因为每一帧的frame_num是不同的（不断累加）。</p>
<p>如果POC值不变时就表明，解码器没有进行解码操作。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>POC值表示了解码后图像的显示顺序</li>
<li>POC值也可以反映解码器的解码状态，比如在硬核解码时，如果读取的POC值在一定时间内没有发生变化，可以认为解码器不进行解码了。</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDI0MDY3L2FydGljbGUvZGV0YWlscy8xMDc1MzU2NzM=">H264—播放顺序POC（pic_order_cnt）—pic_order_cnt_type&#x3D;0、1、2 + POC和framenum比较<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMTM5MzgzL2FydGljbGUvZGV0YWlscy8xMTUzNTc0OTQ=">H.264&#x2F;AVC学习-POC计算<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vVGFpZ2FDb24vcC8zNTUxMDAxLmh0bWw=">h.264的POC计算<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3l1X3l1YW5fMTMxNC9hcnRpY2xlL2RldGFpbHMvOTAxMTg5OQ==">编码顺序、frame_num和POC<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>多媒体</category>
        <category>H264</category>
      </categories>
      <tags>
        <tag>h264</tag>
      </tags>
  </entry>
  <entry>
    <title>H264 ES PS TS流之间的联系</title>
    <url>/post/51817.html</url>
    <content><![CDATA[<blockquote>
<p><code>ES流(Elementary Stream)</code>: 也叫基本码流,包含视频、音频或数据的连续码流.</p>
</blockquote>
<blockquote>
<p><code>PES流(Packet Elementary Stream)</code>: 也叫打包的基本码流, 是将基本的码流ES流根据需要分成长度不等的数据包, 并加上包头就形成了打包的基本码流PES流.</p>
</blockquote>
<blockquote>
<p><code>TS流(Transport Stream)</code>: 也叫传输流, 是由固定长度为<code>188字节</code>的包组成, 含有独立时基的一个或多个program, 一个program又可以包含多个视频、音频、和文字信息的ES流;</p>
</blockquote>
<span id="more"></span>

<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="ES"><a href="#ES" class="headerlink" title="ES"></a>ES</h3><p>ES是只包含一种<code>内容的数据流</code>，如只含<code>视频</code>或只含<code>音频</code>等，打包之后的PES也是只含一种性质的ES,如只含视频ES的PES,只含音频ES的PES等。每个ES都由若干个<code>存取单元（AU）</code>组成，每个视频AU或音频AU都是<code>由头部和编码数据</code>两部分组成，<code>个AU相当于编码的1幅视频图像或1个音频帧</code>，也可以说，每个AU实际上是编码数据流的显示单元，即相当于解码的1幅视频图像或1个音频帧的取样。</p>
<h3 id="PES"><a href="#PES" class="headerlink" title="PES"></a>PES</h3><p>PES–Packetized  Elementary Streams  (分组的ES)，ES形成的分组称为<code>PES分组</code>，是用来<code>传递ES的一种数据结构</code>。PES流是ES流经过PES打包器处理后形成的数据流，在这个过程中完成了将ES流分组、打包、加入包头信息等操作（对ES流的第一次打包）。PES流的基本单位是PES包。PES包由<code>包头和payload</code>组成。</p>
<h3 id="PS"><a href="#PS" class="headerlink" title="PS"></a>PS</h3><p>PS–Program Stream(节目流)PS流由PS包组成，而一个PS包又由若干个PES包组成（到这里，ES经过了两层的封装）。PS包的包头中包含了<code>同步信息</code>与<code>时钟恢复信息</code>。一个PS包最多可包含具有<code>同一时钟基准</code>的16个视频PES包和32个音频PES包。</p>
<h3 id="TS"><a href="#TS" class="headerlink" title="TS"></a>TS</h3><p>TS–Transport Stream（传输流）由定长的TS包组成（188字节），而TS包是对PES包的一个重新封装（到这里，ES也经过了两层的封装）。<code>PES包的包头信息依然存在于TS包中</code>。</p>
<h3 id="PS和TS区别："><a href="#PS和TS区别：" class="headerlink" title="PS和TS区别："></a>PS和TS区别：</h3><p>TS流与PS流的区别在于<code>TS流的包结构是固定长度的</code>,而<code>PS流的包结构是可变长度的</code>。PS包由于长度是变化的,一旦丢失某一PS包的同步信息,接收机就会进入失步状态,从而导致严重的信息丢失事件。而TS码流由于采用了固定长度的包结构,当传输误码破坏了某一TS包的同步信息时,接收机可在固定的位置检测它后面包中的同步信息,从而恢复同步,避免了信息丢失。因此<code>在信道环境较为恶劣、传输误码较高时一般采用TS码流</code>,而<code>在信环境较好、传输误码较低时一般采用PS码流</code>。</p>
<h3 id="PTS、DTS"><a href="#PTS、DTS" class="headerlink" title="PTS、DTS"></a>PTS、DTS</h3><p>PTS–PresentationTime Stamp（显示时间标记）表示显示单元出现在系统目标解码器（H.264、MJPEG等）的时间。</p>
<p>DTS–Decoding Time Stamp（解码时间标记）表示将存取单元全部字节从解码缓存器移走的时间。</p>
<p>PTS&#x2F;DTS是打在<code>PES包</code>的包头里面的，这两个参数是解决音视频同步显示，防止解码器输入缓存上溢或下溢的关键。每一个I（关键帧）、P（预测帧）、B（双向预测 帧）帧的包头都有一个PTS和DTS，但PTS与DTS对于B帧不一样，无需标出B帧的DTS，对于I帧和P帧，显示前一定要存储于视频解码器的重新排序缓存器中，经过延迟（重新排序）后再显示，所以一定要分别标明PTS和DTS。</p>
]]></content>
      <categories>
        <category>多媒体</category>
        <category>H264</category>
      </categories>
      <tags>
        <tag>h264</tag>
      </tags>
  </entry>
  <entry>
    <title>[译] H.264高级视频编码-完整概述</title>
    <url>/post/d3178cac.html</url>
    <content><![CDATA[<blockquote>
<p>原文：<span class="exturl" data-url="aHR0cHM6Ly93d3cuZ3VtbGV0LmNvbS9sZWFybi93aGF0LWlzLWgyNjQv">https://www.gumlet.com/learn/what-is-h264/<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<h2 id="什么是H-264"><a href="#什么是H-264" class="headerlink" title="什么是H.264"></a>什么是H.264</h2><p>H.264，也称为MPEG-4 Part 10或高级视频编码 (AVC)，H.264将数字视频转换为占用极少存储空间的格式。这使得通过Internet流式传输、播放和传输视频变得更加容易。 H.264定义了各种配置文件（工具）和级别最大分辨率和比特率）我们将在本文后面更深入地检查这一点。 H.264压缩支持高达8K超高清的数字视频。</p>
<p>H.264编解码器由MPEG（运动图像专家组）和 ITU（国际电信单位）联合开发。 许多著名的供应商在他们自己的编解码器版本中使用 H.264-例如 Apple Codec、MainConcept Codec、x264 Codec等。</p>
<span id="more"></span>

<h2 id="H-264编解码器如何工作？"><a href="#H-264编解码器如何工作？" class="headerlink" title="H.264编解码器如何工作？"></a>H.264编解码器如何工作？</h2><p>基于H.264标准的视频编解码器可压缩数字视频流，使其仅适合MPEG-2 (H.262)标准的一半带宽或存储空间。 使用H.264压缩，编解码器可以保持视频质量不变，同时将所需空间减少到原始空间的一半。</p>
<p>H.264视频<code>编码器</code>执行三个重要过程：<code>预测(prediction)</code>、<code>变换(transform)</code>和<code>编码(encoding)</code>以提供压缩的H.264比特流。 <code>解码器</code>然后执行互补过程:<code>解码(decoding)</code>、<code>逆变换(inverse transform)</code>和<code>重建(reconstruction)</code>以产生解码的视频流。</p>
<p>让我们详细看一下H.264<code>编码器</code>的流程：</p>
<ul>
<li><p><strong>Prediction</strong>（预测）：编码器处理一帧视频的单元是宏块（Macroblock）（16x16显示像素）。这形成了基于先前编码数据的宏块预测，来自当前帧（帧内预测）或来自先前编码和传输帧（帧间预测），编码器提取预测并形成残差。</p>
</li>
<li><p><strong>Transformation and quantization</strong>（变换和量化）：残差样本块使用离散余弦变换或8x8或4x4整数变换的近似形式进行变换。这会输出一组系数，每个系数都与标准基础模式的权重值有关。可以组合这些基本模式以重新创建残差样本的初始块。这个输出是量化的，即每个系数除以一个整数值。这样做的目的是产生一个块，其中大部分或所有系数为零，只有很少的非零系数。</p>
</li>
<li><p><strong>Bitstream encoding</strong>（比特流编码）：之前产生的所有值现在都需要编码。这些值包括<em>量化系数</em>、<em>解码器重新创建预测的信息</em>、<em>有关压缩数据结构和使用的压缩工具的信息</em>、<em>有关整个视频序列的信息</em>。这些值和参数使用<code>算术编码</code>或<code>可变长度编码</code>进行编码，以产生初始信息的紧凑二进制信息。然后根据要求存储或传输该比特流。</p>
</li>
</ul>
<p>另一方面，<code>解码器</code>通过互补编码器的步骤来工作，方式如下：</p>
<ul>
<li><p><strong>Bitstream decoding</strong>（比特流解码）：解码器接收压缩的比特流并解码每个句法元素（h264的码流格式）。然后，它提取上述信息。这就是编码过程的逆向发生并重新创建视频图像序列的方式。</p>
</li>
<li><p><strong>Rescaling and inverse transform</strong>（恢复和逆变换）： 通过乘以整数值来重新缩放量化系数以恢复初始缩放。 该过程有助于重建每个残差数据块，然后将其组合形成宏块。</p>
</li>
<li><p><strong>Reconstruction</strong>（重建）：对于每个宏块，解码器对编码器最初创建的预测形成最准确的预测。解码器将此预测添加到解码的残差中。这导致解码宏块的重建，然后将其显示为视频帧的片段。</p>
</li>
</ul>
<p><img data-src="/images/2022/09/h264_encoding_and_decoding.png" alt="h264 encoding and decoding"></p>
<h2 id="H-264-x2F-AVC概述"><a href="#H-264-x2F-AVC概述" class="headerlink" title="H.264&#x2F;AVC概述"></a>H.264&#x2F;AVC概述</h2><p>H.264通常被称为AVC(Advanced Video Coding的缩写)，也称为MPEG-4 Part 10。H.264编码标准由ISO&#x2F;IEC和ITU-T两个标准国际机构创建。 它于2003年作为题为“推荐 H.264：高级视频编码”的文档的一部分首次发布。</p>
<p>以下是 H.264 的一些功能和其他基本概述。</p>
<h3 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h3><p>H.264压缩将视频容器的大小减少到原来的一半左右。这样做时，基于H.264的编解码器不会影响任何质量。就使其能够执行此壮举的功能而言，以下是一些：</p>
<ul>
<li>切片结构编码(Slice structure coding)：切片可以理解为一个特定切片组内的一组宏块。它们在视频数据中提供不同的重新同步点，并确保在切片边界上不会发生帧内预测。此功能使H.264压缩可以将丢包概率和视觉退化等损失降至最低。</li>
<li>灵活的宏块排序（Flexible Macroblock ordering,FMO）：这是一种重新调度宏块表示顺序的策略。这对于在视频传输过程中具有长期积极影响的错误鲁棒性非常方便。</li>
<li>数据分区(Data partitioning:)：这是H.264的另一个关键特性，它允许通过将所有句法元素分配到网络抽象层单元来分离标头、运动信息和内部信息。</li>
<li>帧内编码(Intra-coding)：使用帧内编码限制了丢包对运动补偿的影响。它还有助于终止错误传播并将其减少到最低限度。</li>
<li>切换图片(Switching pictures)：H.264的这一特性允许在参考信号存在差异的情况下进行预测编码。此功能可用于自适应错误恢复目的，尤其是在无线环境中。</li>
</ul>
<p>让我们看看在 H.264 压缩环境中的配置文件和级别</p>
<h3 id="Profile和levels"><a href="#Profile和levels" class="headerlink" title="Profile和levels"></a>Profile和levels</h3><p>Level和Proflie是谈论H.264压缩时要考虑的两个重要参数。</p>
<p>在profile方面，H.264支持以下编码profile：</p>
<ul>
<li>Baseline</li>
<li>Main</li>
<li>High10</li>
<li>Extended.</li>
</ul>
<p>这些Profile是H.264可用的整个编码技术的各种子集。</p>
<p>Baseline profile是个简单的设计，因为它仅支持所有技术的有限子集。这就是为什么它需要更少的代码行和更少的处理能力。由于这些原因，baseline profile针对的是低功耗手持设备。另一方面，Main profile支持大多数编码技术。这就是为什么它需要更多的代码、内存和更大的处理能力才能正确完成解码。机顶盒等支持Main profile。 High profile支持几乎所有的H264编码技术，专为HD和FullHD设计，软件解码器也支持。</p>
<p>当涉及到这些Profile之间并找出最佳使用的Profile时，答案完全取决于你的最终要求。如果你只针对Flash Player，你可以只使用High Profile，但如果您针对iPhone，例如，您肯定需要使用Baseline配置文件对视频进行编码。</p>
<p>虽然Profile有助于处理代码复杂性和处理能力，但Level都是关于处理解码端的<code>带宽</code>、<code>最大分辨率</code>和<code>内存</code>的问题。特定设备支持最大的Profile，具体取决于它们可用的<code>最大分辨率</code>和<code>内存</code>。较低Level是指较低的分辨率、较少的比特率和较少的存储帧的内存。从本质上讲，H.264中的Level有助于指定设备可以支持的最大视频分辨率和数据速率。例如，iPad2的规格表明该设备可以在3.1级播放Main Profile编码的视频。同样，不同的设备具有不同的操作级别。</p>
<h3 id="h-264的应用"><a href="#h-264的应用" class="headerlink" title="h.264的应用"></a>h.264的应用</h3><p>H.264压缩已被证明非常适合从一个来源到多个目的地的A&#x2F;V（Audio&#x2F;Video）分发。 H.264在所有需要使用电线长距离传输信号的用例中都非常有用。由于这速度极快且不会影响视频质量，因此它正迅速成为数字世界的首选视频压缩格式。除此之外，H.264的应用范围非常广泛，从外部广播车、教育、运输无人机、环境监测等等。</p>
<p>H.264编码器从各种压缩工具中进行选择，使其非常适合从低延迟、低比特率的移动传输到高清或全高清消费电视，甚至专业电视制作的各种用例。H.264标准为传输或存储提供集成支持，其中包括量化压缩格式和将传输错误影响降至最低的功能。H.264压缩已证明其价值的一些应用包括：</p>
<ul>
<li>高清 DVD 格式</li>
<li>高清电视广播</li>
<li>移动电视广播</li>
<li>互联网视频冲浪和流媒体</li>
<li>视频会议等等。</li>
</ul>
<h3 id="为什么要进行h-264压缩？"><a href="#为什么要进行h-264压缩？" class="headerlink" title="为什么要进行h.264压缩？"></a>为什么要进行h.264压缩？</h3><p>H.264视频压缩旨在以远低于其他视频压缩格式的比特率提供最佳质量的视频。它在不增加复杂性或降低比特流的鲁棒性的情况下完成所有这些工作。这也使H.264成为一种灵活的格式，因为它可以应用于广泛的用例并解决几个问题。</p>
<h4 id="与其他视频编解码器的比较"><a href="#与其他视频编解码器的比较" class="headerlink" title="与其他视频编解码器的比较"></a>与其他视频编解码器的比较</h4><p>还有各种其他可用的压缩标准，但H.264最常见的比较是与H.265、MPEG2、VP9和AV1。 让我们简要介绍一下这些不同的编解码器是什么，以及如何为您的事业找到最好的编解码器。</p>
<ul>
<li><p><code>H.265/HEVC</code>：H.265或HEVC（高效视频编码）：这是AVC的继承者，可提供高达20-40%的压缩效率，同时视频质量得到改善或保持不变。与AVC一样，它支持8K超高清分辨率，但提供的文件(码流)相对较小，这使其在流式传输或长期传输时更加高效。HEVC设计有高级视频编码层、并行处理工具和其他重要扩展。</p>
</li>
<li><p><code>AV1</code>：由 AOM（Alliance for Open Media）开发，AV1是真正的下一代视频编码格式。该编解码器将HEVC的编码和解码能力提高了<code>30%</code>，并使用低计算能力和快速的硬件优化。这使其能够提供最高质量的实时视频，并可扩展到任何设备。此编解码器使用更高级的算法，旨在与Opus音频编解码器格式一起用于WebRTC和HTML5 Web视频。</p>
</li>
<li><p><code>VP9</code>：这是H.265的免版税替代方案，由Google开发。以任何方式链接到Google的每个视频平台——从Chrome浏览器、Android手机到YouTube等等——都支持VP9编解码器。这可在与H.264相同的比特率下提供更好的视频质量，使其有效地在线传输和传输4K高清视频。</p>
</li>
</ul>
<p>针对H.264与H.265、AV1和VP9的比较而言，您应该记住H.264是一种较旧的编解码器。 随着技术的快速进步，编解码器多年来一直在发展，以应对更加复杂和具体的挑战。 但是，每个编解码器（新旧编解码器）仍有大量用例，具体取决于所使用的设备和带宽。</p>
<h3 id="h-264的好处"><a href="#h-264的好处" class="headerlink" title="h.264的好处"></a>h.264的好处</h3><p>总而言之，H.264 的好处包括：</p>
<ul>
<li>无缝支持超过并包括8K超高清的分辨率。</li>
<li>即使将它们压缩到原始大小的一半，也能获得极高品质的视频。</li>
<li>H.264不断提出频繁更新，以保持压缩算法更新并为下一个挑战做好准备。 目前，它是第26个版本—于2019年6月发布。此版本对内容颜色体积、球体旋转、内容亮度信息等进行了更改。</li>
<li>H.264使用的存储空间显着减少，这对于通过IP轻松传输视频至关重要。</li>
</ul>
]]></content>
      <categories>
        <category>多媒体</category>
        <category>H264</category>
      </categories>
      <tags>
        <tag>h264</tag>
      </tags>
  </entry>
  <entry>
    <title>H265编码—Profile、Level、Tier</title>
    <url>/post/46234127.html</url>
    <content><![CDATA[<p>在H265中的Profile和Level参数表示的含义与H264中类似。</p>
<p>为了提供不同应用之间的兼容互通，HEVC&#x2F;H265定义了不同的编码<code>Profile</code>(档次)、<code>Level</code>(水平)、<code>Tier</code>(等级)</p>
<h2 id="Profile、Level、Tier三者的关系"><a href="#Profile、Level、Tier三者的关系" class="headerlink" title="Profile、Level、Tier三者的关系"></a>Profile、Level、Tier三者的关系</h2><ul>
<li><code>Profile</code>规定了码流中使用了哪些编码工具和算法</li>
<li><code>Level</code>中规定了对给定 Profile、Tier所对应的解码器处理负担和存储容量参数，主要包括采样率、分辨率、码率的最大值、压缩率的最小值、解码图像缓存区的容量(DPB)、编码图像缓存区的容量(CPB)等。</li>
<li><code>Tier</code>规定了每个水平的码率的高低。</li>
</ul>
<span id="more"></span>

<h2 id="Profile"><a href="#Profile" class="headerlink" title="Profile"></a>Profile</h2><p>常用的三个Main profile，即常规8bit像素精度的<code>Main profile</code>，支持10bit像素精度的<code>Main 10 profile</code>和支持静止图像的<code>Main Still Picture profile</code>。</p>
<p>HEVC的<em>第一个版本</em>定义了三个配置文件：</p>
<ul>
<li><code>Main Profile</code>:</li>
<li><code>Main 10 Profile</code>:</li>
<li><code>Main Still Picture Profile</code>:</li>
</ul>
<p><img data-src="/images/2022/09/h265_profile.png" alt="H265 Profile"></p>
<h2 id="Level"><a href="#Level" class="headerlink" title="Level"></a>Level</h2><p><img data-src="/images/2022/09/h265_level_limits.png" alt="h265 level limits"></p>
<h3 id="计算方法"><a href="#计算方法" class="headerlink" title="计算方法"></a>计算方法</h3><p>比如分辨率: <code>1920x1080</code>, 参考帧率:<code>60</code> 的h265码流是哪个level呢?</p>
<p>H.265的亮度(luma)图像的大小计算公式为:</p>
<ul>
<li>samples &#x3D;  width  *  height</li>
</ul>
<p>计算得：1920*1080&#x3D;2073600</p>
<p>每秒亮度采样数量为每帧samples乘以帧率.</p>
<ul>
<li>samples&#x2F;s &#x3D;samples*参考帧率</li>
</ul>
<p>计算得： 2073600*60&#x3D;124416000</p>
<p>参考<em>Rec. ITU-T H.265 v8 (08&#x2F;2021) 266页</em>查表(或上图)，得<code>1920x1080@60fps</code>的level应为<code>4.1</code></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuaXR1LmludC9yZWMvZG9sb2dpbl9wdWIuYXNwP2xhbmc9ZSZpZD1ULVJFQy1ILjI2NS0yMDIxMDgtSSEhUERGLUUmdHlwZT1pdGVtcw==">T-REC-H.265-202108-I!!PDF-E.pdf<i class="fa fa-external-link-alt"></i></span> —— pdf</li>
</ul>
]]></content>
      <categories>
        <category>多媒体</category>
        <category>H265</category>
      </categories>
      <tags>
        <tag>h265</tag>
      </tags>
  </entry>
  <entry>
    <title>[译] H.265编解码器综合指南</title>
    <url>/post/5946407e.html</url>
    <content><![CDATA[<blockquote>
<p>原文：<span class="exturl" data-url="aHR0cHM6Ly93d3cuZ3VtbGV0LmNvbS9sZWFybi93aGF0LWlzLWgyNjUv">https://www.gumlet.com/learn/what-is-h265/<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<h2 id="什么是-H-265？"><a href="#什么是-H-265？" class="headerlink" title="什么是 H.265？"></a>什么是 H.265？</h2><p>H.265 是一种视频压缩编解码器，是H.264的继承者。 它建立在类似于其前身的概念之上，但由于各地迅速采用4K内容，它变得越来越流行。 在不影响视频质量的情况下，H.265允许以其前身H.264的一半比特率进行视频压缩，使其理论上效率提高一倍。当我们将H.265压缩到与H.264相同的比特率时，我们发现H.265提供了显着改进的视频质量。 由于所有这些优势和升级，H.265使流式传输和下载4K视频变得更加容易——这在H.264中是不可能的，因为它占用了大量空间并且具有高比特率。</p>
<span id="more"></span>

<h2 id="H-265编解码器如何工作？"><a href="#H-265编解码器如何工作？" class="headerlink" title="H.265编解码器如何工作？"></a>H.265编解码器如何工作？</h2><p>H.265编解码器基于与以前的H.264标准相同的一般思路和结构。 如前所述，它的源视频由一系列由编码器编码（或压缩）的帧组成，这会产生压缩的比特流。这个压缩的比特流要么被存储，要么被共享，另一端的解码器解压比特流以创建原始的帧序列。</p>
<p>在H.265<code>编码器</code>工作方面，编码器执行的步骤包括：</p>
<ul>
<li><p>第一步是预测每个单元并执行必要的计算（即从原始图片单元中减去它）。在此步骤中，编码器接收一帧<code>16x16</code>显示像素（宏块）的视频单元。该宏块以两种方式形成预测,从当前帧（帧内预测）或从先前传输的帧（传输间）。</p>
</li>
<li><p>量化和变换残差。残差是指预测与原始图片单元之间的差异。这是通过使用离散余弦变换的近似形式来输出一组系数来完成的，每个系数都与基本模式的加权值有关。这些基础模式稍后可以组合起来以创建初始残差。</p>
</li>
<li><p>对变换后的输出、模式信息、预测信息和标头进行熵编码（即执行无损数据压缩方案）。</p>
</li>
</ul>
<p>另一方面，H.265<code>解码器</code>执行以下步骤:</p>
<ul>
<li>熵解码——即反转熵编码期间执行的步骤，并从编码的序列中提取原始元素。</li>
<li>反转变换和重新缩放。</li>
<li>预测每个单元并将其添加到逆变换的输出中</li>
<li>重建最终解码的视频图像。</li>
</ul>
<p>从本质上讲，不是对每一帧的每个像素进行编码，而是通过识别静态区域而不是逐帧变化来最小化带宽使用。这确保了编码工作可以更好地应用于每帧都在变化的区域。</p>
<p>如果我们从更技术的角度来看，从计算能力的角度来看，我们发现HEVC要求更高，但它为视频编解码提供了更加智能的方法。H.265通过寻找帧内的重叠空间来工作。有了这些信息，H.265寻找机会不在一系列帧上发送相同的信息。H.265可以发送第一个完整帧，而不是按顺序发送每个单独的图像，如果它在这些帧的空间内发现任何重复，它不会再次发送这些帧。这导致总文件大小的整体减小。从本质上讲，H.265的工作原理是提高空间和运动分辨率估计的复杂程度，从而可以阻止重复信息的发送，并且可以进一步压缩大小。</p>
<p><img data-src="/images/2022/09/h265_encoder_decoder.png" alt="H265 Encoder Decoder"></p>
<h2 id="H-265-x2F-HEVC概述"><a href="#H-265-x2F-HEVC概述" class="headerlink" title="H.265&#x2F;HEVC概述"></a>H.265&#x2F;HEVC概述</h2><p>用于视频压缩的HEVC标准有可能提供远远优于其前身（如H.264&#x2F;AVC）的性能。虽然HEVC具有与AVC和MPEG-2相同的核心结构，但它也有许多增量和急需的改进，例如：</p>
<ul>
<li>增加了分区的灵活性。</li>
<li>在转换块大小和预测模式方面具有更大的灵活性。</li>
<li>更好的插值和去块滤波器。</li>
<li>改进了模式和运动矢量的信令。</li>
<li>高效的并行处理功能。</li>
</ul>
<p>所有这些共同产生了一种视频编码格式，即使对于最高端的视频类型，它也能提供更好的压缩而不影响质量。以下是您需要了解的有关H.265视频压缩格式的其他重要方面的简要概述。</p>
<h3 id="Profile-levels-and-parameters"><a href="#Profile-levels-and-parameters" class="headerlink" title="Profile, levels, and parameters"></a>Profile, levels, and parameters</h3><p>Profile可以简单地理解为编码所需的一组工具，用于创建与该特定Profile相关的比特流。 特定Profile的编码器可以选择它需要使用的编码工具，以生成相关的比特流。 另一方面，特定Profile的解码器必须支持该Profile可以使用的所有编码工具。</p>
<blockquote>
<p>Profile:可以翻译成配置文件、档次等</p>
</blockquote>
<p>进入更多技术细节，HEVC 的第一个版本定义了三个配置文件：</p>
<ul>
<li>Main</li>
<li>Main 10</li>
<li>Main Still Picture.</li>
</ul>
<p>第二个版本添加了<code>21</code>个范围扩展Profile、一个多视图Profile和两个可扩展扩展Profile。这进一步经历了一些变化和修改。</p>
<p>在Tiers和Level方面，HEVC标准定义了两个main tiers: High和Main。 它还定义了<code>13</code>个levels。 Level本质上是比特流的一组约束。 对于低于4的级别，仅允许主层。开发这些层是为了处理具有不同最大比特率的应用程序。主层的设计考虑了大多数应用程序，而高级层则迎合了更高端的应用程序。符合给定级别&#x2F;层的解码器应该能够轻松解码为该特定级别&#x2F;层和所有较低级别&#x2F;层编码的所有比特流。</p>
<h3 id="h-265的应用"><a href="#h-265的应用" class="headerlink" title="h.265的应用"></a>h.265的应用</h3><p>H.265编解码器使用不同于H.264的<code>宏块编码方法</code>，称为<code>编码树单元 (CTU，Coding Tree Units)</code>。 CTU以更高的编码效率处理信息，并支持<code>64x64</code>宏块。这使得H.265 式在许多应用中非常有用。 一些此类应用包括：</p>
<ul>
<li>H.265支持广泛的色彩空间， 例如 NTSC、Rec. 601、PAL、通用胶片、SMPTE 170M、sRGN、sYCC 等。</li>
<li>用于下一代HDTV（高清晰度电视）显示器和内容捕获系统的无缝流媒体和数据共享。</li>
</ul>
<h3 id="为什么要进行h-265压缩？"><a href="#为什么要进行h-265压缩？" class="headerlink" title="为什么要进行h.265压缩？"></a>为什么要进行h.265压缩？</h3><p>这个问题的简单答案是<em>提高效率</em>。 编解码器在不牺牲图像质量的情况下用于压缩和解压缩图像的比特流越少，其效率就越高。从这个角度来看，H.265比H.264编解码器效率更高。除此之外，随着事物的发展，人们的观看分辨率也发生了变化，人们用于观看视频的屏幕分辨率也发生了变化。 有如此多的限制和修改，转向一种专为现代视频需求而设计的压缩技术是有意义的。</p>
<h3 id="h-265的好处"><a href="#h-265的好处" class="headerlink" title="h.265的好处"></a>h.265的好处</h3><p>总而言之，以下是H.265压缩标准提供的主要优势和改进：</p>
<ul>
<li>提供 H.264 一半的压缩比。</li>
<li>与H.264支持的16x16相比，支持64x64像素宏块。</li>
<li>视频压缩依赖于帧之间的预测运动，而H.265具有更好的运动预测机制。这导致改进的压缩标准。</li>
<li>帧间预测在H.265中比在H.264中更详细。</li>
<li>H.265支持的分辨率远高于H.264支持的8K超高清。</li>
<li>与H.264编解码器相比，H.265的比特率要低得多，从而使整个过程更加高效。</li>
</ul>
]]></content>
      <categories>
        <category>多媒体</category>
        <category>H265</category>
      </categories>
      <tags>
        <tag>h265</tag>
      </tags>
  </entry>
  <entry>
    <title>[译] H.264和H.265的区别</title>
    <url>/post/4a8fdf27.html</url>
    <content><![CDATA[<blockquote>
<p>原文： <span class="exturl" data-url="aHR0cHM6Ly93d3cuZ3VtbGV0LmNvbS9sZWFybi9oMjY0LXZzLWgyNjUv">https://www.gumlet.com/learn/h264-vs-h265/<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<p>H.264和H.265是视频流界最常用的编解码器。这是一个详细的指南，探讨了H.264和H.265之间的差异。</p>
<span id="more"></span>

<h2 id="什么是视频编解码器？"><a href="#什么是视频编解码器？" class="headerlink" title="什么是视频编解码器？"></a>什么是视频编解码器？</h2><p>术语编解码器是单词“编码器（encoder）”和“解码器（decoder）”（或“压缩器（compressor）”“解压缩器（decompressor）”）的组合。 因此，简单地说，视频编解码器是用于压缩和解压缩数字视频文件的硬件或软件——本质上是为了使它们更小并在不影响质量的情况下简化它们的传输。</p>
<p>正因为如此，视频编解码器与视频流的世界密不可分。编解码器技术有助于创建、编辑、传输和流式传输数字视频的每一步。随着流媒体的发展，编解码器及其能力也在发展。虽然有多种编解码器可用，但H.264和H.265是最常用的编解码器。因此，经常会混淆两种编解码器中的哪一种更好。 H.264与H.265的效果如何？</p>
<p>在本文中，我们将简要介绍H.264和H.265编解码器，然后我们将在以下重要参数上比较这两种编解码器：</p>
<ul>
<li>压缩比（Compression ratio）</li>
<li>视频质量（Video quality）</li>
<li>文件大小（File size）</li>
<li>兼容性（Compatibility）</li>
<li>性能（Performance）</li>
</ul>
<h2 id="什么是H-264编解码器？"><a href="#什么是H-264编解码器？" class="headerlink" title="什么是H.264编解码器？"></a>什么是H.264编解码器？</h2><p>H.264编解码器非常有用和流行。它提供复杂的压缩级别，质量损失最小。H.264也不需要极高的计算能力。这使许多计算机硬件能够对H.264的硬件或软件辅助版本的视频数据进行编码。</p>
<p>H.264，也称为高级视频编码(AVC)，通过使用基于运动压缩、面向块的视频压缩标准处理视频帧来工作。这些单元称为<code>宏块</code>，它们由16x16像素样本组成。这可以进一步细分为块和预测块。继续阅读以下文章，深入了解H.264的技术细节。</p>
<p>总体而言，H.264编解码器提供的比特率远低于其前身，并且仍被不同的流媒体源使用。</p>
<h2 id="什么是H-265编解码器？"><a href="#什么是H-265编解码器？" class="headerlink" title="什么是H.265编解码器？"></a>什么是H.265编解码器？</h2><p>H.265是H.264的升级和更高级的版本。也称为高效视频编码(HEVC)，它支持比H.264进一步减小文件（码流）的大小，因此流式传输和传输视频所需的带宽更少。</p>
<p>与H.264的宏块方法不同，H.265使用编码树单元(CTU)处理信息。宏块的限制是它们可以跨越4x4或16x16大小，但CTU可以处理多达64x64的块，这有助于提高压缩效率。除了CTU大小的这种修改之外，HEVC还支持比其前身改进的运动压缩和空间预测。因此，HEVC需要更高的计算能力才能压缩数据。请阅读以下文章，了解H.265编解码器的技术概述！</p>
<p>有了基础知识，现在让我们看看H.264与H.265编解码器之间的区别！</p>
<h2 id="H-264编解码器与H-265编解码器—它们有何不同？"><a href="#H-264编解码器与H-265编解码器—它们有何不同？" class="headerlink" title="H.264编解码器与H.265编解码器—它们有何不同？"></a>H.264编解码器与H.265编解码器—它们有何不同？</h2><p><img data-src="/images/2022/09/h264_vs_h265.png" alt="H264 vs H265"></p>
<p>以下是两种编解码器的一些重要比较点：</p>
<h3 id="压缩比"><a href="#压缩比" class="headerlink" title="压缩比"></a>压缩比</h3><p>压缩比是区分H.264和H.265编解码器的主要因素。与AVC相比，H.265（又名 HEVC）提供了<code>两倍</code>的编码效率。 这意味着HEVC在提供相同编码质量的同时节省了大约50%的比特率。更具体而言，H.265的平均比特减少在4K UHD时为65%，在1080p时为60%，在720p时为58%，在480p时为50%。</p>
<h3 id="视频质量"><a href="#视频质量" class="headerlink" title="视频质量"></a>视频质量</h3><p>H.264和H.265编解码器在相同比特率下的视频质量存在很大差异。在H.264中，块的边界可能会失真。这是因为每个宏块是固定的，每个宏块的数据是相互独立的。另一方面，使用H.265时，图像更清晰、更详细，并且具有更少的阻塞和伪影。这是因为它根据区域信息确定CTU的大小。因此，H.265在压缩时优于H.264，具有更好的图像质量。</p>
<h3 id="文件（码流）大小"><a href="#文件（码流）大小" class="headerlink" title="文件（码流）大小"></a>文件（码流）大小</h3><p>编解码器对数字视频的压缩程度与需要传输或流式传输的最终文件大小直接相关。带宽越小，文件大小越低。通常，H.264编解码器生成的视频比H.265生成的视频大<code>1-3</code>倍。 因此，在文件大小和保存大文件的有限存储空间方面，H.265胜过H.264。</p>
<h3 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h3><p>在兼容性方面，AVC胜过HEVC，与AVC相比，HEVC的普及程度相当落后。如果100个设备和平台支持H.264编解码器，您会发现只有30个相应的设备和平台支持H.265。您不能否认H.265是未来的编解码器，并且缓慢但肯定地，更多的平台和设备将适应H.265。</p>
<h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><p>关于整体性能比较，H.265无疑胜过H.264，但这并非没有它的背景。H.264具有适用于几乎所有常见设备的日常用例。然而，HEVC编码需要高计算能力。因此，HEVC可以比AVC更有效地压缩视频，同时保持相同水平的图像质量。H.264性能达不到4K流媒体的标准，但HEVC做到了这一点。</p>
<p><img data-src="/images/2022/09/h265_decode_performance.png" alt="H265 Decode Performance"></p>
<h3 id="H-264和H-265的综合比较"><a href="#H-264和H-265的综合比较" class="headerlink" title="H.264和H.265的综合比较"></a>H.264和H.265的综合比较</h3><p>除了上面讨论的之外，这里还有一些比较点来详细说明 H.264与H.265：</p>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">H.264&#x2F;AVC</th>
<th align="center">H.265&#x2F;HEVC</th>
</tr>
</thead>
<tbody><tr>
<td align="center">名字</td>
<td align="center">MPEG-4 Part 10 AVC</td>
<td align="center">MPEG-H, HEVC, Part 2</td>
</tr>
<tr>
<td align="center">发布时间</td>
<td align="center">2004</td>
<td align="center">2013</td>
</tr>
<tr>
<td align="center">继承者</td>
<td align="center">MPEG-2 Part 2</td>
<td align="center">MPEG 4 AVC, H.264</td>
</tr>
<tr>
<td align="center">用例</td>
<td align="center">蓝光光盘。<br/>从 YouTube、Vimeo等流式传输数字视频。<br/>HDTV通过有线、地面和卫星进行广播。</td>
<td align="center">高清视频:4K、8K等分辨率。</br>下一代高清电视和卫星电视。</td>
</tr>
<tr>
<td align="center">重大改进</td>
<td align="center">与前代产品相比，比特率降低了40-50%。<br/>简化了广播和在线媒体的高清内容交付。</td>
<td align="center">在不影响视频质量的情况下，比特率降低 40-50%，如 H.264。<br/>为广播和 OTT 实现 UHD、2K、4K 的潜力。</td>
</tr>
<tr>
<td align="center">规格</td>
<td align="center">最高支持 4K。<br/>最高支持 59.94 fps。<br/>21 个Profile和17个Level。</td>
<td align="center">最高支持 8K 超高清电视。<br/>最高支持 300 帧&#x2F;秒。<br/>3 个标准的Profile，13个Level。</td>
</tr>
<tr>
<td align="center">缺点</td>
<td align="center">由于高比特率要求，无法提供 4K 或 8K 内容。 帧率支持也很低。</td>
<td align="center">由于昂贵的运动估计和较大的预测单元，计算成本很高。</td>
</tr>
</tbody></table>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>简而言之，H.264和H.265编解码器的视频压缩效率不同。H.265提供比H.264更有效的资源和带宽，从而减少最终托管数字文件的服务器的压力。从长远来看，所有这些都降低了总体成本。正如您所读到的，HEVC也并非没有缺点，尽管它取得了所有进步，但它确实有一些缺点需要牢记。这些不是破坏交易的因素，但最好将它们牢记在心以全面了解它们。。</p>
<p>除了以较低的比特率提供更高的分辨率外，HEVC还提供了改进的色域，比以往任何时候都提高了图像质量。如果您当前正在使用H.264编解码器，最好为您的视频内容或视频流项目尝试H.265！</p>
]]></content>
      <categories>
        <category>多媒体</category>
        <category>H265</category>
      </categories>
      <tags>
        <tag>h264</tag>
        <tag>h265</tag>
      </tags>
  </entry>
  <entry>
    <title>ADV7611硬件特性</title>
    <url>/post/29135.html</url>
    <content><![CDATA[<p><img data-src="/images/2019/03/adv7611_function_diagram.png" alt="adv7611_function_diagram"></p>
<blockquote>
<p>HDMI接收器,用于通过HDMI接口将输入的<code>视频信号</code>转换成<code>YUV</code>或<code>RGB</code>像素数据输出</p>
</blockquote>
<span id="more"></span>

<h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul>
<li>TMDS时钟频率： 165 MHz(最大值)</li>
<li>24位输出像素总线</li>
<li>可编程HDMI均衡器</li>
<li>HDMI端口支持5 V检测和热插拔<blockquote>
<p>具体见参考文档</p>
</blockquote>
</li>
</ul>
<h2 id="EDID"><a href="#EDID" class="headerlink" title="EDID"></a>EDID</h2><blockquote>
<ul>
<li>在视频模式中，PLCK不能超过165Mhz</li>
<li>EDID扩展的128bit，主要包含音频能力和可支持视频标准的640x480像素的描述信息<ul>
<li>主要目的为HDMI源提供音频能力信息（如声道，采样率等），和所支持的视频标准信息（如色彩空间YCbCr422等）</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="硬件连接逻辑"><a href="#硬件连接逻辑" class="headerlink" title="硬件连接逻辑"></a>硬件连接逻辑</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+----------+</span><br><span class="line">|   LCD    |</span><br><span class="line">|  直接显示|</span><br><span class="line">+-^------^-+</span><br><span class="line">  |      |</span><br><span class="line">  | bus  |              +-----------+                +--------+</span><br><span class="line">+-+------+---+   bus    |           |    HDMI线      |        |</span><br><span class="line">| BT1120接口 +&lt;---------+  adv7611  +&lt;---------------+  HDMI  |</span><br><span class="line">+-+------+---+          |           |                |        |</span><br><span class="line">  | bus  |              +-----------+                +--------+</span><br><span class="line">  |      |</span><br><span class="line">+-v------v-+</span><br><span class="line">|  camera  |</span><br><span class="line">| 数据采集 |</span><br><span class="line">+----------+</span><br></pre></td></tr></table></figure>
<blockquote>
<p>CSI: CMOS Sensor Interface</p>
<ul>
<li>adv7611直接输出的是像素信息，<code>VS</code>，<code>HS</code>，<code>data[15~0]</code>，<code>PIXCLK</code></li>
</ul>
</blockquote>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuYW5hbG9nLmNvbS9jbi9wcm9kdWN0cy9hZHY3NjExLmh0bWwjcHJvZHVjdC1vdmVydmlldw==">ADV7611官网资料<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cudG9ueWxhYnMuY29tL2Rvd25sb2Fkcy9kYXRhc2hlZXQvYW5hbG9nLWRldmljZXMtYWR2NzYxMS1kYXRhc2hlZXQ=">Analog Devices ADV7611 数据手册<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuYW5hbG9nLmNvbS9tZWRpYS9lbi90ZWNobmljYWwtZG9jdW1lbnRhdGlvbi91c2VyLWd1aWRlcy9VRy0xODAucGRm">ADV7611 Reference Manual UG-180<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>多媒体</category>
        <category>HDMI</category>
      </categories>
      <tags>
        <tag>adv7611</tag>
        <tag>hdmi</tag>
      </tags>
  </entry>
  <entry>
    <title>HDMI/DVI接口显示器热插拔原理（HPD）</title>
    <url>/post/57591.html</url>
    <content><![CDATA[<p><img data-src="/images/2019/03/hdmi_cable_link.png" alt="hdmi_cable_link"></p>
<blockquote>
<p>硬件接口， <code>HDMI(19Pin)/DVI（16 pin）</code>的功能是热插拔检测<code>（HPD）</code>，这个信号将作为主机系统是否对HDMI&#x2F;DVI是否发送<code>TMDS</code>信号的依据</p>
</blockquote>
<span id="more"></span>
<p><img data-src="/images/2019/03/hdmi_and_vdi_interface.png" alt="hdmi_and_vdi_interface"></p>
<h2 id="HPD-Hot-Plug-Detection"><a href="#HPD-Hot-Plug-Detection" class="headerlink" title="HPD - (Hot Plug Detection)"></a>HPD - (Hot Plug Detection)</h2><p>HPD是从<code>显示器</code>输出送往<code>计算机主机</code>的一个检测信号.</p>
<p>作用：</p>
<blockquote>
<p>当显示器等数字显示器通过HDMI或DVI接口与计算机主机相连或断开连接时，计算机主机能够通过HDMI&#x2F;DVI的HPD引脚检测出这一事件，并做出响应</p>
</blockquote>
<h2 id="热插拔时的信号变化"><a href="#热插拔时的信号变化" class="headerlink" title="热插拔时的信号变化"></a>热插拔时的信号变化</h2><ul>
<li>HDMI&#x2F;DVI接口插入<ul>
<li>HPD: <code>low --&gt; high</code></li>
</ul>
</li>
</ul>
<blockquote>
<p>主机上的显卡检测到HPD引脚被拉高（电压大于2V），主机认为此时显示设备已连接成功。主机中的显卡将发生一个信号，通过DDC读取显示器中的存储的EDID数据，通过读取到的EDID中显示器的工作模式范围与显卡相适应，则显卡将激活TMDS信号进行数据传输。</p>
</blockquote>
<ul>
<li>HDMI&#x2F;DVI接口拔出<ul>
<li>HPD: <code>high --&gt; low</code></li>
</ul>
</li>
</ul>
<blockquote>
<p>主机上的显卡检测到HPD引脚被拉低（电压小于0.8V），表示显示设备与主机断开连接。此时主机中的显卡也会发一个信号，通知显卡关闭TMDS信号的工作。</p>
</blockquote>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuZnBnYTRmdW4uY29tL2ZpbGVzL0hETUlfRGVteXN0aWZpZWRfcmV2XzFfMDIucGRm">HDMI Demystified<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>多媒体</category>
        <category>HDMI</category>
      </categories>
      <tags>
        <tag>hdmi</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenGL Frame Buffer</title>
    <url>/post/302c8d9a.html</url>
    <content><![CDATA[<p>OpenGL中<code>Frame Buffer</code>包含多种不同类型的buffer,主要有<code>ColorBuffers</code>,<code>Z buffer</code>, <code>double-buffer</code></p>
<span id="more"></span>

<h2 id="double-buffer"><a href="#double-buffer" class="headerlink" title="double-buffer"></a>double-buffer</h2><blockquote>
<p><code>Front buffer</code> &#x3D; what is being shown on screen (the last frame)<br><code>Back buffer</code> &#x3D; where you’re currently drawing (the current frame)</p>
</blockquote>
<h2 id="Z-buffer"><a href="#Z-buffer" class="headerlink" title="Z buffer"></a>Z buffer</h2><p>Z-buffer也称为Depth Buffer存储fragment的深度，即离视点的距离</p>
<h2 id="Stencil-Buffer"><a href="#Stencil-Buffer" class="headerlink" title="Stencil Buffer"></a>Stencil Buffer</h2><p>模版缓冲（stencil buffer）或印模缓冲，是在OpenGL三维绘图等计算机图像硬件中常见的除颜色缓冲、像素缓冲、深度缓冲之外另一种数据缓冲。</p>
<p><code>stencil buffer</code>可以将绘图限制到屏幕的规定部分，比如透过窗户的场景。</p>
<h2 id="Accumulation-Buffer"><a href="#Accumulation-Buffer" class="headerlink" title="Accumulation Buffer"></a>Accumulation Buffer</h2><p>Accumulation Buffer存储的也是颜色值，这个buffer累积一些列的图像，得到一个最终图像，可用于super sampling antialiasing。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuZ2Vla3Nmb3JnZWVrcy5vcmcvei1idWZmZXItZGVwdGgtYnVmZmVyLW1ldGhvZC8=">Z-Buffer or Depth-Buffer method<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuZ2FtZWRldi5uZXQvZm9ydW1zL3RvcGljLzYxOTA1MS13aGF0LWlzLWJhY2stYW5kLWZyb250LWJ1ZmZlci8=">What is Back and Front Buffer?<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>多媒体</category>
        <category>OpenGL</category>
      </categories>
      <tags>
        <tag>opengl</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenGL中的共享上下文</title>
    <url>/post/44245d70.html</url>
    <content><![CDATA[<p>OpenGL渲染中有一个<code>线程相关</code>的上下文(Context), OpenGL所创建的资源, 其实对程序员可见的仅仅是<code>上下文ID</code>而已, 其内容依赖于这个上下文, 有时候为了方便起见, 在某个线程中创建了上下文之后, 所有的OpenGL操作都转到此线程来调用. 这样在简单的2d&#x2F;3d 渲染中尚可, 但是如果涉及复杂的OpenGL渲染时, 这样就未必足够， 事实上OpenGL已经考虑到这一点， <code>上下文是可以在多个线程间共享的</code>，在使用<code>glXCreateContext</code>或<code>eglCreateContext</code>时， 可以传入一个已创建成功的上下文， 这样就可以得到一个共享的上下文(Shared Context).</p>
<span id="more"></span>

<p>OpenGL的绘制命令都是作用在当前的Context上，这个Current Context是一个<code>线程私有（thread-local）的变量</code>，也就是说如果我们在线程中绘制，那么需要为该线程制定一个Current Context的，当多个线程参与绘制任务时，需要原线程解绑再重新绑定新的线程。多个线程不能同时指定同一个Context为Current Context，否则会导致崩溃。</p>
<h2 id="共享上下文"><a href="#共享上下文" class="headerlink" title="共享上下文"></a>共享上下文</h2><p>一个是进程可以创建多个Context，它们可以分别描绘出不同的图形界面，就像一个应用程序可以打开多个窗口一样。每个OpenGL Context是相互独立的，它们都有自己的OpenGL对象集。但有时会有场景需要多个上下文使用同一份纹理资源的情况，创建Context，意味着系统资源的占用，同一份纹理重复申请会造成资源浪费，因此OpenGL上下文允许共享一部分资源。大部分OpenGL Objects是可以共享的，包括<code>Sync Object</code>和<code>GLSL Objects</code>。<code>Container Objects</code>和<code>Query Objects</code>是不能共享的。例如纹理、shader、Buffer等资源是可以共享的，但Frame Buffer Object(FBO)、Vertex Array Object（VAO）等容器对象不可共享，但可将共享的纹理和VBO绑定到各自上下文的容器对象上。</p>
<ul>
<li>共享资源: <code>纹理</code>、<code>shader</code>、<code>Buffer</code></li>
<li>不共享资源: <code>FBO</code>, <code>VAO</code></li>
</ul>
<h2 id="EGL-Context"><a href="#EGL-Context" class="headerlink" title="EGL Context"></a>EGL Context</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">EGLContext <span class="title function_">eglCreateContext</span><span class="params">(EGLDisplay display,</span></span><br><span class="line"><span class="params">  	                        EGLConfig config,</span></span><br><span class="line"><span class="params">  	                        EGLContext share_context,</span></span><br><span class="line"><span class="params">  	                        EGLint <span class="type">const</span> * attrib_list)</span>;</span><br></pre></td></tr></table></figure>






<h2 id="GLX-Context"><a href="#GLX-Context" class="headerlink" title="GLX Context"></a>GLX Context</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">GLXContext <span class="title function_">glXCreateContext</span><span class="params">(Display * dpy,</span></span><br><span class="line"><span class="params"> 	                        XVisualInfo * vis,</span></span><br><span class="line"><span class="params"> 	                        GLXContext shareList,</span></span><br><span class="line"><span class="params"> 	                        Bool direct)</span>;</span><br></pre></td></tr></table></figure>

<p>GLX创建共享上下文：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">GLXContext currctx = glXGetCurrentContext();</span><br><span class="line">GLXFBConfig* fb_config;</span><br><span class="line"><span class="type">int</span> fb_config_id;</span><br><span class="line"><span class="type">int</span> nelements;</span><br><span class="line"><span class="type">int</span> res;</span><br><span class="line"></span><br><span class="line">XInitThreads();</span><br><span class="line"></span><br><span class="line">Display* dpy = XOpenDisplay(<span class="literal">NULL</span>);</span><br><span class="line">assert(dpy != <span class="literal">NULL</span>)</span><br><span class="line"></span><br><span class="line">res = glXQueryContext(dpy, currctx, GLX_FBCONFIG_ID, &amp;fb_config_id);</span><br><span class="line">assert(res);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> visual_attribs[] = &#123;</span><br><span class="line">    GLX_FBCONFIG_ID, fb_config_id,</span><br><span class="line">    None</span><br><span class="line">&#125;;</span><br><span class="line">fb_config = glXChooseFBConfig(dpy, DefaultScreen(dpy), visual_attribs, &amp;nelements);</span><br><span class="line">assert(fb_config);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> context_attribs[] = &#123;</span><br><span class="line">    GLX_CONTEXT_MAJOR_VERSION_ARB, <span class="number">4</span>,</span><br><span class="line">    GLX_CONTEXT_MINOR_VERSION_ARB, <span class="number">0</span>,</span><br><span class="line">    GLX_CONTEXT_PROFILE_MASK_ARB, GLX_CONTEXT_CORE_PROFILE_BIT_ARB,</span><br><span class="line">    None</span><br><span class="line">&#125;;</span><br><span class="line">GLXContext glx_share_context = glXCreateContextAttribsARB(dpy, fb_config[<span class="number">0</span>], currctx,</span><br><span class="line">        True, context_attribs);</span><br><span class="line">assert(glx_share_context);</span><br></pre></td></tr></table></figure>


<h2 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h2><p>在执行OpenGL函数之前,必须将切换到其当前的上下文进行处理</p>
<h3 id="EGL"><a href="#EGL" class="headerlink" title="EGL"></a>EGL</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">EGLBoolean <span class="title function_">eglMakeCurrent</span><span class="params">(EGLDisplay display,</span></span><br><span class="line"><span class="params">  	                      EGLSurface draw,</span></span><br><span class="line"><span class="params">  	                      EGLSurface read,</span></span><br><span class="line"><span class="params">  	                      EGLContext context)</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">eglMakeCurrent(display, EGL_NO_SURFACE, EGL_NO_SURFACE, context);</span><br></pre></td></tr></table></figure>

<h3 id="GLX"><a href="#GLX" class="headerlink" title="GLX"></a>GLX</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Bool <span class="title function_">glXMakeCurrent</span><span class="params">(Display * dpy,</span></span><br><span class="line"><span class="params"> 	                GLXDrawable drawable,</span></span><br><span class="line"><span class="params"> 	                GLXContext ctx)</span>;</span><br></pre></td></tr></table></figure>








<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cua2hyb25vcy5vcmcvcmVnaXN0cnkvRUdML3Nkay9kb2NzL21hbi9odG1sL2VnbENyZWF0ZUNvbnRleHQueGh0bWw=">https://www.khronos.org/registry/EGL/sdk/docs/man/html/eglCreateContext.xhtml<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9raHJvbm9zLm9yZy9yZWdpc3RyeS9PcGVuR0wtUmVmcGFnZXMvZ2wyLjEveGh0bWwvZ2xYQ3JlYXRlQ29udGV4dC54bWw=">https://khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glXCreateContext.xml<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cua2hyb25vcy5vcmcvcmVnaXN0cnkvRUdML3Nkay9kb2NzL21hbi9odG1sL2VnbE1ha2VDdXJyZW50LnhodG1s">https://www.khronos.org/registry/EGL/sdk/docs/man/html/eglMakeCurrent.xhtml<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cua2hyb25vcy5vcmcvcmVnaXN0cnkvT3BlbkdMLVJlZnBhZ2VzL2dsMi4xL3hodG1sL2dsWE1ha2VDdXJyZW50LnhtbA==">https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glXMakeCurrent.xml<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NoZW55aTBfMC9hcnRpY2xlL2RldGFpbHMvMTA5MzgyNTA5">OpenGL中的上下文 理解整理<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cua2hyb25vcy5vcmcvcmVnaXN0cnkvT3BlbkdMLVJlZnBhZ2VzL2dsMi4xLw==">GLX Reference Pages<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cua2hyb25vcy5vcmcvcmVnaXN0cnkvRUdML3Nkay9kb2NzL21hbi8=">EGL Reference Pages<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>多媒体</category>
        <category>OpenGL</category>
      </categories>
      <tags>
        <tag>opengl</tag>
        <tag>egl</tag>
        <tag>glx</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenGL之Sync Object</title>
    <url>/post/8528.html</url>
    <content><![CDATA[<blockquote>
<p><em>Sync Objects</em> are objects that are used to synchronize the activity between the GPU and the application. <code>glFinish</code> is a start to synchronization, but sync objects allow for much finer grained control.</p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cua2hyb25vcy5vcmcvb3BlbmdsL3dpa2kvU3luY19PYmplY3Q=">https://www.khronos.org/opengl/wiki/Sync_Object<i class="fa fa-external-link-alt"></i></span></li>
</ul>
</blockquote>
<span id="more"></span>

<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">GLsync</span> *<span class="title">GLsync</span>;</span></span><br></pre></td></tr></table></figure>

<p><code>GLsync</code>同步对象永远不会绑定到上下文，也不会像普通GL对象一样封装状态。 这些不是OpenGL对象。</p>
<p>有一个通用的glDeleteSync函数可删除任何类型的同步对象。</p>
<h2 id="图像渲染"><a href="#图像渲染" class="headerlink" title="图像渲染"></a>图像渲染</h2><p>egl为opengl的执行创建了一个上下文Context。这时Context中绑定了一个默认的Framebuffer。后续所有的渲染都是在这个framebuffer上进行的。</p>
<p>当我们调用<code>drawcall</code>来绘制一组三维物体的时候，实际上这个<code>drawcall</code>并没有立即执行，或者说并不保证立即执行了，gl库的实现也可能只是制作了一个命令队列，往这个命令队列里填加了一些命令，当你调用下一条opengl函数时，上一个函数会没有被执行，它还在排队。也就是说普通的opengl函数是异步的。</p>
<p>所有的opengl函数都是异步的肯定是不行的，有些时候我们必须保证某个函数返回时，它及它之前的函数都真正被执行了。也就是说要有一些不普通的函数，它们是同步的。比如说<code>glFinish</code>，当这个函数返回时，gl库会保证之前的命令全部都执行完毕了。</p>
<p>还有<code>glFlush</code>，gl库会立即把队列里的所有命令提交给显卡去执行一轮。<br>在glFlush和glFinsh之后的函数调用，都会落在下一轮渲染管线执行中了。</p>
<blockquote>
<p><code>drawcall</code>的标志很简单，一个<code>glDrawXXX</code>函数调用就是一个drawcall的结束标志。</p>
</blockquote>
<h2 id="同步——Synchronization"><a href="#同步——Synchronization" class="headerlink" title="同步——Synchronization"></a>同步——Synchronization</h2><p>同步对象的目的是使CPU与GPU的动作同步。为此，同步对象具有当前状态的概念。同步对象的状态可以发信号或不发信号。此状态代表GPU的某种状态，具体取决于同步对象的特定类型及其使用方式。这类似于使用互斥在线程之间同步行为的方式。当发出互斥信号时，它允许正在等待它的其他线程激活。</p>
<ul>
<li>要阻塞所有CPU操作，直到发出同步对象信号为止<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title function_">glClientWaitSync</span><span class="params">(GLsync sync, GLbitfield flags, GLuint64 timeout)</span></span><br></pre></td></tr></table></figure></li>
<li>指示GL服务器阻塞，直到发出指定的同步对象信号为止<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">glWaitSync</span><span class="params">(GLsync sync, GLbitfield flags, GLuint64 timeout)</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="接口函数"><a href="#接口函数" class="headerlink" title="接口函数"></a>接口函数</h2><h3 id="glFenceSync"><a href="#glFenceSync" class="headerlink" title="glFenceSync"></a>glFenceSync</h3><blockquote>
<p><code>glFenceSync</code> — create a new sync object and insert it into the GL command stream</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">GLsync <span class="title function_">glFenceSync</span><span class="params">(GLenum condition,</span></span><br><span class="line"><span class="params">  	             GLbitfield flags)</span>;</span><br></pre></td></tr></table></figure>
<p>glFenceSync创建一个新的fence同步对象，将fence命令插入GL命令流并将其与该同步对象相关联，并返回与该同步对象相对应的非零名称。</p>
<p>当fence命令满足了同步对象的指定条件时，GL将向该同步对象发出信号，从而使所有在同步中阻塞的glWaitSync和glClientWaitSync命令解除阻塞。 glFenceSync或关联的fence命令的执行不会影响其他任何状态。</p>
<p>条件必须为GL_SYNC_GPU_COMMANDS_COMPLETE。通过完成与同步对象相对应的fence命令以及同一命令流中的所有先前命令，可以满足此条件。在完全实现这些命令对GL客户端和服务器状态以及帧缓冲区的所有影响之前，不会发信号通知同步对象。请注意，一旦更改了相应同步对象的状态，便会完成fence命令，但是直到fence命令完成后，等待该同步对象的命令才可能被释放。</p>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">GLsync sync = glFenceSync(GL_SYNC_GPU_COMMANDS_COMPLETE, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">glWaitSync(sync, <span class="number">0</span>, GL_TIMEOUT_IGNORED);</span><br><span class="line">glDeleteSync(sync);</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cua2hyb25vcy5vcmcvb3BlbmdsL3dpa2kvU3luY19PYmplY3Q=">Sync Object<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>多媒体</category>
        <category>OpenGL</category>
      </categories>
      <tags>
        <tag>opengl</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenGL学习</title>
    <url>/post/36394.html</url>
    <content><![CDATA[<p>OpenGL中的概念与数据渲染流程：<br><img data-src="/images/2019/11/opengl_pipeline.png" alt="opengl_pipeline"></p>
<span id="more"></span>

<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="OpenGL-Context"><a href="#OpenGL-Context" class="headerlink" title="OpenGL Context"></a>OpenGL Context</h3><p>OpenGL上下文代表许多东西。上下文存储与此OpenGL实例关联的所有状态。它表示未绘制到帧缓冲区对象时渲染命令将绘制到的（潜在可见）默认帧缓冲区。将上下文视为拥有所有OpenGL的对象；当上下文被销毁时，OpenGL被销毁。</p>
<blockquote>
<p>In order for any OpenGL commands to work, a context must be current; all OpenGL commands affect the state of whichever context is current. The current context is a thread-local variable, so a single process can have several threads, each of which has its own current context. However, <strong>a single context cannot be current in multiple threads at the same time.</strong><br><span class="exturl" data-url="aHR0cHM6Ly93d3cua2hyb25vcy5vcmcvb3BlbmdsL3dpa2kvT3BlbkdMX0NvbnRleHQ=">Khronos wiki<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<h2 id="OpenGL渲染管线"><a href="#OpenGL渲染管线" class="headerlink" title="OpenGL渲染管线"></a>OpenGL渲染管线</h2><p><img data-src="/images/2019/11/gl_block_diagram.png" alt="gl_block_diagram"></p>
<p><img data-src="/images/2019/11/opengl_ops.png" alt="opengl_ops"></p>
<p><img data-src="/images/2019/11/opengl_render_pipeline.png" alt="OpenGL_render_pipeline"></p>
<ul>
<li>顶点着色</li>
<li>细分着色</li>
<li>几何着色</li>
<li>图元装配<ul>
<li>将顶点与相关的几何图元之间组织起来，准备下一步的剪切和光栅化</li>
</ul>
</li>
<li>剪切<ul>
<li>顶点可能会落到视口（viewport）之外，此时与顶点相关的图元会进行改动，保证像素不会在视口之外绘制，这个过叫剪切，全部由OpenGL自动完成</li>
</ul>
</li>
<li>光栅化<ul>
<li>更新后的图元传递到光栅化单元，生成片元。光栅化的工作是判断某一部分几何体（点，线或者三角形）所覆盖的屏幕空间</li>
</ul>
</li>
<li>片元着色<ul>
<li>通过着色器计算片元的最终颜色</li>
</ul>
</li>
<li>逐片元操作<ul>
<li>使用深度测试（depth test 或者称为z缓存）和模板测试（stencil test）的方式来决定一个片元是否是可见的</li>
</ul>
</li>
</ul>
<p><strong>顶点着色（包括细分和几何着色）决定了一个图元应该位于屏幕的什么位置；片元着色使用这些信息决定某个片元的颜色应该是什么</strong></p>
<h2 id="OpenGL可编程管线"><a href="#OpenGL可编程管线" class="headerlink" title="OpenGL可编程管线"></a>OpenGL可编程管线</h2><p>OpenGL 4.5版本的图形管线有4个阶段，还有1个通用计算阶段。</p>
<ol>
<li>顶点着色阶段（vertex shader stage）</li>
<li>细分着色阶段（tessellation shader stage）</li>
</ol>
<ul>
<li>细分控制着色器（tessellation control shader）</li>
<li>细分赋值着色器（tessellation evaluation shader）</li>
</ul>
<ol start="3">
<li>几何着色阶段（geometry shader stage）</li>
<li>片元着色阶段（fragment shader stage）</li>
<li>计算着色阶段（compute shader stage）</li>
</ol>
<h2 id="着色器"><a href="#着色器" class="headerlink" title="着色器"></a>着色器</h2><h3 id="细分控制着色器（Tessellation-Control-Shader）"><a href="#细分控制着色器（Tessellation-Control-Shader）" class="headerlink" title="细分控制着色器（Tessellation Control Shader）"></a>细分控制着色器（Tessellation Control Shader）</h3><h3 id="细分赋值着色器（Tessellation-Evaluation-Shader）"><a href="#细分赋值着色器（Tessellation-Evaluation-Shader）" class="headerlink" title="细分赋值着色器（Tessellation Evaluation Shader）"></a>细分赋值着色器（Tessellation Evaluation Shader）</h3><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><span class="exturl" data-url="aHR0cDovL3d3dy5zb25naG8uY2Evb3Blbmds">OpenGL<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9zdHVkaW9waXhsLmNvbS8yMDE3LTA1LTEzL2xpbnV4LWdyYXBoaWMtc3RhY2stYW4tb3ZlcnZpZXc=">Linux graphic stack<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vb3BlbmNhc2NhZGUvcC80NjA0NzM0Lmh0bWw=">A Simple OpenGL Shader Example<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL3d3dy5vcGVuZ2wtdHV0b3JpYWwub3JnL2NuL2JlZ2lubmVycy10dXRvcmlhbHMvdHV0b3JpYWwtMi10aGUtZmlyc3QtdHJpYW5nbGUv">opengl tutorial 教程<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9sZWFybm9wZW5nbC1jbi5naXRodWIuaW8v">Learn OpenGL【中】<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9sZWFybm9wZW5nbC5jb20v">Learn OpenGL【英】<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuc2Nzcy50Y2QuaWUvTWljaGFlbC5NYW56a2UvQ1M3MDU1L0xhYjIvU3VwZXJCaWJsZS40dGguRWQuQ2g4LTkucGRm">CHAPTER8 Texture Mapping: The Basics<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cua2hyb25vcy5vcmcvcmVnaXN0cnkvT3BlbkdML3NwZWNzL2dsL2dseDEuNC5wZGY=">OpenGLR©Graphics with the X Window System (Version 1.4)<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>多媒体</category>
        <category>OpenGL</category>
      </categories>
      <tags>
        <tag>opengl</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenGL纹理——Cubemap Texture</title>
    <url>/post/43690.html</url>
    <content><![CDATA[<blockquote>
<p>A Cubemap Texture is a texture, where each mipmap level consists of six 2D images which must be square. The 6 images represent the faces of a cube. The texture coordinate used to access a cubemap is a 3D direction vector which represents a direction from the center of the cube to the value to be accessed.<br><span class="exturl" data-url="aHR0cHM6Ly93d3cua2hyb25vcy5vcmcvb3BlbmdsL3dpa2kvQ3ViZW1hcF9UZXh0dXJl">https://www.khronos.org/opengl/wiki/Cubemap_Texture<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<span id="more"></span>

<h2 id="error"><a href="#error" class="headerlink" title="error"></a>error</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Mesa: User error: GL_INVALID_ENUM in glSamplerParameteri(pname=GL_TEXTURE_CUBE_MAP_SEAMLESS)</span><br></pre></td></tr></table></figure>
<ul>
<li><p>错误打印</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> INVALID_PNAME:</span><br><span class="line">_mesa_error(ctx, GL_INVALID_ENUM, <span class="string">&quot;glSamplerParameteri(pname=%s)\n&quot;</span>,</span><br><span class="line">        _mesa_enum_to_string(pname));</span><br></pre></td></tr></table></figure>
<blockquote>
<p>mesa:src&#x2F;mesa&#x2F;main&#x2F;samplerobj.c</p>
</blockquote>
</li>
<li><p>错误函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">glSamplerParameteri(state-&gt;ids[i], GL_TEXTURE_CUBE_MAP_SEAMLESS, templ-&gt;seamless_cube_map);</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="GL-TEXTURE-CUBE-MAP-SEAMLESS"><a href="#GL-TEXTURE-CUBE-MAP-SEAMLESS" class="headerlink" title="GL_TEXTURE_CUBE_MAP_SEAMLESS"></a>GL_TEXTURE_CUBE_MAP_SEAMLESS</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">glEnable(GL_TEXTURE_CUBE_MAP_SEAMLESS);</span><br></pre></td></tr></table></figure>


<p>立方体贴图的边界利用相邻面线性差值,消除立方体边缘的缝隙</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9sZWFybm9wZW5nbC1jbi5yZWFkdGhlZG9jcy5pby96aC9sYXRlc3QvMDQlMjBBZHZhbmNlZCUyME9wZW5HTC8wNiUyMEN1YmVtYXBzLw==">立方体贴图(Cubemap)<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>多媒体</category>
        <category>OpenGL</category>
      </categories>
      <tags>
        <tag>opengl</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenGL调试——apitrace</title>
    <url>/post/65255.html</url>
    <content><![CDATA[<p><code>apitrace</code>是一套用于调试OpenGL应用程序和驱动程序的工具，其中包括用于生成应用程序进行的所有OpenGL调用的跟踪的工具以及用于在程序执行期间重放这些跟踪并检查渲染和OpenGL状态的工具。</p>
<span id="more"></span>

<h2 id="官网"><a href="#官网" class="headerlink" title="官网"></a>官网</h2><blockquote>
<p><span class="exturl" data-url="aHR0cDovL2FwaXRyYWNlLmdpdGh1Yi5pby8=">http://apitrace.github.io<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<p>源码下载：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/janesma/apitrace.git</span><br></pre></td></tr></table></figure>

<p>ubuntu安装:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt install apitrace apitrace-gui</span><br></pre></td></tr></table></figure>

<h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><h3 id="命令行-——-apitrace"><a href="#命令行-——-apitrace" class="headerlink" title="命令行 —— apitrace"></a>命令行 —— apitrace</h3><ul>
<li><p>全部抓取</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$apitrace trace glxgears</span><br></pre></td></tr></table></figure>
<p>生成glxgears.trace文件</p>
</li>
<li><p>webgl</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./apitrace trace --api gl /usr/bin/chromium-browser https://webglsamples.org/aquarium/aquarium.html</span><br></pre></td></tr></table></figure>
</li>
<li><p>重现解析</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./apitrace replay --pgpu --pcpu --ppd chromium-browser.trace &gt; chromium-browser.retrace</span><br></pre></td></tr></table></figure>
</li>
<li><p>输出结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># call no gpu_start gpu_dura cpu_start cpu_dura vsize_start vsize_dura rss_start rss_dura pixels program name</span><br><span class="line">call 741 0 0 15358963 4741 0 0 0 0 -1 0 glViewport</span><br><span class="line">call 742 0 0 15389926 2370 0 0 0 0 -1 0 glScissor</span><br><span class="line">call 2903 0 0 125774519 8000 0 0 0 0 -1 0 glViewport</span><br><span class="line">call 2904 0 0 125802222 6223 0 0 0 0 -1 0 glScissor</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="图形-——-qapitrace"><a href="#图形-——-qapitrace" class="headerlink" title="图形 —— qapitrace"></a>图形 —— qapitrace</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$qapitrace</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$qapitrace chromium-browser.trace</span><br></pre></td></tr></table></figure>

<h4 id="profile"><a href="#profile" class="headerlink" title="profile"></a>profile</h4><p>选中工具栏Trace下的<code>Profile</code>功能，会执行与replay相同的动作，并将结果更直观的展示出来</p>
<p><img data-src="/images/2019/12/qapistrace_profile.png" alt="qapistrace-profile"></p>
<blockquote>
<p>将鼠标放到某个函数上会出现提示信息，双击会在主窗口中显示当前函数</p>
</blockquote>
<p>界面说明：</p>
<ul>
<li>第一部分<ul>
<li><code>Frames</code>: 帧号</li>
<li><code>CPU</code>: 处理器端的执行顺序和时长（用宽度表示）</li>
<li><code>GPU</code>: 显卡draw函数的执行顺序和时长</li>
<li><code>编号n</code>: 第n个shader的执行情况</li>
</ul>
</li>
<li>第二部分<ul>
<li><code>GPU</code>、<code>CPU</code>的执行时长（高度）</li>
</ul>
</li>
<li>第三部分<ul>
<li><code>Program</code>: shader的执行情况,左边编号与第一部分相对应</li>
</ul>
</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cueC5vcmcvd2lraS9FdmVudHMvWERDMjAxNi9Qcm9ncmFtL3RydWtoaW5fYXBpdHJhY2UucGRm">Apitrace OpenGL profiling view<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLnNpbWJvdC5uZXQvaW5kZXgucGhwLzIwMTcvMTIvMDkvYXBpdHJhY2Uv">使用apitrace分析OpenGL程序性能<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>多媒体</category>
        <category>OpenGL</category>
      </categories>
      <tags>
        <tag>opengl</tag>
      </tags>
  </entry>
  <entry>
    <title>Zink for OpenGL</title>
    <url>/post/27461.html</url>
    <content><![CDATA[<p><code>Zink</code>是Gallium 3D的驱动程序，主要是在vulkan上实现OpenGL API接口</p>
<blockquote>
<p>Zink is a Gallium driver that translate gallium API calls into Vulkan calls</p>
</blockquote>
<p><img data-src="/images/2020/03/mesa_gallium_zink.png" alt="mesa_gallium_zink"></p>
<span id="more"></span>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly94ZGMyMDE5Lngub3JnL2V2ZW50LzUvY29udHJpYnV0aW9ucy8zMjkvYXR0YWNobWVudHMvNDMzLzY4Ny9YREMyMDE5LVppbmstc2xpZGUtZGVjay5wZGY=">Zink: OpenGL on Vulkan<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>多媒体</category>
        <category>OpenGL</category>
      </categories>
      <tags>
        <tag>mesa</tag>
        <tag>zink</tag>
      </tags>
  </entry>
  <entry>
    <title>EDID</title>
    <url>/post/47714.html</url>
    <content><![CDATA[<blockquote>
<p>环境： ubuntu 18.04</p>
</blockquote>
<p>EDID: <span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRXh0ZW5kZWRfRGlzcGxheV9JZGVudGlmaWNhdGlvbl9EYXRh">Extended Display Identification Data<i class="fa fa-external-link-alt"></i></span></p>
<p>edid读取工具： get-edid</p>
<p>EDID的大小：<code>VGA/DVI</code>&#x3D;128Byte; <code>HDMI</code>&#x3D;256Byte</p>
<span id="more"></span>

<h2 id="get-edid"><a href="#get-edid" class="headerlink" title="get-edid"></a>get-edid</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get install read-edid edid-decode</span><br></pre></td></tr></table></figure>

<h2 id="获取EDID原始数据并存储到文件"><a href="#获取EDID原始数据并存储到文件" class="headerlink" title="获取EDID原始数据并存储到文件"></a>获取EDID原始数据并存储到文件</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo get-edid &gt; edid.bin</span><br></pre></td></tr></table></figure>

<h2 id="解析edid"><a href="#解析edid" class="headerlink" title="解析edid"></a>解析edid</h2><h3 id="在线解析"><a href="#在线解析" class="headerlink" title="在线解析"></a>在线解析</h3><blockquote>
<p>在<span class="exturl" data-url="aHR0cDovL3d3dy5lZGlkcmVhZGVyLmNvbS8=">http://www.edidreader.com/<i class="fa fa-external-link-alt"></i></span>网站可以对该数据进行在线解析。把以上128字节复制到该网站的对应数据窗口</p>
</blockquote>
<h3 id="本地解析"><a href="#本地解析" class="headerlink" title="本地解析"></a>本地解析</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">parse-edid &lt; edid.bin</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$parse-edid &lt; edid.bin</span><br><span class="line">Checksum Correct</span><br><span class="line"></span><br><span class="line">Section &quot;Monitor&quot;</span><br><span class="line">	Identifier &quot;PHL 237E7&quot;</span><br><span class="line">	ModelName &quot;PHL 237E7&quot;</span><br><span class="line">	VendorName &quot;PHL&quot;</span><br><span class="line">	# Monitor Manufactured week 24 of 2016</span><br><span class="line">	# EDID version 1.3</span><br><span class="line">	# Analog Display</span><br><span class="line">	Option &quot;SyncOnGreen&quot; &quot;true&quot;</span><br><span class="line">	DisplaySize 510 290</span><br><span class="line">	Gamma 2.20</span><br><span class="line">	Option &quot;DPMS&quot; &quot;true&quot;</span><br><span class="line">	Horizsync 30-83</span><br><span class="line">	VertRefresh 56-76</span><br><span class="line">	# Maximum pixel clock is 170MHz</span><br><span class="line">	#Not giving standard mode: 1920x1080, 60Hz</span><br><span class="line">	#Not giving standard mode: 1440x900, 60Hz</span><br><span class="line">	#Not giving standard mode: 1440x900, 75Hz</span><br><span class="line">	#Not giving standard mode: 1680x1050, 60Hz</span><br><span class="line">	#Not giving standard mode: 1280x720, 60Hz</span><br><span class="line">	#Not giving standard mode: 1280x1024, 60Hz</span><br><span class="line">	#Not giving standard mode: 1280x960, 60Hz</span><br><span class="line">	Modeline 	&quot;Mode 0&quot; 148.50 1920 2008 2052 2200 1080 1084 1089 1125 +hsync +vsync</span><br><span class="line">EndSection</span><br></pre></td></tr></table></figure>


<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># the integer after -m is the monitor id, starting from zero and incrementing by one.</span><br><span class="line">sudo get-edid -m 0 &gt; edid.bin</span><br><span class="line"></span><br><span class="line"># View the output of this command and verify you have the right monitor.</span><br><span class="line"># You can tell via the vendor, resolutions, serial number, all that jazz.</span><br><span class="line">cat edid.bin | edid-decode</span><br></pre></td></tr></table></figure>


<h3 id="Window：-EDID-Manager"><a href="#Window：-EDID-Manager" class="headerlink" title="Window： EDID Manager"></a>Window： EDID Manager</h3><p>下载：<span class="exturl" data-url="aHR0cHM6Ly9wYW4uYmFpZHUuY29tL3MvMTFWeE5CcmJ2dTQtNGRhQjdSN2h1RXc=">EDID Manager<i class="fa fa-external-link-alt"></i></span></p>
<h3 id="Window：-EDID编辑"><a href="#Window：-EDID编辑" class="headerlink" title="Window： EDID编辑"></a>Window： EDID编辑</h3><p>下载：<span class="exturl" data-url="aHR0cHM6Ly9wYW4uYmFpZHUuY29tL3MvMUV5bkpVR1EtRkhwX0J5dlk1VmhweXc=">Phoenix EDID Designer<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="示例：-Lenovo-1600x900"><a href="#示例：-Lenovo-1600x900" class="headerlink" title="示例： Lenovo 1600x900"></a>示例： Lenovo 1600x900</h2><blockquote>
<p>视频输出接口： <code>VGA</code></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00000000: 003f 3f3f 3f3f 3f00 303f 3f65 0101 0101  .??????.0??e....</span><br><span class="line">00000010: 071a 0103 6c2c 1978 2e2c c5a4 5650 3f28  ....l,.x.,..VP?(</span><br><span class="line">00000020: 0f50 543f 3f00 714f 3f3f 3f3f 3fc0 a9cf  .PT??.qO?????...</span><br><span class="line">00000030: 9500 0101 0101 302a 403f 603f 6430 1850  ......0*@?`?d0.P</span><br><span class="line">00000040: 1300 3f3f 1000 001e 0000 003f 0055 3041  ..??.......?.U0A</span><br><span class="line">00000050: 595a 3834 300a 2020 2020 0000 003f 0032  YZ840.    ...?.2</span><br><span class="line">00000060: 4b1e 5315 000a 2020 2020 2020 0000 003f  K.S...      ...?</span><br><span class="line">00000070: 004c 454e 204c 5332 3033 3377 480a 0049  .LEN LS2033wH..I</span><br><span class="line">00000080: 0a                                       .</span><br></pre></td></tr></table></figure>
<blockquote>
<p>EDID： 128-byte EDID successfully retrieved from i2c bus 0</p>
</blockquote>
<h3 id="解析：Edid-Manager"><a href="#解析：Edid-Manager" class="headerlink" title="解析：Edid Manager"></a>解析：Edid Manager</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">			Time: 11:22:16</span><br><span class="line">			Date: 2018年9月13日</span><br><span class="line">			EDID Manager Version: 1.0.0.14</span><br><span class="line">	___________________________________________________________________</span><br><span class="line"></span><br><span class="line">	Block 0 (EDID Base Block), Bytes 0 - 127,  128  BYTES OF EDID CODE:</span><br><span class="line"></span><br><span class="line">		        0   1   2   3   4   5   6   7   8   9</span><br><span class="line">		000  |  00  FF  FF  FF  FF  FF  FF  00  30  AE</span><br><span class="line">		010  |  A9  65  01  01  01  01  07  1A  01  03</span><br><span class="line">		020  |  6C  2C  19  78  2E  2C  C5  A4  56  50</span><br><span class="line">		030  |  A1  28  0F  50  54  AF  EF  00  71  4F</span><br><span class="line">		040  |  81  80  81  8A  A9  C0  A9  CF  95  00</span><br><span class="line">		050  |  01  01  01  01  30  2A  40  C8  60  84</span><br><span class="line">		060  |  64  30  18  50  13  00  B0  F0  10  00</span><br><span class="line">		070  |  00  1E  00  00  00  FF  00  55  30  41</span><br><span class="line">		080  |  59  5A  38  34  30  0A  20  20  20  20</span><br><span class="line">		090  |  00  00  00  FD  00  32  4B  1E  53  15</span><br><span class="line">		100  |  00  0A  20  20  20  20  20  20  00  00</span><br><span class="line">		110  |  00  FC  00  4C  45  4E  20  4C  53  32</span><br><span class="line">		120  |  30  33  33  77  48  0A  00  49</span><br><span class="line"></span><br><span class="line">(8-9)    	ID Manufacture Name : LEN</span><br><span class="line">(10-11)  	ID Product Code     : 65A9</span><br><span class="line">(12-15)  	ID Serial Number    : N/A</span><br><span class="line">(16)     	Week of Manufacture : 7</span><br><span class="line">(17)     	Year of Manufacture : 2016</span><br><span class="line"></span><br><span class="line">(18)     	EDID Version Number : 1</span><br><span class="line">(19)     	EDID Revision Number: 3</span><br><span class="line"></span><br><span class="line">(20)     	Video Input Definition: Analog</span><br><span class="line">			0.700, 0.000 (0.700 V p-p)</span><br><span class="line">			Separate SyncsComposite Syncs</span><br><span class="line"></span><br><span class="line">(21)     	Maximum Horizontal Image Size: 44 cm</span><br><span class="line">(22)     	Maximum Vertical Image Size  : 25 cm</span><br><span class="line">(23)     	Display Gamma                : 2.20</span><br><span class="line">(24)     	Power Management and Supported Feature(s):</span><br><span class="line">			Active Off/Very Low Power, RGB Color, sRGB, Preferred Timing Mode</span><br><span class="line"></span><br><span class="line">(25-34)  	Color Characteristics</span><br><span class="line">			Red Chromaticity   :  Rx = 0.641  Ry = 0.338</span><br><span class="line">			Green Chromaticity :  Gx = 0.315  Gy = 0.625</span><br><span class="line">			Blue Chromaticity  :  Bx = 0.159  By = 0.055</span><br><span class="line">			Default White Point:  Wx = 0.313  Wy = 0.329</span><br><span class="line"></span><br><span class="line">(35)     	Established Timings I</span><br><span class="line"></span><br><span class="line">			720 x 400 @ 70Hz (IBM, VGA)</span><br><span class="line">			640 x 480 @ 60Hz (IBM, VGA)</span><br><span class="line">			640 x 480 @ 72Hz (VESA)</span><br><span class="line">			640 x 480 @ 75Hz (VESA)</span><br><span class="line">			800 x 600 @ 56Hz (VESA)</span><br><span class="line">			800 x 600 @ 60Hz (VESA)</span><br><span class="line"></span><br><span class="line">(36)     	Established Timings II</span><br><span class="line"></span><br><span class="line">			800 x 600 @ 72Hz (VESA)</span><br><span class="line">			800 x 600 @ 75Hz (VESA)</span><br><span class="line">			832 x 624 @ 75Hz (Apple, Mac II)</span><br><span class="line">			1024 x 768 @ 60Hz (VESA)</span><br><span class="line">			1024 x 768 @ 70Hz(VESA)</span><br><span class="line">			1024 x 768 @ 75Hz (VESA)</span><br><span class="line">			1280 x 1024 @ 75Hz (VESA)</span><br><span class="line"></span><br><span class="line">(37)     	Manufacturer&#x27;s Timings (Not Used)</span><br><span class="line"></span><br><span class="line">(38-53)  	Standard Timings</span><br><span class="line"></span><br><span class="line">			1152x864 @ 75 Hz (4:3 Aspect Ratio)</span><br><span class="line">			1280x1024 @ 60 Hz (5:4 Aspect Ratio)</span><br><span class="line">			1280x1024 @ 70 Hz (5:4 Aspect Ratio)</span><br><span class="line">			1600x900 @ 60 Hz (16:9 Aspect Ratio)</span><br><span class="line">			1600x900 @ 75 Hz (16:9 Aspect Ratio)</span><br><span class="line">			1440x900 @ 60 Hz (16:10 Aspect Ratio)</span><br><span class="line"></span><br><span class="line">(54-71)  	Detailed Descriptor #1: Preferred Detailed Timing (1600x900 @ 60Hz)</span><br><span class="line"></span><br><span class="line">			Pixel Clock            : 108 MHz</span><br><span class="line">			Horizontal Image Size  : 432 mm</span><br><span class="line">			Vertical Image Size    : 240 mm</span><br><span class="line">			Refresh Mode           : Non-interlaced</span><br><span class="line">			Normal Display, No Stereo</span><br><span class="line"></span><br><span class="line">			Horizontal:</span><br><span class="line">				Active Time     : 1600 Pixels</span><br><span class="line">				Blanking Time   : 200 Pixels</span><br><span class="line">				Sync Offset     : 24 Pixels</span><br><span class="line">				Sync Pulse Width: 80 Pixels</span><br><span class="line">				Border          : 0 Pixels</span><br><span class="line">				Frequency       : 60 kHz</span><br><span class="line"></span><br><span class="line">			Vertical:</span><br><span class="line">				Active Time     : 900 Lines</span><br><span class="line">				Blanking Time   : 100 Lines</span><br><span class="line">				Sync Offset     : 1 Lines</span><br><span class="line">				Sync Pulse Width: 3 Lines</span><br><span class="line">				Border          : 0 Lines</span><br><span class="line"></span><br><span class="line">			Digital Separate, Horizontal Polarity (+), Vertical Polarity (+)</span><br><span class="line"></span><br><span class="line">			Modeline: &quot;1600x900&quot; 108.000 1600 1624 1704 1800 900 901 904 1000 +hsync +vsync</span><br><span class="line"></span><br><span class="line">(72-89)  	Detailed Descriptor #2: Monitor Serial Number</span><br><span class="line"></span><br><span class="line">			Monitor Serial Number: U0AYZ840</span><br><span class="line"></span><br><span class="line">(90-107) 	Detailed Descriptor #3: Monitor Range Limits</span><br><span class="line"></span><br><span class="line">			Horizontal Scan Range: 30kHz-83kHz</span><br><span class="line">			Vertical Scan Range  : 50Hz-75Hz</span><br><span class="line">			Supported Pixel Clock: 210 MHz</span><br><span class="line">			Secondary GTF        : Not Supported</span><br><span class="line"></span><br><span class="line">(108-125)	Detailed Descriptor #4: Monitor Name</span><br><span class="line"></span><br><span class="line">			Monitor Name: LEN LS2033wH</span><br><span class="line"></span><br><span class="line">(126-127)	Extension Flag and Checksum</span><br><span class="line"></span><br><span class="line">			Extension Block(s)  : 0</span><br><span class="line">			Checksum Value      : 73</span><br><span class="line"></span><br><span class="line">	___________________________________________________________________</span><br></pre></td></tr></table></figure>
<ul>
<li><code>Horizontal</code>: 水平方向</li>
<li><code>Vertical</code>： 垂直方向</li>
<li><code>Active Time</code>： 有效区域</li>
<li><code>Blanking Time</code>： 空白区域（包括上部和底部，或者是左边和右边的和）</li>
</ul>
<h3 id="Pixel-Clock"><a href="#Pixel-Clock" class="headerlink" title="Pixel Clock"></a>Pixel Clock</h3><p>Pixel clock：像素时脉(Pixel clock)指的是用来划分进来的影像水平线里的个别画素，Pixel clock会将每一条水平线分成取样的样本，越高频率的Pixel clock，每条扫瞄线会有越多的样本画素。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pixclock = 1/dotclock</span><br></pre></td></tr></table></figure>
<blockquote>
<p>dotclock是视频硬件在显示器上绘制像素的速率</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dotclock = Htotal × Vtotal × framerate</span><br></pre></td></tr></table></figure>
<ul>
<li><code>Htotal</code>: 水平方向上的所有像素点，（Active Time + Blanking Time）</li>
<li><code>Vtotal</code>: 垂直方向上的所有像素点，（Active Time + Blanking Time）</li>
<li><code>framerate</code>: 帧数</li>
</ul>
<h4 id="示例中的Pixel-Clock"><a href="#示例中的Pixel-Clock" class="headerlink" title="示例中的Pixel Clock"></a>示例中的Pixel Clock</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Pixel Clock = 60 x (1600 + 200) x (900 + 100) = 108000000Hz = 108Mhz</span><br></pre></td></tr></table></figure>
<h2 id="扩展EDID-E-EDID"><a href="#扩展EDID-E-EDID" class="headerlink" title="扩展EDID - E-EDID"></a>扩展EDID - E-EDID</h2><blockquote>
<p>大小<code>256Byte</code>， 追加一个128Byte的block， 在Block0中的 <code>Extension Block(s)  : 1</code></p>
</blockquote>
<p><img data-src="/images/2019/03/edid_cea_version3.png" alt="edid_CEA_version3"></p>
<h3 id="数据块-–-index-x3D-4"><a href="#数据块-–-index-x3D-4" class="headerlink" title="数据块 – index&#x3D;4"></a>数据块 – index&#x3D;4</h3><p>在EDID的扩展块中，第四个字节开始，后的数据块是可变长的部分。</p>
<p><img data-src="/images/2019/03/edid_cea_data_block.png" alt="edid_CEA_data_block"></p>
<ul>
<li>子数据块头部格式：</li>
</ul>
<p><img data-src="/images/2019/03/edid_cea_data_block_head.png" alt="EDID_CEA_data_block_head"></p>
<ul>
<li>数据标签</li>
</ul>
<p><img data-src="/images/2019/03/edid_cea_data_block_head_tag.png" alt="EDID_CEA_data_block_head_tag"></p>
<h4 id="Video-Data-Block"><a href="#Video-Data-Block" class="headerlink" title="Video Data Block"></a>Video Data Block</h4><p>主要存储SVD（Short Video Description）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Video Data Block</span><br><span class="line"></span><br><span class="line">640x480p @ 59.94/60Hz - EDTV (4:3, 1:1)</span><br><span class="line">720x480p @ 59.94/60Hz - EDTV (16:9, 32:27)</span><br><span class="line">1280x720p @ 59.94/60Hz - HDTV (16:9, 1:1) [Native]</span><br></pre></td></tr></table></figure>

<h4 id="Audio-Data-Block"><a href="#Audio-Data-Block" class="headerlink" title="Audio Data Block"></a>Audio Data Block</h4><p>进行短音频描述（short audio description）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Audio Data Block</span><br><span class="line"></span><br><span class="line">Audio Format #1    : LPCM, 2-Channel, 24-Bit, 20-Bit, 16-Bit</span><br><span class="line">Sampling Frequency : 48 kHz, 44.1 kHz, 32 kHz</span><br><span class="line"></span><br><span class="line">Audio Format #2    : AC-3, 2-Channel, 640 k Max bit rate</span><br><span class="line">Sampling Frequency : 96 kHz, 48 kHz, 44.1 kHz, 32 kHz</span><br></pre></td></tr></table></figure>

<h4 id="Speaker-Allocation-Data-Block-–-SADB"><a href="#Speaker-Allocation-Data-Block-–-SADB" class="headerlink" title="Speaker Allocation Data Block – SADB"></a>Speaker Allocation Data Block – SADB</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Speaker Allocation Data Block (SADB)</span><br><span class="line"></span><br><span class="line">Front Left/Front Right Audio Channel (FL/FR)</span><br></pre></td></tr></table></figure>

<h4 id="Vendor-Specific-Data-Block-–-VSDB"><a href="#Vendor-Specific-Data-Block-–-VSDB" class="headerlink" title="Vendor Specific Data Block – VSDB"></a>Vendor Specific Data Block – VSDB</h4><p><img data-src="/images/2019/03/edid_cea_vasb.png" alt="EDID_CEA_VASB"></p>
<p>供应商指定的特定数据块，其中可以标识出数据接口是HDMI还是DVI接口。</p>
<p>HDMI的源端可以检查是否为合理的HDMI VSDB，然后包含有IEEE Registration Identifier登记识别符号<code>0x000C03</code>，就可以判断为HDMI装置，而不是DVI装置。</p>
<blockquote>
<p>In order to determine if a sink is an HDMI device, an HDMI Source shall check the E-EDID for the<br>presence of an HDMI Vendor Specific Data Block within the first CEA Extension. Any device with<br>an HDMI VSDB of any valid length, containing the IEEE Registration Identifier of <code>0x000C03</code>, shall<br>be treated as an HDMI device.<br>Any device with an E-EDID that does not contain a CEA Extension or does not contain an HDMI<br>VSDB of any valid length shall be treated by the Source as a DVI device (see Appendix C).</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Vendor Specific Data Block (VSDB)</span><br><span class="line"></span><br><span class="line">IEEE Registration Identifier: 0x000C03</span><br><span class="line">CEC Physical Address        : 0x0030</span><br><span class="line">Maximum TMDS Clock          : 165MHz</span><br></pre></td></tr></table></figure>

<h2 id="首选最佳分辨率"><a href="#首选最佳分辨率" class="headerlink" title="首选最佳分辨率"></a>首选最佳分辨率</h2><blockquote>
<p>A.2.10.1 First Detailed Timing Descriptor<br>The VESA E-EDID Standard [10] requires that the First Detailed Timing Descriptor be used for the most<br><code>“preferred”</code> video format and subsequent detailed timing descriptors are listed in order of decreasing<br>preference.</p>
</blockquote>
<blockquote>
<p>All DTDs and SVDs shall be listed in order of priority; meaning that the first is the one that the display<br>manufacturer has identified as optimal.</p>
</blockquote>
<blockquote>
<p>The first 18 Byte Descriptor Block shall contain the preferred timing mode. The display manufacturer<br>defines the “Preferred Timing Mode (PTM)” as the video timing mode that will produce the best quality<br>image on the display’s viewing screen.</p>
</blockquote>
<h2 id="解析工具"><a href="#解析工具" class="headerlink" title="解析工具"></a>解析工具</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9jb2RpbmcubmV0L3UvV2luZGRvaW5nL3Avc29mdHdhcmVfdG9vbHMvZ2l0L3Jhdy9tYXN0ZXIvZWRpZF9tYW5hZ2VydjF4MC56aXA=">edid_manager<i class="fa fa-external-link-alt"></i></span> — 获取即解析EDID</li>
<li><span class="exturl" data-url="aHR0cHM6Ly9jb2RpbmcubmV0L3UvV2luZGRvaW5nL3Avc29mdHdhcmVfdG9vbHMvZ2l0L3Jhdy9tYXN0ZXIvc2V0dXBfRUVkaXRaLTBwOTYuemlw">EEditZ<i class="fa fa-external-link-alt"></i></span> — 编辑即解析EDID</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><span class="exturl" data-url="aHR0cDovL3JlYWQucHVkbi5jb20vZG93bmxvYWRzMjIyL2RvYy8xMDQ2MTI5L0NFQTg2MUQucGRm">EDID CEA Standard<i class="fa fa-external-link-alt"></i></span> – 规范</li>
<li><span class="exturl" data-url="aHR0cHM6Ly9lbmdpbmVlcmluZy5wdXJkdWUuZWR1L2VjZTQ3Ny9BcmNoaXZlLzIwMTIvU3ByaW5nL1MxMi1HcnAxMC9EYXRhc2hlZXRzL0NFQ19IRE1JX1NwZWNpZmljYXRpb24ucGRm">High-Definition Multimedia Interface Specification Version 1.3<i class="fa fa-external-link-alt"></i></span> – VSDB</li>
<li><span class="exturl" data-url="aHR0cDovL3JlYWQucHVkbi5jb20vZG93bmxvYWRzMTEwL2Vib29rLzQ1NjAyMC9FLUVESUQlMjBTdGFuZGFyZC5wZGY=">E-EDID Standard<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2J1bGxldG1hcmsvZWRpZC1ydw==">修改显示器EDID工具(源码)<i class="fa fa-external-link-alt"></i></span>)</li>
<li><span class="exturl" data-url="aHR0cDovL2h1YnBhZ2VzLmNvbS90ZWNobm9sb2d5L2hvdy10by1yZWZsYXNoLWEtbW9uaXRvcnMtY29ycnVwdGVkLWVkaWQ=">http://hubpages.com/technology/how-to-reflash-a-monitors-corrupted-edid //读取和修改显示器的EDID<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dhbnNodXl1L2FydGljbGUvZGV0YWlscy8zODg0NDk2Mw==">EDID使用说明<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hhb3hpbmdoZW5nL2FydGljbGUvZGV0YWlscy81MTU4NjA3MA==">EDID标准简介<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>多媒体</category>
        <category>edid</category>
      </categories>
      <tags>
        <tag>edid</tag>
      </tags>
  </entry>
  <entry>
    <title>mesa框架与目录结构</title>
    <url>/post/39ae47e2.html</url>
    <content><![CDATA[<p><code>mesa</code>在平台实现OpenGL接口的实现.官网:<span class="exturl" data-url="aHR0cHM6Ly9tZXNhM2Qub3JnLw==">https://mesa3d.org<i class="fa fa-external-link-alt"></i></span></p>
<span id="more"></span>

<p>由于工作原因接触到mesa,在这里主要记录一下最近对mesa整体框架的一些认识和其整个目录的结构,可能有些理解错误以后慢慢更新.</p>
<ul>
<li>整体框架组成</li>
<li>目录结构</li>
</ul>
<p>mesa版本:<code>20.2.0-devel</code>(代码库最新代码)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone https://gitlab.freedesktop.org/mesa/mesa.git</span><br></pre></td></tr></table></figure>

<h2 id="mesa框架"><a href="#mesa框架" class="headerlink" title="mesa框架"></a>mesa框架</h2><h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><ul>
<li><strong>docs</strong> - Documentation</li>
<li><strong>include</strong> - Public OpenGL header files</li>
<li><strong>src</strong><ul>
<li><strong>amd</strong> - AMD-specific sources<ul>
<li><strong>addrlib</strong> - common sources for creating images</li>
<li><strong>common</strong> - common code between RADV, radeonsi and ACO</li>
<li><strong>compiler</strong> - ACO shader compiler</li>
<li><strong>llvm</strong> - common code between RADV and radeonsi for compiling shaders using LLVM</li>
<li><strong>registers</strong> - register definitions</li>
<li><strong>vulkan</strong> - RADV Vulkan implementation for AMD Southern Island and newer</li>
</ul>
</li>
<li><strong>compiler</strong> - Common utility sources for different compilers.<ul>
<li><strong>glsl</strong> - the GLSL IR and compiler</li>
<li><strong>nir</strong> - the NIR IR and compiler</li>
<li><strong>spirv</strong> - the SPIR-V compiler</li>
</ul>
</li>
<li><strong>egl</strong> - EGL library sources<ul>
<li><strong>drivers</strong> - EGL drivers</li>
<li><strong>main</strong> - main EGL library implementation. This is where all the EGL API functions are implemented, like eglCreateContext().</li>
</ul>
</li>
<li><strong>freedreno</strong> - Adreno-specific sources<ul>
<li><strong>fdl</strong> - mipmap layout manager</li>
<li><strong>vulkan</strong> - Turnip is a Vulkan implementation for Qualcomm Adreno</li>
</ul>
</li>
<li><strong>gbm</strong> - Generic Buffer Manager is a memory allocator for device buffers</li>
<li><strong>intel</strong> - Intel-specific sources<ul>
<li><strong>blorp</strong> - BLit Or Resolve Pass is a blit and HiZ resolve framework</li>
<li><strong>vulkan</strong> - Anvil is a Vulkan implementation for Intel gen 7 (Ivy Bridge) and newer</li>
</ul>
</li>
<li><strong>mapi</strong> - Mesa APIs<ul>
<li><strong>glapi</strong> - OpenGL API dispatch layer. This is where all the GL entrypoints like glClear, glBegin, etc. are generated, as well as the GL dispatch table. All GL function calls jump through the dispatch table to functions found in main&#x2F;.</li>
</ul>
</li>
<li><strong>mesa</strong> - Main Mesa sources<ul>
<li><strong>main</strong> - The core Mesa code (mainly state management)</li>
<li><strong>drivers</strong> - Mesa drivers (not used with Gallium)<ul>
<li><strong>common</strong> - code which may be shared by all drivers</li>
<li><strong>dri</strong> - Direct Rendering Infrastructure drivers<ul>
<li><strong>common</strong> - code shared by all DRI drivers</li>
<li><strong>i915</strong> - driver for Intel i915&#x2F;i945</li>
<li><strong>i965</strong> - driver for Intel i965</li>
<li><strong>nouveau</strong> - driver for nVidia nv04&#x2F;nv10&#x2F;nv20</li>
<li><strong>radeon</strong> - driver for ATI R100</li>
<li><strong>r200</strong> - driver for ATI R200</li>
<li><strong>swrast</strong> - software rasterizer driver that uses the swrast module</li>
</ul>
</li>
<li><strong>x11</strong> - Xlib-based software driver</li>
<li><strong>osmesa</strong> - off-screen software driver</li>
</ul>
</li>
<li><strong>math</strong> - vertex array translation and transformation code (not used with Gallium)</li>
<li><strong>program</strong> - Vertex&#x2F;fragment shader and GLSL compiler code</li>
<li><strong>sparc</strong> - Assembly code&#x2F;optimizations for SPARC systems (not used with Gallium)</li>
<li><strong>state_tracker</strong> - Translator from Mesa to Gallium. This is basically a Mesa device driver that speaks to Gallium. This directory may be moved to src&#x2F;mesa&#x2F;drivers&#x2F;gallium at some point.</li>
<li><strong>swrast</strong> - Software rasterization module. For drawing points, lines, triangles, bitmaps, images, etc. in software. (not used with Gallium)</li>
<li><strong>swrast_setup</strong> - Software primitive setup. Does things like polygon culling, glPolygonMode, polygon offset, etc. (not used with Gallium)</li>
<li><strong>tnl</strong> - Software vertex Transformation ‘n Lighting. (not used with Gallium)</li>
<li><strong>tnl_dd</strong> - TNL code for device drivers. (not used with Gallium)</li>
<li><strong>vbo</strong> - Vertex Buffer Object code. All drawing with glBegin&#x2F;glEnd, glDrawArrays, display lists, etc. goes through this module. The results is a well-defined set of vertex arrays which are passed to the device driver (or tnl module) for rendering.</li>
<li><strong>x86</strong> - Assembly code&#x2F;optimizations for 32-bit x86 systems (not used with Gallium)</li>
<li><strong>x86-64</strong> - Assembly code&#x2F;optimizations for 64-bit x86 systems (not used with Gallium)</li>
</ul>
</li>
<li><strong>gallium</strong> - Gallium3D source code<ul>
<li><strong>include</strong> - Gallium3D header files which define the Gallium3D interfaces</li>
<li><strong>drivers</strong> - Gallium3D device drivers<ul>
<li><strong>etnaviv</strong> - Driver for Vivante.</li>
<li><strong>freedreno</strong> - Driver for Qualcomm Adreno.</li>
<li><strong>i915</strong> - Driver for Intel i915&#x2F;i945.</li>
<li><strong>iris</strong> - Driver for Intel gen 8 (Broadwell) and newer.</li>
<li><strong>lima</strong> - Driver for ARM Mali-400 (Utgard) series.</li>
<li><strong>llvmpipe</strong> - Software driver using LLVM for runtime code generation.</li>
<li><strong>nouveau</strong> - Driver for NVIDIA GPUs.</li>
<li><strong>panfrost</strong> - Driver for ARM Mali Txxx (Midgard) and Gxx (Bifrost) GPUs.</li>
<li><strong>radeon</strong> - Shared module for the r600 and radeonsi drivers.</li>
<li><strong>r300</strong> - Driver for ATI R300 - R500.</li>
<li><strong>r600</strong> - Driver for ATI&#x2F;AMD R600 - Northern Island (Terascale).</li>
<li><strong>radeonsi</strong> - Driver for AMD Southern Island and newer (GCN, RDNA).</li>
<li><strong>softpipe</strong> - Software reference driver.</li>
<li><strong>svga</strong> - Driver for VMware’s SVGA virtual GPU.</li>
<li><strong>swr</strong> - Software driver with massively parellel vertex processing.</li>
<li><strong>tegra</strong> - Driver for NVIDIA Tegra GPUs.</li>
<li><strong>v3d</strong> - Driver for Broadcom VideoCore 5 and newer.</li>
<li><strong>vc4</strong> - Driver for Broadcom VideoCore 4.</li>
<li><strong>virgl</strong> - Driver for Virtio virtual GPU of QEMU.</li>
<li><strong>zink</strong> - Driver that uses Vulkan for rendering.</li>
</ul>
</li>
<li><strong>auxiliary</strong> - Gallium support code<ul>
<li><strong>pipe-loader</strong> - provides device enumeration and creation of winsys&#x2F;pipe_screen instances. 用于加载driver&#x2F;winsys</li>
<li><strong>cso_cache</strong> - Constant State Objects Cache. Used to filter out redundant state changes between frontends and drivers.</li>
<li><strong>draw</strong> - Software vertex processing and primitive assembly module. This includes vertex program execution, clipping, culling and optional stages for drawing wide lines, stippled lines, polygon stippling, two-sided lighting, etc. Intended for use by drivers for hardware that does not have vertex shaders. Geometry shaders will also be implemented in this module.</li>
<li><strong>gallivm</strong> - LLVM module for Gallium. For LLVM-based compilation, optimization and code generation for TGSI shaders. Incomplete.</li>
<li><strong>hud</strong> - Heads-Up Display, an overlay showing GPU statistics</li>
<li><strong>pipebuffer</strong> - utility module for managing buffers</li>
<li><strong>rbug</strong> - Gallium remote debug utility</li>
<li><strong>rtasm</strong> - run-time assembly&#x2F;machine code generation. Currently there’s run-time code generation for x86&#x2F;SSE, PowerPC and Cell SPU.</li>
<li><strong>tessellator</strong>- used by software drivers to implement tessellation shaders</li>
<li><strong>tgsi</strong> - TG Shader Infrastructure. Code for encoding, manipulating and interpreting GPU programs.</li>
<li><strong>translate</strong> - module for translating vertex data from one format to another.</li>
<li><strong>util</strong> - assorted utilities for arithmetic, hashing, surface creation, memory management, 2D blitting, simple rendering, etc.</li>
<li><strong>vl</strong> - utility code for video decode&#x2F;encode</li>
<li>XXX more</li>
</ul>
</li>
<li><strong>frontends</strong> - These implement various libraries using the device drivers(各种使用设备驱动的用户空间库)<ul>
<li><strong>clover</strong> - OpenCL frontend</li>
<li><strong>dri</strong> - Meta frontend for DRI drivers, see mesa&#x2F;state_tracker(前端驱动的接口)</li>
<li><strong>glx</strong> - Meta frontend for GLX</li>
<li><strong>hgl</strong> - Haiku OpenGL</li>
<li><strong>nine</strong> - D3D9 frontend, see targets&#x2F;d3dadapter9</li>
<li><strong>omx</strong> - OpenMAX Bellagio frontend</li>
<li><strong>osmesa</strong> - Off-screen OpenGL rendering library</li>
<li><strong>va</strong> - VA-API frontend</li>
<li><strong>vdpau</strong> - VDPAU frontend</li>
<li><strong>wgl</strong> - Windows WGL frontend</li>
<li><strong>xa</strong> - XA frontend</li>
<li><strong>xvmc</strong> - XvMC frontend</li>
</ul>
</li>
<li><strong>winsys</strong> - The device drivers are platform-independent, the winsys connects them to various platforms. There is usually one winsys per device family, and within the winsys directory there can be multiple flavors connecting to different platforms.<ul>
<li><strong>drm</strong> - Direct Rendering Manager on Linux</li>
<li><strong>gdi</strong> - Windows</li>
<li><strong>xlib</strong> - indirect rendering on X Window System</li>
<li>XXX more</li>
</ul>
</li>
<li><strong>targets</strong> - These control how the Gallium code is compiled into different libraries. Each of these roughly corresponds to one frontend.<ul>
<li><strong>d3dadapter9</strong> - d3dadapter9.so for Wine</li>
<li><strong>dri</strong> - libgallium_dri.so loaded by libGL.so</li>
<li><strong>graw</strong> - raw gallium interface without a frontend</li>
<li>XXX more</li>
</ul>
</li>
</ul>
</li>
<li><strong>glx</strong> - The GLX library code for building libGL.so using DRI drivers.</li>
<li><strong>loader</strong> - Used by libGL.so to find and load the appropriate DRI driver.</li>
<li><strong>panfrost</strong> - Panfrost-specific sources<ul>
<li><strong>bifrost</strong> - shader compiler for the Bifrost generation GPUs</li>
<li><strong>midgard</strong> - shader compiler for the Midgard generation GPUs</li>
<li><strong>pandecode</strong> - command stream debugger</li>
</ul>
</li>
<li><strong>util</strong> - Various utility codes</li>
<li><strong>vulkan</strong> - Common code for Vulkan drivers</li>
</ul>
</li>
</ul>
<blockquote>
<p>From: <span class="exturl" data-url="aHR0cHM6Ly9kb2NzLm1lc2EzZC5vcmcvc291cmNldHJlZS5odG1s">https://docs.mesa3d.org/sourcetree.html<i class="fa fa-external-link-alt"></i></span>  time:2020-07-14</p>
</blockquote>
]]></content>
      <categories>
        <category>多媒体</category>
        <category>mesa</category>
      </categories>
      <tags>
        <tag>gpu</tag>
        <tag>mesa</tag>
        <tag>opengl</tag>
      </tags>
  </entry>
  <entry>
    <title>mesa调试——运行时函数栈的打印</title>
    <url>/post/1987c89c.html</url>
    <content><![CDATA[<p>阅读mesa代码时，追踪一些函数的调用关系，但是由于mesa的编译选项的不同导致一些函数调用流程存在差异。在编译的配置选项中发现了<code>-Dlibunwind=true</code>，mesa应该提供了函数调用栈打印的接口，接口如下：</p>
<span id="more"></span>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">debug_stack_frame</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> HAVE_LIBUNWIND</span></span><br><span class="line">   <span class="type">unw_word_t</span> start_ip;</span><br><span class="line">   <span class="type">unsigned</span> <span class="type">int</span> off;</span><br><span class="line">   <span class="type">const</span> <span class="type">char</span> *procname;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">   <span class="type">const</span> <span class="type">void</span> *function;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">debug_backtrace_capture</span><span class="params">(<span class="keyword">struct</span> debug_stack_frame *backtrace,</span></span><br><span class="line"><span class="params">                        <span class="type">unsigned</span> start_frame,</span></span><br><span class="line"><span class="params">                        <span class="type">unsigned</span> nr_frames)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">debug_backtrace_dump</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> debug_stack_frame *backtrace,</span></span><br><span class="line"><span class="params">                     <span class="type">unsigned</span> nr_frames)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">debug_backtrace_print</span><span class="params">(FILE *f,</span></span><br><span class="line"><span class="params">                      <span class="type">const</span> <span class="keyword">struct</span> debug_stack_frame *backtrace,</span></span><br><span class="line"><span class="params">                      <span class="type">unsigned</span> nr_frames)</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>file: src&#x2F;gallium&#x2F;auxiliary&#x2F;util&#x2F;u_debug_stack.h</p>
</blockquote>
<h2 id="添加函数栈打印接口"><a href="#添加函数栈打印接口" class="headerlink" title="添加函数栈打印接口"></a>添加函数栈打印接口</h2><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="comment">--- a/src/gallium/drivers/virgl/virgl_context.c</span></span><br><span class="line"><span class="comment">+++ b/src/gallium/drivers/virgl/virgl_context.c</span></span><br><span class="line"><span class="meta">@@ -1471,6 +1471,9 @@</span> struct pipe_context *virgl_context_create(struct pipe_screen *pscreen,</span><br><span class="line">       return NULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="addition">+   debug_backtrace_capture(vctx-&gt;create_backtrace, 1, VIRGL_DEBUG_CREATE_BACKTRACE);</span></span><br><span class="line"><span class="addition">+   debug_backtrace_dump(vctx-&gt;create_backtrace, VIRGL_DEBUG_CREATE_BACKTRACE);</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line">    vctx-&gt;base.destroy = virgl_context_destroy;</span><br><span class="line">    vctx-&gt;base.create_surface = virgl_create_surface;</span><br><span class="line">    vctx-&gt;base.surface_destroy = virgl_surface_destroy;</span><br><span class="line"><span class="comment">diff --git a/src/gallium/drivers/virgl/virgl_context.h b/src/gallium/drivers/virgl/virgl_context.h</span></span><br><span class="line"><span class="comment">index 8ea3e1e2f6e..1dbfd41573e 100644</span></span><br><span class="line"><span class="comment">--- a/src/gallium/drivers/virgl/virgl_context.h</span></span><br><span class="line"><span class="comment">+++ b/src/gallium/drivers/virgl/virgl_context.h</span></span><br><span class="line"><span class="meta">@@ -31,6 +31,8 @@</span></span><br><span class="line"> #include &quot;virgl_staging_mgr.h&quot;</span><br><span class="line"> #include &quot;virgl_transfer_queue.h&quot;</span><br><span class="line"></span><br><span class="line"><span class="addition">+#include &quot;util/u_debug_stack.h&quot;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"> struct pipe_screen;</span><br><span class="line"> struct tgsi_token;</span><br><span class="line"> struct u_upload_mgr;</span><br><span class="line"><span class="meta">@@ -66,11 +68,15 @@</span> struct virgl_shader_binding_state &#123;</span><br><span class="line">    uint32_t image_enabled_mask;</span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="addition">+#define VIRGL_DEBUG_CREATE_BACKTRACE 15</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"> struct virgl_context &#123;</span><br><span class="line">    struct pipe_context base;</span><br><span class="line">    struct virgl_cmd_buf *cbuf;</span><br><span class="line">    unsigned cbuf_initial_cdw;</span><br><span class="line"></span><br><span class="line"><span class="addition">+   struct debug_stack_frame create_backtrace[VIRGL_DEBUG_CREATE_BACKTRACE];</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line">    struct virgl_shader_binding_state shader_bindings[PIPE_SHADER_TYPES];</span><br><span class="line">    struct pipe_shader_buffer atomic_buffers[PIPE_MAX_HW_ATOMIC_BUFFERS];</span><br><span class="line">    uint32_t atomic_buffer_enabled_mask;</span><br></pre></td></tr></table></figure>

<p>这是是想获取<code>virgl_context_create</code>函数的调用栈，因此将<code>debug_backtrace_capture</code>和<code>debug_backtrace_dump</code>接口加在了同一个位置，其实<code>debug_backtrace_dump</code>接口也可以加到后续调用的函数中</p>
<p><strong>注</strong>：目前我在window系统中使用这些接口无法打印函数栈信息</p>
<ul>
<li>函数调用栈</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/home/out/lib/x86_64-linux-gnu/dri/swrast_dri.so(+0xe20b5) (st_api_create_context+0x22a) [0x7f4bb8a000b5]</span><br><span class="line">/home/out/lib/x86_64-linux-gnu/dri/swrast_dri.so(+0xd07c6) (dri_create_context+0x477) [0x7f4bb89ee7c6]</span><br><span class="line">/home/out/lib/x86_64-linux-gnu/dri/swrast_dri.so(+0x85c327) (driCreateContextAttribs+0x499) [0x7f4bb917a327]</span><br><span class="line">/home/out/lib/x86_64-linux-gnu/dri/swrast_dri.so(+0x85c3be) (driCreateNewContextForAPI+0x59) [0x7f4bb917a3be]</span><br><span class="line">/home/out/lib/x86_64-linux-gnu/dri/swrast_dri.so(+0x85c414) (driCreateNewContext+0x3c) [0x7f4bb917a414]</span><br><span class="line">/home/out/lib/x86_64-linux-gnu/libGL.so.1(+0x47828) (drisw_create_context+0x137) [0x7f4bb9f9a828]</span><br><span class="line">/home/out/lib/x86_64-linux-gnu/libGL.so.1(+0x492b9) (CreateContext+0xbd) [0x7f4bb9f9c2b9]</span><br><span class="line">/home/out/lib/x86_64-linux-gnu/libGL.so.1(+0x49788) (glXCreateContext+0x13f) [0x7f4bb9f9c788]</span><br><span class="line">glxgears(+0x416f) (?+0x27f) [0x55b7c388816f]</span><br><span class="line">glxgears(+0x257f) (?+0x16f) [0x55b7c388657f]</span><br><span class="line">/lib/x86_64-linux-gnu/libc.so.6(+0x270b3) (__libc_start_main+0xf3) [0x7f4bb9ad80b3]</span><br><span class="line">glxgears(+0x2f0a) (?+0x2a) [0x55b7c3886f0a]</span><br></pre></td></tr></table></figure>

<h2 id="SwapBuffer接口调用"><a href="#SwapBuffer接口调用" class="headerlink" title="SwapBuffer接口调用"></a>SwapBuffer接口调用</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func: virgl_flush_eq, line: 922</span><br><span class="line">   /home/out/lib/x86_64-linux-gnu/dri/swrast_dri.so(+0x951a57) (virgl_flush_from_st+0x3e) [0x7f19f19f6a57]</span><br><span class="line">   /home/out/lib/x86_64-linux-gnu/dri/swrast_dri.so(+0xfbf26) (st_flush+0x4a) [0x7f19f11a0f26]</span><br><span class="line">   /home/out/lib/x86_64-linux-gnu/dri/swrast_dri.so(+0xfc03d) (st_glFlush+0x42) [0x7f19f11a103d]</span><br><span class="line">   /home/out/lib/x86_64-linux-gnu/dri/swrast_dri.so(+0x1aeb37) (_mesa_flush+0x96) [0x7f19f1253b37]</span><br><span class="line">   /home/out/lib/x86_64-linux-gnu/dri/swrast_dri.so(+0x1aec65) (_mesa_Flush+0x56) [0x7f19f1253c65]</span><br><span class="line">   /home/out/lib/x86_64-linux-gnu/libGL.so.1(+0x47f08) (driswSwapBuffers+0x3f) [0x7f19f2721f08]</span><br><span class="line">   /home/out/lib/x86_64-linux-gnu/libGL.so.1(+0x4a1e9) (glXSwapBuffers+0x9d) [0x7f19f27241e9]</span><br><span class="line">   ./glxgears(+0x2dfd) (main+0x61d) [0x564f11c10dfd]</span><br><span class="line">   /lib/x86_64-linux-gnu/libc.so.6(+0x270b3) (__libc_start_main+0xf3) [0x7f19f225f0b3]</span><br><span class="line">   ./glxgears(+0x330e) (_start+0x2e) [0x564f11c1130e]</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>多媒体</category>
        <category>mesa</category>
      </categories>
      <tags>
        <tag>gpu</tag>
        <tag>debug</tag>
        <tag>mesa</tag>
        <tag>opengl</tag>
      </tags>
  </entry>
  <entry>
    <title>流媒体之RTSP/RTP/RTCP</title>
    <url>/post/34052.html</url>
    <content><![CDATA[<p><img data-src="/images/media/media_C_S.jpg" alt="media_c_s"></p>
<blockquote>
<p>用一句简单的话总结：RTSP发起&#x2F;终结流媒体、RTP传输流媒体数据 、RTCP对RTP进行控制，同步。</p>
</blockquote>
<span id="more"></span>

<p><img data-src="/images/media/media_protocol.png" alt="流媒体协议"></p>
<ul>
<li><p>RTP：实时传输协议（Real-time Transport Protocol）</p>
<ul>
<li>RTP&#x2F;RTCP是实际传输数据的协议</li>
<li>RTP传输音频&#x2F;视频数据，如果是PLAY，Server发送到Client端，如果是RECORD，可以由Client发送到Server</li>
<li>整个RTP协议由两个密切相关的部分组成：RTP数据协议和RTP控制协议（即RTCP）</li>
</ul>
</li>
<li><p>RTSP：实时流协议（Real Time Streaming Protocol，RTSP）</p>
<ul>
<li>RTSP的请求主要有DESCRIBE,SETUP,PLAY,PAUSE,TEARDOWN,OPTIONS等，顾名思义可以知道起对话和控制作用</li>
<li>RTSP的对话过程中SETUP可以确定RTP&#x2F;RTCP使用的端口，PLAY&#x2F;PAUSE&#x2F;TEARDOWN可以开始或者停止RTP的发送，等等</li>
</ul>
</li>
<li><p>RTCP：RTP 控制协议（RTP Control Protocol）</p>
<ul>
<li>RTP&#x2F;RTCP是实际传输数据的协议</li>
<li>RTCP包括Sender Report和Receiver Report，用来进行音频&#x2F;视频的同步以及其他用途，是一种控制协议</li>
</ul>
</li>
</ul>
<h2 id="RTP"><a href="#RTP" class="headerlink" title="RTP"></a>RTP</h2><p>RTP数据协议负责对流媒体数据进行封包并实现媒体流的实时传输，每一个RTP数据报都由<code>头部（Header）</code>和<code>负载（Payload）</code>两个部分组成，其中头部前<em><strong>12个字节</strong></em>的含义是固定的，而负载则可以是<code>音频</code>或者<code>视频</code>数据。RTP数据报的头部格式如图：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 0                   1                   2                   3</span><br><span class="line"> 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|V=2|P|X|   CC  |M|     PT      |      sequence number          |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                         timestamp                             |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|           synchronization source (SSRC) identifier            |</span><br><span class="line">+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+</span><br><span class="line">|            contributing source (CSRC) identifiers             |</span><br><span class="line">|                            ....                               |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure>

<p>从RTP数据报的格式不难看出，它包含了传输媒体的<code>类型</code>、<code>格式</code>、<code>序列号</code>、<code>时间戳</code>以及是否有附加数据等信息，这些都为实时的流媒体传输提供了相应的基础。</p>
<h3 id="字段解析"><a href="#字段解析" class="headerlink" title="字段解析"></a>字段解析</h3><table>
<thead>
<tr>
<th align="center">字段</th>
<th align="center">位宽</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">V</td>
<td align="center">2</td>
<td align="center">RTP协议的版本号，当前协议版本号为2。</td>
</tr>
<tr>
<td align="center">P</td>
<td align="center">1</td>
<td align="center">填充标志, 如果P&#x3D;1，则在该报文的尾部填充一个或多个额外的八位组，它们不是有效载荷的一部分。</td>
</tr>
<tr>
<td align="center">X</td>
<td align="center">1</td>
<td align="center">扩展标志，如果X&#x3D;1，则在RTP报头后跟有一个扩展报头。</td>
</tr>
<tr>
<td align="center">CC</td>
<td align="center">4</td>
<td align="center">CSRC计数器， 指示CSRC 标识符的个数。</td>
</tr>
<tr>
<td align="center">M</td>
<td align="center">1</td>
<td align="center">标记，不同的有效载荷有不同的含义，对于<code>视频</code>，标记一帧的结束；对于<code>音频</code>，标记会话的开始。</td>
</tr>
<tr>
<td align="center">PT</td>
<td align="center">7</td>
<td align="center">有效载荷类型，用于说明RTP报文中有效载荷的类型，如GSM音频、JPEM图像等。</td>
</tr>
<tr>
<td align="center">sequence number</td>
<td align="center">16</td>
<td align="center">用于标识发送者所发送的RTP报文的序列号，每发送一个报文，序列号增1。接收者通过序列号来检测报文丢失情况，重新排序报文，恢复数据。</td>
</tr>
<tr>
<td align="center">timestamp</td>
<td align="center">32</td>
<td align="center">时戳反映了该RTP报文的第一个八位组的采样时刻。接收者使用时戳来计算延迟和延迟抖动，并进行同步控制。</td>
</tr>
<tr>
<td align="center">SSRC</td>
<td align="center">32</td>
<td align="center">用于标识同步信源。该标识符是随机选择的，参加同一视频会议的两个同步信源不能有相同的SSRC。</td>
</tr>
<tr>
<td align="center">CSRC</td>
<td align="center">32</td>
<td align="center">每个CSRC标识符占32位，可以有0～15个。每个CSRC标识了包含在该RTP报文有效载荷中的所有特约信源。</td>
</tr>
</tbody></table>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>RTP协议的目的是提供实时数据（如交互式的音频和视频）的端到端传输服务，因此在<code>RTP中没有连接的概念</code>，它可以<code>建立在底层的面向连接或面向非连接的传输协议之上</code>；RTP也不依赖于特别的网络地址格式，而仅仅只需要底层传输协议支持组帧（Framing）和分段（Segmentation）就足够了；另外RTP本身还不提供任何可靠性机制，这些都要由传输协议或者应用程序自己来保证。在典型的应用场合下，RTP一般是在传输协议之上作为应用程序的一部分加以实现的，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+-----------------------------------------------------------------+</span><br><span class="line">|                     Application Layer                           |</span><br><span class="line">+-----------------------------------------------------------------+</span><br><span class="line">|                           RTP/RTCP                              |</span><br><span class="line">+--------------------------------+--------------------------------+</span><br><span class="line">|              UDP               |              TCP               |</span><br><span class="line">+--------------------------------+--------------------------------+</span><br><span class="line">|                         IPv4/IPv6                               |</span><br><span class="line">+-----------------------------------------------------------------+</span><br><span class="line">|                          LAN/WAN                                |</span><br><span class="line">+-----------------------------------------------------------------+</span><br></pre></td></tr></table></figure>

<h2 id="RTSP"><a href="#RTSP" class="headerlink" title="RTSP"></a>RTSP</h2><p>作为一个应用层协议，RTSP提供了一个可供扩展的框架，它的意义在于使得<code>实时流媒体数据的受控和点播变得可能</code>。总的说来，RTSP是一个流媒体表示协议，主要用来控制具有实时特性的数据发送，但它本身并不传输数据，而是必须依赖于下层传输协议所提供的某些服务。</p>
<p><strong>RTSP可以对流媒体提供诸如播放、暂停、快进等操作，它负责定义具体的控制消息、操作方法、状态码等，此外还描述了与RTP间的交互操作（RFC2326）。</strong></p>
<p>由RTSP控制的媒体流集合可以用表示描述（Presentation  Description）来定义，所谓表示是指流媒体服务器提供给客户机的一个或者多个媒体流的集合，而表示描述则包含了一个表示中各个媒体流的相关信 息，如数据编码&#x2F;解码算法、网络地址、媒体流的内容等。虽然RTSP服务器同样也使用标识符来区别每一流连接会话（Session），但RTSP连接并没有被绑定到传输层连接（如TCP等），也就是说在整个 RTSP连接期间，RTSP用户可打开或者关闭多个对RTSP服务器的可靠传输连接以发出RTSP  请求。此外，RTSP连接也可以基于面向无连接的传输协议（如UDP等）。</p>
<blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cuaWV0Zi5vcmcvcmZjL3JmYzIzMjYudHh0">Real Time Streaming Protocol (RTSP)<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">=======================================================================================================================================</span><br><span class="line">RTSP/Packet Counter:</span><br><span class="line">Topic / Item            Count         Average       Min val       Max val       Rate (ms)     Percent       Burst rate    Burst start</span><br><span class="line">---------------------------------------------------------------------------------------------------------------------------------------</span><br><span class="line">Total RTSP Packets      18                                                      0.0005        100%          0.0700        5.792</span><br><span class="line"> RTSP Response Packets  0                                                       0.0000        0.00%         -             -</span><br><span class="line">  ???: broken           0                                                       0.0000                      -             -</span><br><span class="line">  5xx: Server Error     0                                                       0.0000                      -             -</span><br><span class="line">  4xx: Client Error     0                                                       0.0000                      -             -</span><br><span class="line">  3xx: Redirection      0                                                       0.0000                      -             -</span><br><span class="line">  2xx: Success          0                                                       0.0000                      -             -</span><br><span class="line">  1xx: Informational    0                                                       0.0000                      -             -</span><br><span class="line"> RTSP Request Packets   9                                                       0.0002        50.00%        0.0400        5.848</span><br><span class="line">  SET_PARAMETER         2                                                       0.0001        22.22%        0.0200        5.859</span><br><span class="line">  SETUP                 1                                                       0.0000        11.11%        0.0100        5.933</span><br><span class="line">  PLAY                  1                                                       0.0000        11.11%        0.0100        5.986</span><br><span class="line">  OPTIONS               2                                                       0.0001        22.22%        0.0200        5.751</span><br><span class="line">  GET_PARAMETER         3                                                       0.0001        33.33%        0.0100        5.848</span><br><span class="line"> Other RTSP Packets     9                                                       0.0002        50.00%        0.0400        5.792</span><br><span class="line"></span><br><span class="line">---------------------------------------------------------------------------------------------------------------------------------------</span><br></pre></td></tr></table></figure>

<blockquote>
<p>RTSP是一种基于<code>文本</code>的协议，用<code>CRLF</code>作为一行的结束符。使用基于文本协议的好处在于我们可以随时在使用过程中的增加自定义的参数，也可以随便将协议包抓住很直观的进行分析。</p>
</blockquote>
<h3 id="报文"><a href="#报文" class="headerlink" title="报文"></a>报文</h3><p>RTSP有两类报文：<code>请求报文</code>和<code>响应报文</code></p>
<ul>
<li>请求报文:指从客户端向服务器发送请求报文</li>
<li>响应报文:指从服务器到客户端的回答</li>
</ul>
<p>RTSP报文由三部分组成，即<code>开始行</code>、<code>首部行</code>和<code>实体主体</code>。</p>
<h4 id="请求报文"><a href="#请求报文" class="headerlink" title="请求报文"></a>请求报文</h4><p>在请求报文中，开始行就是请求行，RTSP请求报文的结构如图</p>
<p><img data-src="/images/media/rtsp_request_message.jpg" alt="请求报文"></p>
<p>RTSP请求报文的常用方法及作用：</p>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="left">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">OPTIONS</td>
<td align="left">获得服务器提供的可用方法</td>
</tr>
<tr>
<td align="center">DESCRIBE</td>
<td align="left">得到会话描述信息</td>
</tr>
<tr>
<td align="center">SETUP</td>
<td align="left">客户端提醒服务器建立会话，并确定传输模式</td>
</tr>
<tr>
<td align="center">TEARDOWN</td>
<td align="left">客户端发起关闭请求</td>
</tr>
<tr>
<td align="center">PLAY</td>
<td align="left">客户端发送播放请求</td>
</tr>
<tr>
<td align="center">SET_PARAMETER</td>
<td align="left">给URI指定的表示或媒体流设置参数值</td>
</tr>
<tr>
<td align="center">GET_PARAMETER</td>
<td align="left">获取URI中指定的表示或流的任何指定参数或参数的值</td>
</tr>
</tbody></table>
<h4 id="响应报文"><a href="#响应报文" class="headerlink" title="响应报文"></a>响应报文</h4><p>响应报文的<code>开始行</code>是<code>状态行</code>，RTSP响应报文的结构如图：</p>
<p><img data-src="/images/media/rtsp_answer_message.jpg" alt="响应报文"></p>
<h4 id="示例-交互"><a href="#示例-交互" class="headerlink" title="示例-交互"></a>示例-交互</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">OPTIONS * RTSP/1.0</span><br><span class="line">Date: Thu, 01 Jan 1970 00:11:07 +0000</span><br><span class="line">Server: linux</span><br><span class="line">CSeq: 1</span><br><span class="line">Require: org.wfa.wfd1.0</span><br><span class="line"></span><br><span class="line">RTSP/1.0 200 OK</span><br><span class="line">Date: Thu, 01 Jan 1970 00:00:49 +0000</span><br><span class="line">User-Agent: stagefright/1.1 (Linux;Android 4.1)</span><br><span class="line">CSeq: 1</span><br><span class="line">Public: org.wfa.wfd1.0, GET_PARAMETER, SET_PARAMETER</span><br><span class="line"></span><br><span class="line">OPTIONS * RTSP/1.0</span><br><span class="line">Date: Thu, 01 Jan 1970 00:00:49 +0000</span><br><span class="line">User-Agent: stagefright/1.1 (Linux;Android 4.1)</span><br><span class="line">CSeq: 1</span><br><span class="line">Require: org.wfa.wfd1.0</span><br><span class="line"></span><br><span class="line">RTSP/1.0 200 OK</span><br><span class="line">Date: Thu, 01 Jan 1970 00:11:07 +0000</span><br><span class="line">Server: linux</span><br><span class="line">CSeq: 1</span><br><span class="line">Public: org.wfa.wfd1.0, SETUP, TEARDOWN, PLAY, PAUSE, GET_PARAMETER, SET_PARAMETER</span><br><span class="line"></span><br><span class="line">GET_PARAMETER rtsp://localhost/wfd1.0 RTSP/1.0</span><br><span class="line">Date: Thu, 01 Jan 1970 00:11:07 +0000</span><br><span class="line">Server: linux</span><br><span class="line">CSeq: 2</span><br><span class="line">Content-Type: text/parameters</span><br><span class="line">Content-Length: 90</span><br><span class="line"></span><br><span class="line">wfd_video_formats</span><br><span class="line">wfd_audio_codecs</span><br><span class="line">wfd_client_rtp_ports</span><br><span class="line">wfd_rtp_multicast: 239.0.0.11</span><br><span class="line">RTSP/1.0 200 OK</span><br><span class="line">Date: Thu, 01 Jan 1970 00:00:49 +0000</span><br><span class="line">User-Agent: stagefright/1.1 (Linux;Android 4.1)</span><br><span class="line">CSeq: 2</span><br><span class="line">Content-Type: text/parameters</span><br><span class="line">Content-Length: 259</span><br><span class="line"></span><br><span class="line">wfd_video_formats: 28 00 02 02 0001DEFF 157C7FFF 00000FFF 00 0000 0000 11 none none, 01 02 0001DEFF 157C7FFF 00000FFF 00 0000 0000 11 none none</span><br><span class="line">wfd_audio_codecs: LPCM 00000002 00, AAC 00000001 00</span><br><span class="line">wfd_client_rtp_ports: RTP/AVP/UDP;unicast 15550 0 mode=play</span><br><span class="line">SET_PARAMETER rtsp://localhost/wfd1.0 RTSP/1.0</span><br><span class="line">Date: Thu, 01 Jan 1970 00:11:07 +0000</span><br><span class="line">Server: linux</span><br><span class="line">CSeq: 3</span><br><span class="line">Content-Type: text/parameters</span><br><span class="line">Content-Length: 203</span><br><span class="line"></span><br><span class="line">wfd_video_formats: wfd_audio_codecs: LPCM 00000002 00</span><br><span class="line">wfd_presentation_URL: rtsp://192.168.100.2/wfd1.0/streamid=0 none</span><br><span class="line">wfd_client_rtp_ports: RTP/AVP/UDP;unicast 15550 0 mode=play</span><br><span class="line">wfd_display_edid:</span><br><span class="line">RTSP/1.0 200 OK</span><br><span class="line">Date: Thu, 01 Jan 1970 00:00:49 +0000</span><br><span class="line">User-Agent: stagefright/1.1 (Linux;Android 4.1)</span><br><span class="line">CSeq: 3</span><br><span class="line"></span><br><span class="line">SET_PARAMETER rtsp://localhost/wfd1.0 RTSP/1.0</span><br><span class="line">Date: Thu, 01 Jan 1970 00:11:07 +0000</span><br><span class="line">Server: linux</span><br><span class="line">CSeq: 4</span><br><span class="line">Content-Type: text/parameters</span><br><span class="line">Content-Length: 27</span><br><span class="line"></span><br><span class="line">wfd_trigger_method: SETUP</span><br><span class="line">RTSP/1.0 200 OK</span><br><span class="line">Date: Thu, 01 Jan 1970 00:00:49 +0000</span><br><span class="line">User-Agent: stagefright/1.1 (Linux;Android 4.1)</span><br><span class="line">CSeq: 4</span><br><span class="line"></span><br><span class="line">SETUP rtsp://192.168.100.2/wfd1.0/streamid=0 RTSP/1.0</span><br><span class="line">Date: Thu, 01 Jan 1970 00:00:49 +0000</span><br><span class="line">User-Agent: stagefright/1.1 (Linux;Android 4.1)</span><br><span class="line">CSeq: 2</span><br><span class="line">Transport: RTP/AVP/UDP;unicast;client_port=15550-15551</span><br><span class="line"></span><br><span class="line">RTSP/1.0 200 OK</span><br><span class="line">Date: Thu, 01 Jan 1970 00:11:07 +0000</span><br><span class="line">Server: linux</span><br><span class="line">CSeq: 2</span><br><span class="line">Session: 1649760492;timeout=319201969439387</span><br><span class="line">Transport: RTP/AVP/UDP;unicast;client_port=15550-15551;server_port=22648-22649</span><br><span class="line"></span><br><span class="line">PLAY rtsp://192.168.100.2/wfd1.0/streamid=0 RTSP/1.0</span><br><span class="line">Date: Thu, 01 Jan 1970 00:00:49 +0000</span><br><span class="line">User-Agent: stagefright/1.1 (Linux;Android 4.1)</span><br><span class="line">CSeq: 3</span><br><span class="line">Session: 1649760492</span><br><span class="line"></span><br><span class="line">RTSP/1.0 200 OK</span><br><span class="line">Date: Thu, 01 Jan 1970 00:11:07 +0000</span><br><span class="line">Server: linux</span><br><span class="line">CSeq: 3</span><br><span class="line">Session: 1649760492;timeout=319201969439387</span><br><span class="line">Range: npt=now-</span><br><span class="line"></span><br><span class="line">GET_PARAMETER rtsp://localhost/wfd1.0 RTSP/1.0</span><br><span class="line">Date: Thu, 01 Jan 1970 00:11:27 +0000</span><br><span class="line">Server: linux</span><br><span class="line">CSeq: 5</span><br><span class="line">Session: 1649760492</span><br><span class="line"></span><br><span class="line">RTSP/1.0 200 OK</span><br><span class="line">Date: Thu, 01 Jan 1970 00:01:08 +0000</span><br><span class="line">User-Agent: stagefright/1.1 (Linux;Android 4.1)</span><br><span class="line">CSeq: 5</span><br><span class="line">Content-Type: text/parameters</span><br><span class="line">Content-Length: 0</span><br><span class="line"></span><br><span class="line">GET_PARAMETER rtsp://localhost/wfd1.0 RTSP/1.0</span><br><span class="line">Date: Thu, 01 Jan 1970 00:11:47 +0000</span><br><span class="line">Server: linux</span><br><span class="line">CSeq: 6</span><br><span class="line">Session: 1649760492</span><br><span class="line"></span><br><span class="line">RTSP/1.0 200 OK</span><br><span class="line">Date: Thu, 01 Jan 1970 00:01:28 +0000</span><br><span class="line">User-Agent: stagefright/1.1 (Linux;Android 4.1)</span><br><span class="line">CSeq: 6</span><br><span class="line">Content-Type: text/parameters</span><br><span class="line">Content-Length: 0</span><br></pre></td></tr></table></figure>

<h2 id="RTCP"><a href="#RTCP" class="headerlink" title="RTCP"></a>RTCP</h2><p>RTCP控制协议需要与RTP数据协议一起配合使用，<strong>当应用程序启动一个RTP会话时将同时占用两个端口，分别供RTP和RTCP使用</strong>。<code>RTP本身并不能为按序传输数据包提供可靠的保证，也不提供流量控制和拥塞控制，这些都由RTCP来负责完成</code>。通常RTCP会采用与RTP相同的分发机制，向会话中的所有成员周期性地发送控制信息，应用程序通过接收这些数据，从中获取会话参与者的相关资料，以及网络状况、分组丢失概率等反馈信息，从而能够对服务质量进行控制或者对网络状况进行诊断。</p>
<h2 id="开源代码"><a href="#开源代码" class="headerlink" title="开源代码"></a>开源代码</h2><ul>
<li>C++<ul>
<li><span class="exturl" data-url="aHR0cDovL3Jlc2VhcmNoLmVkbS51aGFzc2VsdC5iZS9qb3JpL3BhZ2UvQ1MvSnJ0cGxpYi5odG1s">JRTPLIB<i class="fa fa-external-link-alt"></i></span>【<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2owcjEvSlJUUExJQi5naXQ=">Code<i class="fa fa-external-link-alt"></i></span>】</li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0Fuc2Vyc2lvbi9teVJ0c3BDbGllbnQ=">myRtspClient<i class="fa fa-external-link-alt"></i></span></li>
</ul>
</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3d3NTA2NzcyMzYyL2FydGljbGUvZGV0YWlscy81MjYwOTM3OQ==">RTSP&#x2F;RTP 媒体传输和控制协议<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly90b29scy5pZXRmLm9yZy9wZGYvcmZjNjE4NC5wZGY=">RTP Payload Format for H.264 Video<i class="fa fa-external-link-alt"></i></span>【<span class="exturl" data-url="aHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzYxODQ=">html<i class="fa fa-external-link-alt"></i></span>】</li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuaWFuYS5vcmcvYXNzaWdubWVudHMvcnRzcHYyLXBhcmFtZXRlcnMvcnRzcHYyLXBhcmFtZXRlcnMueGh0bWw=">Real-Time Streaming Protocol (RTSP) 2.0 Parameters<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL3d3dy50eHJqeS5jb20vdGhyZWFkLTM1NzkyOC0xLTEuaHRtbA==">RTP&#x2F;RTSP&#x2F;RTCP的区别<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly95cS5hbGl5dW4uY29tL2FydGljbGVzLzIyOTI5NQ==">RTSP协议介绍<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>多媒体</category>
        <category>rtp</category>
      </categories>
      <tags>
        <tag>rtp</tag>
      </tags>
  </entry>
  <entry>
    <title>TS流</title>
    <url>/post/36727.html</url>
    <content><![CDATA[<p>TS流</p>
<span id="more"></span>

<p><img data-src="/images/media/TS.svg" alt="TS"></p>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="TS头"><a href="#TS头" class="headerlink" title="TS头"></a>TS头</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Transport packet header</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TS_packet_header</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">unsigned</span> sync_byte                    : <span class="number">8</span>;	<span class="comment">//同步字节, 固定为0x47,表示后面的是一个TS分组</span></span><br><span class="line">	<span class="type">unsigned</span> transport_error_indicator    : <span class="number">1</span>;	<span class="comment">//传输误码指示符</span></span><br><span class="line">	<span class="type">unsigned</span> payload_unit_start_indicator : <span class="number">1</span>;	<span class="comment">//效荷载单元起始指示符</span></span><br><span class="line">	<span class="type">unsigned</span> transport_priority           : <span class="number">1</span>;	<span class="comment">//传输优先, 1表示高优先级,传输机制可能用到，解码用不着</span></span><br><span class="line">	<span class="type">unsigned</span> PID                          : <span class="number">13</span>;	<span class="comment">//PID</span></span><br><span class="line">	<span class="type">unsigned</span> transport_scrambling_control : <span class="number">2</span>;	<span class="comment">//传输加扰控制</span></span><br><span class="line">	<span class="type">unsigned</span> adaption_field_control       : <span class="number">2</span>;	<span class="comment">//自适应控制 01仅含有效负载，10仅含调整字段，11含有调整字段和有效负载。为00解码器不进行处理</span></span><br><span class="line">	<span class="type">unsigned</span> continuity_counter           : <span class="number">4</span>;	<span class="comment">//连续计数器 一个4bit的计数器，范围0-15</span></span><br><span class="line">&#125; TS_packet_header;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>TS包的标识(即sync_byte)为<code>0x47</code>，并且为了确保这个TS包里的数据有效，所以我们一开始查找<code>47 40 00</code>这三组16进制数</p>
<blockquote>
<p>包头大小: <code>4Byte</code></p>
</blockquote>
</blockquote>
<ul>
<li><code>adaption_field_control</code> : 调整字段控制<ul>
<li>0x00 : reserved for future use by ISO&#x2F;IEC</li>
<li>0x01 : 无调整字段,仅含有效负载</li>
<li>0x10 : 仅含调整字段,无有效负载</li>
<li>0x11 : 调整字段后含有效负载<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (adaption_field_control == <span class="string">&#x27;10&#x27;</span> || adaption_field_control == <span class="string">&#x27;11&#x27;</span>) &#123;</span><br><span class="line">        adaption_fields() <span class="comment">//调整字段的处理</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (adaption_field_control == <span class="string">&#x27;01&#x27;</span> || adaption_field_control == <span class="string">&#x27;11&#x27;</span>) &#123;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; N ; i++) <span class="comment">//N值 = 184 - 调整字段的字节数</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><code>continuity_counter</code> : 用于对传输误码进行检测。在发送端对所有的包都做0-15的循环计数，在接收终端，如发现循环计数器的值有中断，表明数据在传输中有丢失。</li>
</ul>
<h3 id="PAT"><a href="#PAT" class="headerlink" title="PAT"></a>PAT</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Program Association Table</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">PAT_Packet_tag</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">unsigned</span> table_id                        : <span class="number">8</span>;	<span class="comment">//固定为0x00 ，标志是该表是PAT</span></span><br><span class="line">	<span class="type">unsigned</span> section_syntax_indicator        : <span class="number">1</span>; 	<span class="comment">//段语法标志位，固定为1</span></span><br><span class="line">	<span class="type">unsigned</span> zero                            : <span class="number">1</span>; 	<span class="comment">//0</span></span><br><span class="line">	<span class="type">unsigned</span> reserved_1                      : <span class="number">2</span>; 	<span class="comment">//保留位</span></span><br><span class="line">	<span class="type">unsigned</span> section_length                  : <span class="number">12</span>;	<span class="comment">//表示这个字节后面有用的字节数，包括CRC32</span></span><br><span class="line">	<span class="type">unsigned</span> transport_stream_id             : <span class="number">16</span>;	<span class="comment">//该传输流的ID，区别于一个网络中其它多路复用的流</span></span><br><span class="line">	<span class="type">unsigned</span> reserved_2                      : <span class="number">2</span>; 	<span class="comment">//保留位</span></span><br><span class="line">	<span class="type">unsigned</span> version_number                  : <span class="number">5</span>; 	<span class="comment">//范围0-31，表示PAT的版本号</span></span><br><span class="line">	<span class="type">unsigned</span> current_next_indicator          : <span class="number">1</span>; 	<span class="comment">//发送的PAT是当前有效还是下一个PAT有效</span></span><br><span class="line">	<span class="type">unsigned</span> section_number                  : <span class="number">8</span>; 	<span class="comment">//分段的号码。PAT可能分为多段传输，第一段为00，以后每个分段加1，最多可能有256个分段</span></span><br><span class="line">	<span class="type">unsigned</span> last_section_number             : <span class="number">8</span>; 	<span class="comment">//最后一个分段的号码</span></span><br><span class="line">	<span class="comment">// for(i=0; i&lt;N; i++) &#123;  //N = (section_length - 4(CRC的4Byte) - 5(section_lengt以后的5Byte))/4</span></span><br><span class="line">	<span class="type">unsigned</span> program_number                  : <span class="number">16</span>;</span><br><span class="line">	<span class="type">unsigned</span> reserved_3                      : <span class="number">3</span>;</span><br><span class="line">	<span class="type">unsigned</span> network_PID                     : <span class="number">16</span>;	<span class="comment">// 或者program_map_PID</span></span><br><span class="line">	<span class="comment">// &#125;</span></span><br><span class="line">	<span class="type">unsigned</span> CRC_32                          : <span class="number">32</span>;</span><br><span class="line">&#125; PAT_Packet;</span><br></pre></td></tr></table></figure>

<h3 id="PMT"><a href="#PMT" class="headerlink" title="PMT"></a>PMT</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Program Map Table</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">PMT_Packet_tag</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">     <span class="type">unsigned</span> table_id                        : <span class="number">8</span>;</span><br><span class="line">     <span class="type">unsigned</span> section_syntax_indicator        : <span class="number">1</span>;</span><br><span class="line">     <span class="type">unsigned</span> zero                            : <span class="number">1</span>;</span><br><span class="line">     <span class="type">unsigned</span> reserved_1                      : <span class="number">2</span>;</span><br><span class="line">     <span class="type">unsigned</span> section_length                  : <span class="number">12</span>;</span><br><span class="line">     <span class="type">unsigned</span> program_number                  : <span class="number">16</span>;</span><br><span class="line">     <span class="type">unsigned</span> reserved_2                      : <span class="number">2</span>;</span><br><span class="line">     <span class="type">unsigned</span> version_number                  : <span class="number">5</span>;</span><br><span class="line">     <span class="type">unsigned</span> current_next_indicator          : <span class="number">1</span>;</span><br><span class="line">     <span class="type">unsigned</span> section_number                  : <span class="number">8</span>;</span><br><span class="line">     <span class="type">unsigned</span> last_section_number             : <span class="number">8</span>;</span><br><span class="line">     <span class="type">unsigned</span> reserved_3                      : <span class="number">3</span>;</span><br><span class="line">     <span class="type">unsigned</span> PCR_PID                         : <span class="number">13</span>;</span><br><span class="line">     <span class="type">unsigned</span> reserved_4                      : <span class="number">4</span>;</span><br><span class="line">     <span class="type">unsigned</span> program_info_length             : <span class="number">12</span>;</span><br><span class="line">     <span class="comment">// for(i=0; i&lt;N; i++) &#123;</span></span><br><span class="line">     <span class="type">unsigned</span> stream_type                     : <span class="number">8</span>;</span><br><span class="line">     <span class="type">unsigned</span> reserved_5                      : <span class="number">3</span>;</span><br><span class="line">     <span class="type">unsigned</span> elementary_PID                  : <span class="number">13</span>;</span><br><span class="line">     <span class="type">unsigned</span> reserved_6                      : <span class="number">4</span>;</span><br><span class="line">     <span class="type">unsigned</span> ES_info_length                  : <span class="number">12</span>;</span><br><span class="line">     <span class="comment">// &#125;</span></span><br><span class="line">     <span class="type">unsigned</span> CRC_32                          : <span class="number">32</span>;</span><br><span class="line">&#125; PMT_Packet;</span><br></pre></td></tr></table></figure>
<h2 id="数据包"><a href="#数据包" class="headerlink" title="数据包"></a>数据包</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1	0.000000000			MPEG TS	188	 Service Description Table (SDT)</span><br><span class="line">2	0.000055764			MPEG TS	188	 Program Association Table (PAT)</span><br><span class="line">3	0.000111529			MPEG TS	188	 Program Map Table (PMT)</span><br><span class="line">4	0.000167294			MPEG TS	188	 [MP2T fragment of a reassembled packet]</span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<blockquote>
<p>开始时解析到的数据包:<code>SDT-&gt;PAT-&gt;PMT</code></p>
</blockquote>
<p>SDT包只出现在TS文件的开头，而PAT和PMT包，每隔<code>42Packet</code>将出现一次。</p>
<h3 id="SDT"><a href="#SDT" class="headerlink" title="SDT"></a>SDT</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Frame 1: 188 bytes on wire (1504 bits), 188 bytes captured (1504 bits)</span><br><span class="line">    Encapsulation type: ISO/IEC 13818-1 MPEG2-TS (138)</span><br><span class="line">    Arrival Time: Jan  1, 1970 08:00:00.000000000 CST</span><br><span class="line">    [Time shift for this packet: 0.000000000 seconds]</span><br><span class="line">    Epoch Time: 0.000000000 seconds</span><br><span class="line">    [Time delta from previous captured frame: 0.000000000 seconds]</span><br><span class="line">    [Time delta from previous displayed frame: 0.000000000 seconds]</span><br><span class="line">    [Time since reference or first frame: 0.000000000 seconds]</span><br><span class="line">    Frame Number: 1</span><br><span class="line">    Frame Length: 188 bytes (1504 bits)</span><br><span class="line">    Capture Length: 188 bytes (1504 bits)</span><br><span class="line">    [Frame is marked: False]</span><br><span class="line">    [Frame is ignored: False]</span><br><span class="line">    [Protocols in frame: mp2t:mpeg_sect:dvb_sdt]</span><br><span class="line">ISO/IEC 13818-1 PID=0x11 CC=0</span><br><span class="line">    Header: 0x47401110</span><br><span class="line">        0100 0111 .... .... .... .... .... .... = Sync Byte: Correct (0x47)</span><br><span class="line">        .... .... 0... .... .... .... .... .... = Transport Error Indicator: 0</span><br><span class="line">        .... .... .1.. .... .... .... .... .... = Payload Unit Start Indicator: 1</span><br><span class="line">        .... .... ..0. .... .... .... .... .... = Transport Priority: 0</span><br><span class="line">        .... .... ...0 0000 0001 0001 .... .... = PID: Unknown (0x0011)</span><br><span class="line">        .... .... .... .... .... .... 00.. .... = Transport Scrambling Control: Not scrambled (0x0)</span><br><span class="line">        .... .... .... .... .... .... ..01 .... = Adaptation Field Control: Payload only (0x1)</span><br><span class="line">        .... .... .... .... .... .... .... 0000 = Continuity Counter: 0</span><br><span class="line">    [MPEG2 PCR Analysis]</span><br><span class="line">    Pointer: 0</span><br><span class="line">DVB Service Description Table</span><br><span class="line">    Table ID: Service Description Table (SDT), current network (0x42)</span><br><span class="line">    1... .... .... .... = Syntax indicator: 1</span><br><span class="line">    .111 .... .... .... = Reserved: 0x7</span><br><span class="line">    .... 0000 0010 0101 = Length: 37</span><br><span class="line">    Transport Stream ID: 0x0001</span><br><span class="line">    11.. .... = Reserved: 0x3</span><br><span class="line">    ..00 000. = Version Number: 0x00</span><br><span class="line">    .... ...1 = Current/Next Indicator: Currently applicable (1)</span><br><span class="line">    Section Number: 0</span><br><span class="line">    Last Section Number: 0</span><br><span class="line">    Original Network ID: 0xff01</span><br><span class="line">    Reserved: 0xff</span><br><span class="line">    Service 0x0001</span><br><span class="line">        Service ID: 0x0001</span><br><span class="line">        1111 11.. = Reserved: 0x3f</span><br><span class="line">        .... ..0. = EIT Schedule Flag: 0</span><br><span class="line">        .... ...0 = EIT Present Following Flag: 0</span><br><span class="line">        100. .... .... .... = Running Status: Running (0x4)</span><br><span class="line">        ...0 .... .... .... = Free CA Mode: Not Scrambled (0x0)</span><br><span class="line">        .... 0000 0001 0100 = Descriptors Loop Length: 0x014</span><br><span class="line">        Descriptor Tag=0x48</span><br><span class="line">            Descriptor Tag: Service Descriptor (0x48)</span><br><span class="line">            Descriptor Length: 18</span><br><span class="line">            Service Type: digital television service (0x01)</span><br><span class="line">            Provider Name Length: 6</span><br><span class="line">            [Default character table (Latin)]</span><br><span class="line">            Service Provider Name: FFmpeg</span><br><span class="line">            Service Name Length: 9</span><br><span class="line">            [Default character table (Latin)]</span><br><span class="line">            Service Name: Service01</span><br><span class="line">    CRC 32: 0x777c43ca [unverified]</span><br><span class="line">    [CRC 32 Status: Unverified]</span><br><span class="line">Stuffing</span><br><span class="line">    Stuffing: ffffffffffffffffffffffffffffffffffffffffffffffff...</span><br></pre></td></tr></table></figure>

<h3 id="PAT-1"><a href="#PAT-1" class="headerlink" title="PAT"></a>PAT</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Frame 2: 188 bytes on wire (1504 bits), 188 bytes captured (1504 bits)</span><br><span class="line">    Encapsulation type: ISO/IEC 13818-1 MPEG2-TS (138)</span><br><span class="line">    Arrival Time: Jan  1, 1970 08:00:00.000055764 CST</span><br><span class="line">    [Time shift for this packet: 0.000000000 seconds]</span><br><span class="line">    Epoch Time: 0.000055764 seconds</span><br><span class="line">    [Time delta from previous captured frame: 0.000055764 seconds]</span><br><span class="line">    [Time delta from previous displayed frame: 0.000055764 seconds]</span><br><span class="line">    [Time since reference or first frame: 0.000055764 seconds]</span><br><span class="line">    Frame Number: 2</span><br><span class="line">    Frame Length: 188 bytes (1504 bits)</span><br><span class="line">    Capture Length: 188 bytes (1504 bits)</span><br><span class="line">    [Frame is marked: False]</span><br><span class="line">    [Frame is ignored: False]</span><br><span class="line">    [Protocols in frame: mp2t:mpeg_sect:mpeg_pat]</span><br><span class="line">ISO/IEC 13818-1 PID=0x0 CC=0</span><br><span class="line">    Header: 0x47400010</span><br><span class="line">        0100 0111 .... .... .... .... .... .... = Sync Byte: Correct (0x47)</span><br><span class="line">        .... .... 0... .... .... .... .... .... = Transport Error Indicator: 0</span><br><span class="line">        .... .... .1.. .... .... .... .... .... = Payload Unit Start Indicator: 1</span><br><span class="line">        .... .... ..0. .... .... .... .... .... = Transport Priority: 0</span><br><span class="line">        .... .... ...0 0000 0000 0000 .... .... = PID: Program Association Table (0x0000)</span><br><span class="line">        .... .... .... .... .... .... 00.. .... = Transport Scrambling Control: Not scrambled (0x0)</span><br><span class="line">        .... .... .... .... .... .... ..01 .... = Adaptation Field Control: Payload only (0x1)</span><br><span class="line">        .... .... .... .... .... .... .... 0000 = Continuity Counter: 0</span><br><span class="line">    [MPEG2 PCR Analysis]</span><br><span class="line">    Pointer: 0    //自适应区,1Byte,如果为0 表示没有自适应区</span><br><span class="line">MPEG2 Program Association Table</span><br><span class="line">    Table ID: Program Association Table (PAT) (0x00)</span><br><span class="line">    1... .... .... .... = Syntax indicator: 1</span><br><span class="line">    .011 .... .... .... = Reserved: 0x3</span><br><span class="line">    .... 0000 0000 1101 = Length: 13</span><br><span class="line">    Transport Stream ID: 0x0001</span><br><span class="line">    11.. .... = Reserved: 0x3</span><br><span class="line">    ..00 000. = Version Number: 0x00</span><br><span class="line">    .... ...1 = Current/Next Indicator: Currently applicable</span><br><span class="line">    Section Number: 0</span><br><span class="line">    Last Section Number: 0</span><br><span class="line">    Program 0x0001 -&gt; PID 0x1000</span><br><span class="line">        Program Number: 0x0001</span><br><span class="line">        111. .... .... .... = Reserved: 0x7</span><br><span class="line">        ...1 0000 0000 0000 = Program Map PID: 0x1000</span><br><span class="line">    CRC 32: 0x2ab104b2 [unverified]</span><br><span class="line">    [CRC 32 Status: Unverified]</span><br><span class="line">Stuffing</span><br><span class="line">    Stuffing: ffffffffffffffffffffffffffffffffffffffffffffffff...</span><br></pre></td></tr></table></figure>

<h3 id="PMT-1"><a href="#PMT-1" class="headerlink" title="PMT"></a>PMT</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Frame 3: 188 bytes on wire (1504 bits), 188 bytes captured (1504 bits)</span><br><span class="line">    Encapsulation type: ISO/IEC 13818-1 MPEG2-TS (138)</span><br><span class="line">    Arrival Time: Jan  1, 1970 08:00:00.000111529 CST</span><br><span class="line">    [Time shift for this packet: 0.000000000 seconds]</span><br><span class="line">    Epoch Time: 0.000111529 seconds</span><br><span class="line">    [Time delta from previous captured frame: 0.000055765 seconds]</span><br><span class="line">    [Time delta from previous displayed frame: 0.000055765 seconds]</span><br><span class="line">    [Time since reference or first frame: 0.000111529 seconds]</span><br><span class="line">    Frame Number: 3</span><br><span class="line">    Frame Length: 188 bytes (1504 bits)</span><br><span class="line">    Capture Length: 188 bytes (1504 bits)</span><br><span class="line">    [Frame is marked: False]</span><br><span class="line">    [Frame is ignored: False]</span><br><span class="line">    [Protocols in frame: mp2t:mpeg_sect:mpeg_pmt]</span><br><span class="line">ISO/IEC 13818-1 PID=0x1000 CC=0</span><br><span class="line">    Header: 0x47500010</span><br><span class="line">        0100 0111 .... .... .... .... .... .... = Sync Byte: Correct (0x47)</span><br><span class="line">        .... .... 0... .... .... .... .... .... = Transport Error Indicator: 0</span><br><span class="line">        .... .... .1.. .... .... .... .... .... = Payload Unit Start Indicator: 1</span><br><span class="line">        .... .... ..0. .... .... .... .... .... = Transport Priority: 0</span><br><span class="line">        .... .... ...1 0000 0000 0000 .... .... = PID: Unknown (0x1000)</span><br><span class="line">        .... .... .... .... .... .... 00.. .... = Transport Scrambling Control: Not scrambled (0x0)</span><br><span class="line">        .... .... .... .... .... .... ..01 .... = Adaptation Field Control: Payload only (0x1)</span><br><span class="line">        .... .... .... .... .... .... .... 0000 = Continuity Counter: 0</span><br><span class="line">    [MPEG2 PCR Analysis]</span><br><span class="line">    Pointer: 0</span><br><span class="line">MPEG2 Program Map Table</span><br><span class="line">    Table ID: Program Map Table (PMT) (0x02)</span><br><span class="line">    1... .... .... .... = Syntax indicator: 1</span><br><span class="line">    .011 .... .... .... = Reserved: 0x3</span><br><span class="line">    .... 0000 0001 1101 = Length: 29</span><br><span class="line">    Program Number: 0x0001</span><br><span class="line">    11.. .... = Reserved: 0x3</span><br><span class="line">    ..00 000. = Version Number: 0x00</span><br><span class="line">    .... ...1 = Current/Next Indicator: Currently applicable (0x1)</span><br><span class="line">    Section Number: 0</span><br><span class="line">    Last Section Number: 0</span><br><span class="line">    111. .... .... .... = Reserved: 0x7</span><br><span class="line">    ...0 0001 0000 0000 = PCR PID: 0x0100</span><br><span class="line">    1111 .... .... .... = Reserved: 0xf</span><br><span class="line">    .... 0000 0000 0000 = Program Info Length: 0x000</span><br><span class="line">    Stream PID=0x0100</span><br><span class="line">        Stream type: AVC video stream as defined in ITU-T Rec. H.264 | ISO/IEC 14496-10 Video (0x1b)</span><br><span class="line">        111. .... .... .... = Reserved: 0x7</span><br><span class="line">        ...0 0001 0000 0000 = Elementary PID: 0x0100</span><br><span class="line">        1111 .... .... .... = Reserved: 0xf</span><br><span class="line">        .... 0000 0000 0000 = ES Info Length: 0x000</span><br><span class="line">    Stream PID=0x0101</span><br><span class="line">        Stream type: ISO/IEC 11172 Audio (0x03)</span><br><span class="line">        111. .... .... .... = Reserved: 0x7</span><br><span class="line">        ...0 0001 0000 0001 = Elementary PID: 0x0101</span><br><span class="line">        1111 .... .... .... = Reserved: 0xf</span><br><span class="line">        .... 0000 0000 0110 = ES Info Length: 0x006</span><br><span class="line">        Descriptor Tag=0x0a</span><br><span class="line">            Descriptor Tag: ISO 639 Language Descriptor (0x0a)</span><br><span class="line">            Descriptor Length: 4</span><br><span class="line">            ISO 639 Language Code: und</span><br><span class="line">            ISO 639 Language Type: Undefined (0x00)</span><br><span class="line">    CRC 32: 0x30afbe63 [unverified]</span><br><span class="line">    [CRC 32 Status: Unverified]</span><br><span class="line">Stuffing</span><br><span class="line">    Stuffing: ffffffffffffffffffffffffffffffffffffffffffffffff...</span><br></pre></td></tr></table></figure>

<h3 id="packet"><a href="#packet" class="headerlink" title="packet"></a>packet</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Frame 4: 188 bytes on wire (1504 bits), 188 bytes captured (1504 bits)</span><br><span class="line">    Encapsulation type: ISO/IEC 13818-1 MPEG2-TS (138)</span><br><span class="line">    Arrival Time: Jan  1, 1970 08:00:00.000167294 CST</span><br><span class="line">    [Time shift for this packet: 0.000000000 seconds]</span><br><span class="line">    Epoch Time: 0.000167294 seconds</span><br><span class="line">    [Time delta from previous captured frame: 0.000055765 seconds]</span><br><span class="line">    [Time delta from previous displayed frame: 0.000055765 seconds]</span><br><span class="line">    [Time since reference or first frame: 0.000167294 seconds]</span><br><span class="line">    Frame Number: 4</span><br><span class="line">    Frame Length: 188 bytes (1504 bits)</span><br><span class="line">    Capture Length: 188 bytes (1504 bits)</span><br><span class="line">    [Frame is marked: False]</span><br><span class="line">    [Frame is ignored: False]</span><br><span class="line">    [Protocols in frame: mp2t]</span><br><span class="line">ISO/IEC 13818-1 PID=0x100 CC=0</span><br><span class="line">    Header: 0x47410030</span><br><span class="line">        0100 0111 .... .... .... .... .... .... = Sync Byte: Correct (0x47)</span><br><span class="line">        .... .... 0... .... .... .... .... .... = Transport Error Indicator: 0</span><br><span class="line">        .... .... .1.. .... .... .... .... .... = Payload Unit Start Indicator: 1</span><br><span class="line">        .... .... ..0. .... .... .... .... .... = Transport Priority: 0</span><br><span class="line">        .... .... ...0 0001 0000 0000 .... .... = PID: Unknown (0x0100)</span><br><span class="line">        .... .... .... .... .... .... 00.. .... = Transport Scrambling Control: Not scrambled (0x0)</span><br><span class="line">        .... .... .... .... .... .... ..11 .... = Adaptation Field Control: Adaptation Field and Payload (0x3)</span><br><span class="line">        .... .... .... .... .... .... .... 0000 = Continuity Counter: 0</span><br><span class="line">    [MPEG2 PCR Analysis]</span><br><span class="line">    Adaptation Field Length: 7</span><br><span class="line">    Adaptation Field</span><br><span class="line">        0... .... = Discontinuity Indicator: 0</span><br><span class="line">        .1.. .... = Random Access Indicator: 1</span><br><span class="line">        ..0. .... = Elementary Stream Priority Indicator: 0</span><br><span class="line">        ...1 .... = PCR Flag: 1</span><br><span class="line">        .... 0... = OPCR Flag: 0</span><br><span class="line">        .... .0.. = Splicing Point Flag: 0</span><br><span class="line">        .... ..0. = Transport Private Data Flag: 0</span><br><span class="line">        .... ...0 = Adaptation Field Extension Flag: 0</span><br><span class="line">        Program Clock Reference: 0x000000000132a20c</span><br><span class="line">Reassembled in: 7139</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>多媒体</category>
        <category>ts</category>
      </categories>
      <tags>
        <tag>ts</tag>
      </tags>
  </entry>
  <entry>
    <title>RTCP协议</title>
    <url>/post/32277.html</url>
    <content><![CDATA[<blockquote>
<p>Real-time Transport Control Protocol或RTP Control Protocol或简写RTCP）是实时传输协议（RTP）的一个姐妹协议。RTCP由<span class="exturl" data-url="aHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzM1NTA=">RFC 3550<i class="fa fa-external-link-alt"></i></span>定义（取代作废的RFC 1889）。RTP 使用一个 偶数 UDP port ；而RTCP 则使用 RTP 的下一个 port，也就是一个奇数 port。RTCP与RTP联合工作，RTP实施实际数据的传输，RTCP则负责将控制包送至电话中的每个人。其主要功能是就RTP正在提供的服务质量(Quality of Service)做出反馈。</p>
</blockquote>
<p>RTCP协议将控制包周期发送给所有连接者，应用与数据包相同的分布机制。低层协议提供数据与控制包的复用，如使用单独的UDP端口号。</p>
<p>作用:</p>
<ul>
<li>主要是提供数据发布的质量反馈</li>
<li>RTCP带有称作规范名字（CNAME）的RTP源持久传输层标识</li>
<li>传送最小连接控制信息，如参加者辨识</li>
</ul>
<span id="more"></span>

<h2 id="RTCP分类"><a href="#RTCP分类" class="headerlink" title="RTCP分类"></a>RTCP分类</h2><table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">缩写</th>
<th align="center">用途</th>
</tr>
</thead>
<tbody><tr>
<td align="center">200</td>
<td align="center">SR（Sender Report）</td>
<td align="center">发送端报告</td>
</tr>
<tr>
<td align="center">201</td>
<td align="center">RR（Receiver Report）</td>
<td align="center">接收端报告</td>
</tr>
<tr>
<td align="center">202</td>
<td align="center">SDES（Source Description Items）</td>
<td align="center">源点描述</td>
</tr>
<tr>
<td align="center">203</td>
<td align="center">BYE</td>
<td align="center">结束传输</td>
</tr>
<tr>
<td align="center">204</td>
<td align="center">APP</td>
<td align="center">特定应用</td>
</tr>
</tbody></table>
<h3 id="RTCP的扩展"><a href="#RTCP的扩展" class="headerlink" title="RTCP的扩展"></a>RTCP的扩展</h3><table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">缩写</th>
<th align="center">用途</th>
<th align="center">所在RFC</th>
</tr>
</thead>
<tbody><tr>
<td align="center">195</td>
<td align="center">1J(Extended Jitter Report)</td>
<td align="center">扩展Jitter报告</td>
<td align="center">RFC 5450</td>
</tr>
<tr>
<td align="center">205</td>
<td align="center">RTPFB(Transport FB)</td>
<td align="center">传输层反馈</td>
<td align="center"><span class="exturl" data-url="aHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzQ1ODU=">RFC 4585<i class="fa fa-external-link-alt"></i></span></td>
</tr>
<tr>
<td align="center">206</td>
<td align="center">PSFB(Payload-specific FB)</td>
<td align="center">负载相关反馈</td>
<td align="center">RFC 5104</td>
</tr>
<tr>
<td align="center">207</td>
<td align="center">XR(Exteneded Report)</td>
<td align="center">扩展报告</td>
<td align="center">RFC 3611</td>
</tr>
</tbody></table>
<blockquote>
<ul>
<li>FB: Feedback(反馈)</li>
</ul>
</blockquote>
<h2 id="反馈报文"><a href="#反馈报文" class="headerlink" title="反馈报文"></a>反馈报文</h2><p>类型:</p>
<ul>
<li>Transport layer FB messages</li>
<li>Payload-specific FB messages</li>
<li>Application layer FB messages</li>
</ul>
<h3 id="报文格式"><a href="#报文格式" class="headerlink" title="报文格式"></a>报文格式</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0                   1                   2                   3</span><br><span class="line">  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><br><span class="line"> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line"> |V=2|P|   FMT   |       PT      |          length               |</span><br><span class="line"> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line"> |                  SSRC of packet sender                        |</span><br><span class="line"> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line"> |                  SSRC of media source                         |</span><br><span class="line"> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line"> :            Feedback Control Information (FCI)                 :</span><br><span class="line"> :                                                               :</span><br></pre></td></tr></table></figure>

<ul>
<li>version(V), 2bits : 标识当前RTP版本2</li>
<li>padding(P), 1bit : 填充位标识</li>
<li>Feedback message type(FMT), 5bits : 标识反馈消息的类型</li>
<li>Payload type (PT), 8 bits : rtcp包的类型</li>
<li>Length, 16 bits :</li>
</ul>
<h3 id="FMT报文子类型"><a href="#FMT报文子类型" class="headerlink" title="FMT报文子类型"></a>FMT报文子类型</h3><table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">子类型</th>
<th align="center">缩写</th>
<th align="center">用途</th>
</tr>
</thead>
<tbody><tr>
<td align="center">205</td>
<td align="center">1</td>
<td align="center">Generic NACK</td>
<td align="center">RTP丢包重传</td>
</tr>
<tr>
<td align="center">-</td>
<td align="center">3</td>
<td align="center">TMMBR</td>
<td align="center">Temporary Maximum Media Stream Bitrate Request</td>
</tr>
<tr>
<td align="center">-</td>
<td align="center">4</td>
<td align="center">TMMBN</td>
<td align="center">Temporary Maximum Media Stream Bitrate Notification</td>
</tr>
<tr>
<td align="center">206</td>
<td align="center">1</td>
<td align="center">PLI</td>
<td align="center">Picture Loss Indication</td>
</tr>
</tbody></table>
<h3 id="Generic-NACK"><a href="#Generic-NACK" class="headerlink" title="Generic NACK"></a>Generic NACK</h3><blockquote>
<p>The Generic NACK message is identified by <code>PT=RTPFB</code> and <code>FMT=1</code>.</p>
</blockquote>
<p>消息语法:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0                   1                   2                   3</span><br><span class="line">  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><br><span class="line"> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line"> |            PID                |             BLP               |</span><br><span class="line"> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure>

<ul>
<li>PID: Packet ID (PID): 16 bits<ul>
<li>丢失RTP包的ID</li>
</ul>
</li>
<li>BLP:  bitmask of following lost packets (BLP): 16 bits<ul>
<li>从PID开始接下来16个RTP数据包的丢失情况,一个NACK报文可以携带多个RTP序列号，NACK接收端对这些序列号逐个处理。</li>
</ul>
</li>
</ul>
<h2 id="丢包重传"><a href="#丢包重传" class="headerlink" title="丢包重传"></a>丢包重传</h2><p>如果在接收端检查到出现丢包现象,通过RTCP发送丢包ID接可以让丢包重传.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">RequestLostPacket</span><span class="params">(<span class="type">rtp_t</span> *rtp, <span class="type">unsigned</span> <span class="type">int</span> rtpSsrc, <span class="type">int</span> seqNo)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> FB_msg_packet[<span class="number">128</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> srcId = rtpSsrc;</span><br><span class="line">    <span class="type">int</span> blp = <span class="number">0</span>; <span class="comment">//表示一个只处理一个丢包</span></span><br><span class="line"></span><br><span class="line">    FB_msg_packet[<span class="number">0</span>] = <span class="number">0x80</span> | <span class="number">1</span>;  <span class="comment">// version=2, Generic NACK</span></span><br><span class="line">    FB_msg_packet[<span class="number">1</span>] = <span class="number">205</span>;       <span class="comment">// RTPFB</span></span><br><span class="line">    FB_msg_packet[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">    FB_msg_packet[<span class="number">3</span>] = <span class="number">3</span>;         <span class="comment">//length = 3</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// SSRC of packet sender</span></span><br><span class="line">    FB_msg_packet[<span class="number">4</span>] = <span class="number">0xde</span>;</span><br><span class="line">    FB_msg_packet[<span class="number">5</span>] = <span class="number">0xad</span>;</span><br><span class="line">    FB_msg_packet[<span class="number">6</span>] = <span class="number">0xbe</span>;</span><br><span class="line">    FB_msg_packet[<span class="number">7</span>] = <span class="number">0xef</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//SSRC of media source</span></span><br><span class="line">    FB_msg_packet[<span class="number">8</span>] = (srcId &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">    FB_msg_packet[<span class="number">9</span>] = (srcId &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">    FB_msg_packet[<span class="number">10</span>] = (srcId &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">    FB_msg_packet[<span class="number">11</span>] = (srcId &amp; <span class="number">0xff</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//lost packet ID</span></span><br><span class="line">    FB_msg_packet[<span class="number">12</span>] = (seqNo &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">    FB_msg_packet[<span class="number">13</span>] = (seqNo &amp; <span class="number">0xff</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//BLP</span></span><br><span class="line">    FB_msg_packet[<span class="number">14</span>] = (blp &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">    FB_msg_packet[<span class="number">15</span>] = (blp &amp; <span class="number">0xff</span>);</span><br><span class="line"></span><br><span class="line">    net_session_write(&amp;rtp-&gt;rtcp_net, FB_msg_packet, <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="其他格式"><a href="#其他格式" class="headerlink" title="其他格式"></a>其他格式</h2><h3 id="SR-Sender-Report-RTCP-Packet"><a href="#SR-Sender-Report-RTCP-Packet" class="headerlink" title="SR: Sender Report RTCP Packet"></a>SR: Sender Report RTCP Packet</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0                   1                   2                   3</span><br><span class="line">        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><br><span class="line">       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">header |V=2|P|    RC   |   PT=SR=200   |             length            |</span><br><span class="line">       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">       |                         SSRC of sender                        |</span><br><span class="line">       +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+</span><br><span class="line">sender |              NTP timestamp, most significant word             |</span><br><span class="line">info   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">       |             NTP timestamp, least significant word             |</span><br><span class="line">       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">       |                         RTP timestamp                         |</span><br><span class="line">       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">       |                     sender&#x27;s packet count                     |</span><br><span class="line">       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">       |                      sender&#x27;s octet count                     |</span><br><span class="line">       +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+</span><br><span class="line">report |                 SSRC_1 (SSRC of first source)                 |</span><br><span class="line">block  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">  1    | fraction lost |       cumulative number of packets lost       |</span><br><span class="line">       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">       |           extended highest sequence number received           |</span><br><span class="line">       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">       |                      interarrival jitter                      |</span><br><span class="line">       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">       |                         last SR (LSR)                         |</span><br><span class="line">       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">       |                   delay since last SR (DLSR)                  |</span><br><span class="line">       +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+</span><br><span class="line">report |                 SSRC_2 (SSRC of second source)                |</span><br><span class="line">block  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">  2    :                               ...                             :</span><br><span class="line">       +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+</span><br><span class="line">       |                  profile-specific extensions                  |</span><br><span class="line">       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure>


<h3 id="RR-Receiver-Report-RTCP-Packet"><a href="#RR-Receiver-Report-RTCP-Packet" class="headerlink" title="RR: Receiver Report RTCP Packet"></a>RR: Receiver Report RTCP Packet</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0                   1                   2                   3</span><br><span class="line">      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><br><span class="line">     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">header |V=2|P|    RC   |   PT=RR=201   |             length            |</span><br><span class="line">     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">     |                     SSRC of packet sender                     |</span><br><span class="line">     +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+</span><br><span class="line">report |                 SSRC_1 (SSRC of first source)                 |</span><br><span class="line">block  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">1    | fraction lost |       cumulative number of packets lost       |</span><br><span class="line">     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">     |           extended highest sequence number received           |</span><br><span class="line">     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">     |                      interarrival jitter                      |</span><br><span class="line">     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">     |                         last SR (LSR)                         |</span><br><span class="line">     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">     |                   delay since last SR (DLSR)                  |</span><br><span class="line">     +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+</span><br><span class="line">report |                 SSRC_2 (SSRC of second source)                |</span><br><span class="line">block  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">2    :                               ...                             :</span><br><span class="line">     +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+</span><br><span class="line">     |                  profile-specific extensions                  |</span><br><span class="line">     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>多媒体</category>
        <category>传输</category>
      </categories>
      <tags>
        <tag>rtcp</tag>
      </tags>
  </entry>
  <entry>
    <title>图像处理——灰度化、二值化、反色、饱和度、对比度</title>
    <url>/post/25039.html</url>
    <content><![CDATA[<h2 id="RGB"><a href="#RGB" class="headerlink" title="RGB"></a>RGB</h2><p>RGB色彩模式使用RGB模型为图像中每个像素的RGB分量分配一个0~255范围内的强度值。RGB图像仅仅使用三种颜色，R(red)、G(green)、B(blue)，就能够使它们依照不同的比例混合，在屏幕上呈现16777216(256 * 256 * 256)种颜色。</p>
<p>在电脑中，RGB的所谓“多少”就是指亮度，并使用整数来表示。通常情况下，RGB各有256级亮度，用数字表示为从0、1、2…直到255。</p>
<span id="more"></span>

<h2 id="ARGB"><a href="#ARGB" class="headerlink" title="ARGB"></a>ARGB</h2><p>一种色彩模式，也就是RGB色彩模式附加上Alpha（透明度）通道，常见于32位位图的存储结构。</p>
<p><code>ARGB</code>— Alpha,Red,Green,Blue.</p>
<h2 id="灰度化"><a href="#灰度化" class="headerlink" title="灰度化"></a>灰度化</h2><p>在RGB模型中，假设R&#x3D;G&#x3D;B时，则彩色表示一种灰度颜色，当中R&#x3D;G&#x3D;B的值叫灰度值，因此，灰度图像每一个像素仅仅需一个字节存放灰度值（又称强度值、亮度值），灰度范围为0-255。一般有下面四种方法对彩色图像进行灰度化</p>
<h2 id="二值化"><a href="#二值化" class="headerlink" title="二值化"></a>二值化</h2><p>一幅图像包含目标物体、背景还有噪声，要想从多值的数字图像中直接提取出目标物体，最经常使用的方法就是<strong>设定一个全局的阈值T，用T将图像的数据分成两部分：大于T的像素群和小于T的像素群。将大于T的像素群的像素值设定为白色（或者黑色），小于T的像素群的像素值设定为黑色（或者白色）。</strong></p>
<h2 id="反色"><a href="#反色" class="headerlink" title="反色"></a>反色</h2><p>反色的实际含义是将R、G、B值反转，若颜色的量化级别是256，则新图的R、G、B值为255减去原图的R、G、B值。</p>
<h2 id="饱和度"><a href="#饱和度" class="headerlink" title="饱和度"></a>饱和度</h2><p>所谓的饱和度，指的其实是色彩的纯度，纯度越高，表现越鲜明，纯度较低，表现则较黯淡，色饱和度表示光线的彩色深浅度或鲜艳度，取决于彩色中的白色光含量，白光含量越高，即彩色光含量就越低，色彩饱和度即越低，反之亦然。其数值为百分比，介于0-100% 之间。纯白光的色彩饱和度为0，而纯彩色光的饱和度则为100%。</p>
<h2 id="对比度"><a href="#对比度" class="headerlink" title="对比度"></a>对比度</h2><p>对比度指的是一幅图像中明暗区域最亮的白和最暗的黑之间不同亮度层级的测量，差异范围越大代表对比越大，差异范围越小代表对比越小，好的对比率120:1就可容易地显示生动、丰富的色彩，当对比率高达300:1时，便可支持各阶的颜色。但对比率遭受和亮度相同的困境，现今尚无一套有效又公正的标准来衡量对比率，所以最好的辨识方式还是依靠使用者眼睛。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2V2c3FpZXppL2FydGljbGUvZGV0YWlscy83OTA1NDM2">图像分析–灰度化,二值化,反色,饱和度，对比度<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0tvZmZlaW5GbHVtbWkvYXJtYWtl">C实现（PAA转换，二值化&#x2F;快速化，PBO打包）<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>多媒体</category>
        <category>编码</category>
      </categories>
      <tags>
        <tag>图像</tag>
      </tags>
  </entry>
  <entry>
    <title>数据压缩算法---霍夫曼编码（Huffman）</title>
    <url>/post/3506.html</url>
    <content><![CDATA[<p>霍夫曼编码是一种基于<code>最小冗余编码</code>的压缩算法。最小冗余编码是指，如果知道一组数据中符号出现的频率，就可以用一种特殊的方式来表示符号从而减少数据需要的存储空间。</p>
<ul>
<li>用较少的位对出现频率高的符号编码</li>
<li>用较多的位对出现频率低的符号编码</li>
</ul>
<p>一个符号不一定必须是文本字符，它可以是任何大小的数据，但往往它只占一个字节。</p>
<blockquote>
<p>Huffman Coding：译为哈夫曼编码、赫夫曼编码、霍夫曼编码。 是<code>可变字长编码(VLC)</code>的一种。用于<code>无损数据压缩</code>的<code>熵编码（权编码）</code>算法，是一种通过字符出现频率，根据二叉树实现。</p>
</blockquote>
<span id="more"></span>

<h2 id="编码示例"><a href="#编码示例" class="headerlink" title="编码示例"></a>编码示例</h2><h3 id="编码字符统计"><a href="#编码字符统计" class="headerlink" title="编码字符统计"></a>编码字符统计</h3><table>
<thead>
<tr>
<th align="center">符号</th>
<th align="center">概率</th>
<th align="center">每个实例的熵</th>
</tr>
</thead>
<tbody><tr>
<td align="center">U</td>
<td align="center">12&#x2F;72</td>
<td align="center">2.584 963</td>
</tr>
<tr>
<td align="center">V</td>
<td align="center">18&#x2F;72</td>
<td align="center">2.000 000</td>
</tr>
<tr>
<td align="center">W</td>
<td align="center">7&#x2F;72</td>
<td align="center">3.362 570</td>
</tr>
<tr>
<td align="center">X</td>
<td align="center">15&#x2F;72</td>
<td align="center">2.263 034</td>
</tr>
<tr>
<td align="center">Y</td>
<td align="center">20&#x2F;72</td>
<td align="center">1.847 997</td>
</tr>
</tbody></table>
<h4 id="熵和最小冗余"><a href="#熵和最小冗余" class="headerlink" title="熵和最小冗余"></a>熵和最小冗余</h4><p>每个数据集都有一定的信息量，这就是所谓的熵。一组数据的熵是数据中每个符号熵的总和</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Sz = -lg2 Pz</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>Pz</code> 就数据集中z出现的频率</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Su = -lg2(12/72) = 2.584 963位</span><br></pre></td></tr></table></figure>
<blockquote>
<p>72个字符的字符串中，U字符最少可以使用3位表示（四舍五入）</p>
</blockquote>
<h3 id="构造霍夫曼树"><a href="#构造霍夫曼树" class="headerlink" title="构造霍夫曼树"></a>构造霍夫曼树</h3><p><img data-src="/images/2019/02/huffman_tree.png" alt="huffman_tree"></p>
<p><strong>出现频率越多的会越在上层，编码也越短，出现频率越少的就越在下层，编码也越长</strong></p>
<blockquote>
<p>用霍夫曼树压缩数据，给定一个具体的符号，从树的根开始，然后沿着树的叶向叶子结点追踪。在向下追踪的过程中.</p>
<ul>
<li>当向左分支移动时，向当前编码的末尾追加<code>0</code>；</li>
<li>当向右分支移动时，向当前编码的末尾追加<code>1</code></li>
</ul>
</blockquote>
<h3 id="编码表"><a href="#编码表" class="headerlink" title="编码表"></a>编码表</h3><table>
<thead>
<tr>
<th align="center">字符</th>
<th align="center">编码</th>
</tr>
</thead>
<tbody><tr>
<td align="center">U</td>
<td align="center">‘101’</td>
</tr>
<tr>
<td align="center">V</td>
<td align="center">‘01’</td>
</tr>
<tr>
<td align="center">W</td>
<td align="center">‘100’</td>
</tr>
<tr>
<td align="center">X</td>
<td align="center">‘00’</td>
</tr>
<tr>
<td align="center">Y</td>
<td align="center">‘11’</td>
</tr>
</tbody></table>
<h3 id="编码效率"><a href="#编码效率" class="headerlink" title="编码效率"></a>编码效率</h3><ul>
<li><p>不压缩数据大小：72*8&#x3D;576bit</p>
</li>
<li><p>压缩后数据大小：12<em>3+18</em>2+7<em>3+15</em>2+20*2&#x3D;163bit</p>
</li>
<li><p><strong>压缩比</strong>：1 - 163&#x2F;576 &#x3D; 71.7%</p>
</li>
</ul>
<p>在通常情况下，霍夫曼编码并不是最高效的压缩方法，但它压缩和解压缩的速度非常快。</p>
<ul>
<li>一般来说，造成霍夫曼编码比较耗时的原因是它需要<code>扫描两次数据</code>：一次用来计算频率；另一次才是用来压缩数据。</li>
<li>而解压缩数据非常高效，因为解码每个符号的序列只需要扫描一次霍夫曼树。</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><span class="exturl" data-url="aHR0cDovL2Jsb2cuam9iYm9sZS5jb20vMjAwOTEv">霍夫曼编码压缩算法<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>多媒体</category>
        <category>编码</category>
      </categories>
      <tags>
        <tag>huffman</tag>
      </tags>
  </entry>
  <entry>
    <title>音视频同步</title>
    <url>/post/56216.html</url>
    <content><![CDATA[<p>音视频同步主要指两类：</p>
<ul>
<li>a. 同一设备播放音视频数据之间的同步</li>
<li>b. 不同设备（同一个音视频源通过组播播放）时，多个设备之间的音视频同步。（特例）<blockquote>
<p>在使用组播进行多路投放时，视频数据画面同步，但是音频数据不同步，没有丢音效果。</p>
</blockquote>
</li>
</ul>
<span id="more"></span>

<h2 id="同一设备"><a href="#同一设备" class="headerlink" title="同一设备"></a>同一设备</h2><p>标准规定在原始音频和视频流中,<code>PTS</code>的间隔不能超过0.7s，出现在TS包头的PCR间隔不能超过0.1s。</p>
<p>同步模式：</p>
<ul>
<li>以音频为准</li>
<li>以视频为准</li>
</ul>
<blockquote>
<p>在音频和视频数据中的什么作为参考？？？</p>
</blockquote>
<h2 id="不同设备"><a href="#不同设备" class="headerlink" title="不同设备"></a>不同设备</h2><p><img data-src="/images/net/multicast/multicast_r_s_samp.png" alt="场景"></p>
<blockquote>
<p><strong>问题</strong>：实际视频投放中，视频画面同步，但是音频数据存在不同步现象。</p>
</blockquote>
<h3 id="音频产生不同步的可能性："><a href="#音频产生不同步的可能性：" class="headerlink" title="音频产生不同步的可能性："></a>音频产生不同步的可能性：</h3><ol>
<li>网络延时。</li>
<li>R端音频处理缓存区过大，数据处理之间存在时间差所致。</li>
<li>R端socket的接收buffer过大。</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vd2FuZ2d1Y2hhbmdxaW5nL3AvNTkwMDQyNi5odG1s">FFmpeg学习6：视音频同步<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>多媒体</category>
        <category>视频</category>
      </categories>
      <tags>
        <tag>视频</tag>
      </tags>
  </entry>
  <entry>
    <title>码率,帧率,分辨率对视频画质的影响</title>
    <url>/post/60235.html</url>
    <content><![CDATA[<p>在这几天的调试中降低<code>码率</code>和<code>帧率</code>后,将会减少延时和花屏的情况,主要是提高了解码的速度,但是对画质的影响,主要在于什么地方?</p>
<ul>
<li>对帧率的修改,<code>60fps</code>降到<code>25fps</code>后,看到的显示效果没有变化,为什么?对用户体验的影响</li>
</ul>
<blockquote>
<p>用户体验: 只关系视频的画面质量,如果需要存储还需要关心视频文件的大小</p>
<ul>
<li>流畅度: 主要受视频帧率(FPS)的影响</li>
<li>清晰度: 单位面积的画面所承载的信息，在对视频进行评价是就是当FPS和分辨率固定时，考察视频的清晰度。码率</li>
<li>分辨率: 视频画面的大小</li>
</ul>
</blockquote>
<span id="more"></span>

<h2 id="码率"><a href="#码率" class="headerlink" title="码率"></a>码率</h2><blockquote>
<p>码率:比特率，英文为<code>Bit Rate</code>，是指每秒传送的比特(bit)数</p>
</blockquote>
<h3 id="码率影响视频清晰度"><a href="#码率影响视频清晰度" class="headerlink" title="码率影响视频清晰度"></a>码率影响视频<code>清晰度</code></h3><p><img data-src="/images/2018/11/video_bit_rate.png" alt="video_bit_rate"></p>
<blockquote>
<p>当比特率越大，视频清晰度就越高。其影响存在边际效应递减现象，并且存在上限（视频原始数据的画质）。</p>
</blockquote>
<h3 id="码率决定了视频大小"><a href="#码率决定了视频大小" class="headerlink" title="码率决定了视频大小"></a>码率决定了视频<code>大小</code></h3><p>视频大小size和码率BitRate的关系：</p>
<p>size &#x3D; $\dfrac{VideoDuration * BitRate}{8}$</p>
<h2 id="帧率—FPS"><a href="#帧率—FPS" class="headerlink" title="帧率—FPS"></a>帧率—FPS</h2><blockquote>
<p>FPS是图像领域中的定义，是指画面每秒传输帧数，通俗来讲就是指动画或视频的画面数。FPS是测量用于保存、显示动态视频的信息数量。每秒钟帧数愈多，所显示的动作就会越流畅。</p>
<blockquote>
<p>在游戏过程中一般人不觉得卡顿的FPS频率大约是30Hz，想要达到流畅等级则需要60Hz。</p>
</blockquote>
</blockquote>
<ol>
<li><p><strong>帧率对视频画质没有影响</strong> 帧率和视频大小正相关。视频大小和FPS&#x2F;GOP_SIZE存在一定的线性相关性。</p>
<blockquote>
<p>GOP_SIZE是ffmpeg中的一个编码参数，表示的每GOP_SIZE个帧存在一个关键帧。</p>
</blockquote>
</li>
<li><p>在显示<strong>“分辨率”不变</strong>的情况下，FPS越高，则对显卡的处理能力要求越高。</p>
</li>
</ol>
<h2 id="分辨率"><a href="#分辨率" class="headerlink" title="分辨率"></a>分辨率</h2><p>分辨率对视频大小和画质有着非常重要的影响。</p>
<p>如果清晰度和流畅度不变，分辨与视频画质，大小正相关。但是前提条件是清晰度不变，单纯的增加分辨并不能带来更好的画质.</p>
<blockquote>
<p>结果显示，同等分辨率的前提下，显示屏幕越大，主观感受越差。</p>
</blockquote>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlaXhpYW9odWExMDIwL2FydGljbGUvZGV0YWlscy8xMjg1NjA4Nw==">视频质量，分辨率以及码率之间的关系<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>多媒体</category>
        <category>视频</category>
      </categories>
      <tags>
        <tag>视频 帧率</tag>
      </tags>
  </entry>
  <entry>
    <title>视频流基础知识1-PSI/SI</title>
    <url>/post/10069.html</url>
    <content><![CDATA[<p>在ts流转成es流的学习过程中,了解到PSI相关的基础知识在这里做一记录总结,方便以后查找和理解.</p>
<blockquote>
<p>在数据传输前打包成MPEG-2的TS(传输流)包,这些TS包如果没有引导信息,接收端的解码器将无法找到需要的码流信息,因此MPEG-2专门定义了<code>PSI</code>(节目信息),PSI的作用<strong>自动设置和引导解码器进行解码</strong></p>
</blockquote>
<span id="more"></span>

<h2 id="PSI-x2F-SI关键词"><a href="#PSI-x2F-SI关键词" class="headerlink" title="PSI&#x2F;SI关键词"></a>PSI&#x2F;SI关键词</h2><table>
<thead>
<tr>
<th align="center">序号</th>
<th align="center">关键字</th>
<th align="center">全拼</th>
<th align="center">翻译</th>
<th align="left">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">PSI</td>
<td align="center">Program Specific Information</td>
<td align="center">节目引导信息</td>
<td align="left">对单一码流的描述</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">SI</td>
<td align="center">Service Information</td>
<td align="center">业务信息</td>
<td align="left">对系统中所有码流的描述，包含了PSI（PSI+9张表）</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">TS包</td>
<td align="center">Transport Packet</td>
<td align="center">传输包</td>
<td align="left">数字视音频、图文数据打包成TS包</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">TS</td>
<td align="center">Transport Stream</td>
<td align="center">传输流（TS流）</td>
<td align="left">一个频道（多个节目及业务）的TS包复用后称TS流</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">PAT</td>
<td align="center">Program Association Table</td>
<td align="center">节目关联表</td>
<td align="left">将节目号码和节目映射表PID相关联，获取数据的开始</td>
</tr>
<tr>
<td align="center">6</td>
<td align="center">PMT</td>
<td align="center">Program Map Table</td>
<td align="center">节目映射表</td>
<td align="left">指定一个或多个节目的PID</td>
</tr>
<tr>
<td align="center">7</td>
<td align="center">CAT</td>
<td align="center">Conditional Access Table</td>
<td align="center">条件接收表</td>
<td align="left">将一个或多个专用EMM流分别与唯一的PID相关联</td>
</tr>
<tr>
<td align="center">8</td>
<td align="center">NIT</td>
<td align="center">Network Information Table</td>
<td align="center">网络信息表</td>
<td align="left">描述整个网络，如多少TS流、频点和调制方式等信息</td>
</tr>
<tr>
<td align="center">9</td>
<td align="center">SDT</td>
<td align="center">Service Description Table</td>
<td align="center"><strong>业务</strong>描述表</td>
<td align="left">包含业务数据（如业务名称、起始时间、持续时间等）</td>
</tr>
<tr>
<td align="center">10</td>
<td align="center">BAT</td>
<td align="center">Bouquet Association Table</td>
<td align="center">业务群关联表</td>
<td align="left">给出业务群的名称及其业务列表等信息</td>
</tr>
<tr>
<td align="center">11</td>
<td align="center">EIT</td>
<td align="center">Event Information Table</td>
<td align="center"><strong>事件</strong>信息表</td>
<td align="left">包含事件或节目相关数据，是生成EPG的主要表</td>
</tr>
<tr>
<td align="center">12</td>
<td align="center">RST</td>
<td align="center">Running Status Table</td>
<td align="center">运行状态表</td>
<td align="left">给出事件的状态（运行&#x2F;非运行）</td>
</tr>
<tr>
<td align="center">13</td>
<td align="center">TDT</td>
<td align="center">Time&amp;Date Table</td>
<td align="center">时间和日期表</td>
<td align="left">给出当前事件和日期相关信息，更新频繁</td>
</tr>
<tr>
<td align="center">14</td>
<td align="center">TOT</td>
<td align="center">Time Offset Table</td>
<td align="center">时间偏移表</td>
<td align="left">给出了当前时间日期与本地时间偏移的信息</td>
</tr>
<tr>
<td align="center">15</td>
<td align="center">ST</td>
<td align="center">Stuffing Table</td>
<td align="center">填充表</td>
<td align="left">用于使现有的段无效，如在一个传输系统的边界</td>
</tr>
<tr>
<td align="center">16</td>
<td align="center">SIT</td>
<td align="center">Stuffing Information Table</td>
<td align="center">选择信息表</td>
<td align="left">仅用于码流片段中，如记录的一段码流，包含描述该码流片段业务信息段的地方</td>
</tr>
<tr>
<td align="center">17</td>
<td align="center">DIT</td>
<td align="center">Discontinuity Information Table</td>
<td align="center">间断信息表</td>
<td align="left">仅用于码流片段，如记录的一段码流中，它将插入到码流片段业务信息间断的地方</td>
</tr>
</tbody></table>
<blockquote>
<ul>
<li><code>PAT</code>,<code>PMT</code>,<code>CAT</code>,<code>NIT</code>为<strong>PSI信息</strong>,由<strong>MPEG2标准</strong>定义,NIT是由<strong>SI标准</strong>规定</li>
<li><code>SDT</code>,<code>BAT</code>,<code>EIT</code>,<code>RST</code>,<code>TDT</code>,<code>TOT</code>,<code>ST</code>,<code>SIT</code>,<code>DIT</code>为<strong>SI信息</strong></li>
</ul>
</blockquote>
<h2 id="业务-Service-与事件-Event"><a href="#业务-Service-与事件-Event" class="headerlink" title="业务(Service)与事件(Event)"></a>业务(Service)与事件(Event)</h2><p><code>业务</code>就是指“频道”，<code>事件</code>就是“节目”.</p>
<blockquote>
<p>举个例子：CCTV1是一个频道，也就是我们所说的“业务（Service）”；《新闻联播》是一个节目，也就是我们所说的“事件(Event)”。</p>
</blockquote>
<h2 id="SI信息的构成"><a href="#SI信息的构成" class="headerlink" title="SI信息的构成"></a>SI信息的构成</h2><blockquote>
<p>SI信息内容是按照network(网络)→transport strem（传输流）→service（业务）→event（事件）的分层顺序描述</p>
</blockquote>
<p><img data-src="/images/2018/11/video_ts_si.png" alt="video_ts_SI"></p>
<p>为了能有效地从众多的数据包中组织起SI信息，而使用了很多的标识。有Network_id(网络标识)、 Original_network_id(原始网络标识)、Transport_stream_id(传输流标识)、Service id(业务标识)、eventid_id(事件标识)、Bouquet_id(业务群组标识)。</p>
<ul>
<li>一个网络信息由network_id来定位。</li>
<li>一个TS由network_id、Original_network_id、Transport_stream_id来定位，标明这个流在那个网络播发，它原属那个网络，并给它加上标识。</li>
<li>一个业务由network_id、Original_network_id、Transport_stream_id、service_id来定位，标明这个业务在那个网络播发，它原属那个网络和那个流，并给它加上标识。这体现在SDT表中。</li>
<li>一个事件由network_id、Original_network_id、Transport_stream_id、service_id、event_id来定位，标明这个事件在那个网络播发，它原属那个网络和那个流及那个业务，并给它加上标识。这体现在EIT表中。</li>
</ul>
<h3 id="SI和SI信息的各种表的PID"><a href="#SI和SI信息的各种表的PID" class="headerlink" title="SI和SI信息的各种表的PID"></a>SI和SI信息的各种表的PID</h3><table>
<thead>
<tr>
<th align="center">Table</th>
<th align="center">PID</th>
</tr>
</thead>
<tbody><tr>
<td align="center">PAT</td>
<td align="center">0x0000</td>
</tr>
<tr>
<td align="center">CAT</td>
<td align="center">0x0001</td>
</tr>
<tr>
<td align="center">TSDT</td>
<td align="center">0x0002</td>
</tr>
<tr>
<td align="center">NIT,ST</td>
<td align="center">0x0010</td>
</tr>
<tr>
<td align="center">SDT,BAT,ST</td>
<td align="center">0x0011</td>
</tr>
<tr>
<td align="center">EIT,ST</td>
<td align="center">0x0012</td>
</tr>
<tr>
<td align="center">RST,ST</td>
<td align="center">0x0013</td>
</tr>
<tr>
<td align="center">TDT,TOT,ST</td>
<td align="center">0x0014</td>
</tr>
<tr>
<td align="center">DIT</td>
<td align="center">0x001E</td>
</tr>
<tr>
<td align="center">SIT</td>
<td align="center">0x001F</td>
</tr>
</tbody></table>
<h3 id="表"><a href="#表" class="headerlink" title="表"></a>表</h3><blockquote>
<p>表是组成SI信息的一种数据结构。</p>
</blockquote>
<p>由MPEG-2定义的TS里面，数据包携带了两类信息：</p>
<ul>
<li>一是音、视频等素材的数据，</li>
<li>二是PSI表。</li>
</ul>
<p>具有给定PID的数据包的有序排列就形成了TS 流。PSI表里的承载的内容主要是TS（本节目流）的描述参数。</p>
<p>由MPEG-2定义的PSI主要包含有三个表：<code>PAT</code>、<code>PMT</code>、<code>CAT</code>。每个表都可作为一个或多个TS包的净荷插入TS中传送。</p>
<p>一个TS数据包的净荷为188个字节，当一个PSI&#x2F;SI表的字节长度大于184字节时，就要对这个表进行分割，形成段（section）来传送。分段机制主要是将一个数据表分割成多个数据段。在PSI&#x2F;SI表到TS包的转换过程中，段起到了中介的作用。由于一个数据包只有188字节，而段的长度是可变的，EIT表的段限长4096字节，其余PSI&#x2F;SI表的段限长为1024字节。因此，一个段要分成几部分插入到TS包的净荷中。<br><img data-src="/images/2018/11/video_ts_table.png" alt="video_ts_table"></p>
<h2 id="缩写"><a href="#缩写" class="headerlink" title="缩写"></a>缩写</h2><ul>
<li>EPG(Electronic Program Guide) : 电子节目指南</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2trZGVzdGlueS9hcnRpY2xlL2RldGFpbHMvMTI5OTM5NzE=">【PSI&#x2F;SI学习系列】2.PSI&#x2F;SI深入学习1——预备知识<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL2Jsb2cuc2luYS5jb20uY24vcy9ibG9nX2E1N2MxNTY4MDEwMTRwNTcuaHRtbA==">PSI&#x2F;SI解析（各种id说明）<i class="fa fa-external-link-alt"></i></span></li>
<li>DVB-T Transport Stream :<span class="exturl" data-url="aHR0cHM6Ly9jc2llLm50dXQuZWR1LnR3L2xhYmFzcGwvZWR1L01QRUcyX1RTKE5DVFUyKUEucGRm">https://csie.ntut.edu.tw/labaspl/edu/MPEG2_TS(NCTU2)A.pdf<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>多媒体</category>
        <category>视频</category>
      </categories>
      <tags>
        <tag>视频 psi</tag>
      </tags>
  </entry>
  <entry>
    <title>micro2440开发板启动linux</title>
    <url>/post/32798.html</url>
    <content><![CDATA[<h3 id="1-Micro2440移植Linux2-6的流程"><a href="#1-Micro2440移植Linux2-6的流程" class="headerlink" title="1.Micro2440移植Linux2.6的流程"></a>1.Micro2440移植Linux2.6的流程</h3><blockquote>
<blockquote>
<p>移植uboot-&gt;移植内核-&gt;移植文件系统</p>
</blockquote>
</blockquote>
<p>这里只记录在开发板启动时，移植的基本步骤：</p>
<h3 id="2-烧写Linux内核镜像"><a href="#2-烧写Linux内核镜像" class="headerlink" title="2.烧写Linux内核镜像"></a>2.烧写Linux内核镜像</h3><h4 id="a-修改uboot环境变量"><a href="#a-修改uboot环境变量" class="headerlink" title="a.修改uboot环境变量"></a>a.修改uboot环境变量</h4><pre><code>setenv bootargs &#39;root=/dev/mtdblock2 noinitrd console=ttySAC0,115200&#39;

setenv bootcmd &#39;nand read 0x30008000 0x200000 0x400000;bootm&#39;
</code></pre>
<p><strong>注</strong>：<br>root&#x3D;&#x2F;dev&#x2F;mtdblock2指定根文件系统路径，&#x2F;dev&#x2F;mtdblock2表示在nandflash的第三块分区中（第一块分区用0表示）。<br>bootm指使用uImage引导<br>修改完uboot引导命令后，就制作uImage</p>
<!---more--->
<h4 id="b-制作内核镜像"><a href="#b-制作内核镜像" class="headerlink" title="b.制作内核镜像"></a>b.制作内核镜像</h4><p>根据自己项目的需求的开发板的设计，剪裁linux内核进行编译。linux内核编译完有两种不同格式的内核镜像（uImage和zImage）。<br>uImage和zImage的区别：</p>
<blockquote>
<p>这两个都是内核，zImage是真正的内核，在内存中的地址0x30008000；而uImage是包含64字节头的内核，在头中存放着bootargs环境变量，在内存中的地址0x30007fc0<br>![uImage和zImage区别]（&#x2F;images&#x2F;uImage-zImage.PNG）</p>
</blockquote>
<p>到这时你就要选择到底使用哪个镜像了，这里根据你uboot的环境变量bootcmd判断。</p>
<h4 id="c-选择镜像"><a href="#c-选择镜像" class="headerlink" title="c.选择镜像"></a>c.选择镜像</h4><h5 id="烧写zImage"><a href="#烧写zImage" class="headerlink" title="烧写zImage"></a>烧写zImage</h5><p>到这里想那就烧写正真的内核吧zImage，我们uboot中也是在0x30008000内存地址中启动的，将zImage烧写到nandflash启动开发板，内核启动错。</p>
<pre><code>Starting kernel ...

test:machid:805306624
test: bi_boot_params:0x31f5bfb8
test:starting 1
data abort
pc : [&lt;30008008&gt;]          lr : [&lt;31f98ba4&gt;]
sp : 31f5ba94  ip : 30008000     fp : 31f5bca4
r10: 00000000  r9 : 00000001     r8 : 31f5bfdc
r7 : 00000000  r6 : 31fcbd1c     r5 : 31f5c83d  r4 : 00000000
r3 : 31f5bfb8  r2 : 30000100     r1 : 000000c1  r0 : 00000000
Flags: nZCv  IRQs off  FIQs off  Mode SVC_32
Resetting CPU ...
</code></pre>
<p>内核不断重启就是进不去，是因为缺失内核的一个头部信息，需要添加64字节的内核头，zImage也需要添加。<br>怎么添加头呢，需要什么工具？<br>编译完成uboot已经提供的这个工具<strong>mkimage</strong><br>工具使用参数解析：</p>
<pre><code>-A指定cpu体系结构
-O指定是什么操作系统
-T指定映像类型，如standalone、kernel、ramdisk、multi、firmware、script、filesystem等
-C指定映像压缩方式，如none(不压缩)、gzip、bzip2。这里不对uImage进行压缩
-a指定映象在内存中的加载地址，映象下载到内存中时，要按照用MKIMAGE制作映象时，这个参数所指定的地址值来下载
-e 指定映象运行的入口点地址，这个地址就是-a参数指定的值加上0x40（因为前面有个MKIMAGE添加的0x40个字节的头）
-n 指定映象名
-d 指定制作映象的源文件
</code></pre>
<p>添加所需头信息：</p>
<pre><code>16:23 [root@linfeng boot]#mkimage -n &#39;linux-2.6&#39; -A arm -O linux -T kernel -C none -a 0x30008000 -e 0x30008040 -d zImage zImage.img
</code></pre>
<p>正真内核烧写这么麻烦那就以后使用uImage</p>
<h5 id="烧写uImage"><a href="#烧写uImage" class="headerlink" title="烧写uImage"></a>烧写uImage</h5><p>将uImage镜像直接烧写到nandflash，启动开发板，无法启动。<br>不着急刚才uboot环境变量还没有修改过来呢，重新进入uboot修改环境变量</p>
<pre><code>setenv bootcmd &#39;nand read 0x30007fc0 0x200000 0x400000;bootm&#39;
</code></pre>
<p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;<br><strong>经过第二次的内核烧写测试，使用该方法也不可行，同样会报出内核恐慌错误</strong><br>现在可以正常启动，成功进入内核后有出现：</p>
<pre><code>yaffs: dev is 32505858 name is &quot;mtdblock2&quot;
yaffs: passed flags &quot;&quot;
yaffs: Attempting MTD mount on 31.2, &quot;mtdblock2&quot;
yaffs: auto selecting yaffs2
yaffs_read_super: isCheckpointed 0
VFS: Mounted root (yaffs filesystem) on device 31:2.
Freeing init memory: 156K
Warning: unable to open an initial console.
Kernel panic - not syncing: No init found.  Try passing init= option to kerne.
Backtrace:
[&lt;c00341cc&gt;] (dump_backtrace+0x0/0x10c) from [&lt;c0329f3c&gt;] (dump_stack+0x18/0x)
r7:00000000one_wire_status: 4
 r6:00000000 r5:c001f308 r4:c0481c50
[&lt;c0329f24&gt;] (dump_stack+0x0/0x1c) from [&lt;c0329f8c&gt;] (panic+0x4c/0x114)
[&lt;c0329f40&gt;] (panic+0x0/0x114) from [&lt;c002f598&gt;] (init_post+0xa8/0x10c)
r3:00000000 r2:c393a100one_wire_status: 4
 r1:c393a200 r0:c03db74c
[&lt;c002f4f0&gt;] (init_post+0x0/0x10c) from [&lt;c00084b4&gt;] (kernel_init+0xe4/0x114)
r5:c001f308 r4:c04813e0
[&lt;c00083d0&gt;] (kernel_init+0x0/0x114) from [&lt;c004bbbc&gt;] (do_exit+0x0/0x620)
 r5:00000000 r4:00000000
</code></pre>
<p>这是没有找到yaffs文件系统，因为你还没有移植呢</p>
<h3 id="移植yaffs文件系统"><a href="#移植yaffs文件系统" class="headerlink" title="移植yaffs文件系统"></a>移植yaffs文件系统</h3><p>将你自己做好的文件系统使用<a href="/src/toolchains/mkyaffs2image.tgz">mkyaffs2image</a>工具制作出文件系统镜像。可是这时使用nand write 0x30008000 0x600000 0x2100000进行烧写后，开发板启动后同样进不到文件系统。<br>正确的烧写命令：</p>
<pre><code>nand write.yaffs 0x30008000 0x600000 0x2100000
</code></pre>
<hr>
<p><strong>写入yaffs文件系统时，下载的文件系统有多大。就烧写多大，但是大小必须是2k倍</strong></p>
<h3 id="烧写的方式"><a href="#烧写的方式" class="headerlink" title="烧写的方式"></a>烧写的方式</h3><p>通过tftp将uboot、kernel、文件系统下载到0x30008000这块可读可写的内存中，然后使用nand相关命令进行操作。<br><strong>nandflash操作命令：</strong></p>
<blockquote>
<p>nand - NAND sub-system</p>
</blockquote>
<p>  Usage:<br>  nand info - show available NAND devices<br>  nand device [dev] - show or set current device<br>  nand read - addr off|partition size<br>  nand write - addr off|partition size<br>      read&#x2F;write ‘size’ bytes starting at offset ‘off’<br>      to&#x2F;from memory address ‘addr’, skipping bad blocks.<br>  nand erase [clean] [off size] - erase ‘size’ bytes from<br>      offset ‘off’ (entire device if not specified)<br>  nand read[.yaffs[1]] is not provide temporarily!<br>  nand write[.yaffs[1]]    addr off size - write the <code>size&#39; byte yaffs image stg      at offset </code>off’ from memory address &#96;addr’ (.yaffs1 for 512+16 NAND)<br>  nand bad - show bad blocks<br>  nand dump[.oob] off - dump page<br>  nand scrub - really clean NAND erasing bad blocks (UNSAFE)<br>  nand markbad off […] - mark bad block(s) at offset (UNSAFE)<br>  nand biterr off - make a bit error at offset (UNSAFE)</p>
<h3 id="附：NSF文件系统启动时，uboot环境变量的设置"><a href="#附：NSF文件系统启动时，uboot环境变量的设置" class="headerlink" title="附：NSF文件系统启动时，uboot环境变量的设置"></a>附：NSF文件系统启动时，uboot环境变量的设置</h3><pre><code>setenv bootargs &#39;noinitrd console=ttySAC0,115200 init=/linuxrc root=/dev/nfs nfsroot=192.168.11.11:/work/embedded/rootfs ip=192.168.11.22:192.168.11.11:192.168.11.11:255.255.255.0:micro2440.arm9.net:eth0&#39;


setenv bootcmd &#39;tftp 0x30007fc0 uImage ; bootm&#39;
</code></pre>
]]></content>
      <categories>
        <category>嵌入式</category>
        <category>arm</category>
      </categories>
      <tags>
        <tag>arm</tag>
      </tags>
  </entry>
  <entry>
    <title>移植mjpg-streamer</title>
    <url>/post/50611.html</url>
    <content><![CDATA[<p>Mjpg‐streamer是一个开源软件，用于从webcam摄像头采集图像，把它们以流的形式通过基于ip的网络传输到浏览器如Firefox，Cambozola，VLC播放器，Windows的移动设备或者其他拥有浏览器的移动设备</p>
<p>移植Mjpg-streamer需要libjpeg库，因此要先移植libjpeg</p>
<!---more--->
<h3 id="1-移植jpeg"><a href="#1-移植jpeg" class="headerlink" title="1.移植jpeg"></a>1.移植jpeg</h3><h4 id="a-从http-lt-x2F-x2F-www-ijg-org-files-gt-下载jpeg源码包；"><a href="#a-从http-lt-x2F-x2F-www-ijg-org-files-gt-下载jpeg源码包；" class="headerlink" title="a. 从http:&lt;&#x2F;&#x2F;www.ijg.org/files/&gt;下载jpeg源码包；"></a>a. 从http:&lt;&#x2F;&#x2F;<span class="exturl" data-url="aHR0cDovL3d3dy5pamcub3JnL2ZpbGVzLz4lRTQlQjglOEIlRTglQkQlQkRqcGVnJUU2JUJBJTkwJUU3JUEwJTgxJUU1JThDJTg1JUVGJUJDJTlC">www.ijg.org/files/&gt;下载jpeg源码包；<i class="fa fa-external-link-alt"></i></span></h4><h4 id="b-解压，进入其目录"><a href="#b-解压，进入其目录" class="headerlink" title="b. 解压，进入其目录"></a>b. 解压，进入其目录</h4><pre><code>    tar zxvf jpegsrc.v9a.tar.gz
    cd  /work/embedded/video/jpeg-9a
</code></pre>
<h4 id="c-配置源码，（具体配置项可以运行命令-x2F-configure-–help看看是什么意思，根据实际情况修改）"><a href="#c-配置源码，（具体配置项可以运行命令-x2F-configure-–help看看是什么意思，根据实际情况修改）" class="headerlink" title="c. 配置源码，（具体配置项可以运行命令.&#x2F;configure –help看看是什么意思，根据实际情况修改）"></a>c. 配置源码，（具体配置项可以运行命令.&#x2F;configure –help看看是什么意思，根据实际情况修改）</h4><pre><code>    #./configure CC=arm-linux-gcc --host=arm-unknown-linux --prefix=/work/embedded/video/jpeg --enable-shared --enable-static
</code></pre>
<p>其中&#x2F;work&#x2F;embedded&#x2F;video&#x2F;jpeg是编译后安装的目录，根据实际情况修改</p>
<h4 id="d-编译："><a href="#d-编译：" class="headerlink" title="d. 编译："></a>d. 编译：</h4><pre><code>    #make
</code></pre>
<h4 id="e-安装："><a href="#e-安装：" class="headerlink" title="e. 安装："></a>e. 安装：</h4><pre><code>    #make install
</code></pre>
<h4 id="f-拷贝库文件到开发板文件系统"><a href="#f-拷贝库文件到开发板文件系统" class="headerlink" title="f. 拷贝库文件到开发板文件系统"></a>f. 拷贝库文件到开发板文件系统</h4><p>将&#x2F;work&#x2F;embedded&#x2F;video&#x2F;jpeg-9a&#x2F;jpeg<br>目录下全部文件拷贝到开发板文件系统&#x2F;work&#x2F;embedded&#x2F;rootfs&#x2F;usr&#x2F;local&#x2F;mjpg-streamer下(此目录为mjpg-streamer在开发板的安装目录，当然你也可以把它放在开发板的&#x2F;lib&#x2F;目录下）</p>
<pre><code>    cp lib/* /work/embedded/rootfs/lib/
</code></pre>
<h3 id="2-移植mjpg-streamer"><a href="#2-移植mjpg-streamer" class="headerlink" title="2. 移植mjpg-streamer"></a>2. 移植mjpg-streamer</h3><h4 id="a-下载源码，在https-sourceforge-net-projects-mjpg-streamer-下载的源码"><a href="#a-下载源码，在https-sourceforge-net-projects-mjpg-streamer-下载的源码" class="headerlink" title="a. 下载源码，在https://sourceforge.net/projects/mjpg-streamer/下载的源码"></a>a. 下载源码，在<span class="exturl" data-url="aHR0cHM6Ly9zb3VyY2Vmb3JnZS5uZXQvcHJvamVjdHMvbWpwZy1zdHJlYW1lci8lRTQlQjglOEIlRTglQkQlQkQlRTclOUElODQlRTYlQkElOTAlRTclQTAlODE=">https://sourceforge.net/projects/mjpg-streamer/下载的源码<i class="fa fa-external-link-alt"></i></span></h4><pre><code>    #tar zxvf mjpg-streamer-r63.tar.gz
</code></pre>
<h4 id="b-修改plugins-x2F-input-uvc-x2F-Makfile"><a href="#b-修改plugins-x2F-input-uvc-x2F-Makfile" class="headerlink" title="b. 修改plugins&#x2F;input_uvc&#x2F;Makfile"></a>b. 修改plugins&#x2F;input_uvc&#x2F;Makfile</h4><pre><code>    CFLAGS = -O2 -DLINUX -D_GNU_SOURCE -Wall -shared -fPIC
</code></pre>
<p>为（即添加头文件-I）</p>
<pre><code>    CFLAGS += -O2 -DLINUX -D_GNU_SOURCE -Wall -shared -fPIC -I/work/embedded/v    ideo/jpeg-9a/jpeg/include
</code></pre>
<p>修改</p>
<pre><code>    $(CC) $(CFLAGS) -ljpeg -o $@ input_uvc.c v4l2uvc.lo jpeg_utils.lo dynctrl.lo
</code></pre>
<p>为(即添加库文件-L)</p>
<pre><code>     $(CC) $(CFLAGS) -ljpeg -L/work/embedded/video/jpeg-9a/jpeg/lib  -o $@     input_uvc.c v4l2uvc.lo jpeg_utils.lo dynctrl.lo
</code></pre>
<h4 id="c-编译"><a href="#c-编译" class="headerlink" title="c. 编译"></a>c. 编译</h4><pre><code>    #make CC=arm-linux-gcc
</code></pre>
<h4 id="d-建立mjpg-streamer安装目录"><a href="#d-建立mjpg-streamer安装目录" class="headerlink" title="d. 建立mjpg-streamer安装目录"></a>d. 建立mjpg-streamer安装目录</h4><pre><code>    mkdir /work/embedded/rootfs/usr/local/mjpg-streamer
    cp *.so /work/embedded/rootfs/usr/local/mjpg-streamer
    cp mjpg-stream /work/embedded/rootfs/usr/local/mjpg-streamer
</code></pre>
<p>将源码目录中的start.sh到&#x2F;work&#x2F;embedded&#x2F;rootfs&#x2F;mjpg-streamer目录下，www目录下的所有文件拷贝到&#x2F;work&#x2F;embedded&#x2F;rootfs&#x2F;www下，然后就可以测试啦</p>
<h4 id="e-在开发板中运行-x2F-start-sh"><a href="#e-在开发板中运行-x2F-start-sh" class="headerlink" title="e. 在开发板中运行.&#x2F;start.sh"></a>e. 在开发板中运行.&#x2F;start.sh</h4><p>修改start.sh脚本文件</p>
<pre><code>    ./mjpg_streamer -o &quot;output_http.so -w ./www&quot;
</code></pre>
<p>具体的修改方法可以根据start.sh文件中的注释或查看mjpg-streamer的帮助</p>
<pre><code>    ./mjpg_streamer --help
</code></pre>
<p>参考文章：</p>
<blockquote>
<p><span class="exturl" data-url="aHR0cDovL3d3dy5saW51eGlkYy5jb20vTGludXgvMjAxMi0wMi81NDc5N3A0Lmh0bQ==">http://www.linuxidc.com/Linux/2012-02/54797p4.htm<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cDovL2Jsb2cuY2hpbmF1bml4Lm5ldC91aWQtMjcwNzAwMzEtaWQtMzQ1ODk1Ny5odG1s">http://blog.chinaunix.net/uid-27070031-id-3458957.html<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
]]></content>
      <categories>
        <category>嵌入式</category>
        <category>arm</category>
      </categories>
      <tags>
        <tag>arm</tag>
        <tag>mjpg-streamer</tag>
      </tags>
  </entry>
  <entry>
    <title>NEC红外遥控协议</title>
    <url>/post/34467.html</url>
    <content><![CDATA[<h2 id="nec"><a href="#nec" class="headerlink" title="nec"></a>nec</h2><ul>
<li><code>8位</code>地址码，<code>8位</code>命令码</li>
<li>完整发射两次地址码和命令码，以提高可靠性</li>
<li>脉冲时间长短调制方式</li>
<li><code>38KHz</code>载波频率</li>
<li>位时间<code>1.12ms</code>或<code>2.25ms</code></li>
</ul>
<span id="more"></span>


<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuc2Jwcm9qZWN0cy5uZXQva25vd2xlZGdlL2lyL25lYy5waHA=">NEC Protocol<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2plcnJ5dXRzY24vYXJ0aWNsZS9kZXRhaWxzLzcyMDEzNTI=">NEC红外遥控协议理解与实现<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RlY2hlbGVmZW5nL2FydGljbGUvZGV0YWlscy80NTk3MjU4Mw==">红外遥控器工作原理<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>嵌入式</category>
        <category>外设</category>
      </categories>
  </entry>
  <entry>
    <title>micro2440数据传输--串口通信</title>
    <url>/post/15606.html</url>
    <content><![CDATA[<p>这段时间经过这次对比赛的准备，使用到了串口通信。或许这是最简单的通信方式吧，想弄清楚简单的数据传输协议。比较经典的i2c、CAN等数据传输，到以后的usb、ZigBee的数据传输。在这里先聊一聊串口的数据传输。</p>
<p>在Micro2440开发板上进行串口通信，要做的第一步便是串口驱动。这次我的开发板已经移植好了串口驱动。我只需进行操作，这里简单记录串口的基本操作 <strong>收数据</strong>、<strong>发数据</strong>以后用起来也方便，驱动下次分析。</p>
<!---more--->
<h3 id="串口通信"><a href="#串口通信" class="headerlink" title="串口通信"></a>串口通信</h3><p><strong>分类</strong>：同步串口通信（SPI）、异步串口通信（UART）</p>
<p>同步串行是指SPI（Serial Peripheral interface）的缩写，顾名思义就是串行外围设备接口。SPI总线系统是一种同步串行外设接口，它可以使MCU与各种外围设备以串行方式进行通信以交换信息，TRM450是SPI接口。</p>
<p>异步串行是指UART（Universal Asynchronous Receiver&#x2F;Transmitter），通用异步接收&#x2F;发送。UART是一个并行输入成为串行输出的芯片，通常集成在主板上。UART包含TTL电平的串口和RS232电平的串口。 TTL电平是3.3V的，而RS232是负逻辑电平，它定义+5<del>+12V为低电平，而-12</del>-5V为高电平，MDS2710、MDS SD4、EL805等是RS232接口，EL806有TTL接口。</p>
<h3 id="串口数据传输的特点"><a href="#串口数据传输的特点" class="headerlink" title="串口数据传输的特点"></a>串口数据传输的特点</h3><p>1.传输速度慢，数据量不大，数据一位一位的顺序传输</p>
<p>2.支持双向通信，只需一对数据线,也可以一根单向通信</p>
<pre><code>    TXD  ---------&gt; RXD

    RXD  &lt;--------- TXD

    GND  &lt;--------&gt; GND
</code></pre>
<h3 id="串口的参数配置"><a href="#串口的参数配置" class="headerlink" title="串口的参数配置"></a>串口的参数配置</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int set_opt(int fd, int nSpeed, int nBits, char nEvent, int nStop)</span><br><span class="line">&#123;</span><br><span class="line">    struct termios newtio;</span><br><span class="line">    struct termios oldtio;</span><br><span class="line"></span><br><span class="line">    if(tcgetattr(fd,&amp;oldtio) != 0)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;SetupSerial 2&quot;);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bzero(&amp;newtio,sizeof(newtio));</span><br><span class="line">    newtio.c_cflag |= CLOCAL |CREAD;</span><br><span class="line">    newtio.c_cflag &amp;= ~CSIZE;</span><br><span class="line"></span><br><span class="line">    switch(nBits)</span><br><span class="line">    &#123;</span><br><span class="line">        case 7:</span><br><span class="line">            newtio.c_cflag |= CS7;</span><br><span class="line">            break;</span><br><span class="line">        case 8:</span><br><span class="line">            newtio.c_cflag |= CS8;</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    switch(nEvent)</span><br><span class="line">    &#123;</span><br><span class="line">        case &#x27;O&#x27;:</span><br><span class="line">            newtio.c_cflag |= PARENB;</span><br><span class="line">            newtio.c_cflag |= PARODD;</span><br><span class="line">            newtio.c_iflag |= (INPCK | ISTRIP);</span><br><span class="line">            break;</span><br><span class="line">        case &#x27;E&#x27;:</span><br><span class="line">            newtio.c_iflag |= (INPCK |ISTRIP);</span><br><span class="line">            newtio.c_cflag |= PARENB;</span><br><span class="line">            newtio.c_cflag &amp;= ~PARODD;</span><br><span class="line">            break;</span><br><span class="line">        case &#x27;N&#x27;:</span><br><span class="line">            newtio.c_cflag &amp;= ~PARENB;</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    switch(nSpeed)</span><br><span class="line">    &#123;</span><br><span class="line">        case 2400:</span><br><span class="line">            cfsetispeed(&amp;newtio,B2400);</span><br><span class="line">            cfsetospeed(&amp;newtio,B2400);</span><br><span class="line">            break;</span><br><span class="line">        case 4800:</span><br><span class="line">            cfsetispeed(&amp;newtio,B4800);</span><br><span class="line">            cfsetospeed(&amp;newtio,B4800);</span><br><span class="line">            break;</span><br><span class="line">        case 9600:</span><br><span class="line">            cfsetispeed(&amp;newtio,B9600);</span><br><span class="line">            cfsetospeed(&amp;newtio,B9600);</span><br><span class="line">            break;</span><br><span class="line">        case 115200:</span><br><span class="line">            cfsetispeed(&amp;newtio,B115200);</span><br><span class="line">            cfsetospeed(&amp;newtio,B115200);</span><br><span class="line">            break;</span><br><span class="line">        case 460800:</span><br><span class="line">            cfsetispeed(&amp;newtio,B460800);</span><br><span class="line">            cfsetospeed(&amp;newtio,B460800);</span><br><span class="line">            break;</span><br><span class="line">        default:</span><br><span class="line">            cfsetispeed(&amp;newtio,B9600);</span><br><span class="line">            cfsetospeed(&amp;newtio,B9600);</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if(nStop == 1)&#123;</span><br><span class="line">        newtio.c_cflag &amp;= ~CSTOPB;</span><br><span class="line">    &#125;</span><br><span class="line">    else if(nStop ==2)&#123;</span><br><span class="line">        newtio.c_cflag |= CSTOPB;</span><br><span class="line">    &#125;</span><br><span class="line">    newtio.c_cc[VTIME] = 0;</span><br><span class="line">    newtio.c_cc[VMIN] = 0;</span><br><span class="line"></span><br><span class="line">    tcflush(fd,TCIFLUSH);</span><br><span class="line">    if((tcsetattr(fd,TCSANOW,&amp;newtio)) != 0)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;com set error&quot;);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;set done!\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int open_port(int fd,int comport)</span><br><span class="line">&#123;</span><br><span class="line">    char *dev[]=&#123;&quot;/dev/ttySAC0&quot;,&quot;/dev/ttySAC1&quot;,&quot;/dev/ttySAC2&quot;&#125;;</span><br><span class="line">    long vdisable;</span><br><span class="line">    if(comport == 1)</span><br><span class="line">    &#123;</span><br><span class="line">        fd = open(&quot;/dev/ttySAC0&quot;,O_RDWR|O_NOCTTY|O_NDELAY);</span><br><span class="line">        if(fd == -1)&#123;</span><br><span class="line">            perror(&quot;Can&#x27;t Open Serial Port&quot;);</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    else if(comport == 2)</span><br><span class="line">    &#123;</span><br><span class="line">        fd = open(&quot;/dev/ttySAC1&quot;,O_RDWR|O_NOCTTY|O_NDELAY);</span><br><span class="line">        if(fd == -1)&#123;</span><br><span class="line">            perror(&quot;Can&#x27;t Open Serial Port&quot;);</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    else if(comport == 3)</span><br><span class="line">    &#123;</span><br><span class="line">        fd = open(&quot;/dev/ttySAC2&quot;,O_RDWR|O_NOCTTY|O_NDELAY);</span><br><span class="line">        if(fd == -1)&#123;</span><br><span class="line">            perror(&quot;Can&#x27;t Open Serial Port&quot;);</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if(fcntl(fd,F_SETFL,0) &lt; 0)&#123;</span><br><span class="line">        printf(&quot;fcntl failed\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        printf(&quot;fcntl=%d\n&quot;,fcntl(fd,F_SETFL,0));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if(isatty(STDIN_FILENO) == 0)&#123;</span><br><span class="line">        printf(&quot;standard input is not a terminal device\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        printf(&quot;isatty sucess!\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printf(&quot;fd-open=%d\n&quot;,fd);</span><br><span class="line">    return fd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>###接收串口数据</p>
<pre><code>nread = read(fd,buff,n)；
</code></pre>
<h3 id="发送串口数据"><a href="#发送串口数据" class="headerlink" title="发送串口数据"></a>发送串口数据</h3><pre><code>nwrite = write(fd,buff,length);
</code></pre>
<h3 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h3><p>上面两个程序可以完成数据的收发，在具体的项目中在串口的数据传输中多种数据的传输时，会涉及到一些简单的数据处理，需要自定义一些协议。这时串口数据的收发必须精确的每个字符，不能多一个也不能少一个。</p>
<p>read、write函数，它们读写的字符必须精准，在write时写入数据的大小必须和字符串的大小一致。在送单一的数据时，对写数据大小不做要求可是在自定义协议中数据的大小关系到对方的解析。</p>
<p>这次使用的数据格式：FD 00 06 02 00 31 33 33 C8</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">char Speaker(char CMD,char par,char * pString)</span><br><span class="line">&#123;</span><br><span class="line">    char headOfFrame[5];</span><br><span class="line">    char length;         //定义字符串长度</span><br><span class="line">    char ecc = 0;        //定义校验字节</span><br><span class="line">    int i = 0;</span><br><span class="line">    if (pString == NULL) //空字符串</span><br><span class="line">        return 1;</span><br><span class="line">    headOfFrame[0]=0XFD;       //构造帧头FD</span><br><span class="line">    headOfFrame[1]=0X00;       //构造数据区长度的高字节</span><br><span class="line">    length = strlen(pString);  //需要发送文本的长度</span><br><span class="line">    headOfFrame[2]=length+3;   //构造数据区长度的低字节</span><br><span class="line">    headOfFrame[3]=CMD;        //构造命令字：合成播放命令</span><br><span class="line">    headOfFrame[4]=par;        //构造命令参数：编码格式为GB2312</span><br><span class="line">    for(i=0;i&lt;5;i++)           //依次发送构造好的5个帧头字节</span><br><span class="line">    &#123;</span><br><span class="line">        ecc=ecc^(headOfFrame[i]); //对发送的字节进行异或校验</span><br><span class="line">        write(fd,&amp;headOfFrame[i],1);</span><br><span class="line">    &#125;</span><br><span class="line">    for(i=0;i&lt;length;i++)         //依次发送待合成的文本数据</span><br><span class="line">    &#123;</span><br><span class="line">        ecc=ecc^(*pString);</span><br><span class="line">        write(fd,pString,1);</span><br><span class="line">        pString ++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    write(fd,&amp;ecc,1);    //最后发送校验和</span><br><span class="line">    return 0; //成功返回0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>嵌入式</category>
        <category>数据传输</category>
      </categories>
      <tags>
        <tag>数据传输</tag>
        <tag>串口</tag>
      </tags>
  </entry>
  <entry>
    <title>单片机延时函数简单分析</title>
    <url>/post/3878.html</url>
    <content><![CDATA[<h3 id="初识延时程序"><a href="#初识延时程序" class="headerlink" title="初识延时程序"></a>初识延时程序</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">delay</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> xms)</span></span><br><span class="line">&#123;</span><br><span class="line">  	<span class="type">unsigned</span> <span class="type">int</span> i,j;</span><br><span class="line">  	<span class="keyword">for</span>(i=xms;i&gt;<span class="number">0</span>;i--)</span><br><span class="line">    	<span class="keyword">for</span>(j=<span class="number">112</span>;j&gt;<span class="number">0</span>;j--);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用此函数可以达到我们想要的延时，使二极管发生闪烁。这也是我刚学单片机的小白，遇到的第一个问题。为什么要用延时，难道仅仅是为了闪烁，它还有啥作用；当我们调用delay(500)时，它到底延时了多长时间。。。。<span id="more"></span></li>
<li>由于是自学所以只能靠自己了，通过查阅参考书和在网上搜索，自己也算理解一点。现在就将自己理解的记录一下，就当做笔记了</li>
</ul>
<h3 id="术语解释"><a href="#术语解释" class="headerlink" title="术语解释"></a>术语解释</h3><ol>
<li><p><strong>振荡周期：</strong>也称时钟周期，是指为单片机提供时钟脉冲信号的振荡源的周期，两个相邻同方向峰值之间的时间,一个时钟周期 ＝晶振的倒数。。</p>
</li>
<li><p><strong>状态周期：</strong>每个状态周期为时钟周期的2倍，是振荡周期经二分频后得到的。</p>
</li>
<li><p><strong>机器周期：</strong>指单片机完成一个基本操作所花费的时间，一般使用微秒来计量单片机的运行速度，12Mhz的频率，其周期为1&#x2F;12乘10的-6方s,那么1个机器周期就是它的12倍，即1us。51 单片机的一个机器周期包括12个时钟振荡周期，也就是说如果51 单片机采用12MHz 晶振，那么执行一个机器周期就只需要1μs；如果采用的是6MHz 的晶振，那么执行一个机器周期就需要2 μs。</p>
</li>
<li><p><strong>指令周期：</strong>指单片机执行一条指令所需要的时间，一般利用单片机的机器周期来计量指令周期。在51 单片机里有单周期指令（执行这条指令只需一个机器周期），双周期指令（执行这条指令只需要两个机器周期），四周期指令（执行这条指令需要四个机器周期）。除了乘、除两条指令是四周期指令，其余均为单周期或双周期指令。也就是说，如果51 单片机采用的是12MHz 晶振，那么它执行一条指令一般只需<br>1<del>2 微秒的时间；如果采用的是6MH 晶振，执行一条指令一般就需2</del>4 微秒的时间。</p>
</li>
</ol>
<ul>
<li>MCS-51单片机的一个机器周期&#x3D;6个状态周期&#x3D;12个时钟周期</li>
</ul>
<h3 id="为什么要用延时"><a href="#为什么要用延时" class="headerlink" title="为什么要用延时"></a>为什么要用延时</h3><ol>
<li>时序是描述对象之间发送消息的时间顺序显示多个对象之间的动态协作，这样就需要等待，等待就可以通过延时子程序实现。</li>
<li>为了单纯的等待，比如交通信号灯的控制，红灯绿灯黄灯都有时间控制，亮的长短就要由延时程序控制，或者CPU速度快于外设速度时，就需要用延时程序做等待！</li>
<li>为了某些时序逻辑器件的时序要求。</li>
</ol>
<h3 id="延时的具体实现方法"><a href="#延时的具体实现方法" class="headerlink" title="延时的具体实现方法"></a>延时的具体实现方法</h3><ul>
<li>在单片机编程里面并没有真正的延时指令，从上面的概念中我们知道单片机每执行一条指令都需要一定的时间，所以要达到延时的效果，只须让单片机不断地执行没有具体实际意义的指令，从而达到了延时。</li>
</ul>
<h4 id="汇编语言中基本的延时语句"><a href="#汇编语言中基本的延时语句" class="headerlink" title="汇编语言中基本的延时语句"></a>汇编语言中基本的延时语句</h4><ol>
<li><p>数据传送指令 MOV<br>数据传送指令功能是将数据从一个地方复制、拷贝到另一个地方。</p>
<pre><code> MOV R7，#80H   ；将数据80H
</code></pre>
<p>送到寄存器R7，这时寄存器R7里面存放着80H，就单这条指令而言并没有任何实际意义，而执行该指令则需要一个机器周期。</p>
</li>
<li><p>空操作指令 NOP<br>空操作指令功能只是让单片机执行没有意义的操作，消耗一个机器周期。</p>
</li>
<li><p>循环转移指令 DJNZ<br>循环转移指令功能是将第一个数进行减1 并判断是否为0，不为0 则转移到指定地点；为0 则往下执行。</p>
<pre><code> DJNZ R7，KK ；
</code></pre>
<p>将寄存器R7 的内容减1 并判断寄存器R7 里的内容减完1 后是否为0<br>如果不为0 则转移到地址标号为KK 的地方；<br>如果为0 则执行下一条指令。这条指令需要2个机器周期。<br>利用以上三条指令的组合就可以比较精确地编写出所需要的延时程序。</p>
</li>
</ol>
<h4 id="C51下的延时语句"><a href="#C51下的延时语句" class="headerlink" title="C51下的延时语句"></a>C51下的延时语句</h4><ol>
<li>使用空的for循环，可以多层嵌套，比如上面给出的例子</li>
<li>使用while()语句</li>
</ol>
<ul>
<li><strong>注意：</strong>在C51中定义循环变量时，尽量采用无符号整型；for，while循环变量体变量采用减减方法。</li>
</ul>
<h3 id="延时程序时间的计算"><a href="#延时程序时间的计算" class="headerlink" title="延时程序时间的计算"></a>延时程序时间的计算</h3><h4 id="汇编指令的时间计算"><a href="#汇编指令的时间计算" class="headerlink" title="汇编指令的时间计算"></a>汇编指令的时间计算</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">	MOV R6，   #<span class="number">20</span></span><br><span class="line">D1：MOV R7，   #<span class="number">248</span></span><br><span class="line">      	DNJZ R7，$ <span class="comment">//循环248次，共用248X2us,</span></span><br><span class="line">      	DNJZ R6，D1</span><br></pre></td></tr></table></figure>
<ul>
<li>我觉得应该从最后往前算，在MOR R7，#248执行一次前提下，用时1X2us,然后循环减248，用时248X2us,故共用时[2+2X248]us。<br>然而又由于DNJZ R6，D1，上面的过程又循环20次，故上面的循环最终用时20X[2+2X248]us。<br>接着注意到单纯DNJZ R6，D1会用时20X2&#x3D;40us<br>最后注意过执行唯一一次的  MOV R6，#20会用时1X2us。</li>
</ul>
<h4 id="C51延时函数的计算"><a href="#C51延时函数的计算" class="headerlink" title="C51延时函数的计算"></a>C51延时函数的计算</h4><ul>
<li>500ms延时子程序程序:.(晶振12MHz,一个机器周期1us.一条指令周期2us)</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">delay500ms</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> i,j,k;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">15</span>;i&gt;<span class="number">0</span>;i--)</span><br><span class="line">      <span class="keyword">for</span>(j=<span class="number">202</span>;j&gt;<span class="number">0</span>;j--)</span><br><span class="line">         <span class="keyword">for</span>(k=<span class="number">81</span>;k&gt;<span class="number">0</span>;k--);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>计算分析:程序共有三层循环</li>
</ul>
<ol>
<li>一层循环n:R5<em>2 &#x3D; 81</em>2 &#x3D; 162us  DJNZ 2us</li>
<li>二层循环m:R6*(n+3) &#x3D; 202*165 &#x3D; 33330us  DJNZ 2us + R5赋值 1us &#x3D; 3us</li>
<li>三层循环: R7*(m+3) &#x3D; 15*33333 &#x3D; 499995us DJNZ 2us + R6赋值 1us &#x3D; 3us</li>
</ol>
<ul>
<li><p>循环外: 5us [子程序调用 2us + 子程序返回 2us + R7赋值 1us &#x3D; 5us ]</p>
</li>
<li><p>延时总时间 &#x3D; 三层循环 + 循环外 &#x3D; 499995+5 &#x3D; 500 000us &#x3D;500ms</p>
</li>
<li><p><strong>所以开头给出来得延时函数delay(500)时间，循环外+ 两层循环 &#x3D; 5+112<em>2</em>500us &#x3D; 56005us &#x3D; 56.005ms &#x3D;0.056005s</strong></p>
</li>
<li><p><em>1s延时子程序 :</em></p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">delay1s</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> h,i,j,k;</span><br><span class="line">    <span class="keyword">for</span>(h=<span class="number">5</span>;h&gt;<span class="number">0</span>;h--)</span><br><span class="line"> 		<span class="keyword">for</span>(i=<span class="number">4</span>;i&gt;<span class="number">0</span>;i--)</span><br><span class="line">    		<span class="keyword">for</span>(j=<span class="number">116</span>;j&gt;<span class="number">0</span>;j--)</span><br><span class="line">    			<span class="keyword">for</span>(k=<span class="number">214</span>;k&gt;<span class="number">0</span>;k--);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间计算</li>
</ul>
<blockquote>
<p>time &#x3D; 2<em>214</em>116<em>4</em>5 + 5 &#x3D; 992 965us &#x3D; 0.992965s ≈ 1s</p>
</blockquote>
<h3 id="51单片机数据类型大小测试"><a href="#51单片机数据类型大小测试" class="headerlink" title="51单片机数据类型大小测试"></a>51单片机数据类型大小测试</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">sbit led1=P1^<span class="number">0</span>;</span><br><span class="line">sbit led2=P1^<span class="number">1</span>;</span><br><span class="line">sbit led4=P1^<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> char_size, int_size;</span><br><span class="line"></span><br><span class="line">    char_size = <span class="keyword">sizeof</span>(<span class="type">char</span>);</span><br><span class="line">	int_size = <span class="keyword">sizeof</span>(<span class="type">int</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(char_size==<span class="number">1</span>)   <span class="comment">//测试char占一个字节</span></span><br><span class="line">		led1 = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(int_size==<span class="number">2</span>)    <span class="comment">//测试int 占两个字节</span></span><br><span class="line">		led2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>嵌入式</category>
        <category>硬件设计</category>
      </categories>
      <tags>
        <tag>硬件设计</tag>
        <tag>51</tag>
      </tags>
  </entry>
  <entry>
    <title>m-jpeg技术</title>
    <url>/post/60991.html</url>
    <content><![CDATA[<p>M-JPEG是一种基于静态图像压缩技术JPEG发展起来的动态图像压缩技术，可以生成序列化的运动图像。其主要特点是基本不考虑视频流中不同帧之间的变化，只单独对某一帧进行压缩，其压缩倍数为20~80倍，适合静态画面的压缩，分辨率可从352×288到704×576。以往的JPEG压缩技术是直接处理整个画面，所以要等到整个压缩档案传输完成才开始进行解压缩成影像画面，而这样的方式造成传输一个高解析画面时须耗时数十秒甚至数分钟。而新一代的M-JPEG是采取渐层式技术，先传输低解析的图档，然后再补送细部之资料，使画面品质改善。</p>
<!---more--->

<p>M-JPEG压缩技术可以获取清晰度很高的视频图像，而且可以灵活设置每路的视频清晰度和压缩帧数。因期压缩后之格式可读单一画面，所以可以任意剪接。</p>
<p>M-JPEG因采用帧内压缩方式也适于视频编辑。 M-JPEG的主要缺点是压缩效率低，M-JPEG算法是根据每一帧图像的内容进行压缩，而不是根据相邻帧图像之间的差异来进行压缩，因此造成了大量冗余信息被重复存储，存储占用的空间大到每帧8~15K字节，最好也只能做到每帧3K字节，但如果因此而采用高压缩比则视频质量会严重降低。</p>
<p>JPEG是应用相当普遍的文件格式，能使图像占用最少的的空间，又能显示极佳的效果，在设计网页时，一般将文件存储为JPEG格式。 如果一幅彩色图片所占空间比较大，则可以将它存成压缩格式，以减小所占空间，如果此格式用于输出或印刷，那就需要解压缩</p>
]]></content>
      <categories>
        <category>嵌入式</category>
        <category>视频</category>
      </categories>
      <tags>
        <tag>视频</tag>
        <tag>jpeg</tag>
      </tags>
  </entry>
  <entry>
    <title>linux下性能分析---bootchart</title>
    <url>/post/5f89ded7.html</url>
    <content><![CDATA[<blockquote>
<p><code>BootChart</code>是一个用于linux启动过程性能分析的开源软件工具，它可以在内核装载后就开始运行，记录各个程序启动占用的时间、CPU以及硬盘读写，直到系统启动完成为止。进入系统后，bootchart可以将启动时记录下的内容生成多种格式（PNG，SVG或者EPS）的图形报表，以便分析。</p>
</blockquote>
<span id="more"></span>

<h1 id="一般应用运行分析"><a href="#一般应用运行分析" class="headerlink" title="一般应用运行分析"></a>一般应用运行分析</h1><h2 id="用perf录制系统的sched情况"><a href="#用perf录制系统的sched情况" class="headerlink" title="用perf录制系统的sched情况"></a>用perf录制系统的sched情况</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">sudo perf <span class="built_in">sched</span> record -a</span></span><br><span class="line">^C[ perf record: Woken up 5 times to write data ]</span><br><span class="line">[ perf record: Captured and wrote 11.284 MB perf.data (87520 samples) ]</span><br></pre></td></tr></table></figure>

<h2 id="生成timechart"><a href="#生成timechart" class="headerlink" title="生成timechart"></a>生成timechart</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">sudo perf timechart</span></span><br><span class="line">Written 24.6 seconds of trace to output.svg.</span><br></pre></td></tr></table></figure>

<p>使用Firefox浏览器查看生成结果：</p>
<p><img data-src="/images/2020/09/bootchart_sample.png" alt="bootchart_sample"></p>
<h1 id="系统启动时间的分析"><a href="#系统启动时间的分析" class="headerlink" title="系统启动时间的分析"></a>系统启动时间的分析</h1><h2 id="bootchart"><a href="#bootchart" class="headerlink" title="bootchart"></a>bootchart</h2><p><strong>ubuntu20.04中不适用，不过使用<code>systemd-analyze</code>可以查看开机时间和耗时部分</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install bootchart pybootchartgui</span><br></pre></td></tr></table></figure>
<blockquote>
<p><del>在ubuntu20.04系统安装后(其他系统安装也可)，下次系统启动时生成一个系统启动时的各个组件启动所花的时间的记录的图表，此图表位于:<code>/var/log/bootchart</code>文件夹下。默认格式为.png格式</del></p>
</blockquote>
<h2 id="initcall-debug内核启动图"><a href="#initcall-debug内核启动图" class="headerlink" title="initcall_debug内核启动图"></a>initcall_debug内核启动图</h2><p>这个方法多用于嵌入式系统中，在内核命令行中添加<code>initcall_debug</code>参数，可以在<code>dmesg</code>日志中打印出每个函数调用的时间点</p>
<ol>
<li>将<code>dmesg</code>的日志保存到<code>boot.log</code>中</li>
<li>运行内核源码中自带的<code>scripts/bootgraph.pl</code>脚本生成启动图(矢量图)<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scripts/bootgraph.pl boot.log &gt; boot.svg</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>工具</category>
        <category>bootchart</category>
      </categories>
      <tags>
        <tag>性能</tag>
        <tag>bootchart</tag>
      </tags>
  </entry>
  <entry>
    <title>C程序函数调用关系</title>
    <url>/post/1655.html</url>
    <content><![CDATA[<p>阅读源码</p>
<span id="more"></span>

<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get install cflow graphviz</span><br><span class="line">sudo apt-get install gawk</span><br><span class="line"></span><br><span class="line">wget -c https://github.com/tinyclub/linux-0.11-lab/raw/master/tools/tree2dotx</span><br><span class="line">wget -c https://github.com/tinyclub/linux-0.11-lab/raw/master/tools/callgraph</span><br><span class="line">sudo cp tree2dotx callgraph /usr/local/bin</span><br><span class="line">sudo chmod +x /usr/local/bin/&#123;tree2dotx,callgraph&#125;</span><br></pre></td></tr></table></figure>





<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">callgraph -f main</span><br></pre></td></tr></table></figure>



<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><span class="exturl" data-url="aHR0cDovL3RpbnlsYWIub3JnL2NhbGxncmFwaC1kcmF3LXRoZS1jYWxsdHJlZS1vZi1jLWZ1bmN0aW9ucy8=">源码分析：静态分析 C 程序函数调用关系图<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cubGludXhpZGMuY29tL0xpbnV4LzIwMTUtMDEvMTExNTAxLmh0bQ==">看开源代码利器—用Graphviz + CodeViz生成C&#x2F;C++函数调用图(call graph)<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>工具</category>
        <category>callgraph</category>
      </categories>
      <tags>
        <tag>callgraph</tag>
      </tags>
  </entry>
  <entry>
    <title>Github搭建博客的简单记录</title>
    <url>/post/32555.html</url>
    <content><![CDATA[<h3 id="起源"><a href="#起源" class="headerlink" title="起源"></a>起源</h3><ul>
<li>自从想写博客开始，就一直在找一个网站写一些自己的博文。把自己的在学习中的一些体验与心得记录下来。之前在一些网站上注册过一些<span class="exturl" data-url="aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2RyZWFtcQ==">博客<i class="fa fa-external-link-alt"></i></span>，可是广告太多了，文本格式编排很麻烦。后来看到了<span class="exturl" data-url="aHR0cDovL3d3dy5ydWFueWlmZW5nLmNvbS9ibG9nLzIwMTIvMDgvYmxvZ2dpbmdfd2l0aF9qZWt5bGwuaHRtbA==">搭建一个免费的，无限流量的Blog—-github Pages和Jekyll入门<i class="fa fa-external-link-alt"></i></span>这篇文章，就一直想这搭建一个这样的博客，终于在这个寒假接近尾声之际搭建好了。其中遇到了各种麻烦真是一言难尽，在这里简单记录一些搭建过程。</li>
</ul>
<h3 id="博客搭建"><a href="#博客搭建" class="headerlink" title="博客搭建"></a>博客搭建</h3><h5 id="1-安装jekyll进行博客站点的本地预览"><a href="#1-安装jekyll进行博客站点的本地预览" class="headerlink" title="1. 安装jekyll进行博客站点的本地预览"></a>1. 安装<span class="exturl" data-url="aHR0cDovL2pla3lsbHJiLmNvbS8=">jekyll<i class="fa fa-external-link-alt"></i></span>进行博客站点的本地预览</h5><ul>
<li>jekyll的安装需要提前安装ruby</li>
<li>$ sudo apt-get ruby1.9.1-dev<ul>
<li><pre><code>$ gem install rdiscount
</code></pre>
<ul>
<li><pre><code>$ gem install RedCloth
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<span id="more"></span>
<h5 id="2-安装Git将站点文件提交到Github"><a href="#2-安装Git将站点文件提交到Github" class="headerlink" title="2. 安装Git将站点文件提交到Github"></a>2. 安装Git将站点文件提交到<span class="exturl" data-url="aHR0cDovL2dpdGh1Yi5jb20v">Github<i class="fa fa-external-link-alt"></i></span></h5><ul>
<li>在本地站点库目录下<ul>
<li><pre><code>$ git init
</code></pre>
<ul>
<li><pre><code>$ git add .
</code></pre>
<ul>
<li><pre><code>$ git commit -m &quot;first page&quot;
</code></pre>
<ul>
<li><pre><code>$ git remote add origin https://github.com/username/username.github.com.git
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>$ git push -u origin master</li>
</ul>
<h5 id="3-利用jekyll进行本地预览"><a href="#3-利用jekyll进行本地预览" class="headerlink" title="3. 利用jekyll进行本地预览"></a>3. 利用jekyll进行本地预览</h5><ul>
<li><p>终端执行：</p>
</li>
<li><p>$ jekyll serve</p>
</li>
</ul>
<p>  然后在浏览器访问[<span class="exturl" data-url="aHR0cDovLzAuMC4wLjA6NDAwMC9d">http://0.0.0.0:4000/]<i class="fa fa-external-link-alt"></i></span></p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li>本站主题是直接从<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2RlY2VtYmVy">Luyf<i class="fa fa-external-link-alt"></i></span>clone下来的。</li>
<li><span class="exturl" data-url="aHR0cDovL3d3dy5ydWFueWlmZW5nLmNvbS9ibG9nLzIwMTIvMDgvYmxvZ2dpbmdfd2l0aF9qZWt5bGwuaHRtbA==">搭建一个免费的，无限流量的Blog—-github Pages和Jekyll入门<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL2Jsb2cuaXQ1ODAuY29tLyVFNCVCRCVCRiVFNyU5NCVBOGpla3lsbCVFNSU5QyVBOGdpdGh1YiVFNCVCOCU4QSVFNiU5RSVCNiVFOCVBRSVCRWJsb2cv">使用Jekyll在GitHub上架设Blog<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL3d3dy5zb2ltb3J0Lm9yZy9wb3N0cy8xMDEv">像黑客一样写博客——Jekyll入门<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL3dvd3VidW50dS5jb20vbWFya2Rvd24v">Markdown 语法说明 (简体中文版) <i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>工具</category>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>Github简单使用命令</title>
    <url>/post/56471.html</url>
    <content><![CDATA[<h3 id="基本工作流程"><a href="#基本工作流程" class="headerlink" title="基本工作流程"></a>基本工作流程</h3><ul>
<li><p>初始化（init）一个新的版本库，然后将目录中的所有文件纳入管理，Git把这个过程称为stage，最后以快照的方式提交所有文件。</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git init</span><br><span class="line">$ git add .</span><br><span class="line">$ git commit -m &#x27;initial commit&#x27;</span><br></pre></td></tr></table></figure></li>
</ul>
<!---more--->
<ul>
<li><p>创建一个新的分支（branch），将它检出（checkout）为活动分支，然后就可以编辑、载入和提交新的快照。</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git branch featureA</span><br><span class="line">$ git checkout featureA</span><br><span class="line"># (edit files)</span><br><span class="line">$ git add (files)</span><br><span class="line">$ git commit -m &#x27;add feature A&#x27;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="参与GitHub上的开源项目"><a href="#参与GitHub上的开源项目" class="headerlink" title="参与GitHub上的开源项目"></a>参与GitHub上的开源项目</h3><ul>
<li><p>先将托管在GitHub上的项目克隆（clone）到本地，做过更改之后推送回GitHub，然后发送一个pull请求，项目的维护者就会收到邮件通知。 在GitHub上fork（拷贝一份到你的版本库列表）项目：</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git clone https://github.com/my-user/project</span><br><span class="line">$ cd project</span><br><span class="line"># (edit files)</span><br><span class="line">$ git add (files)</span><br><span class="line">$ git commit -m &#x27;Explain what I changed&#x27;</span><br><span class="line">$ git push origin master</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>工具</category>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>Git操作</title>
    <url>/post/53101.html</url>
    <content><![CDATA[<p>记录平时对git的使用方法和技巧</p>
<!--- more --->

<h2 id="创建本地git库"><a href="#创建本地git库" class="headerlink" title="创建本地git库"></a>创建本地git库</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir test.git</span><br></pre></td></tr></table></figure>
<p>进入test.git</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git init --bare --shared</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Window下进行跨平台的clone操作，下载链接前需要添加<code>ssh</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote add origin ssh://hostname@192.168.1.1:/test.git</span><br></pre></td></tr></table></figure>
<p>Linux:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote add origin hostname@192.168.1.1:/test.git</span><br></pre></td></tr></table></figure>
</blockquote>
<p>新建单独用户下载：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">为了禁止登录将shell，修改为git-shell或者/bin/false将禁止登录</span></span><br><span class="line">sudo useradd -c &#x27;git version control&#x27; -s /usr/bin/git-shell -M git -d /git</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置密码</span></span><br><span class="line">sudo passwd git</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建home目录</span></span><br><span class="line">sudo mkdir /git</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改所属权限</span></span><br><span class="line">sudo chown -R git:git /git/</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">测试仓库</span></span><br><span class="line">sudo git init --bare --shared  /git/123.git</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo adduser git</span><br><span class="line">sudo usermod -G sudo -a git</span><br></pre></td></tr></table></figure>

<h2 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git branch branch_name</span><br></pre></td></tr></table></figure>
<p>删除本地分支：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git branch -d branch_name</span><br></pre></td></tr></table></figure>

<h2 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支"></a>切换分支</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout  branch_name</span><br></pre></td></tr></table></figure>

<h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone  URL</span><br></pre></td></tr></table></figure>
<p>下载较大工程：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone --depth=1 URL</span><br></pre></td></tr></table></figure>
<blockquote>
<p>depth用于指定克隆深度，为1即表示只克隆最近一次commit.</p>
</blockquote>
<h2 id="创建本地镜像仓库"><a href="#创建本地镜像仓库" class="headerlink" title="创建本地镜像仓库"></a>创建本地镜像仓库</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone --mirror &lt;URL&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>更新镜像库<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote update</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git commit</span><br></pre></td></tr></table></figure>

<h3 id="日志规范"><a href="#日志规范" class="headerlink" title="日志规范"></a>日志规范</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;</span><br><span class="line">// 空一行</span><br><span class="line">&lt;body&gt;</span><br><span class="line">// 空一行</span><br><span class="line">&lt;footer&gt;</span><br></pre></td></tr></table></figure>

<h4 id="type"><a href="#type" class="headerlink" title="type"></a>type</h4><ul>
<li><code>feat</code>：新功能（feature）</li>
<li><code>fix</code>：修补bug</li>
<li><code>docs</code>：文档（documentation）</li>
<li><code>style</code>： 格式（不影响代码运行的变动）</li>
<li><code>refactor</code>：重构（即不是新增功能，也不是修改bug的代码变动）</li>
<li><code>test</code>：增加测试</li>
<li><code>chore</code>：构建过程或辅助工具的变动</li>
</ul>
<h4 id="scope"><a href="#scope" class="headerlink" title="scope"></a>scope</h4><p><code>scope</code>用于说明 commit 影响的范围，比如数据层、控制层、视图层等等，视项目不同而不同。</p>
<h4 id="subject"><a href="#subject" class="headerlink" title="subject"></a>subject</h4><p>subject是 commit 目的的简短描述，不超过50个字符。填写要求：以动词开头</p>
<h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git push 远程库名  分支名</span><br></pre></td></tr></table></figure>

<h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git pull 远程库名  分支名</span><br></pre></td></tr></table></figure>

<h2 id="添加代码"><a href="#添加代码" class="headerlink" title="添加代码"></a>添加代码</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git add &lt;filename&gt;</span><br><span class="line">git add -A    #添加所有修改</span><br></pre></td></tr></table></figure>

<h2 id="查看日志"><a href="#查看日志" class="headerlink" title="查看日志"></a>查看日志</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git log</span><br><span class="line">git log -n     #查看前n条日志</span><br><span class="line">git log --stat  #查看日志的修改情况</span><br><span class="line">git log -p       #查看日志的具体修改</span><br><span class="line">git log &lt;filename/dirname&gt;  #查看该文件或目录的修改日志</span><br><span class="line">git log -S [keyword]  #在提交log中搜索关键词</span><br></pre></td></tr></table></figure>

<h3 id="tig"><a href="#tig" class="headerlink" title="tig"></a>tig</h3><blockquote>
<p>命令行下查看git历史提交记录的工具</p>
</blockquote>
<h2 id="回退"><a href="#回退" class="headerlink" title="回退"></a>回退</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git reset HEAD &lt;filename&gt; #将该文件从缓冲区撤回</span><br></pre></td></tr></table></figure>
<h2 id="查看远程库"><a href="#查看远程库" class="headerlink" title="查看远程库"></a>查看远程库</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote -v</span><br></pre></td></tr></table></figure>
<p>添加远程库：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote add &lt;name&gt; &lt;url&gt;</span><br></pre></td></tr></table></figure>

<h2 id="获取远程库中的最新版本，但与git-pull-不同它不会merge"><a href="#获取远程库中的最新版本，但与git-pull-不同它不会merge" class="headerlink" title="获取远程库中的最新版本，但与git pull 不同它不会merge"></a>获取远程库中的最新版本，但与git pull 不同它不会merge</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git  fetch  远程库名  分支名</span><br></pre></td></tr></table></figure>
<p>作用：可以对比远程库与当前本地的差异。</p>
<h2 id="查看标签"><a href="#查看标签" class="headerlink" title="查看标签"></a>查看标签</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git tag</span><br></pre></td></tr></table></figure>
<p>作用：一个稳定的版本或者完成一个功能，为了发布或者保存而打的标签，主要是发布</p>
<h2 id="切换标签"><a href="#切换标签" class="headerlink" title="切换标签"></a>切换标签</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout &lt;Tag&gt;</span><br></pre></td></tr></table></figure>

<h2 id="暂存当前改动"><a href="#暂存当前改动" class="headerlink" title="暂存当前改动"></a>暂存当前改动</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git stash</span><br></pre></td></tr></table></figure>
<blockquote>
<p>保存当前工作进度，会把暂存区和工作区的改动保存起来。执行完这个命令后，在运行git status命令，就会发现当前是一个干净的工作区，没有任何改动。使用git stash save ‘message…’可以添加一些注释</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git stash list</span><br></pre></td></tr></table></figure>
<blockquote>
<p>显示保存进度的列表。也就意味着，git stash命令可以多次执行。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git stash pop [–index] [stash_id]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>git stash pop 恢复最新的进度到工作区。git默认会把工作区和暂存区的改动都恢复到工作区。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git stash apply [–index] [stash_id]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>除了不删除恢复的进度之外，其余和git stash pop 命令一样。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git stash drop [stash_id]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>删除一个存储的进度。如果不指定stash_id，则默认删除最新的存储进度。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git stash clear</span><br></pre></td></tr></table></figure>
<blockquote>
<p>删除所有存储的进度。</p>
</blockquote>
<h2 id="恢复本地错误操作"><a href="#恢复本地错误操作" class="headerlink" title="恢复本地错误操作"></a>恢复本地错误操作</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git reflog</span><br></pre></td></tr></table></figure>
<blockquote>
<p>查看所有分支的所有操作记录（包括已经被删除的 commit 记录和 reset 的操作）</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$git reflog -h</span><br><span class="line">usage: git reflog [ show | expire | delete ]</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li><code>show</code>: 显示所有条目,缺省值</li>
<li><code>expire</code>: 删除掉更老的reflog条目</li>
<li><code>delete</code>: 从reflog中删除一个条目</li>
</ul>
</blockquote>
<h2 id="模块管理"><a href="#模块管理" class="headerlink" title="模块管理"></a>模块管理</h2><ol>
<li><p>添加模块</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git submodule add projectB.git projectB</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用子模块</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git submodule init</span><br><span class="line">git submodule update</span><br></pre></td></tr></table></figure>
<blockquote>
<p>克隆项目后，默认子模块目录下无任何内容。需要在项目根目录执行此命令完成子模块的下载</p>
<p><strong>在clone整个项目时添加递归参数:<code>--recurse-submodules</code></strong></p>
</blockquote>
</li>
<li><p>删除子模块</p>
<ol>
<li><code>rm -rf 子模块目录</code> 删除子模块目录及源码</li>
<li><code>vi .gitmodules</code> 删除项目目录下.gitmodules文件中子模块相关条目</li>
<li><code>vi .git/config</code> 删除配置项中子模块相关条目</li>
<li><code>rm .git/module/*</code> 删除模块下的子模块目录，每个子模块对应一个目录，注意只删除对应的子模块目录即可</li>
</ol>
</li>
</ol>
<p>执行完成后，再执行添加子模块命令即可，如果仍然报错，执行如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git rm --cached 子模块名称</span><br></pre></td></tr></table></figure>

<h2 id="commit统计"><a href="#commit统计" class="headerlink" title="commit统计"></a>commit统计</h2><p>可以大致了解一下每个人对这个项目提交的commit数量和大致的贡献度</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git summary</span><br></pre></td></tr></table></figure>

<h2 id="git获取最近一次提交的commit-id"><a href="#git获取最近一次提交的commit-id" class="headerlink" title="git获取最近一次提交的commit-id"></a>git获取最近一次提交的commit-id</h2><ul>
<li><p>获取完整commit id</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git rev-parse HEAD</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取short commit id</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git rev-parse --short HEAD</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="git无法忽略target-或者不生效的情况"><a href="#git无法忽略target-或者不生效的情况" class="headerlink" title=".git无法忽略target,或者不生效的情况"></a>.git无法忽略target,或者不生效的情况</h2><p><code>.gitignore</code>未生效，原因是.gitignore只能忽略那些原来没有被track的文件，如果某些文件已经被纳入了版本管理中，则修改.gitignore是无效的。那么解决方法就是先把本地缓存删除（改变成未track状态），然后再提交</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git rm -r --cached .</span><br><span class="line">git add .</span><br><span class="line">git commit -m &#x27;update .gitignore&#x27;</span><br></pre></td></tr></table></figure>

<h2 id="强制更新代码"><a href="#强制更新代码" class="headerlink" title="强制更新代码"></a>强制更新代码</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git push origin master --force</span><br></pre></td></tr></table></figure>
<ul>
<li>错误：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">remote: error: denying non-fast-forward refs/heads/master (you should pull first)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>该消息表示您不允许进行非快进推送, 远程存储库很可能在其配置中<code>denyNonFastforwards = true</code>, 要更改设置，请执行<code>git config receive.denynonfastforwards false</code></p>
</blockquote>
</li>
</ul>
<h2 id="从git中打包代码"><a href="#从git中打包代码" class="headerlink" title="从git中打包代码"></a>从git中打包代码</h2><ul>
<li>打包某一个分支<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git archive --format=tar.gz --output &quot;output.tar.gz&quot; master</span><br></pre></td></tr></table></figure></li>
<li>打包某一个commit<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git archive --format=tar.gz --output &quot;output.tar.gz&quot; ac1c53d</span><br></pre></td></tr></table></figure></li>
<li>打包某些目录<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git archive --format=tar.gz --output &quot;output.tar.gz&quot; master dir1 dir2</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="合并代码"><a href="#合并代码" class="headerlink" title="合并代码"></a>合并代码</h2><ul>
<li><p>合并指定分支到当前分支</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git merge [branch_name]</span><br></pre></td></tr></table></figure>
</li>
<li><p>选择一个commit，合并到当前分支</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git cherry-pick [branch_name]</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="查看信息"><a href="#查看信息" class="headerlink" title="查看信息"></a>查看信息</h2><ul>
<li>查看指定文件什么人在什么时间修改过<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git blame [filename]</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="git服务器"><a href="#git服务器" class="headerlink" title="git服务器"></a>git服务器</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git daemon --export-all --verbose --base-path=.</span><br></pre></td></tr></table></figure>
<ul>
<li><code>--export-all</code>: “–base-path”下所有的repo仓库</li>
<li><code>--base-path=.</code>: 定义为当前目录</li>
<li><code>--verbose</code>: 任何操作都会给当前repo通知</li>
</ul>
<h2 id="svn仓库迁移至git"><a href="#svn仓库迁移至git" class="headerlink" title="svn仓库迁移至git"></a>svn仓库迁移至git</h2><ul>
<li>svn的日志提交者与git相关用户进行绑定<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">svn log -q | awk -F &#x27;|&#x27; &#x27;/^r/ &#123;sub(&quot;^ &quot;, &quot;&quot;, $2); sub(&quot; $&quot;, &quot;&quot;, $2); print $2&quot; = &quot;$2&quot; &lt;&quot;$2&quot;&gt;&quot;&#125;&#x27; | sort -u &gt; users.txt</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>users.txt</code>的意义仅在于，将svn里面的提交者日志，注意是提交者，不是svn里面所有的用户信息都得关联</p>
</blockquote>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">aaa = git-aaa &lt;aaa@xx.com&gt; #用户名 邮件地址</span><br><span class="line">bbb = git-bbb &lt;bbb@xx.com&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用<code>git-svn</code>进行下载并提交</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt install git-svn</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git svn clone &lt;SVN_URL&gt; --no-metadata --trunk=&quot;svnproject&quot; --tags=&quot;tags&quot; --branches=&quot;svnbranches&quot; --authors-file=users.txt --preserve-empty-dirs project-dir</span><br></pre></td></tr></table></figure>

<ul>
<li><code>--no-metadata</code>: 阻止git导出SVN包含的一些无用信息</li>
<li><code>--trunk=&quot;svnproject&quot;</code>: 指定导出仓库的主干项目路径，默认trunk</li>
<li><code>--tags=&quot;tags&quot;</code>: 日志标记</li>
<li><code>--branches=&quot;svnbranches&quot;</code>: 指定svn的分支项目路径</li>
<li><code>--authors-file=users.txt</code>: 指定svn帐号在git中的映射</li>
<li><code>--preserve-empty-dirs</code>: 保留原SVN项目中的空目录</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote add origin &lt;GIT-URL&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git push origin master #--all</span><br></pre></td></tr></table></figure>

<h2 id="修改已提交的用户名和邮箱"><a href="#修改已提交的用户名和邮箱" class="headerlink" title="修改已提交的用户名和邮箱"></a>修改已提交的用户名和邮箱</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git filter-branch --commit-filter &#x27;</span><br><span class="line">if [ &quot;$GIT_AUTHOR_EMAIL&quot; = &quot;old_email@email.com&quot; ];</span><br><span class="line">then</span><br><span class="line">    GIT_AUTHOR_NAME=&quot;new_name&quot;;</span><br><span class="line">    GIT_AUTHOR_EMAIL=&quot;new_email@email.com&quot;;</span><br><span class="line">    git commit-tree &quot;$@&quot;;</span><br><span class="line">else</span><br><span class="line">    git commit-tree &quot;$@&quot;;</span><br><span class="line">    fi&#x27; HEAD</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注</strong>:可以修改但是在github中还是可以看到之前的用户名,效果不太好</p>
</blockquote>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXQtc2NtLmNvbS9ib29rL3poL3YyL0dpdC0lRTUlQjclQTUlRTUlODUlQjctJUU5JTg3JThEJUU1JTg2JTk5JUU1JThFJTg2JUU1JThGJUIy">7.6 Git 工具 - 重写历史<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<h2 id="命令行工具——tig"><a href="#命令行工具——tig" class="headerlink" title="命令行工具——tig"></a>命令行工具——tig</h2><ul>
<li>commit操作： <code>上/下键</code>可以选择log中的commit</li>
<li>查看修改信息： <code>j/k</code></li>
<li>展示commit-id： <code>shift+x</code></li>
</ul>
<h2 id="删除已删除文件或目录的所以历史记录"><a href="#删除已删除文件或目录的所以历史记录" class="headerlink" title="删除已删除文件或目录的所以历史记录"></a>删除已删除文件或目录的所以历史记录</h2><ul>
<li><p>查找大文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">列出前5个大文件</span></span><br><span class="line">git verify-pack -v .git/objects/pack/pack-*.idx | sort -k 3 -g | tail -5</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看大文件路径</span></span><br><span class="line">git rev-list --objects --all | grep 8f10eff91bb6aa2de1f5d096ee2e1687b0eab007</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git filter-branch --force --index-filter &#x27;git rm --cached --ignore-unmatch pom.xml&#x27; --prune-empty --tag-name-filter cat -- --all</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除目录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git filter-branch --force --index-filter &#x27;git rm --cached -r --ignore-unmatch qemu/qemu-4.2.0/&#x27; --prune-empty --tag-name-filter cat -- --all</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除回收</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rm -rf .git/refs/original/</span><br><span class="line">git reflog expire --expire=now --all</span><br><span class="line">git gc --prune=now</span><br><span class="line">git gc --aggressive --prune=now</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="rebase方式合并分支，分支在一条线"><a href="#rebase方式合并分支，分支在一条线" class="headerlink" title="rebase方式合并分支，分支在一条线"></a>rebase方式合并分支，分支在一条线</h2><ol>
<li>checkout到需要合并的分支feature<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git checkout feature</span><br></pre></td></tr></table></figure></li>
<li>在feature分支上合并master分支的修改，生成一个新的分支版本<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git rebase master</span><br></pre></td></tr></table></figure></li>
<li>如果存在冲突解决冲突<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git mergetool</span><br><span class="line">git rebase —continue</span><br></pre></td></tr></table></figure></li>
<li>checkout到master分支<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git checkout master</span><br></pre></td></tr></table></figure></li>
<li>合并新的feature分支到master分支<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git merge feature</span><br></pre></td></tr></table></figure></li>
<li>合并完毕，可以删除feature分支<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git branch --delete feature</span><br></pre></td></tr></table></figure></li>
<li>提交更新<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git push origin master --force</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="删除已提交的commit"><a href="#删除已提交的commit" class="headerlink" title="删除已提交的commit"></a>删除已提交的commit</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git rebase -i [commit-id]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>commit-id: 为要删除的commit的下一个commit号</p>
</blockquote>
<p>示例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pick 1821834 add gnuplot test</span><br><span class="line">pick 5522ce1 add gnuplot test shell</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Rebase e6fcac3..5522ce1 onto e6fcac3 (2 commands)</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># Commands:</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">p, pick &lt;commit&gt; = use commit</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">r, reword &lt;commit&gt; = use commit, but edit the commit message</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">e, edit &lt;commit&gt; = use commit, but stop <span class="keyword">for</span> amending</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">s, squash &lt;commit&gt; = use commit, but meld into previous commit</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">f, fixup &lt;commit&gt; = like <span class="string">&quot;squash&quot;</span>, but discard this commit<span class="string">&#x27;s log message</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">x, exec &lt;command&gt; = run command (the rest of the line) using shell</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">b, break = stop here (continue rebase later with &#x27;</span>git rebase --<span class="built_in">continue</span><span class="string">&#x27;)</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">d, drop &lt;commit&gt; = remove commit</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">l, label &lt;label&gt; = label current HEAD with a name</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">t, reset &lt;label&gt; = reset HEAD to a label</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">m, merge [-C &lt;commit&gt; | -c &lt;commit&gt;] &lt;label&gt; [# &lt;oneline&gt;]</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">.       create a merge commit using the original merge commit&#x27;</span>s</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">.       message (or the oneline, <span class="keyword">if</span> no original merge commit was</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">.       specified). Use -c &lt;commit&gt; to reword the commit message.</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># These lines can be re-ordered; they are executed from top to bottom.</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># If you remove a line here THAT COMMIT WILL BE LOST.</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># However, if you remove everything, the rebase will be aborted.</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># Note that empty commits are commented out</span></span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>将需要删除的commit前面的<code>pick</code>改写为<code>drop</code>后，保存退出</p>
</blockquote>
<ul>
<li>退出后，可能存在冲突通过<code>git mergetool</code>解决掉冲突后，使用<code>git rebase —continue</code>继续直到解决完所有冲突提示rebase成功，删除完成。</li>
<li>如果中途不想删除后，可以通过<code>git rebase --abort</code>终止删除动作</li>
</ul>
<h2 id="仓库地址为http时-用户名密码保存"><a href="#仓库地址为http时-用户名密码保存" class="headerlink" title="仓库地址为http时,用户名密码保存"></a>仓库地址为http时,用户名密码保存</h2><ul>
<li>临时生效</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config --global credential.helper cache</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config --global credential.helper store</span><br></pre></td></tr></table></figure>
<blockquote>
<p>需要在第一次使用该仓库时,输入用户名密码后,会以配置文件(.git-credentials)保存到本地,后期使用不再需要输入用户名密码</p>
</blockquote>
<p>删除保存的用户名密码配置文件:<code>rm ~/.git-credentials</code></p>
<h2 id="当前仓库信息"><a href="#当前仓库信息" class="headerlink" title="当前仓库信息"></a>当前仓库信息</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">remote=$(git remote -v | grep fetch | awk &#x27;&#123;print $2&#125;&#x27;)</span><br><span class="line">branch=$(git symbolic-ref --short -q HEAD)</span><br><span class="line">tag=$(git log -1 --decorate=short --oneline|grep -Eo &#x27;tag: (.*)[,)]+&#x27;|awk &#x27;&#123;print $2&#125;&#x27;|sed &#x27;s/)//g&#x27;|sed &#x27;s/,//g&#x27;)</span><br><span class="line">commit=$(git rev-parse --short HEAD)</span><br><span class="line">mesg=$(git log -1 --pretty=format:%B)</span><br><span class="line"></span><br><span class="line">echo &quot;$lib info: branch=$branch, tag=$tag, commit=$commit, mesg=$mesg&quot;</span><br></pre></td></tr></table></figure>

<h2 id="git-show-x2F-diff-tab显示宽度"><a href="#git-show-x2F-diff-tab显示宽度" class="headerlink" title="git show&#x2F;diff tab显示宽度"></a>git show&#x2F;diff tab显示宽度</h2><p>设置Tab显示为4个字符的宽度</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global core.pager &#x27;less -x1,5&#x27;</span><br></pre></td></tr></table></figure>

<p>设置Tab显示为8个字符的宽度（默认）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global core.pager &#x27;less&#x27;</span><br></pre></td></tr></table></figure>


<h2 id="gitattributes"><a href="#gitattributes" class="headerlink" title=".gitattributes"></a>.gitattributes</h2><p>当执行 git 动作时，.gitattributes 文件允许你指定由 git 使用的文件和路径的属性</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Declare files that always have LF line endings on checkout</span><br><span class="line">* text eol=lf</span><br><span class="line"># Denote all files that are truly binary and should not be modified</span><br><span class="line">*.bmp binary</span><br><span class="line">*.ttf binar</span><br></pre></td></tr></table></figure>

<ul>
<li><code>* text eol=lf</code>：所有文件上传仓库时将windows下的<code>eol</code>转换为linux下的<code>lf</code></li>
</ul>
<blockquote>
<p>开发者使用不同的操作系统，默认的文件结尾行就会不同。在 Windows 上默认的是回车换行（Carriage Return Line Feed, CRLF），然而，在 Linux&#x2F;MacOS 上则是换行（Line Feed, LF）。</p>
</blockquote>
<h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><h3 id="git-clone"><a href="#git-clone" class="headerlink" title="git clone"></a>git clone</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fatal: The remote end hung up unexpectedly</span><br><span class="line">fatal: early EOF</span><br><span class="line">fatal: index-pack failed</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --add core.compression -1</span><br></pre></td></tr></table></figure>
<blockquote>
<p>compression 是压缩的意思，从clone的终端输出就知道，服务器会压缩目标文件，然后传输到客户端，客户端再解压。取值为 [-1, 9]，-1 以 zlib 为默认压缩库，0 表示不进行压缩，1..9 是压缩速度与最终获得文件大小的不同程度的权衡，数字越大，压缩越慢，当然得到的文件会越小。</p>
</blockquote>
<h2 id="DoTo"><a href="#DoTo" class="headerlink" title="DoTo"></a>DoTo</h2><ol>
<li><span class="exturl" data-url="aHR0cDovL2Jsb2cuam9iYm9sZS5jb20vMTA5NDY2Lw==">Git 最佳实践：分支管理<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9taXJyb3JzLmVkZ2Uua2VybmVsLm9yZy9wdWIvc29mdHdhcmUvc2NtL2dpdC9kb2NzL2dpdC1jb25maWcuaHRtbA==">git-config(1) Manual Page<i class="fa fa-external-link-alt"></i></span></li>
</ol>
]]></content>
      <categories>
        <category>工具</category>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>linux下性能分析---kernelshark</title>
    <url>/post/321101fe.html</url>
    <content><![CDATA[<p>Kernelshark作为trace-cmd的前端，借助图形化，灵活的filter，缩放功能，能更有效的帮助分析，高效的得到结果。它包含Ftrace以进行内部Linux内核跟踪，以分析内核中正在发生的事情。</p>
<blockquote>
<p><code>trace-cmd</code>是设置读取<code>ftrace</code>的命令行工具，<code>kernelshark</code>既可以记录数据，也可以图形化分析结果。</p>
</blockquote>
<span id="more"></span>

<h2 id="安装工具"><a href="#安装工具" class="headerlink" title="安装工具"></a>安装工具</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install trace-cmd kernelshark</span><br></pre></td></tr></table></figure>

<h2 id="trace-cmd"><a href="#trace-cmd" class="headerlink" title="trace-cmd"></a>trace-cmd</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://git.kernel.org/pub/scm/linux/kernel/git/rostedt/trace-cmd.git</span><br></pre></td></tr></table></figure>


<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><h3 id="跟踪系统进程切换"><a href="#跟踪系统进程切换" class="headerlink" title="跟踪系统进程切换"></a>跟踪系统进程切换</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">sudo trace-cmd record -e <span class="string">&#x27;sched_wakeup*&#x27;</span> -e sched_switch -e <span class="string">&#x27;sched_migrate*&#x27;</span></span></span><br><span class="line">Hit Ctrl^C to stop recording</span><br><span class="line">^C</span><br><span class="line">CPU0 data recorded at offset=0x6ea000</span><br><span class="line">    2752512 bytes in size</span><br><span class="line">CPU1 data recorded at offset=0x98a000</span><br><span class="line">    2891776 bytes in size</span><br><span class="line">CPU2 data recorded at offset=0xc4c000</span><br><span class="line">    2756608 bytes in size</span><br><span class="line">CPU3 data recorded at offset=0xeed000</span><br><span class="line">    2805760 bytes in size</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>CTRL+c</code>停止记录并保存到trace.dat中</p>
</blockquote>
<h2 id="kernelshark来打开录制的点"><a href="#kernelshark来打开录制的点" class="headerlink" title="kernelshark来打开录制的点"></a>kernelshark来打开录制的点</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">kernelshark trace.dat</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>方便查看某一个进程在某一个时刻在做什么，在哪个CPU核上运行，其他的CPU核在干什么</p>
</blockquote>
<p><img data-src="/images/2020/09/kernel_shark_sample.png" alt="kernel_shark_sample"></p>
]]></content>
      <categories>
        <category>工具</category>
        <category>kernelshark</category>
      </categories>
      <tags>
        <tag>性能</tag>
        <tag>kernelshark</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux下常用工具</title>
    <url>/post/36295.html</url>
    <content><![CDATA[<p>Linux下常用工具：</p>
<span id="more"></span>

<h2 id="Zeal"><a href="#Zeal" class="headerlink" title="Zeal"></a>Zeal</h2><p>各种语言的离线开发文档</p>
<p><span class="exturl" data-url="aHR0cHM6Ly96ZWFsZG9jcy5vcmcv">https://zealdocs.org/<i class="fa fa-external-link-alt"></i></span></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install zeal</span><br></pre></td></tr></table></figure>
<p>文档下载：<code>tools/script/zeal_download_url.sh</code></p>
<h2 id="yuv-rgba-player"><a href="#yuv-rgba-player" class="headerlink" title="yuv rgba player"></a>yuv rgba player</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0lFTlQvWVVWaWV3">https://github.com/IENT/YUView<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<blockquote>
<p>ubuntu 18.04</p>
</blockquote>
<h2 id="wps"><a href="#wps" class="headerlink" title="wps"></a>wps</h2><ul>
<li><span class="exturl" data-url="aHR0cDovL2NvbW11bml0eS53cHMuY24vZG93bmxvYWQv">http://community.wps.cn/download/<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p>字体：<span class="exturl" data-url="aHR0cDovL3dwcy1jb21tdW5pdHkub3JnL2Rvd25sb2FkLmh0bWw/dmw9Zm9udHMjZG93bmxvYWQ=">http://wps-community.org/download.html?vl=fonts#download<i class="fa fa-external-link-alt"></i></span></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo dpkg -i wps-office_10.1.0.5672~a21_amd64.deb</span><br><span class="line">sudo apt -f install</span><br></pre></td></tr></table></figure>

<blockquote>
<p>wps-office 依赖于 libpng12-0；然而：未安装软件包 libpng12-0。</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget http://ftp.cn.debian.org/debian/pool/main/libp/libpng/libpng12-0_1.2.49-1+deb7u2_amd64.deb</span><br><span class="line"></span><br><span class="line">sudo dpkg -i libpng12-0_1.2.49-1+deb7u2_amd64.deb</span><br><span class="line">sudo dpkg -i wps-office_10.1.0.5672~a21_amd64.deb</span><br><span class="line">sudo dpkg -i wps-office-fonts_1.0_all.deb</span><br></pre></td></tr></table></figure>

<h3 id="缺失字体"><a href="#缺失字体" class="headerlink" title="缺失字体"></a>缺失字体</h3><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9wYW4uYmFpZHUuY29tL3MvMWVTNnhJem8=">https://pan.baidu.com/s/1eS6xIzo<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p>wps_symbol_fonts.zip</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">unzip wps_symbol_fonts.zip</span><br><span class="line">sudo cp mtextra.ttf  symbol.ttf  WEBDINGS.TTF  wingding.ttf  WINGDNG2.ttf  WINGDNG3.ttf  /usr/share/fonts</span><br></pre></td></tr></table></figure>



<h2 id="Free-Download-Manager"><a href="#Free-Download-Manager" class="headerlink" title="Free Download Manager"></a>Free Download Manager</h2><p>可以快速下载，相同的下载链接比浏览器下载速度快。</p>
<blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cuZnJlZWRvd25sb2FkbWFuYWdlci5vcmcvemgv">https://www.freedownloadmanager.org/zh/<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<h2 id="画图"><a href="#画图" class="headerlink" title="画图"></a>画图</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install kolourpaint4</span><br></pre></td></tr></table></figure>

<h2 id="虚拟机-——-VirtualBox"><a href="#虚拟机-——-VirtualBox" class="headerlink" title="虚拟机 —— VirtualBox"></a>虚拟机 —— VirtualBox</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install virturlbox virtualbox-ext-pack</span><br></pre></td></tr></table></figure>

<h3 id="无缝模式"><a href="#无缝模式" class="headerlink" title="无缝模式"></a>无缝模式</h3><p>快捷键： <code>Host + l</code></p>
<h3 id="虚拟机启动时异常终止"><a href="#虚拟机启动时异常终止" class="headerlink" title="虚拟机启动时异常终止"></a>虚拟机启动时异常终止</h3><p>版本：6.1</p>
<p>virtualbox升级后造成的现象，错误码：NS_ERROR_FAILURE (0x80004005)</p>
<p>解决方法：</p>
<p>关闭<code>USB控制器</code>或将其切换到USB1.1上，虚拟机就可以正常启动。</p>
<p>根本原因是virtualbox升级后Extension Pack没有跟着升级所致。</p>
<p>重新执行以下命令即可：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install virtualbox virtualbox-ext-pack</span><br></pre></td></tr></table></figure>

<h3 id="ubuntu虚拟机中访问共享文件夹，无权限"><a href="#ubuntu虚拟机中访问共享文件夹，无权限" class="headerlink" title="ubuntu虚拟机中访问共享文件夹，无权限"></a>ubuntu虚拟机中访问共享文件夹，无权限</h3><p>解决权限不足问题的方法就是将自己登录的用户，添加到vboxsf组中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo usermod -aG vboxsf $(whoami)</span><br><span class="line">sudo reboot</span><br></pre></td></tr></table></figure>
<blockquote>
<p>说明：<code>usermod -aG &lt;group&gt; &lt;user&gt;</code>将用户加入到（追加到）组中，其中选项[-aG]是追加到组的意思</p>
</blockquote>
<h2 id="音视频文件分析工具-–-MediaInfo"><a href="#音视频文件分析工具-–-MediaInfo" class="headerlink" title="音视频文件分析工具 – MediaInfo"></a>音视频文件分析工具 – MediaInfo</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install mediainfo mediainfo-gui</span><br></pre></td></tr></table></figure>

<h2 id="词典"><a href="#词典" class="headerlink" title="词典"></a>词典</h2><ul>
<li><a href="https://winddoing.github.io/post/eba28245.html">翻译工具 ——GoldenDict</a></li>
</ul>
<h2 id="画图–结构图流程图"><a href="#画图–结构图流程图" class="headerlink" title="画图–结构图流程图"></a>画图–结构图流程图</h2><ul>
<li><p><strong>draw.io</strong>: <span class="exturl" data-url="aHR0cHM6Ly93d3cuZHJhdy5pby8=">draw.io<i class="fa fa-external-link-alt"></i></span> —— 在线开源免费的画流程图，思维导图，界面设计等</p>
<ul>
<li>桌面版： <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2pncmFwaC9kcmF3aW8tZGVza3RvcA==">https://github.com/jgraph/drawio-desktop<i class="fa fa-external-link-alt"></i></span></li>
</ul>
</li>
</ul>
<h2 id="ASCII流程图"><a href="#ASCII流程图" class="headerlink" title="ASCII流程图"></a>ASCII流程图</h2><p>官网：<span class="exturl" data-url="aHR0cHM6Ly9hc2NpaWZsb3cuY29tLw==">https://asciiflow.com<i class="fa fa-external-link-alt"></i></span><br>Github：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2xld2lzaC9hc2NpaWZsb3c=">https://github.com/lewish/asciiflow<i class="fa fa-external-link-alt"></i></span></p>
<p>默认官网可以使用但是无法输入中文，因此可以使用下面这个链接</p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9hc2NpaWZsb3cuY24v">https://asciiflow.cn<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<h2 id="思维导图-——-XMind"><a href="#思维导图-——-XMind" class="headerlink" title="思维导图 —— XMind"></a>思维导图 —— XMind</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cueG1pbmQuY24v">https://www.xmind.cn/<i class="fa fa-external-link-alt"></i></span> 【<span class="exturl" data-url="aHR0cHM6Ly93d3cueG1pbmQuY24vZG93bmxvYWQv">下载<i class="fa fa-external-link-alt"></i></span>】</li>
</ul>
<h2 id="vooya"><a href="#vooya" class="headerlink" title="vooya"></a>vooya</h2><p>vooya – Raw YUV&#x2F;RGB Video Player</p>
<ul>
<li><span class="exturl" data-url="aHR0cDovL3d3dy5vZmZtaW5vci5kZS9kb3dubG9hZHMuaHRtbA==">http://www.offminor.de/downloads.html<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<h2 id="gedit汉字乱码"><a href="#gedit汉字乱码" class="headerlink" title="gedit汉字乱码"></a>gedit汉字乱码</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gsettings set org.gnome.gedit.preferences.encodings candidate-encodings &quot;[&#x27;GB18030&#x27;, &#x27;GB2312&#x27;, &#x27;GBK&#x27;, &#x27;UTF-8&#x27;, &#x27;BIG5&#x27;, &#x27;CURRENT&#x27;, &#x27;UTF-16&#x27;]&quot;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>ubntu 18.04</p>
</blockquote>
<h2 id="数据库-sqlitebrowser"><a href="#数据库-sqlitebrowser" class="headerlink" title="数据库:sqlitebrowser"></a>数据库:sqlitebrowser</h2><ul>
<li>官网地址：<span class="exturl" data-url="aHR0cDovL3NxbGl0ZWJyb3dzZXIub3JnLw==">http://sqlitebrowser.org/<i class="fa fa-external-link-alt"></i></span></li>
<li>开源地址：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3NxbGl0ZWJyb3dzZXIvc3FsaXRlYnJvd3Nlcg==">https://github.com/sqlitebrowser/sqlitebrowser<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p>DB Browser for SQLite (DB4S) 是一款面向开发者的高质量的，可视化的开源的工具，他可以创建，设计，以及修改SQlite数据库。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install sqlitebrowser</span><br></pre></td></tr></table></figure>

<h2 id="PyCharm"><a href="#PyCharm" class="headerlink" title="PyCharm"></a>PyCharm</h2><blockquote>
<p>python编辑器</p>
</blockquote>
<ul>
<li><span class="exturl" data-url="aHR0cDovL3d3dy5qZXRicmFpbnMuY29tL3B5Y2hhcm0v">http://www.jetbrains.com/pycharm/<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<h2 id="7yuv"><a href="#7yuv" class="headerlink" title="7yuv"></a>7yuv</h2><p>查看yuv格式的文件</p>
<ul>
<li>官网：<span class="exturl" data-url="aHR0cDovL2RhdGFoYW1tZXIuZGUv">http://datahammer.de<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<h2 id="Nitroshare"><a href="#Nitroshare" class="headerlink" title="Nitroshare"></a>Nitroshare</h2><blockquote>
<p>跨平台局域网传输软件</p>
</blockquote>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9uaXRyb3NoYXJlLm5ldC8=">https://nitroshare.net/<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<h2 id="remmina"><a href="#remmina" class="headerlink" title="remmina"></a>remmina</h2><p>可以管理常用的SSH登录和远程桌面。</p>
<ul>
<li>支持 RDP、VNC、NX、XDMCP 和 SSH</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install remmina remmina-plugin-spice</span><br></pre></td></tr></table></figure>

<h2 id="截图"><a href="#截图" class="headerlink" title="截图"></a>截图</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt inatsll flameshot</span><br></pre></td></tr></table></figure>

<ul>
<li>添加快捷键<code>Ctrl + Alt a</code>，执行命令<code>flameshot gui</code></li>
<li>软件配置界面，可以在状态栏点击打开，如果配置为不在状态栏显示；则可以通过<code>flameshot config</code>打开进行设置</li>
</ul>
<h2 id="ubuntu工作区配置"><a href="#ubuntu工作区配置" class="headerlink" title="ubuntu工作区配置"></a>ubuntu工作区配置</h2><h3 id="Alt-Tab不跨工作区"><a href="#Alt-Tab不跨工作区" class="headerlink" title="Alt+Tab不跨工作区"></a>Alt+Tab不跨工作区</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gsettings set org.gnome.shell.app-switcher current-workspace-only true</span><br></pre></td></tr></table></figure>

<h3 id="Ubuntu-Dock不跨工作区"><a href="#Ubuntu-Dock不跨工作区" class="headerlink" title="Ubuntu Dock不跨工作区"></a>Ubuntu Dock不跨工作区</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gsettings set org.gnome.shell.extensions.dash-to-dock isolate-workspaces true</span><br></pre></td></tr></table></figure>
<blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9hc2t1YnVudHUuY29tL3F1ZXN0aW9ucy85OTI1NTgvaG93LWNhbi1pLWNvbmZpZ3VyZS10aGUtdWJ1bnR1LWRvY2stdG8tc2hvdy13aW5kb3dzLW9ubHktZnJvbS10aGUtY3VycmVudC13b3Jrc3A=">https://askubuntu.com/questions/992558/how-can-i-configure-the-ubuntu-dock-to-show-windows-only-from-the-current-worksp<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<h2 id="Ubuntu文件夹中文改为英文"><a href="#Ubuntu文件夹中文改为英文" class="headerlink" title="Ubuntu文件夹中文改为英文"></a>Ubuntu文件夹中文改为英文</h2><p>在系统选择中文后，Home目录下的默认文件夹名也为中文，在终端中使用很不方便，因此将其设置为英文。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export LANG=en_US</span><br><span class="line">xdg-user-dirs-gtk-update</span><br></pre></td></tr></table></figure>


<h2 id="浏览器配置中文"><a href="#浏览器配置中文" class="headerlink" title="浏览器配置中文"></a>浏览器配置中文</h2><p>点击图标启动系统文字默认中文</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo vim /usr/bin/microsoft-edge</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">或</span></span><br><span class="line">sudo vim /usr/bin/google-chrome</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在开头添加一行：</span></span><br><span class="line">export LANGUAGE=ZH-CN.UTF-8</span><br></pre></td></tr></table></figure>


<h2 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install gnome-tweak-tool</span><br></pre></td></tr></table></figure>

<h3 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h3><ul>
<li><code>dash-to-panel</code>： 任务栏合并，类似window</li>
<li><code>workspace-grid</code>： 多工作区</li>
</ul>
<h3 id="WhiteSur主题"><a href="#WhiteSur主题" class="headerlink" title="WhiteSur主题"></a>WhiteSur主题</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/vinceliuice/WhiteSur-gtk-theme.git</span><br><span class="line">git clone https://github.com/vinceliuice/WhiteSur-icon-theme.git</span><br><span class="line">git clone https://github.com/vinceliuice/WhiteSur-cursors.git</span><br></pre></td></tr></table></figure>

<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9saW51eC5jbi9hcnRpY2xlLTEyMzYxLTEuaHRtbA==">5 个简单步骤使你的 Ubuntu 看起来像 macOS<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>工具</category>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown语法</title>
    <url>/post/22648.html</url>
    <content><![CDATA[<p>在这里主要记录makedown的使用语法，以备后续写作时的不时之需。</p>
<span id="more"></span>

<h2 id="Atom"><a href="#Atom" class="headerlink" title="Atom"></a>Atom</h2><p>软件下载地址（国内）：<span class="exturl" data-url="aHR0cHM6Ly9ucG0udGFvYmFvLm9yZy9taXJyb3JzL2F0b20v">https://npm.taobao.org/mirrors/atom/<i class="fa fa-external-link-alt"></i></span></p>
<blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9yZWdpc3RyeS5ucG1taXJyb3IuY29tLy0vYmluYXJ5L2F0b20vdjEuNjAuMC9hdG9tLWFtZDY0LmRlYg==">https://registry.npmmirror.com/-/binary/atom/v1.60.0/atom-amd64.deb<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<ul>
<li>插件<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apm install tool-bar markdown-writer tool-bar-markdown-writer markdown-scroll-sync</span><br><span class="line">apm install minimap  #右边的代码缩略图</span><br><span class="line">apm install vim-mode-plus #vim操作模式,依赖npm install underscore-plus</span><br></pre></td></tr></table></figure>
侧边栏目录树打开关闭快捷键： <code>Ctrl + \</code></li>
</ul>
<p>正常使用以上命令进行下载过于缓慢，因此可以切换atom源：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apm config set registry https://registry.npm.taobao.org</span><br><span class="line">apm config list       #列出当前配置</span><br><span class="line">apm install --check   #检查是否成功</span><br></pre></td></tr></table></figure>

<ul>
<li>关闭启动欢迎页：File -&gt; Setting -&gt; Packages -&gt; 搜索welcome，点击Disable</li>
<li>关闭拼写检查：File -&gt; Setting -&gt; Packages -&gt; 搜索spell-check，点击Disable</li>
</ul>
<p>如果插件无法下载，可以在github相应的仓库中单独下载解压到<code>$HOME.atom/packages</code>目录下。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">~/.atom/packages</span><br><span class="line">↪ =&gt;$ls</span><br><span class="line">markdown-scroll-sync  markdown-writer  minimap  tool-bar  tool-bar-markdown-writer</span><br></pre></td></tr></table></figure>

<h2 id="Markdown语法"><a href="#Markdown语法" class="headerlink" title="Markdown语法"></a>Markdown语法</h2><ul>
<li><p>分段： <code>两个回车</code></p>
</li>
<li><p>换行 <code>两个空格 + 回车</code></p>
</li>
<li><p>标题 <code># ~ ######</code> 井号的个数表示几级标题，即Markdown可以表示一级标题到六级标题</p>
</li>
<li><p>引用 <code>&gt;</code></p>
</li>
<li><p>列表 <code>* ， + ， - ， 1. </code>选其中之一，注意后面有个空格</p>
</li>
<li><p>代码区块 <code>四个空格</code> 开头</p>
</li>
<li><p>链接 <code>[文字](链接地址)</code></p>
</li>
<li><p>图片 <code>![图片说明](图片地址)</code> ，图片地址可以是本地路劲，也可以是网络地址</p>
</li>
<li><p>强调 <code>**文字**</code> ， <code>__文字__</code></p>
</li>
<li><p>删除线：<code>~~xxxx~~</code></p>
</li>
<li><p>代码: 三个点</p>
</li>
<li><p>待办事宜 <code>- [ ] 表示未完成</code>和<code>- [x] 表示已完成</code></p>
<blockquote>
<ul>
<li><input disabled="" type="checkbox"> 表示未完成</li>
<li><input checked="" disabled="" type="checkbox"> 表示已完成</li>
</ul>
</blockquote>
</li>
<li><p>段落缩进 <code>&amp;ensp;&amp;ensp;</code>（两个空格）</p>
</li>
</ul>
<h2 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h2><table>
<thead>
<tr>
<th align="center">操作模块</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">start&#96;</td>
<td align="center">开始</td>
</tr>
<tr>
<td align="center">end</td>
<td align="center">结束</td>
</tr>
<tr>
<td align="center">opration</td>
<td align="center">普通操作块</td>
</tr>
<tr>
<td align="center">condition</td>
<td align="center">判断块</td>
</tr>
<tr>
<td align="center">subroutine</td>
<td align="center">子任务块</td>
</tr>
<tr>
<td align="center">inputoutput</td>
<td align="center">输入输出块</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;&#x27;&#x27; flow</span><br><span class="line">//定义部分</span><br><span class="line">st=&gt;start: Start:&gt;http://www.google.com[blank]</span><br><span class="line">e=&gt;end:&gt;http://www.google.com</span><br><span class="line">op1=&gt;operation: My Operation</span><br><span class="line">sub1=&gt;subroutine: My Subroutine</span><br><span class="line">cond=&gt;condition: Yes or No?:&gt;http://www.google.com</span><br><span class="line">io=&gt;inputoutput: catch something...</span><br><span class="line"></span><br><span class="line">//判断和位置控制</span><br><span class="line">st-&gt;op1-&gt;cond</span><br><span class="line">cond(yes)-&gt;io-&gt;e</span><br><span class="line">cond(no)-&gt;sub1(right)-&gt;op1</span><br><span class="line">&#x27;&#x27;&#x27;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>st 是变量名， start 是指操作模块名，冒号后面就是内容了。需要注意的是，<code>冒号后要加空格</code>才能识别</p>
</blockquote>
<div id="flowchart-0" class="flow-chart"></div>

<h2 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;&#x27;&#x27;sequence</span><br><span class="line">Alice-&gt;Bob: Hello Bob, how are you?</span><br><span class="line">Note right of Bob: Bob thinks</span><br><span class="line">Bob--&gt;Alice: I am good thanks!</span><br><span class="line">&#x27;&#x27;&#x27;</span><br></pre></td></tr></table></figure>

<div id="sequence-0"></div>


<h2 id="mermaid"><a href="#mermaid" class="headerlink" title="mermaid"></a>mermaid</h2><blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9tZXJtYWlkLWpzLmdpdGh1Yi5pby9tZXJtYWlk">https://mermaid-js.github.io/mermaid<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<pre class="mermaid">graph TD

A[Hard] -->|Text| B(Round)
B --> C{Decision}
C -->|One| D[Result 1]
C -->|Two| E[Result 2]</pre>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NzQ5OTA2L2FydGljbGUvZGV0YWlscy8xMDc0NjIxNDk=">Markdown(四)——绘图工具mermaid之状态图stateDiagram<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<h2 id="Atom和Makedown预览"><a href="#Atom和Makedown预览" class="headerlink" title="Atom和Makedown预览"></a>Atom和Makedown预览</h2><ol>
<li>命令：ctrl + shift + p</li>
<li>输入 markdown preview toggle(可以偷懒只输入<strong>mdpt</strong>，跟Sublime Text一样支持模糊匹配)</li>
</ol>
<h2 id="typora"><a href="#typora" class="headerlink" title="typora"></a>typora</h2><p>官网：<span class="exturl" data-url="aHR0cHM6Ly90eXBvcmEuaW8v">https://typora.io<i class="fa fa-external-link-alt"></i></span></p>
<blockquote>
<p>Debian&#x2F;Ubuntu</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># or use</span><br><span class="line"># sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys BA300B7755AFCFAE</span><br><span class="line">wget -qO - https://typora.io/linux/public-key.asc | sudo apt-key add -</span><br><span class="line"></span><br><span class="line"># add Typora&#x27;s repository</span><br><span class="line">sudo add-apt-repository &#x27;deb https://typora.io/linux ./&#x27;</span><br><span class="line">sudo apt-get update</span><br><span class="line"></span><br><span class="line"># install typora</span><br><span class="line">sudo apt-get install typora</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Windows: <a href="http://winddoing.github.io/software">http://winddoing.github.io/software</a></p>
</blockquote>
<h3 id="使用技巧"><a href="#使用技巧" class="headerlink" title="使用技巧"></a>使用技巧</h3><h4 id="插入目录"><a href="#插入目录" class="headerlink" title="插入目录"></a>插入目录</h4><p>使用“[toc]”会自动根据使用的一二三级标题生成目录</p>
<h4 id="插入分页符"><a href="#插入分页符" class="headerlink" title="插入分页符"></a>插入分页符</h4><p>导出pdf时希望分页可以添加这个html实现</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div style=&quot;page-break-after: always;&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<script src="https://cdnjs.cloudflare.com/ajax/libs/raphael/2.2.7/raphael.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/flowchart/1.6.5/flowchart.min.js"></script><textarea id="flowchart-0-code" style="display: none">//定义部分
st=>start: Start:>http://www.google.com[blank]
e=>end:>http://www.google.com
op1=>operation: My Operation
sub1=>subroutine: My Subroutine
cond=>condition: Yes or No?:>http://www.google.com
io=>inputoutput: catch something...

//判断和位置控制
st->op1->cond
cond(yes)->io->e
cond(no)->sub1(right)->op1</textarea><textarea id="flowchart-0-options" style="display: none">{"theme":"simple","scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-0-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-0", options);</script><script src="https://cdnjs.cloudflare.com/ajax/libs/webfont/1.6.27/webfontloader.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/snap.svg/0.4.1/snap.svg-min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/underscore.js/1.8.3/underscore-min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/js-sequence-diagrams/1.0.6/sequence-diagram-min.js"></script><textarea id="sequence-0-code" style="display: none">Alice->Bob: Hello Bob, how are you?
Note right of Bob: Bob thinks
Bob-->Alice: I am good thanks!</textarea><textarea id="sequence-0-options" style="display: none">{"theme":"simple","scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("sequence-0-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("sequence-0-options").value));  var diagram = Diagram.parse(code);  diagram.drawSVG("sequence-0", options);</script>]]></content>
      <categories>
        <category>工具</category>
        <category>markdown</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>nbench</title>
    <url>/post/18855.html</url>
    <content><![CDATA[<p> nbench是一个简单的用于测试处理器，存储器性能的基准测试程序。即著名的BYTE Magazine杂志的BYTEmark benchmark program。nbench在系统中运行并将结果和一台运行Linux的AMD K6-233电脑比较，得到的比值作为性能指数。由于是完全开源的，爱好者可以在各种平台和操作系统上运行nbench，并进行优化和测试，是一个简单有效的性能测试工具。nbench的结果主要分为MEM、INT和FP，其中MEM指数主要体现处理器总线、CACHE和存储器性能，INT当然是整数处理性能，FP则体现双精度浮点性能</p>
<span id="more"></span>

<h2 id="下载-amp-编译"><a href="#下载-amp-编译" class="headerlink" title="下载&amp;编译"></a>下载&amp;编译</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$git clone https://github.com/Winddoing/nbench.git</span><br><span class="line">$git checkout arch-mips-test</span><br><span class="line">$make</span><br></pre></td></tr></table></figure>

<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>运行<code>./nbench</code></p>
<h3 id="mips"><a href="#mips" class="headerlink" title="mips"></a>mips</h3>]]></content>
      <categories>
        <category>工具</category>
        <category>nbench</category>
      </categories>
      <tags>
        <tag>nbench</tag>
      </tags>
  </entry>
  <entry>
    <title>SVN的基础使用</title>
    <url>/post/56583.html</url>
    <content><![CDATA[<p>svn的基础使用命令：</p>
<span id="more"></span>

<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get install subversion</span><br></pre></td></tr></table></figure>

<h2 id="命令行使用"><a href="#命令行使用" class="headerlink" title="命令行使用"></a>命令行使用</h2><h3 id="下载代码"><a href="#下载代码" class="headerlink" title="下载代码"></a>下载代码</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">svn checkout svn_path local_path</span><br></pre></td></tr></table></figure>

<h3 id="添加新文件"><a href="#添加新文件" class="headerlink" title="添加新文件"></a>添加新文件</h3><blockquote>
<p>将新的文件添加到代码仓库中,如果一个文件不在版本则需要使用add添加</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">svn add files</span><br></pre></td></tr></table></figure>
<ul>
<li><code>--no-ignore</code>: disregard default and svn:ignore and svn:global-ignores property ignores(忽略默认值和 svn:ignore 属性)</li>
<li><code>--force</code>: 强制添加</li>
</ul>
<h4 id="递归添加"><a href="#递归添加" class="headerlink" title="递归添加"></a>递归添加</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">svn add . --no-ignore --force</span><br></pre></td></tr></table></figure>

<h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">svn update</span><br></pre></td></tr></table></figure>

<h3 id="修改提交"><a href="#修改提交" class="headerlink" title="修改提交"></a>修改提交</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">svn commit -m path-to-commit，其中path-to-commit可以为空</span><br></pre></td></tr></table></figure>

<h3 id="查看log"><a href="#查看log" class="headerlink" title="查看log"></a>查看log</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">svn log</span><br></pre></td></tr></table></figure>
<blockquote>
<p>-v : 显示修改目录</p>
</blockquote>
<h3 id="回退到某一个（r123）log"><a href="#回退到某一个（r123）log" class="headerlink" title="回退到某一个（r123）log"></a>回退到某一个（r123）log</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">svn up -r r123</span><br></pre></td></tr></table></figure>

<h3 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">svn copy -m &quot;create branch&quot; http://svn_server/xxx_repository http://svn_server/xxx_repository/br_feature001</span><br></pre></td></tr></table></figure>
<blockquote>
<p>分支名： br_feature001</p>
</blockquote>
<h3 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支"></a>切换分支</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">svn switch http://svn_server/xxx_repository/br_feature001</span><br></pre></td></tr></table></figure>
<h4 id="更新SVN地址"><a href="#更新SVN地址" class="headerlink" title="更新SVN地址"></a>更新SVN地址</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">svn switch --relocate http://192.168.1.1/repos[old addr]  http://192.168.1.11/repos[new addr]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>switch –relocate FROM TO [PATH…]</p>
</blockquote>
<h3 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">svn rm http://svn_server/xxx_repository/br_feature001</span><br></pre></td></tr></table></figure>

<h3 id="恢复本地修改"><a href="#恢复本地修改" class="headerlink" title="恢复本地修改"></a>恢复本地修改</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">revert PATH...</span><br></pre></td></tr></table></figure>

<h2 id="提交代码"><a href="#提交代码" class="headerlink" title="提交代码"></a>提交代码</h2><ol>
<li>将代码更新到与目前版本库里一致（<code>svn up</code>），如果存在冲突解决冲突</li>
<li>使用(<code>svn st</code>)查看所有文件状态，判断使用有新添加的文件，如果有新添加的文件，使用(<code>svn add</code>)将新文件添加到版本库</li>
</ol>
<ul>
<li><strong>在确定提交前，使用（<code>svn st</code>）查看是否有多余的修改，如果有将其退回（svn revert）</strong></li>
</ul>
<ol start="3">
<li>提交代码<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">svn commit -m &quot;备注修改的目的&quot;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="补丁-patch"><a href="#补丁-patch" class="headerlink" title="补丁-patch"></a>补丁-patch</h2><h3 id="制作补丁"><a href="#制作补丁" class="headerlink" title="制作补丁"></a>制作补丁</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">svn diff &gt; patch.diff</span><br></pre></td></tr></table></figure>

<h3 id="打补丁"><a href="#打补丁" class="headerlink" title="打补丁"></a>打补丁</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">patch &lt; to-file.patch</span><br></pre></td></tr></table></figure>

<h3 id="取消补丁"><a href="#取消补丁" class="headerlink" title="取消补丁"></a>取消补丁</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">patch -RE  &lt; to-file.patch</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>-R</code>: 取消打过的补丁<br><code>-E</code>: 选项说明如果发现了空文件，那么就删除它</p>
</blockquote>
<h2 id="示例–创建分支提交"><a href="#示例–创建分支提交" class="headerlink" title="示例–创建分支提交"></a>示例–创建分支提交</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">svn up</span><br><span class="line"></span><br><span class="line">svn copy http://172.16.180.100/svn/Hi3798MV200 http://172.16.180.100/svn/Hi3798MV200/Hi3798MV200_M -m &quot;single S multi R code branch&quot;</span><br><span class="line"></span><br><span class="line">svn</span><br></pre></td></tr></table></figure>

<h2 id="图形界面使用"><a href="#图形界面使用" class="headerlink" title="图形界面使用"></a>图形界面使用</h2><h3 id="RapidSVN"><a href="#RapidSVN" class="headerlink" title="RapidSVN"></a>RapidSVN</h3>]]></content>
      <categories>
        <category>工具</category>
        <category>svn</category>
      </categories>
      <tags>
        <tag>svn</tag>
      </tags>
  </entry>
  <entry>
    <title>tftp</title>
    <url>/post/3037.html</url>
    <content><![CDATA[<p>tftp:</p>
<span id="more"></span>


<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="软件包："><a href="#软件包：" class="headerlink" title="软件包："></a>软件包：</h3><p><code>tftpd（服务端）</code>，<code>tftp（客户端）</code>，<code>xinetd</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get install tftpd tftp xinetd</span><br></pre></td></tr></table></figure>

<h3 id="建立配置文件："><a href="#建立配置文件：" class="headerlink" title="建立配置文件："></a>建立配置文件：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vi /etc/xinetd.d/tftp</span><br><span class="line"></span><br><span class="line">service tftp</span><br><span class="line">&#123;</span><br><span class="line">    protocol        = udp</span><br><span class="line">    port            = 69</span><br><span class="line">    socket_type     = dgram</span><br><span class="line">    wait            = yes</span><br><span class="line">    user            = nobody</span><br><span class="line">    server          = /usr/sbin/in.tftpd</span><br><span class="line">    server_args     = /home/xxx/tftprootfs</span><br><span class="line">    disable         = no</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="重启服务"><a href="#重启服务" class="headerlink" title="重启服务"></a>重启服务</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo /etc/init.d/xinetd restart</span><br></pre></td></tr></table></figure>

<h2 id="window工具–tftpd服务"><a href="#window工具–tftpd服务" class="headerlink" title="window工具–tftpd服务"></a>window工具–tftpd服务</h2><p>下载：<span class="exturl" data-url="aHR0cHM6Ly9wYW4uYmFpZHUuY29tL3MvMXZoRjZ0RDd6d0xoRExRRG1TWTVIc3c=">tftpd32<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="本地测试"><a href="#本地测试" class="headerlink" title="本地测试"></a>本地测试</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$tftp localhost</span><br><span class="line">tftp&gt; get aaa</span><br><span class="line">Received 8 bytes in 0.0 seconds</span><br></pre></td></tr></table></figure>

<h2 id="开发板使用"><a href="#开发板使用" class="headerlink" title="开发板使用"></a>开发板使用</h2><p>下载：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tftp –gr 源文件名  服务器地址</span><br></pre></td></tr></table></figure>

<p>上传：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tftp –pr 目标文件名 服务器地址</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>工具</category>
        <category>tftp</category>
      </categories>
      <tags>
        <tag>tftp</tag>
      </tags>
  </entry>
  <entry>
    <title>tmux</title>
    <url>/post/40876.html</url>
    <content><![CDATA[<p>tmux是一个优秀的终端复用软件，split窗口。可以在一个terminal下打开多个终端。<br>即使非正常掉线，也能保证当前的任务运行，这一点对于远程SSH访问特别有用，网络不好的情况下仍然能保证工作现场不丢失。SSH重新连接以后，就可以直接回到原来的工作环境，不但提高了工作效率，还降低了风险，增加了安全性。</p>
<p>tmux完全使用键盘控制窗口，实现窗口的切换功能</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get install tmux</span><br></pre></td></tr></table></figure>
<span id="more"></span>

<h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL1dpbmRkb2luZy92aW1fd29ya19jb25maWcvbWFzdGVyLy50bXV4LmNvbmY=">my tmux.conf<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<p>tmux的系统级配置文件为<code>/etc/tmux.conf</code>，用户级配置文件为<code>~/.tmux.conf</code>。配置文件实际上就是tmux的命令集合，也就是说每行配置均可在进入命令行模式后输入生效。</p>
]]></content>
      <categories>
        <category>工具</category>
        <category>tmux</category>
      </categories>
      <tags>
        <tag>tmux</tag>
      </tags>
  </entry>
  <entry>
    <title>VIM绘图--dot、uml</title>
    <url>/post/44070.html</url>
    <content><![CDATA[<p>在整理软件逻辑和设计思路时，通过VIM进行画图记录。</p>
<ul>
<li><code>DOT</code> + graphviz: 结构图和流程图</li>
<li><code>plantuml</code>: UML图</li>
<li><code>DrawIt</code>: 简易图（ASCII）</li>
</ul>
<span id="more"></span>

<h2 id="DOT-graphviz"><a href="#DOT-graphviz" class="headerlink" title="DOT + graphviz"></a>DOT + graphviz</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vi aaa.dot</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用DOT语法，绘画</p>
</blockquote>
<h3 id="DOT语法"><a href="#DOT语法" class="headerlink" title="DOT语法"></a>DOT语法</h3><p><code>graph</code>（无向图）或者<code>digraph</code>（无向图）表示图，然后<code>&#123;&#125;</code>中的内容是对图的描述，注释风格和C类似（“<code>//</code>”用于单行注释，<code>/**/</code>用于多行注释）。如一个无向图：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//usr/bin/dot</span><br><span class="line">graph graph1 &#123;</span><br><span class="line">    label = &quot;this is a graph&quot;;</span><br><span class="line">    aa; bb;</span><br><span class="line">    a -- b;</span><br><span class="line"></span><br><span class="line">    &#123;p, q&#125; -- &#123;x, y&#125;;</span><br><span class="line"></span><br><span class="line">    &#123;c, d&#125; -- o;</span><br><span class="line"></span><br><span class="line">    o -- end [style = dotted, color = red];</span><br><span class="line"></span><br><span class="line">    subgraph subgraph1 &#123;</span><br><span class="line">        label = &quot;This is subgraph&quot;;</span><br><span class="line">        bgcolor = greenyellow;</span><br><span class="line">        cc; dd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ccc -- ddd [label = &quot;test&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2p5NjkyNDA1MTgwL2FydGljbGUvZGV0YWlscy81MjA3Nzk3OQ==">Dot脚本语言语法整理<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N0b3JtZHB6aC9hcnRpY2xlL2RldGFpbHMvMTQ2NDg4Mjc=">DOT + graphviz 轻松画图神器<i class="fa fa-external-link-alt"></i></span></li>
</ul>
</blockquote>
<h2 id="Plantuml"><a href="#Plantuml" class="headerlink" title="Plantuml"></a>Plantuml</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vi aaa.uml</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly95cS5hbGl5dW4uY29tL2FydGljbGVzLzI1NDA1">类图<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3poX3dlaXIvYXJ0aWNsZS9kZXRhaWxzLzcyNjc1MDEz">时序图<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3poYW5namlrdWFuL2FydGljbGUvZGV0YWlscy81MzQ4NDU1OA==">流程图<i class="fa fa-external-link-alt"></i></span></li>
</ul>
</blockquote>
<h2 id="DrawIt"><a href="#DrawIt" class="headerlink" title="DrawIt"></a>DrawIt</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+----------------+</span><br><span class="line">|                |</span><br><span class="line">+-------+--------+</span><br><span class="line">|       |        |</span><br><span class="line">|       +--------+</span><br><span class="line">|       |        |</span><br><span class="line">+-------+--------+</span><br></pre></td></tr></table></figure>

<ul>
<li><p>绘图–操作</p>
<blockquote>
<p>:DIstart   – 启动（默认虚线—-）<br>:DIstop    – 停止<br>:DIdbl     – 双实线(════)<br>:DInrml    – 单虚线(—-)<br>:DIsngl    – 单实现(────)</p>
</blockquote>
</li>
<li><p>划线：</p>
<blockquote>
<p>方向键（直线）；Page up、Page Down（斜线）</p>
</blockquote>
</li>
<li><p>箭头：</p>
<blockquote>
<p>&lt;、&gt;、^、v</p>
</blockquote>
</li>
<li><p>擦除：</p>
<blockquote>
<p>空格切换</p>
</blockquote>
</li>
</ul>
]]></content>
      <categories>
        <category>工具</category>
        <category>vim</category>
      </categories>
      <tags>
        <tag>vim</tag>
        <tag>dot</tag>
        <tag>uml</tag>
      </tags>
  </entry>
  <entry>
    <title>vim的简单配置（无插件）</title>
    <url>/post/cce68b0.html</url>
    <content><![CDATA[<p>vim简单的配置信息，记录在此方便后期使用</p>
<span id="more"></span>

<p>vimrc配置文件：<a href="/software/vimrc">.vimrc</a></p>
]]></content>
      <categories>
        <category>工具</category>
        <category>vim</category>
      </categories>
  </entry>
  <entry>
    <title>scoop for window</title>
    <url>/post/5c8794fe.html</url>
    <content><![CDATA[<p>Window下的包管理工具,便于开发环境的搭建和软件安装</p>
<span id="more"></span>

<p>系统版本：<code>window10 2004</code></p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>安装scoop或者choco都需要powershell的支持</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 开启脚本权限</span></span><br><span class="line"><span class="built_in">Set-ExecutionPolicy</span> RemoteSigned <span class="literal">-scope</span> CurrentUser</span><br><span class="line"><span class="comment"># 安装</span></span><br><span class="line"><span class="built_in">iwr</span> <span class="literal">-useb</span> get.scoop.sh | <span class="built_in">iex</span></span><br><span class="line"><span class="comment">#or</span></span><br><span class="line"><span class="built_in">Invoke-Expression</span> (<span class="built_in">New-Object</span> System.Net.WebClient).DownloadString(<span class="string">&#x27;https://get.scoop.sh&#x27;</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果不使用VPNscoop的安装由于下载慢而中断导致失败，那么必须先删除<code>C:\Users\scoop</code>文件夹(默认路径可自定义)，再执行以上命令安装。</p>
</blockquote>
<ul>
<li><p>指定安装路径(指定SCOOP的路径到环境变量)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[environment]::setEnvironmentVariable(&#x27;SCOOP&#x27;,&#x27;C:\Scoop&#x27;,&#x27;User&#x27;)</span><br><span class="line">$env:SCOOP=&#x27;C:\Scoop&#x27;</span><br><span class="line">iex (new-object net.webclient).downloadstring(&#x27;https://get.scoop.sh&#x27;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加官网扩展支持</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scoop bucket add extras</span><br><span class="line">scoop bucket add versions</span><br></pre></td></tr></table></figure>

<blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2x1a2VzYW1wc29uL3Njb29wLWV4dHJhcw==">https://github.com/lukesampson/scoop-extras<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
</li>
</ul>
<h3 id="官方bucket的国内镜像"><a href="#官方bucket的国内镜像" class="headerlink" title="官方bucket的国内镜像"></a>官方bucket的国内镜像</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scoop bucket rm main</span><br><span class="line">scoop bucket add main https://mirror.nju.edu.cn/git/scoop-main.git</span><br><span class="line">scoop bucket add extras https://mirror.nju.edu.cn/git/scoop-extras.git</span><br><span class="line"></span><br><span class="line">scoop update</span><br></pre></td></tr></table></figure>


<h2 id="帮助文档"><a href="#帮助文档" class="headerlink" title="帮助文档"></a>帮助文档</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Usage: scoop &lt;command&gt; [&lt;args&gt;]</span><br><span class="line"></span><br><span class="line">Some useful commands are:</span><br><span class="line"></span><br><span class="line">alias       管理 scoop 别名</span><br><span class="line">bucket      管理 Scoop buckets</span><br><span class="line">cache       显示/清理下载缓存</span><br><span class="line">checkup     检查可能存在的问题</span><br><span class="line">cleanup     移除旧版本清理应用</span><br><span class="line">config      获取或设置配置值</span><br><span class="line">create      创建一个自定义的app manifest</span><br><span class="line">depends     列出一个app的依赖关系</span><br><span class="line">export      导出（可导入的）已安装应用程序列表</span><br><span class="line">help        显示一个命令的帮助</span><br><span class="line">home        打开一个app 的主页</span><br><span class="line">info        显示一个app的相关信息</span><br><span class="line">install     安装 apps</span><br><span class="line">list        列出已安装的 apps</span><br><span class="line">prefix      返回指定应用程序的路径</span><br><span class="line">reset       重置应用程序以解决冲突</span><br><span class="line">search      搜索可用应用</span><br><span class="line">status      显示状态并检查新的应用程序版本</span><br><span class="line">uninstall   卸载 app</span><br><span class="line">update      更新 apps 和更新 Scoop</span><br><span class="line">virustotal  在virustotal.com上查找应用程序的哈希</span><br><span class="line">which       找到一个shim/可执行文件（类似于Linux上的which）</span><br></pre></td></tr></table></figure>

<h2 id="Scoop示例"><a href="#Scoop示例" class="headerlink" title="Scoop示例"></a>Scoop示例</h2><h3 id="reset"><a href="#reset" class="headerlink" title="reset"></a>reset</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scoop install python27 python</span><br><span class="line">python --version # -&gt; Python 3.6.2</span><br><span class="line"></span><br><span class="line"># switch to python 2.7.x</span><br><span class="line">scoop reset python27</span><br><span class="line">python --version # -&gt; Python 2.7.13</span><br><span class="line"></span><br><span class="line"># switch back (to 3.x)</span><br><span class="line">scoop reset python</span><br><span class="line">python --version # -&gt; Python 3.6.2</span><br></pre></td></tr></table></figure>

<h3 id="导出安装软件列表"><a href="#导出安装软件列表" class="headerlink" title="导出安装软件列表"></a>导出安装软件列表</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scoop export &gt; app_list.txt</span><br></pre></td></tr></table></figure>

<h3 id="更新所有安装软件"><a href="#更新所有安装软件" class="headerlink" title="更新所有安装软件"></a>更新所有安装软件</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scoop update * &amp;&amp; scoop cleanup *</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9zY29vcC5zaC8=">Scoop<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRlZS5jb20vc2Nvb3AtYnVja2V0">scoop-bucket, gitee<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NpbnNoaW5lODYvYXJ0aWNsZS9kZXRhaWxzLzEyNjc4Njc4MA==">国内安装scoop的保姆教程<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzAyNTM2L2FydGljbGUvZGV0YWlscy8xMTYwOTc1NDE=">#Scoop windows下的包管理器<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>工具</category>
        <category>windows</category>
      </categories>
      <tags>
        <tag>scoop</tag>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows常用工具</title>
    <url>/post/14436.html</url>
    <content><![CDATA[<p>Windows下的常用工具，提高使用效率</p>
<p>简单记录，方便以后重装系统后安装使用。</p>
<span id="more"></span>

<h2 id="快速搜素–Listary"><a href="#快速搜素–Listary" class="headerlink" title="快速搜素–Listary"></a>快速搜素–Listary</h2><p>官网：<span class="exturl" data-url="aHR0cDovL3d3dy5saXN0YXJ5LmNvbS8=">http://www.listary.com/<i class="fa fa-external-link-alt"></i></span><br>下载：<span class="exturl" data-url="aHR0cDovL3d3dy5saXN0YXJ5LmNvbS9kb3dubG9hZC9MaXN0YXJ5LmV4ZT92ZXJzaW9uPTUuMDAuMjg0Mw==">here<i class="fa fa-external-link-alt"></i></span></p>
<h3 id="使用："><a href="#使用：" class="headerlink" title="使用："></a>使用：</h3><p>快速启动： <code>Ctrl+Ctrl</code></p>
<h2 id="读取Ext4分区–ext2explore"><a href="#读取Ext4分区–ext2explore" class="headerlink" title="读取Ext4分区–ext2explore"></a>读取Ext4分区–ext2explore</h2><p>在Windows和Linux的双系统中，方便在Windows系统下获取Linux中的数据。</p>
<ul>
<li><a href="https://netix.dl.sourceforge.net/project/ext2read/Ext2read%20Version%202.2%20%28Latest%29/ext2explore-2.2.71.zip"><code>ext2explore</code></a>只能读取文件，无法写入，使用时需要管理员权限运行。（Window10可以使用）</li>
<li><a href="https://excellmedia.dl.sourceforge.net/project/ext2fsd/Ext2fsd/0.69/Ext2Fsd-0.69.exe"><code>Ext2fsd</code></a>据说最好用(Windows10无法使用)</li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cucGFyYWdvbi1zb2Z0d2FyZS5jb20vaG9tZS9saW51eGZzLXdpbmRvd3Mv">Paragon ExtFS for Windows<i class="fa fa-external-link-alt"></i></span>需要注册对个人免费。</li>
</ul>
<p>使用：<span class="exturl" data-url="aHR0cHM6Ly9yb292Lm9yZy8yMDE0LzA2L3dpbmRvd3MtZXh0Lw==">在 Windows 下访问 Ext 分区<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="系统镜像下载"><a href="#系统镜像下载" class="headerlink" title="系统镜像下载"></a>系统镜像下载</h2><p>网站：<span class="exturl" data-url="aHR0cHM6Ly9tc2RuLml0ZWxseW91LmNuLw==">https://msdn.itellyou.cn/<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="Windows-10-下清理-WinSxS"><a href="#Windows-10-下清理-WinSxS" class="headerlink" title="Windows 10 下清理 WinSxS"></a>Windows 10 下清理 WinSxS</h2><p>图形界面操作<span class="exturl" data-url="aHR0cDovL3d3dy5jaHV5dS5tZS96aC1IYW5zL2luZGV4Lmh0bWw=">http://www.chuyu.me/zh-Hans/index.html<i class="fa fa-external-link-alt"></i></span></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Dism.exe /online /Cleanup-Image /StartComponentCleanup /ResetBase</span><br></pre></td></tr></table></figure>
<h2 id="磁盘文件目录大小可视化布局"><a href="#磁盘文件目录大小可视化布局" class="headerlink" title="磁盘文件目录大小可视化布局"></a>磁盘文件目录大小可视化布局</h2><p><span class="exturl" data-url="aHR0cDovL3d3dy51ZGVyem8uaXQvbWFpbl9wcm9kdWN0cy9zcGFjZV9zbmlmZmVyLw==">SpaceSniffer<i class="fa fa-external-link-alt"></i></span></p>
<blockquote>
<p>SpaceSniffer_1.1.4.0.1399531007</p>
</blockquote>
<h2 id="同步软件–FreeFileSync"><a href="#同步软件–FreeFileSync" class="headerlink" title="同步软件–FreeFileSync"></a>同步软件–FreeFileSync</h2><p><span class="exturl" data-url="aHR0cHM6Ly9mcmVlZmlsZXN5bmMub3JnL2Rvd25sb2FkLnBocA==">FreeFileSync<i class="fa fa-external-link-alt"></i></span></p>
<blockquote>
<p>硬盘和U盘的同步</p>
</blockquote>
<h2 id="esEye-–-Elecard-StreamEye-Tools"><a href="#esEye-–-Elecard-StreamEye-Tools" class="headerlink" title="esEye – Elecard StreamEye Tools"></a>esEye – Elecard StreamEye Tools</h2><p>esEye 分析264的码流结构</p>
<h2 id="edid-manager"><a href="#edid-manager" class="headerlink" title="edid_manager"></a>edid_manager</h2><p><span class="exturl" data-url="aHR0cHM6Ly9wYW4uYmFpZHUuY29tL3MvMUJQZ1hhZE05TW53d2lvMVBVNGppUFE=">edid_managerv1x0<i class="fa fa-external-link-alt"></i></span></p>
<blockquote>
<p>EDID查询</p>
</blockquote>
<h2 id="dxdiag"><a href="#dxdiag" class="headerlink" title="dxdiag"></a>dxdiag</h2><blockquote>
<p>按键盘<code>win+r</code>调出运行命令，输入<code>dxdiag</code>,如<a href="https://winddoing.github.io/src/DxDiag.txt">DxDiag</a></p>
</blockquote>
<p>Dxdiag可以显示计算机上DirectX相关的文件，检查正在运行的文件、输入设备、视频驱动程序版本、以及当前的系统信息。</p>
]]></content>
      <categories>
        <category>工具</category>
        <category>windows</category>
      </categories>
      <tags>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title>win10家庭版设置软件安装密码——本地组策略编辑器</title>
    <url>/post/40085.html</url>
    <content><![CDATA[<p>win10版本：<code>家庭版</code><br>操作系统版本：<code>18363.592</code></p>
<blockquote>
<p>设置软件安装密码</p>
</blockquote>
<span id="more"></span>

<h2 id="本地组策略编辑器"><a href="#本地组策略编辑器" class="headerlink" title="本地组策略编辑器"></a>本地组策略编辑器</h2><p>设置方法通过<code>gpedit.msc</code>本地组策略，但是win10家庭版中找不到gpedit.msc，需要手动添加网上找的脚本（测试有效）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@echo off</span><br><span class="line">pushd &quot;%~dp0&quot;</span><br><span class="line">dir /b C:\Windows\servicing\Packages\Microsoft-Windows-GroupPolicy-ClientExtensions-Package~3*.mum &gt;List.txt</span><br><span class="line">dir /b C:\Windows\servicing\Packages\Microsoft-Windows-GroupPolicy-ClientTools-Package~3*.mum &gt;&gt;List.txt</span><br><span class="line">for /f %%i in (&#x27;findstr /i . List.txt 2^&gt;nul&#x27;) do dism /online /norestart /add-package:&quot;C:\Windows\servicing\Packages\%%i&quot;</span><br><span class="line">pause</span><br></pre></td></tr></table></figure>

<blockquote>
<p>win10专业版默认自带本地组策略编辑器</p>
</blockquote>
<h2 id="设置软件安装策略"><a href="#设置软件安装策略" class="headerlink" title="设置软件安装策略"></a>设置软件安装策略</h2><p><img data-src="/images/2020/02/win10_gpdeit.png" alt="win10_gpdeit"></p>
<p>双击打开一个用户帐户控制：<code>管理审批模式下管理员的提升提示行为</code> 属性窗口，下拉菜单中点击【提示凭据】</p>
<h2 id="禁止系统软件安装"><a href="#禁止系统软件安装" class="headerlink" title="禁止系统软件安装"></a>禁止系统软件安装</h2><blockquote>
<p>本地组策略编辑器（gpedit.msc） -&gt; 计算机配置 -&gt; 管理模板 -&gt; Window组件 -&gt; Window Installer -&gt; 禁止用户安装 -&gt; （已启用）</p>
</blockquote>
]]></content>
      <categories>
        <category>工具</category>
        <category>windows</category>
      </categories>
      <tags>
        <tag>windows</tag>
        <tag>win10</tag>
      </tags>
  </entry>
  <entry>
    <title>window下的包管理工具</title>
    <url>/post/f9f0e3bd.html</url>
    <content><![CDATA[<p>在window10中微软开发了<code>winget</code>包管理工具,但是由于时间问题可以安装的软件包比较少,以后可能会好些.</p>
<p>除了<code>winget</code>,还有一些第三方包管理工具,比较好的有<code>choco</code>和<code>scoop</code>,但是由于scoop的仓库依赖github,可能有时由于网络的原因导致无法安装使用,如果网络正常可以参考<a href="https://winddoing.github.io/post/5c8794fe.html">scoop</a>使用起来有点像ubuntu下的apt-get,还挺好用.如果网络不能用,使用<code>choco</code>虽然慢点但是还能下载安装,同样简化了软件的安装.</p>
<span id="more"></span>

<h2 id="winget"><a href="#winget" class="headerlink" title="winget"></a>winget</h2><p>暂时没有使用过,以后可能也不会使用了呵呵呵</p>
<h2 id="choco"><a href="#choco" class="headerlink" title="choco"></a>choco</h2><ul>
<li>官网: <span class="exturl" data-url="aHR0cHM6Ly9jaG9jb2xhdGV5Lm9yZy8=">https://chocolatey.org<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p>通过<code>CMD</code>进行安装,需要<code>管理员</code>权限</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@powershell -NoProfile -ExecutionPolicy unrestricted -Command &quot;iex ((new-object net.webclient).DownloadString(&#x27;https://chocolatey.org/install.ps1&#x27;))</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">choco --help</span><br></pre></td></tr></table></figure>
<blockquote>
<p>可以安装的软件包:<span class="exturl" data-url="aHR0cHM6Ly9jaG9jb2xhdGV5Lm9yZy9wYWNrYWdlcw==">https://chocolatey.org/packages<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<h3 id="本地已安装软件"><a href="#本地已安装软件" class="headerlink" title="本地已安装软件"></a>本地已安装软件</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">choco list -lo</span><br></pre></td></tr></table></figure>

<h2 id="scoop"><a href="#scoop" class="headerlink" title="scoop"></a>scoop</h2><blockquote>
<p><a href="https://winddoing.github.io/post/5c8794fe.html">scoop for window</a></p>
</blockquote>
<h2 id="系统激活"><a href="#系统激活" class="headerlink" title="系统激活"></a>系统激活</h2><p>bat脚本,自动激活</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">slmgr /skms kms.03k.org</span><br><span class="line">slmgr /ato</span><br></pre></td></tr></table></figure>
<blockquote>
<p>window10测试有效</p>
</blockquote>
]]></content>
      <categories>
        <category>工具</category>
        <category>windows</category>
      </categories>
      <tags>
        <tag>scoop</tag>
        <tag>windows</tag>
        <tag>choco</tag>
      </tags>
  </entry>
  <entry>
    <title>windows系统之批处理bat语法</title>
    <url>/post/29269ff3.html</url>
    <content><![CDATA[<p>windows下的批处理工具<code>bat</code>的基本语法和使用</p>
<span id="more"></span>
<p>这里只是遇到的一些简单用法具体的详细可以通过<code>关键字</code>+<code>/?</code>查看详细的帮助文档。</p>
<figure class="highlight plaintext"><figcaption><span>basic</span></figcaption><table><tr><td class="code"><pre><span class="line">set /? #注意在CMD中输入查看，powershel不知道为什么没有输出</span><br></pre></td></tr></table></figure>

<p>内置命令：<code>help</code></p>
<figure class="highlight plaintext"><figcaption><span>basic</span></figcaption><table><tr><td class="code"><pre><span class="line">C:\&gt;help</span><br><span class="line">有关某个命令的详细信息，请键入 HELP 命令名</span><br><span class="line">ASSOC          显示或修改文件扩展名关联。</span><br><span class="line">ATTRIB         显示或更改文件属性。</span><br><span class="line">BREAK          设置或清除扩展式 CTRL+C 检查。</span><br><span class="line">BCDEDIT        设置启动数据库中的属性以控制启动加载。</span><br><span class="line">CACLS          显示或修改文件的访问控制列表(ACL)。</span><br><span class="line">CALL           从另一个批处理程序调用这一个。</span><br><span class="line">CD             显示当前目录的名称或将其更改。</span><br><span class="line">CHCP           显示或设置活动代码页数。</span><br><span class="line">CHDIR          显示当前目录的名称或将其更改。</span><br><span class="line">CHKDSK         检查磁盘并显示状态报告。</span><br><span class="line">CHKNTFS        显示或修改启动时间磁盘检查。</span><br><span class="line">CLS            清除屏幕。</span><br><span class="line">CMD            打开另一个 Windows 命令解释程序窗口。</span><br><span class="line">COLOR          设置默认控制台前景和背景颜色。</span><br><span class="line">COMP           比较两个或两套文件的内容。</span><br><span class="line">COMPACT        显示或更改 NTFS 分区上文件的压缩。</span><br><span class="line">CONVERT        将 FAT 卷转换成 NTFS。你不能转换</span><br><span class="line">               当前驱动器。</span><br><span class="line">COPY           将至少一个文件复制到另一个位置。</span><br><span class="line">DATE           显示或设置日期。</span><br><span class="line">DEL            删除至少一个文件。</span><br><span class="line">DIR            显示一个目录中的文件和子目录。</span><br><span class="line">DISKPART       显示或配置磁盘分区属性。</span><br><span class="line">DOSKEY         编辑命令行、撤回 Windows 命令并</span><br><span class="line">               创建宏。</span><br><span class="line">DRIVERQUERY    显示当前设备驱动程序状态和属性。</span><br><span class="line">ECHO           显示消息，或将命令回显打开或关闭。</span><br><span class="line">ENDLOCAL       结束批文件中环境更改的本地化。</span><br><span class="line">ERASE          删除一个或多个文件。</span><br><span class="line">EXIT           退出 CMD.EXE 程序(命令解释程序)。</span><br><span class="line">FC             比较两个文件或两个文件集并显示</span><br><span class="line">               它们之间的不同。</span><br><span class="line">FIND           在一个或多个文件中搜索一个文本字符串。</span><br><span class="line">FINDSTR        在多个文件中搜索字符串。</span><br><span class="line">FOR            为一组文件中的每个文件运行一个指定的命令。</span><br><span class="line">FORMAT         格式化磁盘，以便用于 Windows。</span><br><span class="line">FSUTIL         显示或配置文件系统属性。</span><br><span class="line">FTYPE          显示或修改在文件扩展名关联中使用的文件</span><br><span class="line">               类型。</span><br><span class="line">GOTO           将 Windows 命令解释程序定向到批处理程序</span><br><span class="line">               中某个带标签的行。</span><br><span class="line">GPRESULT       显示计算机或用户的组策略信息。</span><br><span class="line">GRAFTABL       使 Windows 在图形模式下显示扩展</span><br><span class="line">               字符集。</span><br><span class="line">HELP           提供 Windows 命令的帮助信息。</span><br><span class="line">ICACLS         显示、修改、备份或还原文件和</span><br><span class="line">               目录的 ACL。</span><br><span class="line">IF             在批处理程序中执行有条件的处理操作。</span><br><span class="line">LABEL          创建、更改或删除磁盘的卷标。</span><br><span class="line">MD             创建一个目录。</span><br><span class="line">MKDIR          创建一个目录。</span><br><span class="line">MKLINK         创建符号链接和硬链接</span><br><span class="line">MODE           配置系统设备。</span><br><span class="line">MORE           逐屏显示输出。</span><br><span class="line">MOVE           将一个或多个文件从一个目录移动到另一个</span><br><span class="line">               目录。</span><br><span class="line">OPENFILES      显示远程用户为了文件共享而打开的文件。</span><br><span class="line">PATH           为可执行文件显示或设置搜索路径。</span><br><span class="line">PAUSE          暂停批处理文件的处理并显示消息。</span><br><span class="line">POPD           还原通过 PUSHD 保存的当前目录的上一个</span><br><span class="line">               值。</span><br><span class="line">PRINT          打印一个文本文件。</span><br><span class="line">PROMPT         更改 Windows 命令提示。</span><br><span class="line">PUSHD          保存当前目录，然后对其进行更改。</span><br><span class="line">RD             删除目录。</span><br><span class="line">RECOVER        从损坏的或有缺陷的磁盘中恢复可读信息。</span><br><span class="line">REM            记录批处理文件或 CONFIG.SYS 中的注释(批注)。</span><br><span class="line">REN            重命名文件。</span><br><span class="line">RENAME         重命名文件。</span><br><span class="line">REPLACE        替换文件。</span><br><span class="line">RMDIR          删除目录。</span><br><span class="line">ROBOCOPY       复制文件和目录树的高级实用工具</span><br><span class="line">SET            显示、设置或删除 Windows 环境变量。</span><br><span class="line">SETLOCAL       开始本地化批处理文件中的环境更改。</span><br><span class="line">SC             显示或配置服务(后台进程)。</span><br><span class="line">SCHTASKS       安排在一台计算机上运行命令和程序。</span><br><span class="line">SHIFT          调整批处理文件中可替换参数的位置。</span><br><span class="line">SHUTDOWN       允许通过本地或远程方式正确关闭计算机。</span><br><span class="line">SORT           对输入排序。</span><br><span class="line">START          启动单独的窗口以运行指定的程序或命令。</span><br><span class="line">SUBST          将路径与驱动器号关联。</span><br><span class="line">SYSTEMINFO     显示计算机的特定属性和配置。</span><br><span class="line">TASKLIST       显示包括服务在内的所有当前运行的任务。</span><br><span class="line">TASKKILL       中止或停止正在运行的进程或应用程序。</span><br><span class="line">TIME           显示或设置系统时间。</span><br><span class="line">TITLE          设置 CMD.EXE 会话的窗口标题。</span><br><span class="line">TREE           以图形方式显示驱动程序或路径的目录</span><br><span class="line">               结构。</span><br><span class="line">TYPE           显示文本文件的内容。</span><br><span class="line">VER            显示 Windows 的版本。</span><br><span class="line">VERIFY         告诉 Windows 是否进行验证，以确保文件</span><br><span class="line">               正确写入磁盘。</span><br><span class="line">VOL            显示磁盘卷标和序列号。</span><br><span class="line">XCOPY          复制文件和目录树。</span><br><span class="line">WMIC           在交互式命令 shell 中显示 WMI 信息。</span><br><span class="line"></span><br><span class="line">有关工具的详细信息，请参阅联机帮助中的命令行参考。</span><br></pre></td></tr></table></figure>

<h2 id="bat脚本"><a href="#bat脚本" class="headerlink" title="bat脚本"></a>bat脚本</h2><p>在windows下bat脚本的文件名后缀一般为<code>bat</code>或<code>cmd</code></p>
<h2 id="bat语法"><a href="#bat语法" class="headerlink" title="bat语法"></a>bat语法</h2><h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
<th align="center">对应linux命令</th>
</tr>
</thead>
<tbody><tr>
<td><code>cd</code></td>
<td>显示当前目录名或改变当前目录</td>
<td align="center"><code>cd</code></td>
</tr>
<tr>
<td><code>dir</code></td>
<td>显示目录中的文件和子目录列表</td>
<td align="center"><code>ls</code></td>
</tr>
<tr>
<td><code>mkdir</code>&#x2F;<code>md</code></td>
<td>创建目录</td>
<td align="center"><code>mkdir</code></td>
</tr>
<tr>
<td><code>pushd</code></td>
<td>保存当前目录，并切换目录，如<code>pushd c:\work</code></td>
<td align="center"><code>pushd</code></td>
</tr>
<tr>
<td><code>popd</code></td>
<td>恢复当前目录为刚才保存的，如<code>popd</code></td>
<td align="center"><code>popd</code></td>
</tr>
<tr>
<td><code>del</code></td>
<td>删除一个或多个文件,<code>del xxx /f</code></td>
<td align="center"><code>rm</code></td>
</tr>
<tr>
<td><code>rd</code></td>
<td>删除目录， <code>rd /s /q build</code></td>
<td align="center"></td>
</tr>
<tr>
<td><code>mklink</code></td>
<td>创建符号链接</td>
<td align="center"><code>ln</code></td>
</tr>
<tr>
<td><code>rename</code>&#x2F;<code>ren</code></td>
<td>重命名文件</td>
<td align="center"><code>mv</code></td>
</tr>
<tr>
<td><code>copy</code></td>
<td>将一份或多份文件复制到另一个位置</td>
<td align="center"><code>cp</code></td>
</tr>
<tr>
<td><code>type</code></td>
<td>显示文本文件的内容</td>
<td align="center"><code>cat</code></td>
</tr>
</tbody></table>
<h3 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h3><table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>cls</code></td>
<td>清除屏幕</td>
</tr>
<tr>
<td><code>pause</code></td>
<td>暂停批处理文件的处理并显示消息:<code>请按任意键继续. . .</code></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3 id="内置变量"><a href="#内置变量" class="headerlink" title="内置变量"></a>内置变量</h3><p><code>%var%</code>：变量的引用，通过两个%号即可引用该变量的值使用</p>
<ul>
<li>自定义变量，多用于脚本</li>
<li>系统内置变量</li>
</ul>
<table>
<thead>
<tr>
<th>系统内置变量名</th>
<th>变量值</th>
</tr>
</thead>
<tbody><tr>
<td>%SYSTEMROOT%</td>
<td><code>C:\Windows</code></td>
</tr>
<tr>
<td>%ERRORLEVEL%</td>
<td>程序返回码，正确返回0</td>
</tr>
<tr>
<td>%PROCESSOR_ARCHITECTURE%</td>
<td>判断系统位数，比如<code>AMD64</code></td>
</tr>
<tr>
<td>%cd%</td>
<td>当前路径，比如<code>C:\Users</code></td>
</tr>
<tr>
<td>%~dp0</td>
<td>当前路径，比如<code>C:\Users\</code></td>
</tr>
<tr>
<td>NUL</td>
<td>相当于，linux中的dev&#x2F;null</td>
</tr>
</tbody></table>
<h3 id="特殊符号"><a href="#特殊符号" class="headerlink" title="特殊符号"></a>特殊符号</h3><table>
<thead>
<tr>
<th>符号</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>@</code></td>
<td>回显屏蔽</td>
</tr>
<tr>
<td><code>^</code></td>
<td>转义符</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3 id="注释与打印"><a href="#注释与打印" class="headerlink" title="注释与打印"></a>注释与打印</h3><h4 id="rem-和"><a href="#rem-和" class="headerlink" title="rem 和 ::"></a>rem 和 ::</h4><ul>
<li><code>rem</code>: 注释命令，一般用来给程序加上注解，该命令后的内容不被执行，但能回显</li>
<li><code> ::</code> 也可以起到rem 的注释作用, 而且更简洁有效，其后的字符行在执行时不会回显, 无论是否用echo on打开命令行回显状态, 因为命令解释器不认为他是一个有效的命令行</li>
</ul>
<h4 id="echo-和"><a href="#echo-和" class="headerlink" title="echo 和 @"></a>echo 和 @</h4><p><code>@</code>字符放在命令前将关闭该命令回显，无论此时echo是否为打开状态</p>
<h3 id="变量设置—set"><a href="#变量设置—set" class="headerlink" title="变量设置—set"></a>变量设置—set</h3><p>设置环境变量</p>
<figure class="highlight bat"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> var=abcdefg</span><br><span class="line">#or</span><br><span class="line"><span class="built_in">set</span> &quot;var=abcdefg&quot;</span><br></pre></td></tr></table></figure>

<p>参数：</p>
<blockquote>
<p> SET &#x2F;A expression<br> SET &#x2F;P variable&#x3D;[promptString]</p>
</blockquote>
<ul>
<li><p><code>/a</code> ：可以用各种表达式为变量赋值</p>
<figure class="highlight plaintext"><figcaption><span>basic</span></figcaption><table><tr><td class="code"><pre><span class="line">set /a var=1+1 #var=2</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>/p</code> ：可以在用户输入前加一段说明性的描述，即想让用户输入什么内容之类的说明</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set /p var=请输入变量的值：</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="清空变量名"><a href="#清空变量名" class="headerlink" title="清空变量名"></a>清空变量名</h4><figure class="highlight bat"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> VARNAME=</span><br><span class="line">#or</span><br><span class="line"><span class="built_in">set</span> &quot;VARNAME=&quot;</span><br></pre></td></tr></table></figure>





<h3 id="数值检查运算符"><a href="#数值检查运算符" class="headerlink" title="数值检查运算符"></a>数值检查运算符</h3><table>
<thead>
<tr>
<th>比较运算符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>EQU</td>
<td>等于</td>
</tr>
<tr>
<td>NEQ</td>
<td>不等于</td>
</tr>
<tr>
<td>LSS</td>
<td>小于</td>
</tr>
<tr>
<td>LEQ</td>
<td>小于或等于</td>
</tr>
<tr>
<td>GTR</td>
<td>大于</td>
</tr>
<tr>
<td>GEQ</td>
<td>大于或等于</td>
</tr>
</tbody></table>
<h3 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h3><h4 id="if"><a href="#if" class="headerlink" title="if"></a>if</h4><blockquote>
<p>IF [NOT] ERRORLEVEL number command<br>IF [NOT] string1&#x3D;&#x3D;string2 command<br>IF [NOT] EXIST filename command</p>
<p>  NOT               指定只有条件为 false 的情况下，Windows 才<br>                    应该执行该命令。</p>
<p>  ERRORLEVEL number 如果最后运行的程序返回一个等于或大于<br>                    指定数字的退出代码，指定条件为 true。</p>
<p>  string1&#x3D;&#x3D;string2  如果指定的文字字符串匹配，指定条件为 true。</p>
<p>  EXIST filename    如果指定的文件名存在，指定条件为 true。</p>
<p>  command           如果符合条件，指定要执行的命令。如果指定的<br>                    条件为 FALSE，命令后可跟 ELSE 命令，该命令将<br>                    在 ELSE 关键字之后执行该命令。</p>
</blockquote>
<ul>
<li><p><code>/I</code> : 如果指定说明要进行的字符串比较不分大小写,</p>
<figure class="highlight plaintext"><figcaption><span>basic</span></figcaption><table><tr><td class="code"><pre><span class="line">@IF /I NOT &quot;%swr%&quot;==&quot;y&quot; GOTO opengles</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="goto-和"><a href="#goto-和" class="headerlink" title="goto 和 :"></a>goto 和 :</h4><p>跳转到指定的标号处。</p>
<p>在批处理中允许以<code>:xxx</code>来构建一个标号，然后用<code>goto xxx</code>跳转到标号<code>:xxx</code>处，然后执行标号后的命令。</p>
<figure class="highlight plaintext"><figcaption><span>basic</span></figcaption><table><tr><td class="code"><pre><span class="line">@echo off</span><br><span class="line">:start</span><br><span class="line">set /a var+=1</span><br><span class="line">echo %var%</span><br><span class="line">    if %var% leq 3 goto start</span><br><span class="line">pause</span><br></pre></td></tr></table></figure>



<h3 id="CMD窗口名"><a href="#CMD窗口名" class="headerlink" title="CMD窗口名"></a>CMD窗口名</h3><p>设置cmd窗口的标题</p>
<figure class="highlight plaintext"><figcaption><span>basic</span></figcaption><table><tr><td class="code"><pre><span class="line">title 新标题     #可以看到cmd窗口的标题栏变了</span><br></pre></td></tr></table></figure>



<h3 id="setlocal-与-endlocal-命令"><a href="#setlocal-与-endlocal-命令" class="headerlink" title="setlocal 与 endlocal 命令"></a>setlocal 与 endlocal 命令</h3><blockquote>
<p>开始与终止批处理文件中环境改动的本地化操作。在执行 Setlocal 之后所做的环境改动只限于批处理文件。要还原原先的设置，必须执行 Endlocal。达到批处理文件结尾时，对于该批处理文件的每个尚未执行的 Setlocal 命令，都会有一个隐含的 Endlocal 被执行。Endlocal结束批处理文件中环境改动的本地化操作。在执行Endlocal 之后所做的环境改动不再仅限于批处理文件。批处理文件结束后，原先的设置无法还原。</p>
</blockquote>
<figure class="highlight bat"><table><tr><td class="code"><pre><span class="line">&gt;<span class="built_in">setlocal</span> /?</span><br><span class="line">开始批处理文件中环境改动的本地化操作。在执行 <span class="built_in">SETLOCAL</span> 之后</span><br><span class="line">所做的环境改动只限于批处理文件。要还原原先的设置，必须执</span><br><span class="line">行 <span class="built_in">ENDLOCAL</span>。达到批处理文件结尾时，对于该批处理文件的每个</span><br><span class="line">尚未执行的 <span class="built_in">SETLOCAL</span> 命令，都会有一个隐含的 <span class="built_in">ENDLOCAL</span> 被执行。</span><br><span class="line"></span><br><span class="line"><span class="built_in">SETLOCAL</span></span><br><span class="line"></span><br><span class="line">如果启用命令扩展，则 <span class="built_in">SETLOCAL</span> 更改如下:</span><br><span class="line"></span><br><span class="line"><span class="built_in">SETLOCAL</span> 批命令现在可以接受可选参数:</span><br><span class="line">        ENABLEEXTENSIONS / DISABLEEXTENSIONS</span><br><span class="line">            启用或禁用命令处理器扩展。这些</span><br><span class="line">            参数比 <span class="built_in">CMD</span> /E:ON 或 /E:OFF</span><br><span class="line">            开关有优先权。请参阅 <span class="built_in">CMD</span> /? 获取详细信息。</span><br><span class="line">        ENABLEDELAYEDEXPANSION / DISABLEDELAYEDEXPANSION</span><br><span class="line">            启用或禁用延缓环境变量</span><br><span class="line">            扩展。这些参数比 <span class="built_in">CMD</span></span><br><span class="line">            /V:ON 或 /V:OFF 开关有优先权。请参阅 <span class="built_in">CMD</span> /? 获取详细信息。</span><br><span class="line">无论在 <span class="built_in">SETLOCAL</span> 命令之前的设置是什么，这些修改会一直</span><br><span class="line">生效，直到出现相应的 <span class="built_in">ENDLOCAL</span> 命令。</span><br><span class="line"></span><br><span class="line">在给定参数的情况下，</span><br><span class="line"><span class="built_in">SETLOCAL</span> 命令将设置 <span class="keyword">ERRORLEVEL</span> 值。如果给定两个有效参数中的一个，另一个未给定，</span><br><span class="line">则该值为零。</span><br><span class="line">通过以下方法，你可以在批脚本中</span><br><span class="line">使用此项来确定扩展是否可用:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">VERIFY</span> OTHER <span class="number">2</span>&gt;<span class="built_in">nul</span></span><br></pre></td></tr></table></figure>




<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="获取管理员权限"><a href="#获取管理员权限" class="headerlink" title="获取管理员权限"></a>获取管理员权限</h3><figure class="highlight bat"><table><tr><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line">@<span class="built_in">cd</span> /d &quot;%~dp0&quot;</span><br><span class="line">@<span class="built_in">set</span> &quot;<span class="keyword">ERRORLEVEL</span>=&quot;</span><br><span class="line">@<span class="built_in">CMD</span> /C <span class="keyword">EXIT</span> <span class="number">0</span></span><br><span class="line">@&quot;<span class="variable">%SYSTEMROOT%</span>\system32\<span class="built_in">cacls</span>.exe&quot; &quot;<span class="variable">%SYSTEMROOT%</span>\system32\config\system&quot; &gt;<span class="built_in">nul</span> <span class="number">2</span>&gt;&amp;<span class="number">1</span></span><br><span class="line">@<span class="keyword">if</span> <span class="keyword">NOT</span> &quot;<span class="variable">%ERRORLEVEL%</span>&quot;==&quot;<span class="number">0</span>&quot; (</span><br><span class="line">@powershell -Command <span class="built_in">Start</span>-Process &quot;&quot;%<span class="number">0</span>&quot;&quot; -Verb runAs <span class="number">2</span>&gt;<span class="built_in">nul</span></span><br><span class="line">@<span class="keyword">exit</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>





<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vbGl6bTE2Ni9wLzExMTMyNjAxLmh0bWw=">bat脚本的基本命令语法<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vQnJhdmVsaXUvcC81MDgxMDg0Lmh0bWw=">批处理命令——set<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vc213aWtpcGVkaWEvYXJjaGl2ZS8yMDA5LzAzLzMwLzE0MjQ3NDkuaHRtbA==">Windows脚本 - %~dp0的含义<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>工具</category>
        <category>windows</category>
      </categories>
      <tags>
        <tag>windows</tag>
        <tag>bat</tag>
        <tag>批处理</tag>
        <tag>脚本</tag>
      </tags>
  </entry>
  <entry>
    <title>关于Win10中Linux Ubuntu子系统的相关问题</title>
    <url>/post/41029.html</url>
    <content><![CDATA[<p>记录window10中Linux子系统使用的相关问题和常见错误。</p>
<span id="more"></span>

<h2 id="error-0x800703fa"><a href="#error-0x800703fa" class="headerlink" title="error: 0x800703fa"></a>error: 0x800703fa</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Installing, this may take a few minutes...</span><br><span class="line">WslRegisterDistribution failed with error: 0x800703fa</span><br><span class="line">Error: 0x800703fa ???????????????????????</span><br><span class="line"></span><br><span class="line">Press any key to continue...</span><br></pre></td></tr></table></figure>
<ul>
<li>解决方法：<blockquote>
<p>打开服务管理，重启<code>LxssManager</code>服务解决,并将其设置为<code>自动</code><br>路径：开始（右键）-&gt;计算机管理 -&gt; 服务和计算机程序 -&gt; 服务(LxssManager)</p>
</blockquote>
</li>
</ul>
]]></content>
      <categories>
        <category>工具</category>
        <category>windows</category>
      </categories>
      <tags>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux性能测试——CPU性能及工作状态</title>
    <url>/post/e3720616.html</url>
    <content><![CDATA[<p>Linux下查看系统状态的一些命令<code>mpstat</code>、<code>vmstat</code>、<code>iostat</code>、<code>sar</code>、<code>top</code>、<code>pidstat</code>、<code>pstack</code></p>
<p><img data-src="/images/2021/03/linux_observability_tools.png" alt="Linux Performance Tools"></p>
<span id="more"></span>

<h2 id="衡量CPU性能的指标"><a href="#衡量CPU性能的指标" class="headerlink" title="衡量CPU性能的指标"></a>衡量CPU性能的指标</h2><ol>
<li>用户使用CPU</li>
</ol>
<ul>
<li>CPU运行实时进程</li>
<li>CPU运行niced process</li>
<li>CPU运行常规用户进程</li>
</ul>
<ol start="2">
<li>系统使用CPU</li>
</ol>
<ul>
<li>用于I&#x2F;O管理：中断和驱动</li>
<li>用于内存管理：页面交换</li>
<li>用于进程管理：进程开始和上下文切换</li>
</ul>
<ol start="3">
<li>WIO：用于进程等待磁盘I&#x2F;O而使CPU处于空闲状态的比率。</li>
<li>CPU的空闲率，除了上面的WIO以外的空闲时间</li>
<li>CPU用于上下文交换的比率</li>
<li>nice</li>
<li>real-time</li>
<li>运行进程队列的长度</li>
<li>平均负载</li>
</ol>
<h2 id="Linux常用监控CPU整体性能的工具"><a href="#Linux常用监控CPU整体性能的工具" class="headerlink" title="Linux常用监控CPU整体性能的工具"></a>Linux常用监控CPU整体性能的工具</h2><ul>
<li><code>mpstat</code>： mpstat不但能查看所有CPU的平均信息，还能查看指定CPU的信息,以及中断利用率</li>
<li><code>vmstat</code>：只能查看所有CPU的平均信息；查看cpu队列信息；</li>
<li><code>iostat</code>: 只能查看所有CPU的平均信息。</li>
<li><code>sar</code>： 与mpstat 一样，不但能查看CPU的平均信息，还能查看指定CPU的信息。</li>
<li><code>top</code>：显示的信息同ps接近，但是top可以了解到CPU消耗，可以根据用户指定的时间来更新显示。</li>
<li><code>pidstat</code>:用于监控全部或指定进程的cpu、内存、线程、设备IO等系统资源的占用情况,<code>-w</code>可以查看每个进程的上下文切换情况。</li>
<li><code>pstack</code>：显示每个进程的栈跟踪，可以确定进程挂起的位置。此命令允许使用的唯一选项是要检查的进程的PID。</li>
<li><code>gstack</code>: 打印运行进程（线程）调用栈。</li>
<li><code>gcore</code>: 生成正在运行的程序的core文件，可以进行gdb调试。</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3oxMTM0MTQ1ODgxL2FydGljbGUvZGV0YWlscy81MjA4OTY5OA==">linux CPU性能及工作状态查看指令<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL3d3dy5icmVuZGFuZ3JlZ2cuY29tL2xpbnV4cGVyZi5odG1s">Linux Performance<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>工具</category>
        <category>性能测试</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>cpu</tag>
      </tags>
  </entry>
  <entry>
    <title>linux性能测试——load average</title>
    <url>/post/4d1d787a.html</url>
    <content><![CDATA[<p><code>uptime</code>和<code>top</code>等命令都可以看到<code>load average</code>指标，从左至右三个数字分别表示<code>1分钟</code>、<code>5分钟</code>、<code>15分钟</code>的load average：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">uptime</span></span></span><br><span class="line"> 09:52:13 up 20:03, 14 users,  load average: 48.59, 46.08, 46.00</span><br></pre></td></tr></table></figure>
<blockquote>
<p>判断一个系统负载是否偏高需要计算单核CPU的平均负载，等于这里uptime命令显示的系统平均负载&#x2F;CPU核数，一般以0.7为比较合适的值, 偏高说明有比较多的进程在等待使用CPU资源。<br>除了等待运行的进程还有不可中断的线程</p>
</blockquote>
<span id="more"></span>
<h2 id="系统负载"><a href="#系统负载" class="headerlink" title="系统负载"></a>系统负载</h2><ul>
<li>系统负载度量旨在将系统“资源需求”表示为一个数字。 在经典Unix上，它仅计算对CPU的需求（处于Runnable状态的线程）</li>
<li>系统负载度量的单位是“进程&#x2F;线程数”（或在Linux上称为调度单位的任务）。 平均负载是一个时间段（最后1,5,15分钟）内平均线程数，该时间段在经典unix上“竞争CPU”或在Linux上“竞争CPU或以不间断的睡眠状态等待”</li>
<li>可运行状态表示“不受任何阻止”，可以在CPU上运行。 该线程当前正在CPU上运行，或者在CPU运行队列中等待OS调度程序将其放到CPU上</li>
<li>在Linux上，系统负载包括处于<code>Runnable（R）</code>和处于<code>Uninterruptible sleep（D）</code>状态的线程（通常是磁盘I&#x2F;O，但并非总是如此）</li>
</ul>
<p> 当前系统负载只是Linux上处于R或D状态的线程（称为任务）的数量。 我们可以运行ps列出这些状态下的当前线程数：<br> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ps -eo s,user | grep ^[RD] | <span class="built_in">sort</span> | <span class="built_in">uniq</span> -c | <span class="built_in">sort</span> -nbr | <span class="built_in">head</span> -20</span></span><br><span class="line">     3 R root</span><br><span class="line">     1 D root</span><br></pre></td></tr></table></figure></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly90YW5lbHBvZGVyLmNvbS9wb3N0cy9oaWdoLXN5c3RlbS1sb2FkLWxvdy1jcHUtdXRpbGl6YXRpb24tb24tbGludXgv">High System Load with Low CPU Utilization on Linux?<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>工具</category>
        <category>性能测试</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>cpu</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux性能测试工具---Lmbench</title>
    <url>/post/54953.html</url>
    <content><![CDATA[<p>Lmbench是一套简易，可移植的，符合ANSI&#x2F;C标准为UNIX&#x2F;POSIX而制定的微型测评工具。一般来说，它衡量两个关键特征：<code>反应时间</code>和<code>带宽</code>。Lmbench旨在使系统开发者深入了解关键操作的基础成本。</p>
<blockquote>
<p>测试包括文档读写、内存操作、进程创建销毁开销、网络等性能，测试方法简单</p>
<p>Lmbench: <span class="exturl" data-url="aHR0cDovL3d3dy5iaXRtb3Zlci5jb20vbG1iZW5jaC8=">http://www.bitmover.com/lmbench<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">带宽测评(<code>bw_*</code>)</th>
<th align="center">&lt;命令&gt;</th>
<th align="center">反应时间测评（<code>lat_*</code>）</th>
<th align="center">&lt;命令&gt;</th>
</tr>
</thead>
<tbody><tr>
<td align="center">读取缓存文件</td>
<td align="center">bw_file_rd</td>
<td align="center">上下文切换</td>
<td align="center">-</td>
</tr>
<tr>
<td align="center">拷贝内存</td>
<td align="center">bw_mem 1M cp</td>
<td align="center">网络： 连接的建立，管道，TCP，UDP和RPC hot potato</td>
<td align="center">-</td>
</tr>
<tr>
<td align="center">读内存</td>
<td align="center">bw_mem 1M rd</td>
<td align="center">文件系统的建立和删除</td>
<td align="center">-</td>
</tr>
<tr>
<td align="center">写内存</td>
<td align="center">bw_mem 1M wr</td>
<td align="center">进程创建</td>
<td align="center">-</td>
</tr>
<tr>
<td align="center">管道</td>
<td align="center">bw_pipe</td>
<td align="center">信号处理</td>
<td align="center">-</td>
</tr>
<tr>
<td align="center">TCP</td>
<td align="center">bw_tcp</td>
<td align="center">上层的系统调用</td>
<td align="center">-</td>
</tr>
<tr>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">内存读入反应时间</td>
<td align="center">lat_mem_rd</td>
</tr>
</tbody></table>
<blockquote>
<p><code>man</code>获取详细信息</p>
</blockquote>
<span id="more"></span>

<p>移植方便可在buildroot配置</p>
<h2 id="mhz"><a href="#mhz" class="headerlink" title="mhz"></a>mhz</h2><p>计算处理时钟</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">mhz</span></span><br><span class="line">1290 MHz, 0.7752 nanosec clock</span><br></pre></td></tr></table></figure>

<h2 id="tlb"><a href="#tlb" class="headerlink" title="tlb"></a>tlb</h2><p>获取TLB大小</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">tlb</span></span><br><span class="line">tlb: 10 pages</span><br></pre></td></tr></table></figure>

<h2 id="line"><a href="#line" class="headerlink" title="line"></a>line</h2><p>Cache line大小</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">line</span></span><br><span class="line">64</span><br></pre></td></tr></table></figure>

<h2 id="stream"><a href="#stream" class="headerlink" title="stream"></a>stream</h2><p>测试内存带宽</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">stream</span></span><br><span class="line">STREAM copy latency: 4.98 nanoseconds</span><br><span class="line">STREAM copy bandwidth: 3213.50 MB/sec</span><br><span class="line">STREAM scale latency: 6.71 nanoseconds</span><br><span class="line">STREAM scale bandwidth: 2385.57 MB/sec</span><br><span class="line">STREAM add latency: 10.64 nanoseconds</span><br><span class="line">STREAM add bandwidth: 2256.06 MB/sec</span><br><span class="line">STREAM triad latency: 12.45 nanoseconds</span><br><span class="line">STREAM triad bandwidth: 1927.25 MB/sec</span><br></pre></td></tr></table></figure>

<h2 id="lmdd"><a href="#lmdd" class="headerlink" title="lmdd"></a>lmdd</h2><p>移动io进行性能和调试测试</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">time lmdd <span class="keyword">if</span>=/dev/urandom of=/tmp/xxx bs=1M count=10</span></span><br><span class="line">10.0000 MB in 1.7651 secs, 5.6653 MB/sec  #速度</span><br><span class="line">real    0m 1.77s</span><br><span class="line">user    0m 0.00s</span><br><span class="line">sys     0m 1.77s</span><br></pre></td></tr></table></figure>

<h2 id="测试示例"><a href="#测试示例" class="headerlink" title="测试示例"></a>测试示例</h2><h3 id="拷贝内存"><a href="#拷贝内存" class="headerlink" title="拷贝内存"></a>拷贝内存</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">bw_mem 500M <span class="built_in">cp</span></span></span><br><span class="line">500.00 858.05   #500M测试数据，拷贝速度858.05MB/s</span><br></pre></td></tr></table></figure>

<h3 id="内存写入反应时间"><a href="#内存写入反应时间" class="headerlink" title="内存写入反应时间"></a>内存写入反应时间</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">lat_mem_rd 1M</span></span><br><span class="line">&quot;stride=64     #步长，</span><br><span class="line">0.00049 2.343  #写入大小，反应时间纳秒（ns）</span><br><span class="line">0.00098 2.343</span><br><span class="line">0.00195 2.343</span><br><span class="line">0.00293 2.343</span><br><span class="line">^C</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>工具</category>
        <category>性能测试</category>
      </categories>
      <tags>
        <tag>lmbench</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux性能测试工具---sysbench</title>
    <url>/post/37666.html</url>
    <content><![CDATA[<p>Linux环境下的性能测试：</p>
<span id="more"></span>

<h2 id="sysbench"><a href="#sysbench" class="headerlink" title="sysbench"></a>sysbench</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt install sysbench</span><br></pre></td></tr></table></figure>

<p>源码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/akopytov/sysbench.git</span><br></pre></td></tr></table></figure>

<h3 id="CPU测试"><a href="#CPU测试" class="headerlink" title="CPU测试"></a>CPU测试</h3><p>CPU的性能测试通常有：</p>
<ol>
<li>质数计算；</li>
<li>圆周率计算.</li>
</ol>
<p>cpu测试主要是进行<code>质数加法</code>运算, 找指定范围内最大质数<strong>时间越短，性能越好</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sysbench cpu run</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sysbench cpu --cpu-max-prime=100000 --num-threads=`grep &quot;processor&quot; /proc/cpuinfo | sort -u | wc -l` run</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mpstat -P ALL 1</span><br></pre></td></tr></table></figure>
<blockquote>
<p>间隔1s，打印当前所有CPU核的使用情况</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">sysbench cpu run</span></span><br><span class="line">sysbench 1.0.11 (using system LuaJIT 2.1.0-beta3)</span><br><span class="line"></span><br><span class="line">Running the test with following options:</span><br><span class="line">Number of threads: 1  #指定线程数为1</span><br><span class="line">Initializing random number generator from current time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Prime numbers limit: 10000 #每个线程产生的素数上限均为10000个</span><br><span class="line"></span><br><span class="line">Initializing worker threads...</span><br><span class="line"></span><br><span class="line">Threads started!</span><br><span class="line"></span><br><span class="line">CPU speed:</span><br><span class="line">    events per second:  1181.65 #所有线程每秒完成的event次数</span><br><span class="line"></span><br><span class="line">General statistics:</span><br><span class="line">    total time:                          10.0007s #总消耗时间</span><br><span class="line">    total number of events:              11819    #event次数</span><br><span class="line"></span><br><span class="line">Latency (ms):</span><br><span class="line">         min:                                  0.78</span><br><span class="line">         avg:                                  0.85</span><br><span class="line">         max:                                  4.57</span><br><span class="line">         95th percentile:                      0.99</span><br><span class="line">         sum:                               9996.65</span><br><span class="line"></span><br><span class="line">Threads fairness:</span><br><span class="line">    events (avg/stddev):           11819.0000/0.00</span><br><span class="line">    execution time (avg/stddev):   9.9967/0.00</span><br></pre></td></tr></table></figure>

<h2 id="圆周率测试"><a href="#圆周率测试" class="headerlink" title="圆周率测试"></a>圆周率测试</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">time echo &quot;scale=5000;4*a(1)&quot;|bc -l -q</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>工具</category>
        <category>性能测试</category>
      </categories>
      <tags>
        <tag>sysbench</tag>
      </tags>
  </entry>
  <entry>
    <title>更新时间戳</title>
    <url>/post/31965.html</url>
    <content><![CDATA[<h3 id="时间戳不相同时更新命令："><a href="#时间戳不相同时更新命令：" class="headerlink" title="时间戳不相同时更新命令："></a>时间戳不相同时更新命令：</h3><p>第一种：</p>
<pre><code>touch  *
</code></pre>
<p>第二种：（文件很多）</p>
<pre><code>find . -type f -exec touch &#123;&#125; \;
</code></pre>
]]></content>
      <categories>
        <category>工具</category>
        <category>时间戳</category>
      </categories>
      <tags>
        <tag>时间戳</tag>
      </tags>
  </entry>
  <entry>
    <title>常用网站</title>
    <url>/post/20962.html</url>
    <content><![CDATA[<p>平时工作学习的常用网站.</p>
<span id="more"></span>

<h2 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h2><ul>
<li><p>python</p>
<p>  –<span class="exturl" data-url="aHR0cDovL3d3dy5saWFveHVlZmVuZy5jb20vd2lraS8wMDE0MzE2MDg5NTU3MjY0YTZiMzQ4OTU4ZjQ0OTk0OWRmNDJhNmQzYTJlNTQyYzAwMC8=">廖雪峰Python教程<i class="fa fa-external-link-alt"></i></span></p>
</li>
</ul>
<h2 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h2><ul>
<li><p>嵌入式linux学习</p>
<p>  –<span class="exturl" data-url="aHR0cDovL3d3dy53b3dvdGVjaC5uZXQv">蜗窝科技<i class="fa fa-external-link-alt"></i></span></p>
</li>
</ul>
<h2 id="阅读"><a href="#阅读" class="headerlink" title="阅读"></a>阅读</h2><ul>
<li>电子书</li>
</ul>
<p> –<span class="exturl" data-url="aHR0cDovL3d3dy5raW5kbGVwdXNoLmNvbS9tYWlu">kindle推<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>工具</category>
        <category>网站</category>
      </categories>
      <tags>
        <tag>网站</tag>
      </tags>
  </entry>
  <entry>
    <title>ext4文件系统扩容</title>
    <url>/post/38978.html</url>
    <content><![CDATA[<p>ext4文件系统在制作时，已将大小进行固定，但是在实际的使用过程中，由于后续的测试和使用导致文件系统的空间不足，而同时有不想重新进行文件系统的制作，只是单纯的进行容量的扩展</p>
<span id="more"></span>

<h2 id="查看现有ext4文件系统"><a href="#查看现有ext4文件系统" class="headerlink" title="查看现有ext4文件系统"></a>查看现有ext4文件系统</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mount -t ext4 roofs.ext4 tmp</span><br></pre></td></tr></table></figure>

<h2 id="resize2fs"><a href="#resize2fs" class="headerlink" title="resize2fs"></a>resize2fs</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">resize2fs -h</span><br><span class="line">resize2fs 1.44.1 (24-Mar-2018)</span><br><span class="line">Usage: resize2fs [-d debug_flags] [-f] [-F] [-M] [-P] [-p] device [-b|-s|new_size] [-S RAID-stride] [-z undo_file]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>$man resize2fs</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">参数</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>-d</code></td>
<td align="center">打开调试特性</td>
</tr>
<tr>
<td align="center"><code>-f</code></td>
<td align="center">强制执行，覆盖一些通常强制执行的安全检查</td>
</tr>
<tr>
<td align="center"><code>-F</code></td>
<td align="center">执行之前，刷新文件系统的缓冲区</td>
</tr>
<tr>
<td align="center"><code>-M</code></td>
<td align="center">将文件系统缩小到最小值</td>
</tr>
<tr>
<td align="center"><code>-p</code></td>
<td align="center">显示已经完成任务的百分比</td>
</tr>
<tr>
<td align="center"><code>-P</code></td>
<td align="center">显示文件系统的最小值</td>
</tr>
</tbody></table>
<h3 id="显示文件系统最小值"><a href="#显示文件系统最小值" class="headerlink" title="显示文件系统最小值"></a>显示文件系统最小值</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">resize2fs -P  rootfs.ext4</span><br><span class="line">resize2fs 1.44.1 (24-Mar-2018)</span><br><span class="line">Estimated minimum size of the filesystem: 5161</span><br></pre></td></tr></table></figure>

<h3 id="文件系统扩展容量："><a href="#文件系统扩展容量：" class="headerlink" title="文件系统扩展容量："></a>文件系统扩展容量：</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">resize2fs system.ext4 300000</span><br><span class="line">resize2fs system.ext4 300M</span><br></pre></td></tr></table></figure>
<blockquote>
<p>文件系统大小: 300MB，单位可以使用<code>k</code>、<code>M</code>、<code>G</code></p>
</blockquote>
<h2 id="容量扩展"><a href="#容量扩展" class="headerlink" title="容量扩展"></a>容量扩展</h2><h3 id="创建空的文件系统"><a href="#创建空的文件系统" class="headerlink" title="创建空的文件系统"></a>创建空的文件系统</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">dd if=/dev/zero of=new_roofs.ext4 bs=1M count=300</span><br><span class="line">mkfs.ext4 new_roofs.ext4</span><br></pre></td></tr></table></figure>
<blockquote>
<p>文件系统大小：300M</p>
</blockquote>
<h3 id="现有文件系统的拷贝"><a href="#现有文件系统的拷贝" class="headerlink" title="现有文件系统的拷贝"></a>现有文件系统的拷贝</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mount -t ext4 roofs.ext4 tmp</span><br><span class="line">mount -t ext4 new_roofs.ext4 tmp1</span><br><span class="line">cp tmp/* tmp1 -arpdf</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>文件系统</category>
        <category>ext4</category>
      </categories>
      <tags>
        <tag>文件系统</tag>
        <tag>ext4</tag>
      </tags>
  </entry>
  <entry>
    <title>ext4文件系统变为只读</title>
    <url>/post/31493.html</url>
    <content><![CDATA[<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[ 7965.955384] EXT4-fs error (device mmcblk0p7): ext4_mb_generate_buddy:758: group 3, block bitmap and bg descriptor inconsistent: 1901 vs 1900 free clusters</span><br><span class="line">[ 7965.963826] EXT4-fs (mmcblk0p7): Remounting filesystem read-only</span><br><span class="line">[ 7965.975652] EXT4-fs (mmcblk0p7): ext4_writepages: jbd2_start: 2147483644 pages, ino 6032; err -30</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>ext4文件系统bug，在linux4.6.7中以修复。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">commit d123a55f85f5116d686dac80c768ee5c34ec8e06</span><br><span class="line">Author: Vegard Nossum &lt;vegard.nossum@oracle.com&gt;</span><br><span class="line">Date:   Thu Jul 14 23:21:35 2016 -0400</span><br><span class="line"></span><br><span class="line">    ext4: short-cut orphan cleanup on error</span><br><span class="line"></span><br><span class="line">    commit c65d5c6c81a1f27dec5f627f67840726fcd146de upstream.</span><br><span class="line"></span><br><span class="line">    If we encounter a filesystem error during orphan cleanup, we should stop.</span><br><span class="line">    Otherwise, we may end up in an infinite loop where the same inode is</span><br><span class="line">    processed again and again.</span><br><span class="line"></span><br><span class="line">        EXT4-fs (loop0): warning: checktime reached, running e2fsck is recommended</span><br><span class="line">        EXT4-fs error (device loop0): ext4_mb_generate_buddy:758: group 2, block bitmap and bg descriptor inconsistent: 6117 vs 0 free clusters</span><br><span class="line">        Aborting journal on device loop0-8.</span><br><span class="line">        EXT4-fs (loop0): Remounting filesystem read-only</span><br><span class="line">        EXT4-fs error (device loop0) in ext4_free_blocks:4895: Journal has aborted</span><br><span class="line">        EXT4-fs error (device loop0) in ext4_do_update_inode:4893: Journal has aborted</span><br><span class="line">        EXT4-fs error (device loop0) in ext4_do_update_inode:4893: Journal has aborted</span><br><span class="line">        EXT4-fs error (device loop0) in ext4_ext_remove_space:3068: IO failure</span><br><span class="line">        EXT4-fs error (device loop0) in ext4_ext_truncate:4667: Journal has aborted</span><br><span class="line">        EXT4-fs error (device loop0) in ext4_orphan_del:2927: Journal has aborted</span><br><span class="line">        EXT4-fs error (device loop0) in ext4_do_update_inode:4893: Journal has aborted</span><br><span class="line">        EXT4-fs (loop0): Inode 16 (00000000618192a0): orphan list check failed!</span><br><span class="line">        [...]</span><br><span class="line">        EXT4-fs (loop0): Inode 16 (0000000061819748): orphan list check failed!</span><br><span class="line">        [...]</span><br><span class="line">        EXT4-fs (loop0): Inode 16 (0000000061819bf0): orphan list check failed!</span><br><span class="line">        [...]</span><br><span class="line"></span><br><span class="line">    See-also: c9eb13a9105 (&quot;ext4: fix hang when processing corrupted orphaned inode list&quot;)</span><br><span class="line">    Cc: Jan Kara &lt;jack@suse.cz&gt;</span><br><span class="line">    Signed-off-by: Vegard Nossum &lt;vegard.nossum@oracle.com&gt;</span><br><span class="line">    Signed-off-by: Theodore Ts&#x27;o &lt;tytso@mit.edu&gt;</span><br><span class="line">    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;</span><br><span class="line"></span><br><span class="line">diff --git a/fs/ext4/super.c b/fs/ext4/super.c</span><br><span class="line">index 089821b..7fca76b 100644</span><br><span class="line">--- a/fs/ext4/super.c</span><br><span class="line">+++ b/fs/ext4/super.c</span><br><span class="line">@@ -2277,6 +2277,16 @@ static void ext4_orphan_cleanup(struct super_block *sb,</span><br><span class="line">        while (es-&gt;s_last_orphan) &#123;</span><br><span class="line">                struct inode *inode;</span><br><span class="line"></span><br><span class="line">+               /*</span><br><span class="line">+                * We may have encountered an error during cleanup; if</span><br><span class="line">+                * so, skip the rest.</span><br><span class="line">+                */</span><br><span class="line">+               if (EXT4_SB(sb)-&gt;s_mount_state &amp; EXT4_ERROR_FS) &#123;</span><br><span class="line">+                       jbd_debug(1, &quot;Skipping orphan recovery on fs with errors.\n&quot;);</span><br><span class="line">+                       es-&gt;s_last_orphan = 0;</span><br><span class="line">+                       break;</span><br><span class="line">+               &#125;</span><br><span class="line">+</span><br><span class="line">                inode = ext4_orphan_get(sb, le32_to_cpu(es-&gt;s_last_orphan));</span><br><span class="line">                if (IS_ERR(inode)) &#123;</span><br><span class="line">                        es-&gt;s_last_orphan = 0;</span><br></pre></td></tr></table></figure>

<p><span class="exturl" data-url="aHR0cHM6Ly9taXJyb3JzLmVkZ2Uua2VybmVsLm9yZy9wdWIvbGludXgva2VybmVsL3Y0LngvQ2hhbmdlTG9nLTQuNi43">linux v4.x ChangeLog-4.6.7<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="产生的原因："><a href="#产生的原因：" class="headerlink" title="产生的原因："></a>产生的原因：</h2>]]></content>
      <categories>
        <category>文件系统</category>
        <category>ext4</category>
      </categories>
      <tags>
        <tag>ext4</tag>
      </tags>
  </entry>
  <entry>
    <title>proc文件系统解析--进程</title>
    <url>/post/30680.html</url>
    <content><![CDATA[<p>Linux系统上的&#x2F;proc目录是一种文件系统，即proc文件系统。与其它常见的文件系统不同的是，&#x2F;proc是一种伪文件系统（也即虚拟文件系统），存储的是当前内核运行状态的一系列特殊文件，用户可以通过这些文件查看有关系统硬件及当前正在运行进程的信息，甚至可以通过更改其中某些文件来改变内核的运行状态。</p>
<blockquote>
<p>所有说明均可通过<code>man proc</code>获取</p>
</blockquote>
<span id="more"></span>

<p>系统环境：<code>arm64bit</code>， <code>Linux4.4.70</code></p>
<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><ul>
<li>测试进程<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ps</span></span><br><span class="line">...</span><br><span class="line">570 root      2728 S    top</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="built_in">ls</span> -<span class="built_in">ls</span></span></span><br><span class="line">    0 dr-xr-xr-x    2 root     root             0 Jan  1 04:14 attr</span><br><span class="line">    0 -r--------    1 root     root             0 Jan  1 04:14 auxv</span><br><span class="line">    0 -r--r--r--    1 root     root             0 Jan  1 04:14 cgroup</span><br><span class="line">    0 --w-------    1 root     root             0 Jan  1 04:14 clear_refs</span><br><span class="line">    0 -r--r--r--    1 root     root             0 Jan  1 03:31 cmdline</span><br><span class="line">    0 -rw-r--r--    1 root     root             0 Jan  1 04:14 comm</span><br><span class="line">    0 -rw-r--r--    1 root     root             0 Jan  1 04:14 coredump_filter</span><br><span class="line">    0 -r--r--r--    1 root     root             0 Jan  1 04:14 cpuset</span><br><span class="line">    0 lrwxrwxrwx    1 root     root             0 Jan  1 04:14 cwd -&gt; /proc</span><br><span class="line">    0 -r--------    1 root     root             0 Jan  1 04:14 environ</span><br><span class="line">    0 lrwxrwxrwx    1 root     root             0 Jan  1 04:14 exe -&gt; /bin/busybox</span><br><span class="line">    0 dr-x------    2 root     root             0 Jan  1 04:14 fd</span><br><span class="line">    0 dr-x------    2 root     root             0 Jan  1 04:14 fdinfo</span><br><span class="line">    0 -rw-r--r--    1 root     root             0 Jan  1 04:14 gid_map</span><br><span class="line">    0 -r--r--r--    1 root     root             0 Jan  1 04:14 limits</span><br><span class="line">    0 dr-x------    2 root     root             0 Jan  1 04:14 map_files</span><br><span class="line">    0 -r--r--r--    1 root     root             0 Jan  1 04:14 maps</span><br><span class="line">    0 -rw-------    1 root     root             0 Jan  1 04:14 mem</span><br><span class="line">    0 -r--r--r--    1 root     root             0 Jan  1 04:14 mountinfo</span><br><span class="line">    0 -r--r--r--    1 root     root             0 Jan  1 04:14 mounts</span><br><span class="line">    0 -r--------    1 root     root             0 Jan  1 04:14 mountstats</span><br><span class="line">    0 dr-xr-xr-x   10 root     root             0 Jan  1 04:14 net</span><br><span class="line">    0 dr-x--x--x    2 root     root             0 Jan  1 04:14 ns</span><br><span class="line">    0 -r--------    1 root     root             0 Jan  1 04:14 oom_adj</span><br><span class="line">    0 -r--r--r--    1 root     root             0 Jan  1 04:14 oom_score</span><br><span class="line">    0 -r--------    1 root     root             0 Jan  1 04:14 oom_score_adj</span><br><span class="line">    0 -r--------    1 root     root             0 Jan  1 04:14 pagemap</span><br><span class="line">    0 -r--------    1 root     root             0 Jan  1 04:14 personality</span><br><span class="line">    0 -rw-r--r--    1 root     root             0 Jan  1 04:14 projid_map</span><br><span class="line">    0 lrwxrwxrwx    1 root     root             0 Jan  1 04:14 root -&gt; /</span><br><span class="line">    0 -rw-r--r--    1 root     root             0 Jan  1 04:14 sched</span><br><span class="line">    0 -r--r--r--    1 root     root             0 Jan  1 04:14 schedstat</span><br><span class="line">    0 -rw-r--r--    1 root     root             0 Jan  1 04:14 setgroups</span><br><span class="line">    0 -r--r--r--    1 root     root             0 Jan  1 04:14 smaps</span><br><span class="line">    0 -r--------    1 root     root             0 Jan  1 04:14 stack</span><br><span class="line">    0 -r--r--r--    1 root     root             0 Jan  1 03:31 stat</span><br><span class="line">    0 -r--r--r--    1 root     root             0 Jan  1 04:14 statm</span><br><span class="line">    0 -r--r--r--    1 root     root             0 Jan  1 04:14 status</span><br><span class="line">    0 -r--------    1 root     root             0 Jan  1 04:14 syscall</span><br><span class="line">    0 dr-xr-xr-x    3 root     root             0 Jan  1 04:14 task</span><br><span class="line">    0 -rw-rw-rw-    1 root     root             0 Jan  1 04:14 timerslack_ns</span><br><span class="line">    0 -rw-r--r--    1 root     root             0 Jan  1 04:14 uid_map</span><br><span class="line">    0 -r--r--r--    1 root     root             0 Jan  1 04:14 wchan</span><br></pre></td></tr></table></figure>
<h2 id="进程目录"><a href="#进程目录" class="headerlink" title="进程目录"></a>进程目录</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">ls</span> /proc/570/</span></span><br><span class="line">attr             fd               ns               smaps</span><br><span class="line">auxv             fdinfo           oom_adj          stack</span><br><span class="line">cgroup           gid_map          oom_score        stat</span><br><span class="line">clear_refs       limits           oom_score_adj    statm</span><br><span class="line">cmdline          map_files        pagemap          status</span><br><span class="line">comm             maps             personality      syscall</span><br><span class="line">coredump_filter  mem              projid_map       task</span><br><span class="line">cpuset           mountinfo        root             timerslack_ns</span><br><span class="line">cwd              mounts           sched            uid_map</span><br><span class="line">environ          mountstats       schedstat        wchan</span><br><span class="line">exe              net              setgroups</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">选项</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">cmdline</td>
<td align="left">启动当前进程的完整命令，但僵尸进程目录中的此文件不包含任何信息</td>
</tr>
<tr>
<td align="center">cwd</td>
<td align="left">指向当前进程运行目录的一个符号链接</td>
</tr>
<tr>
<td align="center">exe</td>
<td align="left">指向启动当前进程的可执行文件（完整路径）的符号链接</td>
</tr>
<tr>
<td align="center">fd</td>
<td align="left">指向启动当前进程的可执行文件（完整路径）的符号链接</td>
</tr>
<tr>
<td align="center">limits</td>
<td align="left">当前进程所使用的每一个受限资源的软限制、硬限制和管理单元；此文件仅可由实际启动当前进程的UID用户读取；</td>
</tr>
<tr>
<td align="center">maps</td>
<td align="left">当前进程关联到的每个可执行文件和库文件在内存中的映射区域及其访问权限所组成的列表；</td>
</tr>
<tr>
<td align="center">mem</td>
<td align="left">当前进程所占用的内存空间，由open、read和lseek等系统调用使用，不能被用户读取；</td>
</tr>
<tr>
<td align="center">root</td>
<td align="left">指向当前进程运行根目录的符号链接；在Unix和Linux系统上，通常采用chroot命令使每个进程运行于独立的根目录；</td>
</tr>
<tr>
<td align="center">stat</td>
<td align="left">当前进程的状态信息，包含一系统格式化后的数据列，可读性差，通常由ps命令使用；</td>
</tr>
<tr>
<td align="center">statm</td>
<td align="left">当前进程占用内存的状态信息，通常以“页面”（page）表示；</td>
</tr>
<tr>
<td align="center">status</td>
<td align="left">与stat所提供信息类似，但可读性较好</td>
</tr>
<tr>
<td align="center">task</td>
<td align="left">包含由当前进程所运行的每一个线程的相关信息，每个<code>线程</code>的相关信息文件均保存在一个由线程号（tid）命名的目录中，这类似于其内容类似于每个进程目录中的内容</td>
</tr>
</tbody></table>
<h3 id="x2F-proc-x2F-PID-x2F-stat"><a href="#x2F-proc-x2F-PID-x2F-stat" class="headerlink" title="&#x2F;proc&#x2F;[PID]&#x2F;stat"></a>&#x2F;proc&#x2F;[PID]&#x2F;stat</h3><blockquote>
<p>包含了所有CPU活跃的信息，该文件中的所有值都是<code>从系统启动开始累计到当前时刻</code>。</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="built_in">cat</span> /proc/570/stat</span></span><br><span class="line">570 (top) S 565 570 565 34817 570 4210688 110 0 0 0 209 648 0 0 20 0 1 0 1266675 2793472 111 18446744073709551615 4194304 4867856 548828687344 548828686432 548186418324 0 0 0 58751527 1 0 0 17 3 0 0 0 0 0 4933392 4937189 1042927616 548828688219 548828688223 548828688223 548828688363 0</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th align="center">序号</th>
<th align="left">表示</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="left">pid&#x3D;570</td>
<td align="left">进程(包括轻量级进程，即线程)号</td>
</tr>
<tr>
<td align="center">2</td>
<td align="left">comm&#x3D;top</td>
<td align="left">应用程序或命令的名字</td>
</tr>
<tr>
<td align="center">3</td>
<td align="left">task_state&#x3D;R</td>
<td align="left">任务的状态，R:runnign, S:sleeping (TASK_INTERRUPTIBLE), D:disk sleep (TASK_UNINTERRUPTIBLE), T: stopped, T:tracing stop,Z:zombie, X:dead</td>
</tr>
<tr>
<td align="center">4</td>
<td align="left">ppid&#x3D;565</td>
<td align="left">父进程ID</td>
</tr>
<tr>
<td align="center">5</td>
<td align="left">pgid&#x3D;570</td>
<td align="left">线程组ID</td>
</tr>
<tr>
<td align="center">6</td>
<td align="left">session&#x3D;565</td>
<td align="left">该任务所在的会话组ID</td>
</tr>
<tr>
<td align="center">7</td>
<td align="left">tty_nr&#x3D;34817</td>
<td align="left">该任务的tty终端的设备号</td>
</tr>
<tr>
<td align="center">8</td>
<td align="left">tpgid&#x3D;570</td>
<td align="left">终端的进程组号，当前运行在该任务所在终端的前台任务(包括shell 应用程序)的PID。</td>
</tr>
<tr>
<td align="center">9</td>
<td align="left">task-&gt;flags&#x3D;4210688</td>
<td align="left">进程标志位，查看该任务的特性</td>
</tr>
<tr>
<td align="center">10</td>
<td align="left">min_flt&#x3D;110</td>
<td align="left">该任务不需要从硬盘拷数据而发生的缺页（次缺页）的次数</td>
</tr>
<tr>
<td align="center">11</td>
<td align="left">cmin_flt&#x3D;0</td>
<td align="left">累计的该任务的所有的waited-for进程曾经发生的次缺页的次数目</td>
</tr>
<tr>
<td align="center">12</td>
<td align="left">maj_flt&#x3D;0</td>
<td align="left">该任务需要从硬盘拷数据而发生的缺页（主缺页）的次数</td>
</tr>
<tr>
<td align="center">13</td>
<td align="left">cmaj_flt&#x3D;0</td>
<td align="left">累计的该任务的所有的waited-for进程曾经发生的主缺页的次数目</td>
</tr>
<tr>
<td align="center">14</td>
<td align="left">utime&#x3D;209</td>
<td align="left">该任务在用户态运行的时间，单位为jiffies</td>
</tr>
<tr>
<td align="center">15</td>
<td align="left">stime&#x3D;648</td>
<td align="left">该任务在核心态运行的时间，单位为jiffies</td>
</tr>
<tr>
<td align="center">16</td>
<td align="left">cutime&#x3D;0</td>
<td align="left">累计的该任务的所有的waited-for进程曾经在用户态运行的时间，单位为jiffies</td>
</tr>
<tr>
<td align="center">17</td>
<td align="left">cstime&#x3D;0</td>
<td align="left">累计的该任务的所有的waited-for进程曾经在核心态运行的时间，单位为jiffies</td>
</tr>
<tr>
<td align="center">18</td>
<td align="left">priority&#x3D;20</td>
<td align="left">任务的动态优先级</td>
</tr>
<tr>
<td align="center">19</td>
<td align="left">nice&#x3D;0</td>
<td align="left">任务的静态优先级</td>
</tr>
<tr>
<td align="center">20</td>
<td align="left">num_threads&#x3D;1</td>
<td align="left">该任务所在的线程组里线程的个数</td>
</tr>
<tr>
<td align="center">21</td>
<td align="left">it_real_value&#x3D;0</td>
<td align="left">由于计时间隔导致的下一个 SIGALRM 发送进程的时延，以jiffy为单位.</td>
</tr>
<tr>
<td align="center">22</td>
<td align="left">start_time&#x3D;1266675</td>
<td align="left">该任务启动的时间，单位为jiffies</td>
</tr>
<tr>
<td align="center">23</td>
<td align="left">vsize&#x3D;2793472</td>
<td align="left">该任务的虚拟地址空间大小, 单位为page</td>
</tr>
<tr>
<td align="center">24</td>
<td align="left">rss&#x3D;111</td>
<td align="left">该任务当前驻留物理地址空间的大小，单位为page</td>
</tr>
<tr>
<td align="center">25</td>
<td align="left">rlim&#x3D;18446744073709551615</td>
<td align="left">该任务能驻留物理地址空间的最大值. 单位：byte</td>
</tr>
<tr>
<td align="center">26</td>
<td align="left">start_code&#x3D;4194304</td>
<td align="left">该任务在虚拟地址空间的代码段的起始地址</td>
</tr>
<tr>
<td align="center">27</td>
<td align="left">end_code&#x3D;4867856</td>
<td align="left">该任务在虚拟地址空间的代码段的结束地址</td>
</tr>
<tr>
<td align="center">28</td>
<td align="left">startstack&#x3D;548828687344</td>
<td align="left">堆栈的起始地址（即底部）</td>
</tr>
<tr>
<td align="center">29</td>
<td align="left">kstkesp&#x3D;548828686432</td>
<td align="left">esp(堆栈指针) 的当前值, 与在进程的内核堆栈页得到的一致</td>
</tr>
<tr>
<td align="center">30</td>
<td align="left">kstkeip&#x3D;548186418324</td>
<td align="left">指向将要执行的指令的指针, EIP(指令指针)的当前值.</td>
</tr>
<tr>
<td align="center">31</td>
<td align="left">signal&#x3D;0</td>
<td align="left">待处理信号的位图，记录发送给进程的普通信号</td>
</tr>
<tr>
<td align="center">32</td>
<td align="left">blocked&#x3D;0</td>
<td align="left">阻塞信号的位图</td>
</tr>
<tr>
<td align="center">33</td>
<td align="left">sigignore&#x3D;0</td>
<td align="left">忽略的信号的位图</td>
</tr>
<tr>
<td align="center">34</td>
<td align="left">sigcatch&#x3D;58751527</td>
<td align="left">被俘获的信号的位图</td>
</tr>
<tr>
<td align="center">35</td>
<td align="left">wchan&#x3D;1</td>
<td align="left">如果该进程是睡眠状态，该值给出调度的调用点</td>
</tr>
<tr>
<td align="center">36</td>
<td align="left">nswap&#x3D;0</td>
<td align="left">交换的页数（未维护）</td>
</tr>
<tr>
<td align="center">37</td>
<td align="left">cnswap&#x3D;0</td>
<td align="left">子进程的累积nswap（未维护）。</td>
</tr>
<tr>
<td align="center">38</td>
<td align="left">exit_signal&#x3D;17</td>
<td align="left">该进程结束时，向父进程所发送的信号</td>
</tr>
<tr>
<td align="center">39</td>
<td align="left">task_cpu(task)&#x3D;3</td>
<td align="left">运行在哪个CPU上</td>
</tr>
<tr>
<td align="center">40</td>
<td align="left">task_rt_priority&#x3D;0</td>
<td align="left">实时进程的相对优先级别</td>
</tr>
<tr>
<td align="center">41</td>
<td align="left">task_policy&#x3D;0</td>
<td align="left">进程的调度策略，0&#x3D;非实时进程，1&#x3D;FIFO实时进程；2&#x3D;RR实时进程</td>
</tr>
<tr>
<td align="center">42</td>
<td align="left">delayacct_blkio_ticks&#x3D;0</td>
<td align="left">聚合块I&#x2F;O延迟，以时钟周期（厘秒,百分之一秒）为单位。</td>
</tr>
<tr>
<td align="center">43</td>
<td align="left">guest_time&#x3D;0</td>
<td align="left">-</td>
</tr>
<tr>
<td align="center">44</td>
<td align="left">cguest_time&#x3D;0</td>
<td align="left">-</td>
</tr>
<tr>
<td align="center">45</td>
<td align="left">start_data&#x3D;4933392</td>
<td align="left">放置程序数据和未初始化（BSS）数据的地址。</td>
</tr>
<tr>
<td align="center">46</td>
<td align="left">end_data  &#x3D;4937189</td>
<td align="left">-</td>
</tr>
<tr>
<td align="center">47</td>
<td align="left">start_brk&#x3D;1042927616</td>
<td align="left">可以使用brk(2)扩展程序堆的地址。</td>
</tr>
<tr>
<td align="center">48</td>
<td align="left">arg_start&#x3D;548828688219</td>
<td align="left">放置程序命令行参数（argv）的地址。</td>
</tr>
<tr>
<td align="center">49</td>
<td align="left">arg_end  &#x3D;548828688223</td>
<td align="left">-</td>
</tr>
<tr>
<td align="center">50</td>
<td align="left">env_start&#x3D;548828688223</td>
<td align="left">放置程序环境变量的地址。</td>
</tr>
<tr>
<td align="center">51</td>
<td align="left">env_end  &#x3D;548828688363</td>
<td align="left">-</td>
</tr>
<tr>
<td align="center">52</td>
<td align="left">exit_code&#x3D;0</td>
<td align="left">线程的退出状态采用waitpid(2)报告的形式。</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>文件系统</category>
        <category>proc</category>
      </categories>
      <tags>
        <tag>进程</tag>
      </tags>
  </entry>
  <entry>
    <title>double free or corruption (fasttop)</title>
    <url>/post/27831.html</url>
    <content><![CDATA[<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">*** Error in `./rixitest-static-ok&#x27;: double free or corruption (fasttop): 0x76e006f0 ***`</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在进行多线程编程的时候，可能出现<code>double free</code> 问题。主要是在多线程函数中有个对<code>new</code>出来的变量进行操作，但是未加锁同步导致的。只要在在对new变量进行读写操作之前，加个锁，就可以避免该问题的产生。</p>
</blockquote>
<p><code>0x76e006f0</code> : 多次<code>free</code>的变量地址，变量（或对象）通过<code>new</code>得到的，地址空间在堆里。</p>
<p>在多线程测试中，由于其中一个线程因为异常而exit(-1)退出时，另外的线程也可能因为异常对象的生命周期结束而执行析构函数去delete同一个变量。</p>
<span id="more"></span>

<h2 id="exit-and-exit"><a href="#exit-and-exit" class="headerlink" title="exit and _exit"></a><code>exit</code> and <code>_exit</code></h2><blockquote>
<p>用于终止一个程序</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">exit</span><span class="params">(<span class="type">int</span> status)</span>;</span><br><span class="line"><span class="type">void</span> _exit(<span class="type">int</span> status);</span><br></pre></td></tr></table></figure>
<p><img data-src="/images/app/exit_and__exit.png" alt="exit_and__exit"></p>
<p><code>_exit</code>直接进入内核，<code>exit</code>则先执行一些清除处理（在进程退出之前要检查文件状态，将文件缓冲区中的内容写回文件）再进入内核</p>
<p>调用<code>_exit</code>函数时，其会关闭进程所有的文件描述符，清理内存以及其他一些内核清理函数，但不会刷新流（stdin,stdout,stderr…）.<code>exit</code>函数是在<code>_exit</code>函数之上增加了一个封装，写回文件缓存区中的内容</p>
<h2 id="析构函数何时被调用"><a href="#析构函数何时被调用" class="headerlink" title="析构函数何时被调用"></a>析构函数何时被调用</h2><p>析构函数在下边3种情况时被调用：</p>
<ol>
<li>对象生命周期结束，被销毁时；</li>
<li>delete指向对象的指针时，或delete指向对象的基类类型指针，而其基类虚构函数是虚函数时；</li>
<li>对象i是对象o的成员，o的析构函数被调用时，对象i的析构函数也被调用。</li>
</ol>
<h2 id="固定程序的加载地址"><a href="#固定程序的加载地址" class="headerlink" title="固定程序的加载地址"></a>固定程序的加载地址</h2><p>关闭<code>ASLR</code>，每次执行时，进程的加载地址将被固定。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">echo <span class="number">0</span> &gt; /proc/sys/kernel/randomize_va_space</span><br></pre></td></tr></table></figure>
<blockquote>
<p>ASLR（Address space layout randomization）是一种针对缓冲区溢出的安全保护技术，通过对堆、栈、共享库映射等线性区布局的随机化，通过增加攻击者预测目的地址的难度，防止攻击者直接定位攻击代码位置，达到阻止溢出攻击的目的。</p>
</blockquote>
<h2 id="信号处理"><a href="#信号处理" class="headerlink" title="信号处理"></a>信号处理</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Exception::InstallException</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(&amp;mCurrentAction,<span class="number">0</span>,<span class="keyword">sizeof</span>(<span class="keyword">struct</span> sigaction));</span><br><span class="line">	mCurrentAction.sa_handler = Exception::segv_handler;</span><br><span class="line">	mCurrentAction.sa_flags = SA_RESTART | SA_SIGINFO;</span><br><span class="line">	sigemptyset(&amp;mCurrentAction.sa_mask);</span><br><span class="line"></span><br><span class="line">	sigaction (SIGSEGV, &amp;mCurrentAction, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Exception::unInstallException</span><span class="params">()</span>&#123;</span><br><span class="line">	sigaction (SIGSEGV, &amp;mOldAction, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Exception::segv_handler</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">-1</span>); <span class="comment">//Error</span></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在自定义捕获异常信号时，对异常的处理中不能使用<code>exit()</code>来结束进程。</p>
<p>原因：</p>
<ol>
<li>在异常处理中，系统已经陷入内核态进行<code>do_singal</code>的操作，而测试的异常处理函数中存在<code>exit()</code>，执行exit并等待其完成需要等异常信号的完成，而测试正在进行异常信号的处理，因此将造成死锁现象。</li>
<li>异常处理的多次重入，如果在执行exit时，产生新的相同的异常信号，但是此时由于系统的性能下降（存在多个进程执行，压力测试），使其exit的执行需要一定的CPU周期后才可以完成，这时将进行可能在一次进入异常处理，并再一次执行exit，可能将对相同的资源进行再一次的释放，从而造成<code>double free</code>的错误</li>
</ol>
<h3 id="疑问？？？"><a href="#疑问？？？" class="headerlink" title="疑问？？？"></a>疑问？？？</h3><ol>
<li><p>如果在信号处理中调用exit可以造成死锁，为啥不是必现？</p>
</li>
<li><p>两次重入可能对资源造成二次释放的现象，为啥每次释放的地址相同？</p>
</li>
</ol>
<h2 id="进程号"><a href="#进程号" class="headerlink" title="进程号"></a>进程号</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="type">pid_t</span> tgid;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用户空间获取<code>pid</code>和<code>tgid</code>, 分别是<code>syscall(SYS_gettid)</code>和<code>getpid</code></p>
<p>在linux系统中，我们用pid区分每一个进程，linux给每一个进程和轻量级进程都分配一个pid，但是linux程序员希望由一个进程产生的轻量级进程具有相同的pid，这样当我们向进程发送信号时，此信号可以影响进程及进程产生的轻量级进程。<br>为了做到这一点，linux用了线程组（可以理解为轻量级进程组）的概念，在线程组内，每个线程都使用此线程组内第一个线程(thread group leader)的pid，并将此值存入tgid</p>
<h3 id="pid和tgid的关系"><a href="#pid和tgid的关系" class="headerlink" title="pid和tgid的关系"></a>pid和tgid的关系</h3><blockquote>
<p>The four threads will have the same PID but only when viewed from above. What you (as a user) call a PID is not what the kernel (looking from below) calls a PID.</p>
</blockquote>
<blockquote>
<p>In the kernel, each thread has it’s own ID, called a PID (although it would possibly make more sense to call this a TID, or thread ID) and they also have a TGID (thread group ID) which is the PID of the thread that started the whole process.</p>
</blockquote>
<blockquote>
<p>Simplistically, when a new process is created, it appears as a thread where both the PID and TGID are the same (new) number.</p>
</blockquote>
<blockquote>
<p>When a thread starts another thread, that started thread gets its own PID (so the scheduler can schedule it independently) but it inherits the TGID from the original thread.</p>
</blockquote>
<blockquote>
<p>That way, the kernel can happily schedule threads independent of what process they belong to, while processes (thread group IDs) are reported to you.</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">              USER VIEW</span><br><span class="line"> &lt;-- PID 43 --&gt; &lt;----------------- PID 42 -----------------&gt;</span><br><span class="line">                     +---------+</span><br><span class="line">                     | process |</span><br><span class="line">                    _| pid=42  |_</span><br><span class="line">                  _/ | tgid=42 | \_ (new thread) _</span><br><span class="line">       _ (fork) _/   +---------+                  \</span><br><span class="line">      /                                        +---------+</span><br><span class="line">+---------+                                    | process |</span><br><span class="line">| process |                                    | pid=44  |</span><br><span class="line">| pid=43  |                                    | tgid=42 |</span><br><span class="line">| tgid=43 |                                    +---------+</span><br><span class="line">+---------+</span><br><span class="line"> &lt;-- PID 43 --&gt; &lt;--------- PID 42 --------&gt; &lt;--- PID 44 ---&gt;</span><br><span class="line">                     KERNEL VIEW</span><br></pre></td></tr></table></figure>

<h2 id="信号handle的重入"><a href="#信号handle的重入" class="headerlink" title="信号handle的重入"></a>信号handle的重入</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Exception::InstallException</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(&amp;mCurrentAction,<span class="number">0</span>,<span class="keyword">sizeof</span>(<span class="keyword">struct</span> sigaction));</span><br><span class="line">	mCurrentAction.sa_handler = Exception::segv_handler;</span><br><span class="line">	mCurrentAction.sa_flags = SA_RESTART | SA_SIGINFO;</span><br><span class="line">	sigemptyset(&amp;mCurrentAction.sa_mask);</span><br><span class="line"></span><br><span class="line">	sigaction (SIGSEGV, &amp;mCurrentAction, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Exception::unInstallException</span><span class="params">()</span>&#123;</span><br><span class="line">	sigaction (SIGSEGV, &amp;mOldAction, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Exception::segv_handler</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	Exception::unInstallException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<ol>
<li>将异常信号的handle应用程序自定义接受后，由于异常信号的不断产生将不断的进入handle，连续多次的进入会对程序造成什么影响？？?</li>
<li>如果进入异常处理后，最后又交给内核处理，结果会咋样？？？</li>
</ol>
</blockquote>
<p><em><strong>信号的处理handler，必须是可重入的</strong></em></p>
<table>
<thead>
<tr>
<th align="center">可重入函数</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>_exit()</code></td>
</tr>
</tbody></table>
<h3 id="SIG-DFL-and-SIG-IGN"><a href="#SIG-DFL-and-SIG-IGN" class="headerlink" title="SIG_DFL and SIG_IGN"></a>SIG_DFL and SIG_IGN</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">void</span> <span class="type">__signalfn_t</span>(<span class="type">int</span>);</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">__signalfn_t</span> __user *<span class="type">__sighandler_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIG_DFL ((__force __sighandler_t)0) <span class="comment">/* default signal handling */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIG_IGN ((__force __sighandler_t)1) <span class="comment">/* ignore signal */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIG_ERR ((__force __sighandler_t)-1)    <span class="comment">/* error return from signal */</span></span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>file: include&#x2F;uapi&#x2F;asm-generic&#x2F;signal-defs.h</p>
</blockquote>
<p>signal函数中的信号处理函数handler，可以是用户指定的一个信号处理函数，也可以是内核特定的函数指针SIG_IGN或SIG_DFL。若信号句柄是SIG_IGN或SIG_DFL，则分别表示对捕获的信号采取忽略操作或者默认操作。</p>
<h2 id="example"><a href="#example" class="headerlink" title="example"></a>example</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	public:</span><br><span class="line">		Test(<span class="type">int</span> i)</span><br><span class="line">		&#123;</span><br><span class="line">			m_i = i;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%s: construct %d\n&quot;</span>, __func__, m_i);</span><br><span class="line">		&#125;;</span><br><span class="line">		~Test()</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%s: destruct %d\n&quot;</span>, __func__,  m_i);</span><br><span class="line">		&#125;;</span><br><span class="line">	private:</span><br><span class="line">		<span class="type">int</span> m_i;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Test <span class="title function_">t_1</span><span class="params">(<span class="number">1</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">threadFunc</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">	Test <span class="title function_">t_3</span><span class="params">(<span class="number">3</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*	exit(1);*/</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">pthread_t</span> thread;</span><br><span class="line">	<span class="type">int</span> err;</span><br><span class="line">	Test <span class="title function_">t_2</span><span class="params">(<span class="number">2</span>)</span>;</span><br><span class="line"></span><br><span class="line">	err = pthread_create(&amp;thread, <span class="literal">NULL</span>, threadFunc, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (err != <span class="number">0</span>)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;pthread_create fail!!!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	pthread_join(thread,<span class="literal">NULL</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Hello World\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">/*	exit (0);*/</span></span><br><span class="line"><span class="comment">/*	_exit(0);*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="main-return-threadFunc-return"><a href="#main-return-threadFunc-return" class="headerlink" title="main(return), threadFunc(return)"></a>main(return), threadFunc(return)</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Test: construct 1</span><br><span class="line">Test: construct 2</span><br><span class="line">Test: construct 3</span><br><span class="line">~Test: destruct 3</span><br><span class="line">Hello World</span><br><span class="line">~Test: destruct 2</span><br><span class="line">~Test: destruct 1</span><br></pre></td></tr></table></figure>
<h3 id="main-return-，threadFunc-exit"><a href="#main-return-，threadFunc-exit" class="headerlink" title="main(return)，threadFunc(exit)"></a>main(return)，threadFunc(exit)</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Test: construct 1</span><br><span class="line">Test: construct 2</span><br><span class="line">Test: construct 3</span><br><span class="line">~Test: destruct 1</span><br></pre></td></tr></table></figure>

<h3 id="main-exit-，threadFunc-return"><a href="#main-exit-，threadFunc-return" class="headerlink" title="main(exit)，threadFunc(return)"></a>main(exit)，threadFunc(return)</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Test: construct 1</span><br><span class="line">Test: construct 2</span><br><span class="line">Test: construct 3</span><br><span class="line">~Test: destruct 3</span><br><span class="line">Hello World</span><br><span class="line">~Test: destruct 1</span><br></pre></td></tr></table></figure>

<h3 id="main-exit-，threadFunc-return-1"><a href="#main-exit-，threadFunc-return-1" class="headerlink" title="main(_exit)，threadFunc(return)"></a>main(_exit)，threadFunc(return)</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Test: construct 1</span><br><span class="line">Test: construct 2</span><br><span class="line">Test: construct 3</span><br><span class="line">~Test: destruct 3</span><br><span class="line">Hello World</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vTGl0dGxlSGFubi9wLzQwMjY3ODEuaHRtbA==">The Linux Process Principle，NameSpace, PID、TID、PGID、PPID、SID、TID、TTY<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL2Jsb2cuY2hpbmF1bml4Lm5ldC91aWQtMjE3MTgwNDctaWQtMzA2OTQxNi5odG1s">task_struct解析(三) 进程id <i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL3d3dy5jbmJsb2dzLmNvbS9saXVsaXBlbmcvcC8zNTU1Mzk1Lmh0bWw=">#define SIG_DFL ((void(*)(int))0)<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdGFuZ2Fvd2VuL2FydGljbGUvZGV0YWlscy80Nzg1NjcwNQ==">深入理解可重入与线程安全<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTEcxMjU5MTU2Nzc2L2FydGljbGUvZGV0YWlscy81MjczMjg3OQ==">【C&#x2F;C++】对于可重入、线程安全、异步信号安全几个概念的理解<i class="fa fa-external-link-alt"></i></span></li>
</ol>
]]></content>
      <categories>
        <category>程序设计</category>
        <category>C</category>
      </categories>
      <tags>
        <tag>c</tag>
        <tag>free</tag>
      </tags>
  </entry>
  <entry>
    <title>动态指令</title>
    <url>/post/40422.html</url>
    <content><![CDATA[<p>通过程序动态生成指令，然后进行执行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> +------------&gt; +-------+ &lt;--+生成指令，写入buffer</span><br><span class="line"> |              |       |</span><br><span class="line"> +              |       |</span><br><span class="line">PC              |       |</span><br><span class="line">                | buffer|</span><br><span class="line">                |       |</span><br><span class="line">                |       |</span><br><span class="line">                |       |</span><br><span class="line">                +-------+</span><br></pre></td></tr></table></figure>

<span id="more"></span>


<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">uint32_t</span> *InstBuf;</span><br><span class="line">InstBuf = (<span class="type">uint32_t</span>)<span class="built_in">malloc</span>(size);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>: i++) &#123;</span><br><span class="line">	InstBuf[i] = <span class="number">0x03e00008</span>; <span class="comment">/* JR RA */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> (*f)(<span class="type">void</span>);</span><br><span class="line">f = (<span class="type">void</span> (*)(<span class="type">void</span>))(InstBuf);</span><br><span class="line">(*f)();</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>程序设计</category>
        <category>C</category>
      </categories>
      <tags>
        <tag>指令</tag>
      </tags>
  </entry>
  <entry>
    <title>C代码片段</title>
    <url>/post/16839.html</url>
    <content><![CDATA[<p>记录一些遇到代码片段：</p>
<span id="more"></span>

<h2 id="atexit-程序终止时调用注册函数"><a href="#atexit-程序终止时调用注册函数" class="headerlink" title="atexit()程序终止时调用注册函数"></a>atexit()程序终止时调用注册函数</h2><p>C 库函数 int atexit(void (*func)(void)) 当程序正常终止时，调用指定的函数 func。您可以在任何地方注册你的终止函数，但它会在程序终止的时候被调用。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">functionA</span> <span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;这是函数A\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">/* 注册终止函数 */</span></span><br><span class="line">   atexit(functionA );</span><br><span class="line"></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;启动主程序...\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;退出主程序...\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="去掉字符串末尾多余字符：回车-空格"><a href="#去掉字符串末尾多余字符：回车-空格" class="headerlink" title="去掉字符串末尾多余字符：回车 空格"></a>去掉字符串末尾多余字符：回车 空格</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">clean_string</span><span class="params">(<span class="type">char</span> * <span class="type">const</span> str)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> *start = str;</span><br><span class="line">	<span class="type">char</span> *end = str;</span><br><span class="line">	<span class="type">char</span> *p = str;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(*p) &#123;</span><br><span class="line">		<span class="keyword">switch</span>(*p) &#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27; &#x27;</span>:</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;\r&#x27;</span>:</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;\n&#x27;</span>:</span><br><span class="line">			<span class="keyword">if</span>(str != start) &#123;</span><br><span class="line">			*start = *p;</span><br><span class="line">			start++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			*start = *p;</span><br><span class="line">			start++;</span><br><span class="line">			end = start;</span><br><span class="line">		&#125;</span><br><span class="line">		p++;</span><br><span class="line">	&#125;</span><br><span class="line">	*end = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="生成随机数：-异或"><a href="#生成随机数：-异或" class="headerlink" title="生成随机数： 异或"></a>生成随机数： 异或</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">seedrand_val2</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> rand_val = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	gettimeofday(&amp;tv, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//秒(tv.tv_sec)和微秒(tv.tv_usec)和进程ID的位进行异或操作生成随机数</span></span><br><span class="line">	rand_val = tv.tv_sec^tv.tv_usec^getpid();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s: rand_val=%d\n&quot;</span>, __func__, rand_val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="伪随机数：rand"><a href="#伪随机数：rand" class="headerlink" title="伪随机数：rand"></a>伪随机数：rand</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">srand((unsigned)time(NULL));</span><br><span class="line"></span><br><span class="line">#define MIN_BANDWIDTH   60</span><br><span class="line">#define MAX_BANDWIDTH   200</span><br><span class="line">#define random() (MIN_BANDWIDTH + (int)((double)rand() / ((double)RAND_MAX+1.0) * (MAX_BANDWIDTH - MIN_BANDWIDTH)))</span><br></pre></td></tr></table></figure>
<blockquote>
<p>随机范围：60~200</p>
</blockquote>
]]></content>
      <categories>
        <category>程序设计</category>
        <category>C</category>
      </categories>
      <tags>
        <tag>c</tag>
        <tag>代码片段</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言——锁</title>
    <url>/post/37537.html</url>
    <content><![CDATA[<p><code>锁</code>：原子锁, 线程安全</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> _a = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">++_a;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	++_a 大致可以拆分为下面三步(MIPS 指令)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	1&#x27; 把 _a 的值放入`寄存器$1`中   【lw】</span></span><br><span class="line"><span class="comment">	2&#x27; 把`寄存器$1`中值加1    【add】</span></span><br><span class="line"><span class="comment">	3&#x27; 返回`寄存器$1`中值并且设置给a   【sw】</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>自加1</code>和<code>自减1</code>：在GCC中提供了相应的原子指令操作，排除多线程对一个变量的操作的不可预期性。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">type __sync_fetch_and_add (type *ptr, type value, ...)</span><br><span class="line">type __sync_fetch_and_sub (type *ptr, type value, ...)</span><br><span class="line">type __sync_fetch_and_or (type *ptr, type value, ...)</span><br><span class="line">type __sync_fetch_and_and (type *ptr, type value, ...)</span><br><span class="line">type __sync_fetch_and_xor (type *ptr, type value, ...)</span><br><span class="line">type __sync_fetch_and_nand (type *ptr, type value, ...)</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="原子锁与自旋锁"><a href="#原子锁与自旋锁" class="headerlink" title="原子锁与自旋锁"></a>原子锁与自旋锁</h2><blockquote>
<p>原子锁和自旋锁的本质相同，通过对一个变量的<code>自加</code>和<code>自减</code>操作（这里的<code>自加</code>、<code>自减</code>都是通过一条原子指令完成），判断临界区的可操作性。</p>
</blockquote>
<h2 id="memory-barrier"><a href="#memory-barrier" class="headerlink" title="memory barrier"></a>memory barrier</h2><p>memory barrier有几种类型：</p>
<ul>
<li><code>acquire barrier</code> : 不允许将barrier之后的内存读取指令移到barrier之前（linux kernel中的wmb()）。</li>
<li><code>release barrier</code> : 不允许将barrier之前的内存读取指令移到barrier之后 (linux kernel中的rmb())。</li>
<li><code>full barrier</code>    : 以上两种barrier的合集(linux kernel中的mb())。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__sync_synchronize (...)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>GCC: This builtin issues a <code>full memory barrier</code>.</p>
</blockquote>
<h2 id="应用层：原子锁"><a href="#应用层：原子锁" class="headerlink" title="应用层：原子锁"></a>应用层：原子锁</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _H_SIMPLEC_SCATOM</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _H_SIMPLEC_SCATOM</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(__GNUC__)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// v += a ; return v;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ATOM_ADD(v, a)		__sync_add_and_fetch(&amp;(v), (a))</span></span><br><span class="line"><span class="comment">// type tmp = v ; v = a; return tmp;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ATOM_SET(v, a)		__sync_lock_test_and_set(&amp;(v), (a))</span></span><br><span class="line"><span class="comment">// v &amp;= a; return v;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ATOM_AND(v, a)		__sync_and_and_fetch(&amp;(v), (a))</span></span><br><span class="line"><span class="comment">// return ++v;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ATOM_INC(v) 		__sync_add_and_fetch(&amp;(v), 1)</span></span><br><span class="line"><span class="comment">// return --v;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ATOM_DEC(v) 		__sync_sub_and_fetch(&amp;(v), 1)</span></span><br><span class="line"><span class="comment">// bool b = v == c; b ? v=a : ; return b;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ATOM_CAS(v, c, a)	__sync_bool_compare_and_swap(&amp;(v), (c), (a))</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// 保证代码不乱序</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ATOM_SYNC() 		__sync_synchronize()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对ATOM_LOCK 解锁, 当然 直接调用相当于 v = 0;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ATOM_UNLOCK(v)		__sync_lock_release(&amp;(v))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// __GNUC__</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 试图加锁, 用法举例</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	 if(ATOM_TRYLOCK(v)) &#123;</span></span><br><span class="line"><span class="comment">		 // 已经有人加锁了, 处理返回事件</span></span><br><span class="line"><span class="comment">		...</span></span><br><span class="line"><span class="comment">	 &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	 // 得到锁资源, 开始处理</span></span><br><span class="line"><span class="comment">	 ...</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	 ATOM_UNLOCK(v);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 返回1表示已经有人加锁了, 竞争锁失败.</span></span><br><span class="line"><span class="comment"> * 返回0表示得到锁资源, 竞争锁成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ATOM_TRYLOCK(v)		ATOM_SET(v, 1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 使用方式:</span></span><br><span class="line"><span class="comment">//  int lock = 0;</span></span><br><span class="line"><span class="comment">//  ATOM_LOCK(lock);</span></span><br><span class="line"><span class="comment">//  ...</span></span><br><span class="line"><span class="comment">//  ATOM_UNLOCK(lock);</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ATOM_LOCK(v)		while(ATOM_SET(v, 1))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// !_H_SIMPLEC_SCATOM</span></span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>scatom.h</p>
</blockquote>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;include/atom.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> g_iFlagAtom = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WORK_SIZE 5000000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WORKER_COUNT 10</span></span><br><span class="line"><span class="type">pthread_t</span> g_tWorkerID[WORKER_COUNT];</span><br><span class="line"><span class="type">int</span> g_iSum = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> lock = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> * <span class="title function_">thr_worker</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;WORKER THREAD %08X STARTUP\n&quot;</span>, (<span class="type">unsigned</span> <span class="type">int</span>)pthread_self());</span><br><span class="line">	<span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;WORK_SIZE; ++i) &#123;</span><br><span class="line">		<span class="keyword">if</span> (g_iFlagAtom) &#123;</span><br><span class="line">			ATOM_INC(g_iSum);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">//ATOM_LOCK(lock);</span></span><br><span class="line">			g_iSum ++;</span><br><span class="line">			<span class="comment">//ATOM_UNLOCK(lock);</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> * <span class="title function_">thr_management</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;MANAGEMENT THREAD %08X STARTUP\n&quot;</span>, (<span class="type">unsigned</span> <span class="type">int</span>)pthread_self());</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;WORKER_COUNT;++i) &#123;</span><br><span class="line">		pthread_join(g_tWorkerID[i], <span class="literal">NULL</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;ALL WORKER THREADS FINISHED.\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">pthread_t</span> tManagementID;</span><br><span class="line">	<span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">start</span>, <span class="title">end</span>;</span></span><br><span class="line"></span><br><span class="line">	gettimeofday(&amp;start, <span class="literal">NULL</span>);</span><br><span class="line">	pthread_create (&amp;tManagementID, <span class="literal">NULL</span>, thr_management, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;WORKER_COUNT;++i) &#123;</span><br><span class="line">		pthread_create(&amp;g_tWorkerID[i], <span class="literal">NULL</span>, thr_worker, <span class="literal">NULL</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;CREATED %d WORKER THREADS\n&quot;</span>, i);</span><br><span class="line">	pthread_join(tManagementID, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	gettimeofday(&amp;end, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;THE SUM: %d\n&quot;</span>, g_iSum);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Run time: %ldms\n&quot;</span>, <span class="number">1000</span> * (end.tv_sec - start.tv_sec) + (end.tv_usec - start.tv_usec) / <span class="number">1000</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>结果<ul>
<li>g_iSum++  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">THE SUM: 14617872</span><br><span class="line">Run time: 201ms</span><br></pre></td></tr></table></figure></li>
<li>ATOM_INC  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">THE SUM: 50000000</span><br><span class="line">Run time: 1612ms</span><br></pre></td></tr></table></figure></li>
<li>ATOM_LOCK  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">THE SUM: 50000000</span><br><span class="line">Run time: 11821ms</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _H_SIMPLEC_SCRWLOCK</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _H_SIMPLEC_SCRWLOCK</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;scatom.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * create simple write and read lock</span></span><br><span class="line"><span class="comment"> * struct rwlock need zero.</span></span><br><span class="line"><span class="comment"> * is scatom ext</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// init need all is 0</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rwlock</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> rlock;</span><br><span class="line">	<span class="type">int</span> wlock;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// add read lock</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">rwlock_rlock</span><span class="params">(<span class="keyword">struct</span> rwlock * lock)</span>;</span><br><span class="line"><span class="comment">// add write lock</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">rwlock_wlock</span><span class="params">(<span class="keyword">struct</span> rwlock * lock)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// add write lock</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">rwlock_unrlock</span><span class="params">(<span class="keyword">struct</span> rwlock * lock)</span>;</span><br><span class="line"><span class="comment">// unlock write</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">rwlock_unwlock</span><span class="params">(<span class="keyword">struct</span> rwlock * lock)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// !_H_SIMPLEC_SCRWLOCK</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// add read lock</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">rwlock_rlock</span><span class="params">(<span class="keyword">struct</span> rwlock * lock)</span> &#123;</span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		<span class="comment">// 看是否有人在试图读, 得到并防止代码位置优化</span></span><br><span class="line">		<span class="keyword">while</span> (lock-&gt;wlock)</span><br><span class="line">			ATOM_SYNC();</span><br><span class="line"></span><br><span class="line">		ATOM_INC(lock-&gt;rlock);</span><br><span class="line">		<span class="comment">// 没有写占用, 开始读了</span></span><br><span class="line">		<span class="keyword">if</span> (!lock-&gt;wlock)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 还是有写, 删掉添加的读</span></span><br><span class="line">		ATOM_DEC(lock-&gt;rlock);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// unlock read lock</span></span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">rwlock_unrlock</span><span class="params">(<span class="keyword">struct</span> rwlock * lock)</span> &#123;</span><br><span class="line">	ATOM_DEC(lock-&gt;rlock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/ add write lock</span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">rwlock_wlock</span><span class="params">(<span class="keyword">struct</span> rwlock * lock)</span> &#123;</span><br><span class="line">	ATOM_LOCK(lock-&gt;wlock);</span><br><span class="line">	<span class="comment">// 等待读占用锁</span></span><br><span class="line">	<span class="keyword">while</span> (lock-&gt;rlock)</span><br><span class="line">		ATOM_SYNC();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// unlock write lock</span></span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">rwlock_unwlock</span><span class="params">(<span class="keyword">struct</span> rwlock * lock)</span> &#123;</span><br><span class="line">	ATOM_UNLOCK(lock-&gt;wlock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9nY2MuZ251Lm9yZy9vbmxpbmVkb2NzL2djYy00LjEuMi9nY2MvQXRvbWljLUJ1aWx0aW5zLmh0bWw=">Built-in functions for atomic memory access<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3dhbmd6aGlvbmUvY2Rlc2lnbmJvb2svYmxvYi9tYXN0ZXIvJUU3JUFDJUFDMyVFNyVBQiVBMC0lRTYlQjAlOTQlRTUlOEElOUYtJUU1JThFJTlGJUU1JUFEJTkwJUU5JTk0JTgxJUU3JUJBJUJGJUU3JUE4JThCJUU1JThEJThGJUU3JUE4JThCL1JFQURNRS5tZA==">原子锁线程协程<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>程序设计</category>
        <category>C</category>
      </categories>
      <tags>
        <tag>sync</tag>
        <tag>c</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言中__attribute__的作用</title>
    <url>/post/12087.html</url>
    <content><![CDATA[<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sc3</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> a;</span><br><span class="line">    <span class="type">char</span> *b;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>attribute</code>：属性，主要是用来在<code>函数</code>或<code>数据声明</code>中设置其属性,与编译器相关</p>
</blockquote>
<p>GNU C的一大特色就是<code>__attribute__</code>机制。<code>__attribute__</code>可以设置<code>函数属性（Function Attribute）</code>、<code>变量属性（Variable Attribute）</code>和<code>类型属性（Type Attribute）</code>。</p>
<ul>
<li>语法格式：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">__attribute__ ((attribute-list))</span><br></pre></td></tr></table></figure></li>
</ul>
<span id="more"></span>

<h2 id="attribute"><a href="#attribute" class="headerlink" title="attribute"></a>attribute</h2><ul>
<li>数据声明：<ul>
<li><code>__attribute__ ((packed))</code>: 的作用就是告诉编译器取消结构在编译过程中的优化对齐,按照实际占用字节数进行对齐，是GCC特有的语法。</li>
<li><code>__attribute__((aligned(n)))</code>: 内存对齐，指定内存对齐n字节</li>
</ul>
</li>
<li>函数声明：<ul>
<li><code>__attribute__((noreturn))</code>: 的作用告诉编译器这个函数不会返回给调用者，以便编译器在优化时去掉不必要的函数返回代码。</li>
<li><code>__attribute__((weak))</code>: 虚函数，弱符号</li>
</ul>
</li>
</ul>
<h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><h3 id="packed"><a href="#packed" class="headerlink" title="packed"></a>packed</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sc1</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> a;</span><br><span class="line">    <span class="type">char</span> *b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;sc1: sizeof-char*  = %ld\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sc1));</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sc3</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> a;</span><br><span class="line">    <span class="type">char</span> *b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;sc3: packed sizeof-char*  = %ld\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sc3));</span><br></pre></td></tr></table></figure>
<ul>
<li>运行结果：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sc1: sizeof-char*  = 16</span><br><span class="line">sc3: packed sizeof-char*  = 9</span><br></pre></td></tr></table></figure></li>
</ul>
<p>该属性可以使得变量或者结构体成员使用最小的对齐方式，即对变量是一字节对齐，对域（field）是位对齐。</p>
<h3 id="aligned-n"><a href="#aligned-n" class="headerlink" title="aligned(n)"></a>aligned(n)</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((<span class="title">aligned</span>(4))) <span class="title">sc5</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> a;</span><br><span class="line">    <span class="type">char</span> *b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((<span class="title">aligned</span>(4))) <span class="title">sc6</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> a;</span><br><span class="line">    <span class="type">char</span> b[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;sc5: aligned 4 sizeof-char*  = %ld\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sc5));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;sc6: aligned 4 sizeof-char[] = %ld\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sc6));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((<span class="title">aligned</span>(2))) <span class="title">sc7</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> a;</span><br><span class="line">    <span class="type">char</span> *b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((<span class="title">aligned</span>(2))) <span class="title">sc8</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> a;</span><br><span class="line">    <span class="type">char</span> b[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;sc7: aligned 2 sizeof-char*  = %ld\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sc7));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;sc8: aligned 2 sizeof-char[] = %ld\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sc8));</span><br></pre></td></tr></table></figure>

<ul>
<li>运行结果：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sc5: aligned 4 sizeof-char*  = 16</span><br><span class="line">sc6: aligned 4 sizeof-char[] = 4</span><br><span class="line">sc7: aligned 2 sizeof-char*  = 16</span><br><span class="line">sc8: aligned 2 sizeof-char[] = 2</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="noreturn"><a href="#noreturn" class="headerlink" title="noreturn"></a>noreturn</h3><blockquote>
<p>This attribute tells the compiler that the function won’t ever return, and this can be used to suppress errors about code paths not being reached. The C library functions abort() and exit() are both declared with this attribute:</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">exit</span><span class="params">(<span class="type">int</span>)</span>   __<span class="title function_">attribute__</span><span class="params">((<span class="keyword">noreturn</span>))</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">abort</span><span class="params">(<span class="type">void</span>)</span> __<span class="title function_">attribute__</span><span class="params">((<span class="keyword">noreturn</span>))</span>;</span><br></pre></td></tr></table></figure>
<p>函数不会返回。</p>
<h3 id="weak"><a href="#weak" class="headerlink" title="weak"></a>weak</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>  __attribute__((weak))  func(...)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>func转成<code>弱符号类型</code></p>
</blockquote>
<ul>
<li>如果遇到<code>强符号类型</code>（即外部模块定义了func, <code>extern int func(void);</code>），那么我们在本模块执行的func将会是外部模块定义的func。</li>
<li>如果外部模块没有定义，那么将会调用这个弱符号，也就是在本地定义的func，直接返回了一个1（返回值视具体情况而定）相当于增加了一个<code>默认函数</code>。</li>
</ul>
<p><strong>原理</strong>：<code>链接器</code>发现同时存在<code>弱符号</code>和<code>强符号</code>，就先选择强符号，如果发现不存在强符号，只存在弱符号，则选择弱符号。如果都不存在：静态链接，恭喜，编译时报错，动态链接：对不起，系统无法启动。</p>
<blockquote>
<p>weak属性只会在静态库(.o .a )中生效，动态库(.so)中不会生效。</p>
</blockquote>
<h2 id="内存地址对齐"><a href="#内存地址对齐" class="headerlink" title="内存地址对齐"></a>内存地址对齐</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define _ALIGN(x, align) (((x) + (align - 1)) &amp; (~(align - 1)))</span><br><span class="line"></span><br><span class="line">d_p = (d_t *)_ALIGN((unsigned int)d , 64); //将地址d按64bit进行对其后赋值给d_p指针</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://blog.csdn.net/wangzhaotongalex/article/details/22729215">#define PACK_STRUCT <em>attribute</em> ((<em>packed</em>))编译器按字独立分配</a></li>
</ul>
]]></content>
      <categories>
        <category>程序设计</category>
        <category>C</category>
      </categories>
      <tags>
        <tag>gcc</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言中char*和char[]的区别</title>
    <url>/post/44009.html</url>
    <content><![CDATA[<ul>
<li><code>char *c</code> : char型指针，只表示所指向的内存单元</li>
<li><code>char []</code> : 表示数组型的内存单元</li>
</ul>
<p><strong>结论</strong>： <code>char a[]</code>或<code>char a[0]</code>形式的定义在<code>结构体</code>中不占内存大小。</p>
<span id="more"></span>

<p><strong>以下所有测试在<code>64bit</code>系统中进行，结果与32bit系统存在差别。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> int_a;</span><br><span class="line">    <span class="type">int</span>* int_a_p;</span><br><span class="line">    <span class="type">char</span> char_b;</span><br><span class="line">    <span class="type">char</span>* char_b_p;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\tSystem Data Width:\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizeof int(%ld), int*(%ld), char(%ld), char*(%ld)\n&quot;</span>,</span><br><span class="line">            <span class="keyword">sizeof</span>(int_a), <span class="keyword">sizeof</span>(int_a_p), <span class="keyword">sizeof</span>(char_b), <span class="keyword">sizeof</span>(char_b_p));</span><br><span class="line"></span><br><span class="line">	<span class="type">char</span> *c1 = <span class="string">&quot;a b c d&quot;</span>;</span><br><span class="line">	<span class="type">char</span> c2[] = <span class="string">&quot;a b c d&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;c1: %s\n&quot;</span>, c1);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;c2: %s\n&quot;</span>, c2);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;c1-c1[0]=%c\n&quot;</span>, c1[<span class="number">0</span>]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;c2-c2[0]=%c\n&quot;</span>, c2[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//c1[0] = &#x27;x&#x27;; /* Segmentation fault (core dumped) */</span></span><br><span class="line">	c2[<span class="number">0</span>] = <span class="string">&#x27;y&#x27;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;c1-c1[0]=%c\n&quot;</span>, c1[<span class="number">0</span>]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;c2-c2[0]=%c\n&quot;</span>, c2[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sc1</span> &#123;</span></span><br><span class="line">		<span class="type">char</span> a;</span><br><span class="line">		<span class="type">char</span> *b;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sc2</span> &#123;</span></span><br><span class="line">		<span class="type">char</span> a;</span><br><span class="line">		<span class="type">char</span> b[];</span><br><span class="line">	&#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sc2_1</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> a;</span><br><span class="line">    <span class="type">char</span> b[<span class="number">0</span>];</span><br><span class="line">    &#125;;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;sc1: sizeof-char*  = %ld\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sc1)); <span class="comment">//8 + 8</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;sc2: sizeof-char[] = %ld\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sc2)); <span class="comment">//1</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sc2_1: packed sizeof-char[0] = %ld\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sc2_1)); <span class="comment">//1</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sc3</span> &#123;</span></span><br><span class="line">		<span class="type">char</span> a;</span><br><span class="line">		<span class="type">char</span> *b;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sc4</span> &#123;</span></span><br><span class="line">		<span class="type">char</span> a;</span><br><span class="line">		<span class="type">char</span> b[];</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;sc3: packed sizeof-char*  = %ld\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sc3)); <span class="comment">//1 + 8</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;sc4: packed sizeof-char[] = %ld\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sc4)); <span class="comment">//1</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>运行：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">System Data Width:</span><br><span class="line">sizeof int(4), int*(8), char(1), char*(8)</span><br><span class="line">c1: a b c d</span><br><span class="line">c2: a b c d</span><br><span class="line">c1-c1[0]=a</span><br><span class="line">c2-c2[0]=a</span><br><span class="line">c1-c1[0]=a</span><br><span class="line">c2-c2[0]=y</span><br><span class="line">sc1: sizeof-char*  = 16</span><br><span class="line">sc2: sizeof-char[] = 1</span><br><span class="line">sc2_1: packed sizeof-char[0] = 1</span><br><span class="line">sc3: packed sizeof-char*  = 9</span><br><span class="line">sc4: packed sizeof-char[] = 1</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="内存地址对比"><a href="#内存地址对比" class="headerlink" title="内存地址对比"></a>内存地址对比</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sc1</span> <span class="title">sc1_a</span>;</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\tsc1_a addr: %p\n&quot;</span>, &amp;sc1_a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\tsc1_a.a addr: %p\n&quot;</span>, &amp;sc1_a.a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\tsc1_a.b addr: %p\n&quot;</span>, &amp;sc1_a.b);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sc2</span> <span class="title">sc2_a</span>, <span class="title">sc2_b</span>;</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\tsc2_a addr: %p\n&quot;</span>, &amp;sc2_a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\tsc2_a.a addr: %p\n&quot;</span>, &amp;sc2_a.a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\tsc2_a.b addr: %p\n&quot;</span>, &amp;sc2_a.b);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\tsc2_b addr: %p\n&quot;</span>, &amp;sc2_b);</span><br></pre></td></tr></table></figure>
<ul>
<li>运行结果：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sc1_a addr: 0x7ffd44ed7d60</span><br><span class="line">sc1_a.a addr: 0x7ffd44ed7d60</span><br><span class="line">sc1_a.b addr: 0x7ffd44ed7d68</span><br><span class="line">sc2_a addr: 0x7ffd44ed7d7e</span><br><span class="line">sc2_a.a addr: 0x7ffd44ed7d7e</span><br><span class="line">sc2_a.b addr: 0x7ffd44ed7d7f</span><br><span class="line">sc2_b addr: 0x7ffd44ed7d7f</span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li>在结构体中使用<code>char buf[]</code>形式的定义，不占用内存空间</li>
</ul>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>内核部分结构体：如MMC中sdhci的结构体定义</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdhci_host</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> private[<span class="number">0</span>] ____cacheline_aligned;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>利于将自定义结构体部分和公共结构体之间相关联。</p>
<p>自定义结构体：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdhci_custom</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> xxx;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdhci_host</span> *<span class="title">host</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdhci_custom</span> *<span class="title">custom</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//一次性申请内存看见</span></span><br><span class="line">host = kmalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> sdhci_host) + <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sdhci_custom));</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义结构体位置</span></span><br><span class="line">custom = host-&gt;private;</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://blog.csdn.net/u010383937/article/details/78528750"><code>____cacheline_aligned</code>和<code>____cacheline_aligned_in_smp</code></a></li>
</ul>
]]></content>
      <categories>
        <category>程序设计</category>
        <category>C</category>
      </categories>
      <tags>
        <tag>指针</tag>
      </tags>
  </entry>
  <entry>
    <title>状态机</title>
    <url>/post/32902.html</url>
    <content><![CDATA[<h2 id="状态机"><a href="#状态机" class="headerlink" title="状态机"></a>状态机</h2><p>有限状态机（Finite State Machine或者Finite State Automata)是软件领域中一种重要的工具，很多东西的模型实际上就是有限状态机。</p>
<span id="more"></span>

<h3 id="FSM的实现方式："><a href="#FSM的实现方式：" class="headerlink" title="FSM的实现方式："></a>FSM的实现方式：</h3><ol>
<li>switch&#x2F;case或者if&#x2F;else</li>
</ol>
<p>这无意是最直观的方式，使用一堆条件判断，会编程的人都可以做到，对简单小巧的状态机来说最合适，但是毫无疑问，这样的方式比较原始，对庞大的状态机难以维护。</p>
<ol start="2">
<li>状态表</li>
</ol>
<p>维护一个二维状态表，横坐标表示当前状态，纵坐标表示输入，表中一个元素存储下一个状态和对应的操作。这一招易于维护，但是运行时间和存储空间的代价较大。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>有限状态机(finite state machine)是一个数学概念，如果把它运用于程序中，可以发挥很大的作用。它是一种协议，用于有限数量的子程序(“状态”)的发展变化。每个子程序进行一些处理并选择下一种状态(通常取决于下一段输入)。</p>
<p>有限状态机(FSM)可以用作程序的控制结构。FSM对于那些基于输入的在几个不同的可选动作中进行循环的程序尤其合适。投币售货机就是FSM的一个好例子。另外一个你可以想到的复杂的例子就是你正在用的东西，想到了吗？没错，就是操作系统。在投币售货机的例子中，输入是硬币，输出是待售商品，售货机有”接受硬币”，”选择商品”，”发送商品”和”找零钱”等几种状态。</p>
<p>它的基本思路是用一张表保存所有可能的状态，并列出进入每个状态时可能执行的所有动作，其中最后一个动作就是计算(通常在当前状态和下一次输入字符的基础上，另外再经过一次表查询)下一个应该进入的状态。你从一个”初始状态”开始。在这一过程中，翻译表可能告诉你进入了一个错误状态，直到到达结束状态。</p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//比如我们定义了小明一天的状态如下</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	GET_UP,</span><br><span class="line">	GO_TO_SCHOOL,</span><br><span class="line">	HAVE_LUNCH,</span><br><span class="line">	DO_HOMEWORK,</span><br><span class="line">	SLEEP,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	EVENT1 = <span class="number">1</span>,</span><br><span class="line">	EVENT2,</span><br><span class="line">	EVENT3,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">FsmTable_s</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">int</span> event;   <span class="comment">//事件</span></span><br><span class="line">	<span class="type">int</span> CurState;  <span class="comment">//当前状态</span></span><br><span class="line">	<span class="type">void</span> (*eventActFun)();  <span class="comment">//函数指针</span></span><br><span class="line">	<span class="type">int</span> NextState;  <span class="comment">//下一个状态</span></span><br><span class="line">&#125;FsmTable_t;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">FSM_s</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	FsmTable_t* FsmTable;   <span class="comment">//指向的状态表</span></span><br><span class="line">	<span class="type">int</span> curState;  <span class="comment">//FSM当前所处的状态</span></span><br><span class="line">&#125;FSM_t;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> g_max_num;  <span class="comment">//状态表里含有的状态个数</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">GetUp</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// do something</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;xiao ming gets up!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Go2School</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// do something</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;xiao ming goes to school!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">HaveLunch</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// do something</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;xiao ming has lunch!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">DoHomework</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// do something</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;xiao ming does homework!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Go2Bed</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// do something</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;xiao ming goes to bed!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*状态机注册*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">FSM_Regist</span><span class="params">(FSM_t* pFsm, FsmTable_t* pTable)</span></span><br><span class="line">&#123;</span><br><span class="line">	pFsm-&gt;FsmTable = pTable;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*状态迁移*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">FSM_StateTransfer</span><span class="params">(FSM_t* pFsm, <span class="type">int</span> state)</span></span><br><span class="line">&#123;</span><br><span class="line">	pFsm-&gt;curState = state;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*事件处理*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">FSM_EventHandle</span><span class="params">(FSM_t* pFsm, <span class="type">int</span> event)</span></span><br><span class="line">&#123;</span><br><span class="line">	FsmTable_t* pActTable = pFsm-&gt;FsmTable;</span><br><span class="line">	<span class="type">void</span> (*eventActFun)() = <span class="literal">NULL</span>;  <span class="comment">//函数指针初始化为空</span></span><br><span class="line">	<span class="type">int</span> NextState;</span><br><span class="line">	<span class="type">int</span> CurState = pFsm-&gt;curState;</span><br><span class="line">	<span class="type">int</span> flag = <span class="number">0</span>; <span class="comment">//标识是否满足条件</span></span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*获取当前动作函数*/</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i&lt;g_max_num; i++) &#123;</span><br><span class="line">		<span class="comment">//当且仅当当前状态下来个指定的事件，我才执行它</span></span><br><span class="line">		<span class="keyword">if</span> (event == pActTable[i].event &amp;&amp;</span><br><span class="line">				CurState == pActTable[i].CurState) &#123;</span><br><span class="line">			flag = <span class="number">1</span>;</span><br><span class="line">			eventActFun = pActTable[i].eventActFun;</span><br><span class="line">			NextState = pActTable[i].NextState;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (flag) &#123;</span><br><span class="line">		<span class="comment">/*动作执行*/</span></span><br><span class="line">		<span class="keyword">if</span> (eventActFun) &#123;</span><br><span class="line">			eventActFun();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//跳转到下一个状态</span></span><br><span class="line">		FSM_StateTransfer(pFsm, NextState);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// do nothing</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">FsmTable_t XiaoMingTable[] =</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//&#123;到来的事件，当前的状态，将要要执行的函数，下一个状态&#125;</span></span><br><span class="line">	&#123; EVENT1,  SLEEP,           GetUp,        GET_UP &#125;,</span><br><span class="line">	&#123; EVENT2,  GET_UP,          Go2School,    GO_TO_SCHOOL &#125;,</span><br><span class="line">	&#123; EVENT3,  GO_TO_SCHOOL,    HaveLunch,    HAVE_LUNCH &#125;,</span><br><span class="line">	&#123; EVENT1,  HAVE_LUNCH,      DoHomework,   DO_HOMEWORK &#125;,</span><br><span class="line">	&#123; EVENT2,  DO_HOMEWORK,     Go2Bed,       SLEEP &#125;,</span><br><span class="line">	<span class="comment">//add your codes here</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化FSM</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitFsm</span><span class="params">(FSM_t* pFsm)</span></span><br><span class="line">&#123;</span><br><span class="line">	g_max_num = <span class="keyword">sizeof</span>(XiaoMingTable) / <span class="keyword">sizeof</span>(FsmTable_t);</span><br><span class="line">	pFsm-&gt;curState = SLEEP;</span><br><span class="line">	FSM_Regist(pFsm, XiaoMingTable);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> *event)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (*event == <span class="number">3</span>) &#123;</span><br><span class="line">		*event = <span class="number">1</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		(*event)++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	FSM_t fsm;</span><br><span class="line">	InitFsm(&amp;fsm);</span><br><span class="line">	<span class="type">int</span> event = EVENT1;</span><br><span class="line">	<span class="comment">//小明的一天,周而复始的一天又一天，进行着相同的活动</span></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;event %d is coming...\n&quot;</span>, event);</span><br><span class="line">		FSM_EventHandle(&amp;fsm, event);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;fsm current state %d\n&quot;</span>, fsm.curState);</span><br><span class="line">		test(&amp;event);</span><br><span class="line">		sleep(<span class="number">1</span>);  <span class="comment">//休眠1秒，方便观察</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>程序设计</category>
        <category>C</category>
      </categories>
      <tags>
        <tag>fsm</tag>
      </tags>
  </entry>
  <entry>
    <title>getch、getche、getchar的区别和缓冲区的概念</title>
    <url>/post/26893.html</url>
    <content><![CDATA[<h3 id="输入输出缓冲区的概念（C-用的多一些）"><a href="#输入输出缓冲区的概念（C-用的多一些）" class="headerlink" title="输入输出缓冲区的概念（C++用的多一些）"></a>输入输出缓冲区的概念（C++用的多一些）</h3><ul>
<li><p>转载于：<span class="exturl" data-url="aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY3h5b2wvYXJ0aWNsZS9kZXRhaWxzLzYyODMyNA==">http://blog.csdn.net/cxyol/article/details/628324<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li><p>我想以一个例子说明，比如我想把一篇文章以字符序列的方式输出到计算机显示器屏幕上，那么我的程序内存作为数据源而显示器驱动程序作为数据目标，如果数据源直接对数据目标发送数据的话。数据目标获得第一个字符，便将它显示。然后从端口读取下一个字符，可是这时就不能保证数据源向端口发送的恰好是第二个字符（也许是第三个，而第二个已经在数据目标显示时发送过了）。这样的话就不能保证输出的数据能完整的被数据目标所接受并处理。</p>
</li>
<li><p>为了解决这个问题，我们需要在数据源与数据目标中间放置一个保存完整数据内容的区域，那就是 “缓冲区”。这样的话， 数据源可以不考虑数据目标正在处理哪部分数据，只要把数据输出到缓冲区就可以了，数据目标也可以不考虑数据源的发送频率，只是从缓冲区中依次取出下一个数据。从而保证了数据发送的完整性，同时也提高了程序的效率。</p>
<!---more---></li>
<li><p>当然getch(),getche()没有用到缓冲区。</p>
</li>
</ul>
<h3 id="几个函数的区别"><a href="#几个函数的区别" class="headerlink" title="几个函数的区别"></a>几个函数的区别</h3><h3 id="getch"><a href="#getch" class="headerlink" title="getch()"></a>getch()</h3><ul>
<li><p>首先不要忘了，要用getch()必须引入头文件conio.h，以前学C语言的时候，我们总喜欢用在程序的末尾加上它，利用它来实现程序运行完了暂停不退出的效果。如果不加这句话，在TC2.0的环境中我们用Ctrl+F9编译并运行后，程序一运行完了就退回到TC环境中，我们根本来不及看到结果，这时要看结果，我们就要按Alt+F5回到DOS环境中去看结果，这很麻烦。而如果在程序的结尾加上一行getch();语句，我们就可以省掉会DOS看结果这个步骤，因为程序运行完了并不退出，而是在程序最后把屏幕停住了，按任意键才退回到TC环境中去。</p>
</li>
<li><p>那我们来看看getch()到底起的什么作用，getch()实际是一个输入命令，<em>作用</em>是从键盘接收一个字符，而且并不把这个字符显示出来，就是说，你按了一个键后它并不在屏幕上显示你按的什么，而继续运行后面的代码，所以我们在C++中可以用它来实现“按任意键继续”的效果，即程序中遇到getch();这行语句，它就会把程序暂停下来，等你按任意键，它接收了这个字符键后再继续执行后面的代码。</p>
</li>
<li><p>你也许会问，为什么我们在C++中就没有在程序的末尾加上getch()，解释是，软件总是不断更新的，不好的地方当然要进行改正，getch()加在程序末尾，它又不赋值给任何变量，所以它在这个地方完全是垃圾代码，与程序无关。C++中考虑到这一点，于是在每次程序运行完了并不退出，而是自动把屏幕停下来，并显示“press any key…”叫你按任意键退出，这就好比C++在它的环境中运行程序，在程序的末尾自动加上了一行getch();语句，并且在这行语句前还添加了一行输出语句cout&lt;&lt;”press any key…”;来提示你程序结束了，按任意键继续。</p>
</li>
<li><p>实际上我们编译好的程序在程序结束了本身是不会停下来的，我们可以在编译产生的Debug目录中找到这个编译好的应用程序（扩展名exe），在文件夹中双击运行它，你会发现屏幕闪了一下MS-DOS窗口就关闭了，因为程序运行完就自动退出了，回到了windows环境，当然，如果我们在DOS环境中运行这个程序，我们就可以直接在看到DOS屏幕上看到程序运行结果，因为程序运行完后并不清屏。但是，visual stdio.net2003有返回到了tc那样的情况，你必需要有个getch()才行。</p>
</li>
</ul>
<h3 id="getche"><a href="#getche" class="headerlink" title="getche()"></a>getche()</h3><ul>
<li><p>getche()和getch()很相似，它也需要引入头文件conio.h，那它们之间的区别又在哪里呢？<strong>不同之处就在于getch()无返回显示，getche()有返回显示。</strong>就这么一点看看下面的例子：</p>
<pre><code> #include&lt;stdio.h&gt;
 #include&lt;conio.h&gt;
 void main()
 &#123;
     char ch;
     for(int i=0;i&lt;5;i++)
     &#123;
         ch=getch();
         printf(&quot;%c&quot;,ch);
     &#125;
 &#125;
</code></pre>
</li>
<li><p>首先这是个连续5次的循环来实现5次停顿，等待我们输入，我们编译并运行这个程序，假设我们分别输入abcde，屏幕上显示的结果是abcde，这个abcde并不是在ch&#x3D;getch();中输出的，我们把printf(“%c”,ch);这行语句去掉，就会发现我们按5次任意键程序就结束了，但屏幕上什么都没有显示。</p>
</li>
<li><p>然后我们在把代码中的getch()换成getche()看看有什么不同，我们还是分别输入abcde，这时屏幕上显示的结果是aabbccddee，我们把printf(“%c”,ch);这行语句再去掉看看，显示的结果就是abcde了，说明程序在执行ch&#x3D;getche();这条语句的时候就把我们输入的键返回显示在屏幕上，<strong>有无回显就是它们的唯一区别。</strong></p>
</li>
<li><p>有人会说，既然是C的函数库中的，那么就应该淘汰了，我们还研究它，还用它干嘛？但是我发现还是有用着它的地方，否则我也不会在这里说这么多来耽误大家的时间。我就举个例子吧，程序如下：</p>
<pre><code>  #include&lt;stdio.h&gt;
  #include&lt;conio.h&gt;
  void main()
  &#123;
      char ch=&#39;*&#39;;
      while(ch==&#39;*&#39;)
      &#123;
          printf(&quot;\n按 * 继续循环，按其他键退出！&quot;);
          ch=getch();
      &#125;
      printf(&quot;\n退出程序！&quot;);
  &#125;
</code></pre>
</li>
<li><p>我们可以在这个循环体中添加我们想要的功能，程序中按*继续循环，其他任意键退出，而且利用getch()无回显的特性，我们不管按什么，都不会在屏幕上留下痕迹，使我们的界面达到美观效果，如果还有更好的办法实现这个功能。例子：</p>
<pre><code>  void main()
  &#123;
      char c, ch;
      c=getch();     /*从键盘上读入一个字符不回显送给字符变量c*/
      putchar(c);    /*输出该字符*/
      ch=getche();   /*从键盘上带回显的读入一个字符送给字符变量ch*/
      putchar(ch);
      printf(&quot;/n/n&quot;);
  &#125;
</code></pre>
</li>
</ul>
<p> <em>值得注意的是前面两个函数都是从键盘读入数据！</em></p>
<h3 id="getchar"><a href="#getchar" class="headerlink" title="getchar()"></a>getchar()</h3><ul>
<li><p>还有getchar是很值得研究的：getchar()是stdio.h中的库函数，它的作用是从stdin流中读入一个字符，也就是说，如果stdin有数据的话不用输入它就可以直接读取了。而getch()和getche()是conio.h中的库函数，它的<strong>作用</strong>是从键盘接收字符。getchar带有显示。</p>
</li>
<li><p>与前面两个函数的区别在于：</p>
</li>
</ul>
<blockquote>
<p>getchar()函数等待输入直到按回车才结束（前提是缓冲区没有数据），回车前的所有输入字符都会逐个显示在屏幕上。但只有第一个字符作为函数的返回值。</p>
</blockquote>
<pre><code>    #include&lt;stdio.h&gt;
    #include&lt;conio.h&gt;
    void main()
    &#123;
        char c;
        c=getchar();   /*从键盘读入字符直到回车结束*/
               //getchar()在这里它只返回你输入字符串的第一个字符，并把返回值赋值给c
        putchar(c);    /*显示输入的第一个字符*/
        printf(&quot;\n\n&quot;);
    &#125;
</code></pre>
<ul>
<li><p>例四：呵呵，这个程序你运行一下，相信你又会有疑问了。这个就是从缓冲区中读取了例子。第一次getchar()时，确实需要人工的输入，但是如果你输了多个字符，以后的getchar()再执行时就会直接从缓冲区中读取了。</p>
<pre><code>  #include&lt;stdio.h&gt;
  #include&lt;conio.h&gt;
  void main()
  &#123;
      char c;
      while ((c=getchar())!=&#39;\n&#39;)    /*每个getchar()依次读入一个字符*/
          printf(&quot;%c&quot;,c);        /*按照原样输出*/
      printf(&quot;\n\n&quot;);
  &#125;
</code></pre>
</li>
<li><p>程序运行时，首先停下来，等你输入一串字符串，<strong>输入完毕后，它把你输入的整个字符串都输出来了</strong>，咦，你不是说getchar()只返回第一个字符么，这里怎么？</p>
</li>
<li><p>因为我们输入的字符串并不是取了第一个字符就把剩下的字符串丢掉了，它还在我们的内存中，就好比，开闸放水，我们把水放到闸里去以后，开一次闸就放掉一点，开一次就放掉一点，直到放光了为止，这里开闸动作就相当于调用一次getchar()。我们输入的字符串也是这么一回事，首先我们输入的字符串是放在内存的缓冲区中的，我们调用一次getchar()就把缓冲区中里出口最近的一个字符输出，也就是最前面的一个字符输出，输出后，就把它释放掉了，但后面还有字符串，所以我们就用循环把最前面的一个字符一个个的在内存中释放掉，直到不满足循环条件退出为止。</p>
</li>
<li><p>例子中循环条件里的’\n’实际上就是你输入字符串后的回车符，所以意思就是说，直到遇到回车符才结束循环，而getchar()函数就是等待输入（或缓冲区中的数据）直到按回车才结束，所以实现了整个字符串的输出。当然，我们也可以把循环条件改一下，比如while ((c&#x3D;getchar())!&#x3D;’a’)，什么意思呢，意思就是遇到字符’a’就停止循环，当然意思是如果你输入“12345a213123\n”那么只会输出到a，结果是12345a。</p>
</li>
<li><p>再次<strong>注意</strong>：用getchar()它是从“流”中间去读取，所以第一个getchar()接受的是刚刚中断的流队列中即将出列的第一个字符（不限于回车符，上面举过例子了），如果流队列不为空，执行getchar()就继续放水，直到把回车符也放空为止，空了之后再在执行getchar()就停下等待你的输入了；我们用getch()为什么每次都是等待用户的输入呢？因为getch()是从键盘接收，即时的接收，并不是从stdin流中去读取数据。</p>
</li>
<li><p>补充：按键盘上的回车产生了2个字符:回车符(‘\r’)和换行符(‘\n’)。回车符’\r’(CR:carriage return:倒车）使光标回到这行的首部，换行符(‘\n’)(new line)然后再换行。</p>
</li>
<li><p><strong>所以当输入字符’w’,并按下回车键以后。首先得到回车符。那个getchar函数结束了。 但是还存在一个换行符。所以如果用getchar()来做判断的时候。最好再写一次getchar()清除缓冲区的’&#x2F;n’.</strong></p>
</li>
</ul>
<h3 id="如何清空输入缓冲区的内容？"><a href="#如何清空输入缓冲区的内容？" class="headerlink" title="如何清空输入缓冲区的内容？"></a>如何清空输入缓冲区的内容？</h3><ul>
<li><p>如果我想让getchar()每次都能够等待用户输入的话就要清空缓冲区，下面就介绍方法（不同平台）</p>
</li>
<li><p>C标准规定 fflush()函数是用来刷新输出（stdout）缓存的。对于输入（stdin），它是没有定义的。但是有些编译器也定义了 fflush( stdin )的实现，比如微软的VC。其它编译器是否也定义了 fflush( stdin )的实现应当查找它的手册。GCC编译器没有定义它的实现，所以不能使用 fflush( stdin )来刷新输入缓存。</p>
</li>
<li><p>对于没有定义 fflush( stdin )的编译器，可以使用 fgets()函数来代替它（比用 getchar()、scanf()等函数通用性好）。可以这样忽略输入流中留下的回车等其它输入，从而使下一次的输入总保持一个“干净”的状态。（这个是任何平台下都可以的）</p>
<pre><code>  // ...
  char sbuf[1024];
  // ...
  fgets( sbuf, 1024, stdin );
  // ...
</code></pre>
</li>
<li><p>在windows 的vc下面就可以这样了</p>
<pre><code>  for(int i=0;i&lt;10;++i)
  &#123;
         char ch=getchar();
         fflush(stdin); //每次都会有等待状态了
  &#125;
</code></pre>
</li>
</ul>
<h3 id="运用实例"><a href="#运用实例" class="headerlink" title="运用实例"></a>运用实例</h3><pre><code>    //从键盘输入一些字符，逐个把它们送到磁盘上去，直到输入一个&quot;#&quot;为止

    #include &lt;stdio.h&gt;
    #include &lt;stdlib.h&gt;
    void main()
    &#123;
        FILE *fp;
        char ch,filename[10];
        scanf(&quot;%s&quot;,filename);
        if((fp=fopen(filename,&#39;w&#39;))==NULL)
        &#123;
            printf(&quot;cannnot open file\n&quot;);
            exit(0);   /* 终止程序 */
        &#125;
        ch=getchar();   /* 此语句用来接收在执行scanf语句时最后输入的回车符 */
        ch=getchar( );   /* 接收输入的第一个字符 */
        while(ch!=&#39;#&#39;)
        &#123;
            fputc(ch,fp);
            putchar(ch);
            ch=getchar();
        &#125;
        putchar(10);  /*向屏幕输出一个换行符 */
        fclose(fp);
    &#125;
</code></pre>
<ul>
<li>运行情况如下：</li>
</ul>
<blockquote>
<p>file1.c↙             (输入磁盘文件名)<br>computer and c#↙     (输入一个字符串)<br>computer and c        (输出一个字符串)</p>
</blockquote>
]]></content>
      <categories>
        <category>程序设计</category>
        <category>C</category>
      </categories>
      <tags>
        <tag>输入输出</tag>
        <tag>getch</tag>
      </tags>
  </entry>
  <entry>
    <title>IPC---共享内存</title>
    <url>/post/a83ba476.html</url>
    <content><![CDATA[<p>进程间通信的一种方式，多个进程共享一段内存，即“<code>共享内存</code>”。与其他的ipc方式（如：pipe，fifo，messages）相比少copy一次内存</p>
<span id="more"></span>

<h2 id="共享内存接口函数"><a href="#共享内存接口函数" class="headerlink" title="共享内存接口函数"></a>共享内存接口函数</h2><h3 id="shmget"><a href="#shmget" class="headerlink" title="shmget"></a>shmget</h3><p>创建新的，或者获取已有的共享内存</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">shmget</span><span class="params">(<span class="type">key_t</span> key, <span class="type">size_t</span> size, <span class="type">int</span> shmflg)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>key</code>: 类似共享内存的标签,如果key值没有对应任何共享内存,则创建一个新的共享内存；如果已存在,则直接使用创建好的共享内存<blockquote>
<p>由<code>ftok</code>生成的key标识，标识系统的唯一IPC资源</p>
</blockquote>
</li>
<li>返回值: 返回共享内存的标识符，用于后续对该共享内存的操作</li>
</ul>
<h3 id="shmat"><a href="#shmat" class="headerlink" title="shmat"></a>shmat</h3><p>将shmid所指向的共享内存空间映射到进程空间（虚拟内存空间），并返回影射后的起始地址（虚拟地址）。有了这个地址后，就可以通过这个地址对共享内存进行读写操作。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">shmat</span><span class="params">(<span class="type">int</span> shmid, <span class="type">const</span> <span class="type">void</span> *shmaddr, <span class="type">int</span> shmflg)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">shmdt</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *shmaddr)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="shmctl"><a href="#shmctl" class="headerlink" title="shmctl"></a>shmctl</h3><p>取消建立的映射</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">shmctl</span><span class="params">(<span class="type">int</span> shmid, <span class="type">int</span> cmd, <span class="keyword">struct</span> shmid_ds *buf)</span>;</span><br></pre></td></tr></table></figure>

<h2 id="共享内存的使用步骤"><a href="#共享内存的使用步骤" class="headerlink" title="共享内存的使用步骤"></a>共享内存的使用步骤</h2><ul>
<li>进程调用shmget函数创建新的或获取已有共享内存</li>
<li>进程调用shmat函数，将物理内存映射到自己的进程空间，说白了就是让虚拟地址和真实物理地址建议一一对应的映射关系。</li>
<li>shmdt函数，取消映射</li>
<li>调用shmctl函数释放开辟的那片物理内存空间和消息队列的msgctl的功能是一样的，只不过这个是共享内存的。</li>
</ul>
<h2 id="共享内存的删除"><a href="#共享内存的删除" class="headerlink" title="共享内存的删除"></a>共享内存的删除</h2><ol>
<li>重启OS，很麻烦，服务器也不是随随便便就让你去重启的。</li>
<li>进程结束时，调用相应的API来删除</li>
<li>使用ipcrm命令删除</li>
</ol>
<h2 id="查看当前系统中的共享内存"><a href="#查看当前系统中的共享内存" class="headerlink" title="查看当前系统中的共享内存"></a>查看当前系统中的共享内存</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ipcs -m</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjQ4NzUxL2FydGljbGUvZGV0YWlscy8xMDQ4MzYwMDU=">共享内存详解（本机IPC）【linux】<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2d1b3BpbmcxNi9hcnRpY2xlL2RldGFpbHMvNjU4NDA1OA==">共享内存函数（shmget、shmat、shmdt、shmctl）及其范例<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>程序设计</category>
        <category>C</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>ipc</tag>
        <tag>共享内存</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux系统应用层的内存申请--memory</title>
    <url>/post/9412.html</url>
    <content><![CDATA[<p>在linux系统编程中常见的内存申请方式和其特性，<code>malloc</code>，<code>calloc</code>, <code>realloc</code></p>
<span id="more"></span>

<h2 id="malloc"><a href="#malloc" class="headerlink" title="malloc"></a>malloc</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">void</span> *<span class="title function_">malloc</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> num_bytes)</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>功能： 分配长度为num_bytes字节的内存块</li>
<li>返回值： 如果分配成功则返回指向被分配内存的指针(此存储区中的<code>初始值不确定</code>)，否则返回空指针NULL。</li>
</ul>
</blockquote>
<p>函数的工作机制</p>
<p>malloc函数的实质体现在，它有一个将可用的内存块连接为一个长长的列表的所谓空闲链表。调用malloc函数时，它沿连接表寻找一个大到足以满足用户请求所需要的内存块。然后，将该内存块一分为二（一块的大小与用户请求的大小相等，另一块的大小就是剩下的字节）。接下来，将分配给用户的那块内存传给用户，并将剩下的那块（如果有的话）返回到连接表上。</p>
<p>调用free函数时，它将用户释放的内存块连接到空闲链上。到最后，空闲链会被切成很多的小内存片段，如果这时用户申请一个大的内存片段，那么空闲链上可能没有可以满足用户要求的片段了。于是，malloc函数请求延时，并开始在空闲链上翻箱倒柜地检查各内存片段，对它们进行整理，将相邻的小空闲块合并成较大的内存块。如果无法获得符合要求的内存块，malloc函数会返回NULL指针，因此在调用malloc动态申请内存块时，一定要进行返回值的判断。</p>
<p>Linux Libc6采用的机制是在free的时候试图整合相邻的碎片，使其合并成为一个较大的free空间。</p>
<h2 id="calloc"><a href="#calloc" class="headerlink" title="calloc"></a>calloc</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">calloc</span><span class="params">(<span class="type">unsigned</span> n,<span class="type">unsigned</span> size)</span>；</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>功能： 在内存的动态存储区中分配n个长度为size的内存空间，并初始化为<code>0</code></li>
<li>返回值： 函数返回一个指向分配起始地址的指针；如果分配不成功，返回NULL。</li>
</ul>
</blockquote>
<h3 id="malloc的区别"><a href="#malloc的区别" class="headerlink" title="malloc的区别"></a>malloc的区别</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ansidecl.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stddef.h&gt;</span></span></span><br><span class="line"><span class="comment">/* For systems with larger pointers than ints, this must be declared.  */</span></span><br><span class="line">PTR <span class="title function_">malloc</span> <span class="params">(<span class="type">size_t</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">bzero</span> <span class="params">(PTR, <span class="type">size_t</span>)</span>;</span><br><span class="line">PTR</span><br><span class="line"><span class="title function_">calloc</span> <span class="params">(<span class="type">size_t</span> nelem, <span class="type">size_t</span> elsize)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">register</span> PTR ptr;</span><br><span class="line">  <span class="keyword">if</span> (nelem == <span class="number">0</span> || elsize == <span class="number">0</span>)</span><br><span class="line">    nelem = elsize = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  ptr = <span class="built_in">malloc</span> (nelem * elsize);</span><br><span class="line">  <span class="keyword">if</span> (ptr) bzero (ptr, nelem * elsize);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9jb2RlLndvYm9xLm9yZy9nY2MvbGliaWJlcnR5L2NhbGxvYy5jLmh0bWw=">https://code.woboq.org/gcc/libiberty/calloc.c.html<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<p>只多做了初始化清零的操作<code>bzero</code></p>
<h2 id="realloc"><a href="#realloc" class="headerlink" title="realloc"></a>realloc</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">void</span> *<span class="title function_">realloc</span><span class="params">(<span class="type">void</span> *mem_address, <span class="type">unsigned</span> <span class="type">int</span> newsize)</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>功能： 先判断当前的指针是否有足够的连续空间，如果有，扩大mem_address指向的地址，并且将mem_address返回，如果空间不够，先按照newsize指定的大小分配空间，将原有数据从头到尾拷贝到新分配的内存区域，而后释放原来mem_address所指内存区域，同时返回新分配的内存区域的首地址。即重新分配存储器块的地址。</li>
<li>返回值： 如果重新分配成功则返回指向被分配内存的指针，否则返回空指针NULL</li>
</ul>
</blockquote>
<p><strong>注意</strong>：这里原始内存中的数据还是保持不变的。当内存不再使用时，应使用free()函数将内存块释放。</p>
]]></content>
      <categories>
        <category>程序设计</category>
        <category>C</category>
      </categories>
      <tags>
        <tag>内存</tag>
      </tags>
  </entry>
  <entry>
    <title>linux系统调用——vsyscall和vDSO</title>
    <url>/post/f04c402b.html</url>
    <content><![CDATA[<p><code>vsyscall</code>和<code>vDSO</code>段是用于加速Linux中某些系统调用的两种机制。</p>
<blockquote>
<p>The <code>&quot;vDSO&quot;</code> (virtual dynamic shared object) is a small shared library<br>that the kernel automatically maps into the address space of all user-space applications.  Applications usually do not need to concern themselves with these details as the vDSO is most commonly called by the C library.  This way you can code in the normal way using standard functions and the C library will take care of using any functionality that is available via the vDSO.</p>
</blockquote>
<span id="more"></span>


<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9jbG91ZC50ZW5jZW50LmNvbS9kZXZlbG9wZXIvYXJ0aWNsZS8xMDczOTA5">人见人爱的vDSO机制，如今也靠不住了<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTk5MzgzMjQvd2hhdC1hcmUtdmRzby1hbmQtdnN5c2NhbGw=">What are vdso and vsyscall?<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>程序设计</category>
        <category>C</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>syscall</tag>
      </tags>
  </entry>
  <entry>
    <title>memset设置枚举（enum）数组--错误</title>
    <url>/post/50726.html</url>
    <content><![CDATA[<p>在最近的工作中，遇到了一个<code>memset</code>的问题，由于比较特殊在此记录一下。</p>
<p>需求：申请一个enum类型的数据，进行操作均正常，但是使用memset进行统一赋值时，数组各个元素均达不到预期效果。</p>
<p>如果枚举成员值是1，通过memset设置枚举类型数组内存值其结果将变为<code>0x01010101</code>,而不是<code>0x00000001</code></p>
<span id="more"></span>

<h2 id="测试程序"><a href="#测试程序" class="headerlink" title="测试程序"></a>测试程序</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">tst</span> &#123;</span></span><br><span class="line">	a1 = <span class="number">0</span>,</span><br><span class="line">	a2,</span><br><span class="line">	a3 = <span class="number">5</span>,</span><br><span class="line">	a4,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">tst</span>* <span class="title">test</span> =</span> (<span class="keyword">enum</span> tst*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">enum</span> tst) * <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;test=%p, sizeof enum tst=%ld\n&quot;</span>, test, <span class="keyword">sizeof</span>(<span class="keyword">enum</span> tst));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">		test[i] = a2;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;test[%d]=%d\n&quot;</span>, i, test[i]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;a1=%d, a2=%d, a3=%d, a4=%d\n&quot;</span>, a1, a2, a3, a4);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;===&gt; func: %s, line: %d\n&quot;</span>, __func__, __LINE__);</span><br><span class="line">	<span class="built_in">memset</span>(test, a1, <span class="keyword">sizeof</span>(<span class="keyword">enum</span> tst) * <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;test[%d]=%d 0x%08x\n&quot;</span>, i, test[i], test[i]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;===&gt; func: %s, line: %d\n&quot;</span>, __func__, __LINE__);</span><br><span class="line">	<span class="built_in">memset</span>(test, a2, <span class="keyword">sizeof</span>(<span class="keyword">enum</span> tst) * <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;test[%d]=%d 0x%08x\n&quot;</span>, i, test[i], test[i]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;===&gt; func: %s, line: %d\n&quot;</span>, __func__, __LINE__);</span><br><span class="line">	<span class="built_in">memset</span>(test, a3, <span class="keyword">sizeof</span>(<span class="keyword">enum</span> tst) * <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;test[%d]=%d 0x%08x\n&quot;</span>, i, test[i], test[i]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;===&gt; func: %s, line: %d\n&quot;</span>, __func__, __LINE__);</span><br><span class="line">	<span class="built_in">memset</span>(test, a4, <span class="keyword">sizeof</span>(<span class="keyword">enum</span> tst) * <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;test[%d]=%d 0x%08x\n&quot;</span>, i, test[i], test[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">free</span>(test);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="运行结果："><a href="#运行结果：" class="headerlink" title="运行结果："></a>运行结果：</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">test=0x7fffce4d3260, sizeof enum tst=4</span><br><span class="line">test[0]=1</span><br><span class="line">test[1]=1</span><br><span class="line">test[2]=1</span><br><span class="line">test[3]=1</span><br><span class="line">test[4]=1</span><br><span class="line">test[5]=1</span><br><span class="line">test[6]=1</span><br><span class="line">test[7]=1</span><br><span class="line">test[8]=1</span><br><span class="line">test[9]=1</span><br><span class="line">a1=0, a2=1, a3=5, a4=6</span><br><span class="line">===&gt; func: main, line: 37</span><br><span class="line">test[0]=0 0x00000000</span><br><span class="line">test[1]=0 0x00000000</span><br><span class="line">test[2]=0 0x00000000</span><br><span class="line">test[3]=0 0x00000000</span><br><span class="line">test[4]=0 0x00000000</span><br><span class="line">test[5]=0 0x00000000</span><br><span class="line">test[6]=0 0x00000000</span><br><span class="line">test[7]=0 0x00000000</span><br><span class="line">test[8]=0 0x00000000</span><br><span class="line">test[9]=0 0x00000000</span><br><span class="line">===&gt; func: main, line: 44</span><br><span class="line">test[0]=16843009 0x01010101</span><br><span class="line">test[1]=16843009 0x01010101</span><br><span class="line">test[2]=16843009 0x01010101</span><br><span class="line">test[3]=16843009 0x01010101</span><br><span class="line">test[4]=16843009 0x01010101</span><br><span class="line">test[5]=16843009 0x01010101</span><br><span class="line">test[6]=16843009 0x01010101</span><br><span class="line">test[7]=16843009 0x01010101</span><br><span class="line">test[8]=16843009 0x01010101</span><br><span class="line">test[9]=16843009 0x01010101</span><br><span class="line">===&gt; func: main, line: 51</span><br><span class="line">test[0]=84215045 0x05050505</span><br><span class="line">test[1]=84215045 0x05050505</span><br><span class="line">test[2]=84215045 0x05050505</span><br><span class="line">test[3]=84215045 0x05050505</span><br><span class="line">test[4]=84215045 0x05050505</span><br><span class="line">test[5]=84215045 0x05050505</span><br><span class="line">test[6]=84215045 0x05050505</span><br><span class="line">test[7]=84215045 0x05050505</span><br><span class="line">test[8]=84215045 0x05050505</span><br><span class="line">test[9]=84215045 0x05050505</span><br><span class="line">===&gt; func: main, line: 58</span><br><span class="line">test[0]=101058054 0x06060606</span><br><span class="line">test[1]=101058054 0x06060606</span><br><span class="line">test[2]=101058054 0x06060606</span><br><span class="line">test[3]=101058054 0x06060606</span><br><span class="line">test[4]=101058054 0x06060606</span><br><span class="line">test[5]=101058054 0x06060606</span><br><span class="line">test[6]=101058054 0x06060606</span><br><span class="line">test[7]=101058054 0x06060606</span><br><span class="line">test[8]=101058054 0x06060606</span><br><span class="line">test[9]=101058054 0x06060606</span><br></pre></td></tr></table></figure>
<ul>
<li>枚举类型的大小占<code>4字节</code></li>
<li><code>memset</code>后所有的内存值，将别设置为枚举成员的值的十六进制，但是只占1字节，其中4字节全部相同</li>
<li>测试如果枚举类型成员的值大于256（0x400），设置的内存值将是其底8位</li>
</ul>
<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void *memset(void *s, int c, size_t n);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>The memset() function fills the first n bytes of the memory area pointed to by s with the constant byte c.</p>
</blockquote>
<p>memset函数将内存的每个字节设置为第二个参数（在第二个参数被截断之后,因为是按照<code>字节</code>进行设置）。 由于枚举（通常）是int的大小，将得到错误的结果,它唯一有效的是枚举值为<code>0</code>.</p>
<p><strong><code>memset</code>设置内存值是以字节为单位处理，因此所设置的数值范围是<code>0~0xff</code></strong></p>
]]></content>
      <categories>
        <category>程序设计</category>
        <category>C</category>
      </categories>
      <tags>
        <tag>memset</tag>
      </tags>
  </entry>
  <entry>
    <title>linux下字符串操作常用函数</title>
    <url>/post/43508.html</url>
    <content><![CDATA[<h3 id="字符串长度函数"><a href="#字符串长度函数" class="headerlink" title="字符串长度函数"></a>字符串长度函数</h3><pre><code>    size_t strlen(const char *string);
</code></pre>
<h3 id="不受限制的字符串函数"><a href="#不受限制的字符串函数" class="headerlink" title="不受限制的字符串函数"></a>不受限制的字符串函数</h3><pre><code>    char *strcpy(char *dst, const char *src);
    char *strcat(char *dst, const char *src);
    int strcmp(const char *s1, const char *s2);
</code></pre>
<!---more--->
<h3 id="字符串查找"><a href="#字符串查找" class="headerlink" title="字符串查找"></a>字符串查找</h3><pre><code>    /*
     + 功能：查找字符串s中首次出现字符c的位置
     + 说明：返回首次出现c的位置的指针，如果s中不存在c则返回NULL。
     */
    char *strchr(const char *str, int ch);
    //同上
    char *strrchr(const char *str, int ch);
</code></pre>
<h3 id="大小写字符转换函数"><a href="#大小写字符转换函数" class="headerlink" title="大小写字符转换函数"></a>大小写字符转换函数</h3><pre><code>    int tolower(int ch);
    int toupper(int ch);
</code></pre>
<h3 id="内存操作函数"><a href="#内存操作函数" class="headerlink" title="内存操作函数"></a>内存操作函数</h3><pre><code>    void *memcpy(void *dst, const void *src, size_t length);
    void *memmove(void *dst, const void *src, size_t length);
    void *memcmp(const void *a, const void *b, size_t length);
    void *memset(void *a, int ch, size_t length);
</code></pre>
<p><strong>不断更新</strong></p>
]]></content>
      <categories>
        <category>程序设计</category>
        <category>C</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>url链接中汉字乱码转utf-8和gb2312</title>
    <url>/post/34196.html</url>
    <content><![CDATA[<p>在使用URL向服务器提交数据的时候，如果我们提交的数据中存在汉字，就会出现下列情况<br><span class="exturl" data-url="aHR0cDovLzE5Mi4xNjguMTEuMjIvY2dpLWJpbi9zZXJpYWwuY2dpP3R5cGU9dGV4dCZ0ZXh0PSVFRiVCRiVCRCVFRiVCRiVCRCVFRiVCRiVCRCVFRiVCRiVCRCVDOCVBOA==">http://192.168.11.22/cgi-bin/serial.cgi?type=text&amp;text=%C9%DB%CD%FB%C8%A8<i class="fa fa-external-link-alt"></i></span></p>
<p>%C9%DB%CD%FB%C8%A8代表着什么，不是我们想要的数据，那它是什么呢？</p>
<p>去除所有%号：C9DBCDFBC8A8使用<a href="/src/%E6%B1%89%E5%AD%97%E5%86%85%E7%A0%81%E6%9F%A5%E8%AF%A2.exe_modify">汉字内码查询</a>可以看到<br><img data-src="/images/%E6%B1%89%E5%AD%97%E5%86%85%E7%A0%81.png" alt="hanzi"></p>
<!---more--->
<h3 id="将汉字内码转成一个汉字"><a href="#将汉字内码转成一个汉字" class="headerlink" title="将汉字内码转成一个汉字"></a>将汉字内码转成一个汉字</h3><ol>
<li><p>gb2312<br> 两个字节表示一个汉字</p>
<pre><code> #include &lt;stdio.h&gt;
 #include &lt;string.h&gt;

 int main(void)
 &#123;
        char str[3];

        str[0]=201; /*201为C9的十进制值*/
        str[1]=219; /*219为DB的十进制值*/
        str[2]=&#39;\0&#39;;
        printf(&quot;C9DB的汉字的值为:%s&quot;,str);
        return 0;
 &#125;
</code></pre>
</li>
</ol>
<p>注：在终端先可以正确输出‘邵’，（使用gb2312编码，在linux下输出乱码，Windows下正常输出）<br>2. utf-8<br>    三个字节表示一个汉字</p>
<h3 id="多个汉字输出"><a href="#多个汉字输出" class="headerlink" title="多个汉字输出"></a>多个汉字输出</h3><pre><code>    /*将十六进制数转为十进制*/
    int hex_to_decade(char * s)
    &#123;
        char *digits=&quot;0123456789ABCDEF&quot;;

        /*判断大小写，小写的话转为大写，达到统一*/
        if (islower (s[0]))
            s[0]=toupper(s[0]);
        if (islower (s[1]))
            s[1]=toupper(s[1]);

        return 16*(strchr(digits,s[0])-strchr(digits,&#39;0&#39;))+(strchr(digits,s[1])-strchr(digits,&#39;0&#39;));
    &#125;
    void url_to_gb_or_utf(char *get_url, char *return_gb_or_utf)
    &#123;
        int url_position;/*用来保存get_url的位置*/
        int return_position;/*用来保存解码后的字符串的位置*/
        int url_len;/*用来保存get_url的长度*/
        char tmp[2];/*保存%后面的十六进制字符*/
        url_len = strlen(get_url);
        return_position = 0;

        fprintf(stdout, &quot;length=%d\n&quot;, url_len);
        for ( url_position = 0; url_position &lt; url_len; )
        &#123;
            /*如果是%将它后面的十六进制字符考到数组里*/
            if ( get_url[url_position] == &#39;%&#39; )&#123;
                tmp[0] = get_url[url_position+1];/*第一个十六进制字符*/
                tmp[1] = get_url[url_position+2];/*第二个*/
            //  tmp[2] = &#39;\0&#39;;  **串口通信中会出现乱码，结尾必须不能有其他字符**

                url_position+= 3; /*使url_position跳到的下一个%*/
                /*将十六进制数转为十进制后考入要返回的数组里*/

                return_gb_or_utf[return_position] = hex_to_decade(tmp);
                fprintf(stdout, &quot;------%d\n&quot;, return_gb_or_utf[return_position] );
            &#125;
            /*如果不是特殊字符，如英文，数字那么直接返回*/
            else&#123;
                return_gb_or_utf[return_position] = get_url[url_position];
                url_position++;
            &#125;
            return_position++;
        &#125;

        return_gb_or_utf[return_position] = 0;
    &#125;
</code></pre>
<p>***<em><strong>十六进制转十进制可使用：</strong>strtol函数</em>*</p>
<h3 id="汉字编码"><a href="#汉字编码" class="headerlink" title="汉字编码"></a>汉字编码</h3><ol>
<li>UTF-8：Unicode TransformationFormat-8bit，允许含BOM，但通常不含BOM。是用以解决国际上字符的一种多字节编码，它对英文使用8位（即一个字节），中文使用24为（三个字节）来编码。</li>
<li>GBK是国家标准GB2312基础上扩容后兼容GB2312的标准。GBK的文字编码是用双字节来表示的，即不论中、英文字符均使用双字节来表示，为了区分中文，将其最高位都设定成1。GBK包含全部中文字符，是国家编码，通用性比UTF8差，不过UTF8占用的数据库比GBD大。</li>
</ol>
]]></content>
      <categories>
        <category>程序设计</category>
        <category>C</category>
      </categories>
      <tags>
        <tag>编码</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>动态分配二维数组</title>
    <url>/post/42179.html</url>
    <content><![CDATA[<h3 id="动态创建"><a href="#动态创建" class="headerlink" title="动态创建"></a>动态创建</h3><ul>
<li><p>动态数组是指在声明时没有确定数组大小的数组；当要用它时，C语言中用malloc语句重新指出数组的大小。使用动态数组的优点是可以根据用户需要，有效利用存储空间。</p>
</li>
<li><p>有时根据题意需得根据输入的二维数来动态的创建二维数组，那么此时就不能想以前一样直接定义多少行多少列了。因为不知道行列多少，假如设定太大浪费空间，申请太小完成不了程序的数据存储。因此需要合理的开辟二维空间。</p>
<span id="more"></span>
<h3 id="动态数组与静态数组的对比"><a href="#动态数组与静态数组的对比" class="headerlink" title="动态数组与静态数组的对比"></a>动态数组与静态数组的对比</h3></li>
</ul>
<blockquote>
<p>对于静态数组，其创建非常方便，使用完也无需释放，要引用也简单，但是创建后无法改变其大小是其致命弱点！<br>对于动态数组，其创建麻烦，使用完必须由程序员自己释放，否则严重会引起内存泄露。但其使用非常灵活，能根据程序需要动态分配大小。</p>
</blockquote>
<h3 id="遵循原则"><a href="#遵循原则" class="headerlink" title="遵循原则"></a>遵循原则</h3><blockquote>
<p>申请的时候从外层往里层，逐层申请；<br>释放的时候从里层往外层，逐层释放。</p>
</blockquote>
<h3 id="构建所需指针"><a href="#构建所需指针" class="headerlink" title="构建所需指针"></a>构建所需指针</h3><blockquote>
<p>对于构建一维动态数组，需要一维指针；<br>对于二维，则需要一维，二维指针；<br>三维需要一，二，三维指针；<br>依此类推。</p>
</blockquote>
<ul>
<li>以下的两种方法都可以建立动态的二维空间数组。</li>
</ul>
<h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h3><ul>
<li><p>使用指针动态分配</p>
<pre><code>  int i,j;
  int r,c;
  int **a;  //创建二维指针来指向数组
  scanf(&quot;%d%d&quot;,&amp;r,&amp;c);
  a  = (int **) malloc(sizeof(int *) * r);//注意申请的指针格式
  for (j=0;j&lt;r;j++)&#123;
  a[j] = (int *) malloc(sizeof(int) * c);
  ……
  ……
  &#125;
</code></pre>
</li>
<li><p>释放为：</p>
<pre><code>  for (j=0;j&lt;r;j++)
   free(a[j]);//先释放一维指针
   free(a);//最后释放我二维指针
</code></pre>
</li>
</ul>
<h3 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h3><ul>
<li><p>建立链表来存放二维数组。</p>
<pre><code>  typedef struct arr
  &#123;
      int *array;
  &#125;arr;
  main()
  &#123;
      arr *array1;
      int rowx,rowy;
      int i,j,k=0;
      scanf(&quot;%d %d&quot;,&amp;rowx,&amp;rowy);
      array1=(arr *)malloc(sizeof(arr)*rowx);//创建链表数组
      for(i=0;i&lt;rowx;i++)
                  //再在每一个链表中创建一维数组，这样整体就构成二维数组
          array1[i].array=(int *)malloc(sizeof(int)*rowy);
  ……
  ……
</code></pre>
</li>
<li><p>释放同上：</p>
<pre><code>  for (j=0;j&lt;rowx;j++)
   free(array1[j].array);
   free(array);

  ｝
</code></pre>
</li>
</ul>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><pre><code>#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;

int main()
&#123;
    int n1,n2,n3;
    int ***array;
    int i,j,k;

    puts(&quot;输入一维长度:&quot;);
    scanf(&quot;%d&quot;,&amp;n1);
    puts(&quot;输入二维长度:&quot;);
    scanf(&quot;%d&quot;,&amp;n2);
    puts(&quot;输入三维长度:&quot;);
    scanf(&quot;%d&quot;,&amp;n3);

    array=(int***)malloc(n1*sizeof(int**));//第一维
    for(i=0; i&lt;n1; i++)
    &#123;
        array[i]=(int**)malloc(n2*sizeof(int*)); //第二维
        for(j=0;j&lt;n2;j++)
        &#123;
            array[i][j]=(int*)malloc(n3*sizeof(int)); //第三维
            for(k=0;k&lt;n3;k++)
            &#123;
                array[i][j][k]=i+j+k+1;
                printf(&quot;%d\t&quot;,array[i][j][k]);
            &#125;
            puts(&quot;&quot;);
        &#125;
        puts(&quot;&quot;);
    &#125;
    for(i=0;i&lt;n1;i++)
    &#123;
        for(j=0;j&lt;n2;j++)
        &#123;
            free(array[i][j]);//释放第三维指针
        &#125;
    &#125;
    for(i=0;i&lt;n1;i++)
    &#123;
        free(array[i]);//释放第二维指针
    &#125;
    free(array);//释放第一维指针

    return 0;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>程序设计</category>
        <category>C</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>动态分配</tag>
      </tags>
  </entry>
  <entry>
    <title>字节序</title>
    <url>/post/79aef41.html</url>
    <content><![CDATA[<p>字节序有<code>大端字节序</code>与<code>小端字节序</code>,目前X86、arm、mips基本都使用<code>小端字节序</code>。但是在网络数据传输时，使用<code>大端字节序</code>。</p>
<blockquote>
<p>TCP&#x2F;IP协议，RFC1700规定使用“大端”字节序为网络字节序，其他不使用大端的计算机要注意了，发送数据的时候必须要将自己的主机字节序转换为网络字节序（即“大端”字节序），接收到的数据再转换为自己的主机字节序。这样就与CPU、操作系统无关了，实现了网络通信的标准化</p>
</blockquote>
<span id="more"></span>

<p>大小端字节序转换</p>
<h2 id="32bit字节转换"><a href="#32bit字节转换" class="headerlink" title="32bit字节转换"></a>32bit字节转换</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">htonl</span><span class="params">(<span class="type">uint32_t</span> hostlong)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">htons</span><span class="params">(<span class="type">uint16_t</span> hostshort)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">ntohl</span><span class="params">(<span class="type">uint32_t</span> netlong)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">ntohs</span><span class="params">(<span class="type">uint16_t</span> netshort)</span>;</span><br></pre></td></tr></table></figure>

<h2 id="64bit字节转换"><a href="#64bit字节转换" class="headerlink" title="64bit字节转换"></a>64bit字节转换</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;endian.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">htobe16</span><span class="params">(<span class="type">uint16_t</span> host_16bits)</span>;</span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">htole16</span><span class="params">(<span class="type">uint16_t</span> host_16bits)</span>;</span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">be16toh</span><span class="params">(<span class="type">uint16_t</span> big_endian_16bits)</span>;</span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">le16toh</span><span class="params">(<span class="type">uint16_t</span> little_endian_16bits)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">htobe32</span><span class="params">(<span class="type">uint32_t</span> host_32bits)</span>;</span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">htole32</span><span class="params">(<span class="type">uint32_t</span> host_32bits)</span>;</span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">be32toh</span><span class="params">(<span class="type">uint32_t</span> big_endian_32bits)</span>;</span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">le32toh</span><span class="params">(<span class="type">uint32_t</span> little_endian_32bits)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">htobe64</span><span class="params">(<span class="type">uint64_t</span> host_64bits)</span>;</span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">htole64</span><span class="params">(<span class="type">uint64_t</span> host_64bits)</span>;</span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">be64toh</span><span class="params">(<span class="type">uint64_t</span> big_endian_64bits)</span>;</span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">le64toh</span><span class="params">(<span class="type">uint64_t</span> little_endian_64bits)</span>;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>程序设计</category>
        <category>C</category>
      </categories>
      <tags>
        <tag>网络</tag>
        <tag>字节序</tag>
      </tags>
  </entry>
  <entry>
    <title>用户空间互斥锁-mutex</title>
    <url>/post/f9e82db2.html</url>
    <content><![CDATA[<p>在linux系统中多线程的资源同步使用互斥锁pthread_mutex_t，同时它也可以用于多进程之间的资源同步。</p>
<p>互斥锁的使用过程中，主要有pthread_mutex_init，pthread_mutex_destory，pthread_mutex_lock，pthread_mutex_unlock这几个函数以完成锁的初始化，锁的销毁，上锁和释放锁操作。</p>
<span id="more"></span>

<ul>
<li>头文件</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;pthread.h&gt;</span><br></pre></td></tr></table></figure>

<p>mutex锁同步：</p>
<table>
<thead>
<tr>
<th align="left">Attribute</th>
<th align="left">Default value</th>
<th align="left">Supported values</th>
</tr>
</thead>
<tbody><tr>
<td align="left">pshared</td>
<td align="left"><strong>PTHREAD_PROCESS_PRIVATE</strong></td>
<td align="left"><strong>PTHREAD_PROCESS_PRIVATE or PTHREAD_PROCESS_SHARED</strong></td>
</tr>
<tr>
<td align="left">kind (non portable)</td>
<td align="left"><strong>PTHREAD_MUTEX_NONRECURSIVE_NP</strong></td>
<td align="left"><strong>PTHREAD_MUTEX_NONRECURSIVE_NP</strong> or <strong>PTHREAD_MUTEX_RECURSIVE_NP</strong></td>
</tr>
<tr>
<td align="left">name (non portable)</td>
<td align="left"><strong>PTHREAD_DEFAULT_MUTEX_NAME_NP</strong> “QP0WMTX UNNAMED”</td>
<td align="left">Any name that is 15 characters or less. If not terminated by a null character, name is truncated to 15 characters.</td>
</tr>
<tr>
<td align="left">type</td>
<td align="left"><strong>PTHREAD_MUTEX_DEFAULT</strong> (<strong>PTHREAD_MUTEX_NORMAL</strong>)</td>
<td align="left"><strong>PTHREAD_MUTEX_DEFAULT</strong> or <strong>PTHREAD_MUTEX_NORMAL</strong> or <strong>PTHREAD_MUTEX_RECURSIVE</strong> or <strong>PTHREAD_MUTEX_ERRORCHECK</strong> or <strong>PTHREAD_MUTEX_OWNERTERM_NP</strong>  The <strong>PTHREAD_MUTEX_OWNERTERM_NP</strong> attribute value is non portable.</td>
</tr>
</tbody></table>
<h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><h3 id="创建锁"><a href="#创建锁" class="headerlink" title="创建锁"></a>创建锁</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">mutex_handle <span class="title function_">create_mutex</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">pthread_mutex_t</span>* pmutex = (mutex_handle)Rtos_Malloc(<span class="keyword">sizeof</span>(<span class="type">pthread_mutex_t</span>));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(pmutex) &#123;</span><br><span class="line">    <span class="type">pthread_mutexattr_t</span> mutexAttr;</span><br><span class="line">    pthread_mutexattr_init(&amp;mutexAttr);</span><br><span class="line">    pthread_mutexattr_settype(&amp;mutexAttr, PTHREAD_MUTEX_RECURSIVE);</span><br><span class="line">    pthread_mutex_init(pmutex, &amp;mutexAttr);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (mutex_handle)pmutex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>静态的初始化锁:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">pthread_mutex_t</span> mutex = PTHREAD_MUTEX_INITIALIZER;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="销毁锁"><a href="#销毁锁" class="headerlink" title="销毁锁"></a>销毁锁</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">delete_mutex</span><span class="params">(mutex_handle mutex)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">pthread_mutex_t</span>* pmutex = (<span class="type">pthread_mutex_t</span>*)mutex;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(pmutex) &#123;</span><br><span class="line">    pthread_mutex_destroy(pmutex);</span><br><span class="line">    Rtos_Free(pmutex);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="上锁"><a href="#上锁" class="headerlink" title="上锁"></a>上锁</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">get_mutex</span><span class="params">(mutex_handle mutex)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">pthread_mutex_t</span>* pmutex = (<span class="type">pthread_mutex_t</span>*)mutex;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(!pmutex)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(pthread_mutex_lock(pmutex) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="释放锁"><a href="#释放锁" class="headerlink" title="释放锁"></a>释放锁</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">release_mutex</span><span class="params">(mutex_handle mutex)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(!mutex)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>((pthread_mutex_unlock((<span class="type">pthread_mutex_t</span>*)mutex)) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="锁的属性"><a href="#锁的属性" class="headerlink" title="锁的属性"></a>锁的属性</h2><p><code>pthread_mutexattr_init(pthread_mutexattr_t *mattr)</code>接口初始化锁的属性，然后可以通过其他接口可以设置锁的不同属性。</p>
<h3 id="互斥锁的范围"><a href="#互斥锁的范围" class="headerlink" title="互斥锁的范围"></a>互斥锁的范围</h3><ul>
<li><code>PTHREAD_PROCESS_SHARED</code>: 进程间同步，但是由这个属性对象创建的互斥锁将被保存在共享内存中，可以被多个进程中的线程共享。</li>
<li><code>PTHREAD_PROCESS_PRIVATE</code>：线程间同步，只有和创建这个互斥锁的线程在同一个进程中的线程才能访问这个互斥锁。</li>
</ul>
<p>操作接口：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">pthread_mutexattr_setpshared(<span class="type">pthread_mutexattr_t</span> *mattr, <span class="type">int</span> pshared)</span><br><span class="line">pthread_mutexattr_getshared(<span class="type">pthread_mutexattr_t</span> *mattr,<span class="type">int</span> *pshared)</span><br></pre></td></tr></table></figure>

<h3 id="锁的类型"><a href="#锁的类型" class="headerlink" title="锁的类型"></a>锁的类型</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  PTHREAD_MUTEX_TIMED_NP,</span><br><span class="line">  PTHREAD_MUTEX_RECURSIVE_NP,</span><br><span class="line">  PTHREAD_MUTEX_ERRORCHECK_NP,</span><br><span class="line">  PTHREAD_MUTEX_ADAPTIVE_NP</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined __USE_UNIX98 || defined __USE_XOPEN2K8</span></span><br><span class="line">  ,</span><br><span class="line">  PTHREAD_MUTEX_NORMAL = PTHREAD_MUTEX_TIMED_NP,</span><br><span class="line">  PTHREAD_MUTEX_RECURSIVE = PTHREAD_MUTEX_RECURSIVE_NP,</span><br><span class="line">  PTHREAD_MUTEX_ERRORCHECK = PTHREAD_MUTEX_ERRORCHECK_NP,</span><br><span class="line">  PTHREAD_MUTEX_DEFAULT = PTHREAD_MUTEX_NORMAL</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __USE_GNU</span></span><br><span class="line">  <span class="comment">/* For compatibility.  */</span></span><br><span class="line">  , PTHREAD_MUTEX_FAST_NP = PTHREAD_MUTEX_TIMED_NP</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>PTHREAD_MUTEX_TIMED_NP</code>，这是缺省值，也就是普通锁。当一个线程加锁以后，其余请求锁的线程将形成一个等待队列，并在解锁后按优先级获得锁。这种锁策略保证了资源分配的公平性。</li>
<li><code>PTHREAD_MUTEX_RECURSIVE_NP</code>，嵌套锁，允许同一个线程对同一个锁成功获得多次，并通过多次unlock解锁。如果是不同线程请求，则在加锁线程解锁时重新竞争。</li>
<li><code>PTHREAD_MUTEX_ERRORCHECK_NP</code>，检错锁，如果同一个线程请求同一个锁，则返回EDEADLK，否则与PTHREAD_MUTEX_TIMED_NP类型动作相同。这样就保证当不允许多次加锁时不会出现最简单情况下的死锁。</li>
<li><code>PTHREAD_MUTEX_ADAPTIVE_NP</code>，适应锁，动作最简单的锁类型，仅等待解锁后重新竞争。</li>
</ul>
<p>操作接口：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">pthread_mutexattr_settype(<span class="type">pthread_mutexattr_t</span> *attr , <span class="type">int</span> type)</span><br><span class="line">pthread_mutexattr_gettype(<span class="type">pthread_mutexattr_t</span> *attr , <span class="type">int</span> *type)</span><br></pre></td></tr></table></figure>

<h2 id="多进程锁"><a href="#多进程锁" class="headerlink" title="多进程锁"></a>多进程锁</h2><p>在多进程中互斥锁的使用，与多线程基本一致，不过需要注意以下几点：</p>
<ol>
<li>初始化互斥锁时，需要将其属性设置为<code>PTHREAD_PROCESS_SHARED</code></li>
<li>初始化锁的结构<code>pthread_mutex_t</code>,必需多个进程均可以访问，否则无法达到临界区同步的目的，一般使用共享内存共享pthread_mutex_t变量。</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2tpbmdtYXgyNi9hcnRpY2xlL2RldGFpbHMvNTMzODA2NQ==">互斥锁属性PTHREAD_MUTEX_RECURSIVE<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9wdWJzLm9wZW5ncm91cC5vcmcvb25saW5lcHVicy83OTA4Nzk5L3hzaC9wdGhyZWFkLmguaHRtbA==">pthread.h - threads<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuaWJtLmNvbS9kb2NzL2VuL2kvNy4yP3RvcGljPWNhdGVnb3J5LXB0aHJlYWQtYXBpcw==">Pthread APIs<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>程序设计</category>
        <category>C</category>
      </categories>
      <tags>
        <tag>mutex</tag>
      </tags>
  </entry>
  <entry>
    <title>boost asio for anbox</title>
    <url>/post/31474.html</url>
    <content><![CDATA[<p>Boost.Asio是用于<code>网络</code>和<code>低层IO</code>编程的跨平台C++库,为开发者提供了C++环境下稳定的<code>异步模型</code>。</p>
<span id="more"></span>

<h2 id="IO模型"><a href="#IO模型" class="headerlink" title="IO模型"></a>IO模型</h2><p><code>io_service</code>对象是asio框架中的<code>调度器</code>，所有异步io事件都是通过它来分发处理的（io对象的构造函数中都需要传入一个io_service对象）, 其提供着是一个<code>生产者消费者模型</code>。<br><code>io_service</code>类在多线程编程模型中提供了任务队列和任务分发功能,最常用的接口：<code>run</code>、<code>post</code>、<code>stop</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">boost::asio::io_service io_service;</span><br><span class="line">boost::asio::ip::<span class="function">tcp::socket <span class="title">socket</span><span class="params">(io_service)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="同步IO处理"><a href="#同步IO处理" class="headerlink" title="同步IO处理"></a>同步IO处理</h3><p><img data-src="/images/2020/02/asio_socket_sync.png" alt="asio_socket_sync"></p>
<ol>
<li>应用程序调用IO对象成员函数执行IO操作</li>
<li>IO对象向io_service 提出请求.</li>
<li>io_service 调用操作系统的功能<code>执行连接</code>操作.</li>
<li>操作系统向io_service 返回执行结果.</li>
<li>io_service将错误的操作结果翻译为boost::system::error_code类型，再传递给IO对象.</li>
<li>如果操作失败,IO对象抛出boost::system::system_error类型的异常.</li>
</ol>
<h3 id="异步IO处理"><a href="#异步IO处理" class="headerlink" title="异步IO处理"></a>异步IO处理</h3><p><img data-src="/images/2020/02/asio_socket_async.png" alt="asio_socket_async"></p>
<ol>
<li>应用程序调用IO对象成员函数执行IO操作</li>
<li>IO对象请求io_service的服务</li>
<li>io_service 通知操作系统其需要开始一个<code>异步连接</code>操作.</li>
<li>操作系统指示连接操作完成, io_service从队列中获取操作结果</li>
<li>应用程序必须调用io_service::run()以便于接收结果</li>
<li>调用io_service::run()后,io_service返回一个操作结果,并将其翻译为error_code,传递到事件回调函数中</li>
</ol>
<h3 id="常用接口"><a href="#常用接口" class="headerlink" title="常用接口"></a>常用接口</h3><ul>
<li>post</li>
</ul>
<p>post用于发布io事件，如timer，socket读写等，一般由asio框架相应对象调用，无需我们显式调用。</p>
<ul>
<li>run</li>
</ul>
<p>run用于<code>监听io事件</code>响应，并执行响应回调，对于异步io操作需要在代码中显式调用，对于同步io操作则由io对象隐式调用（并不是run函数，不过也是等待io事件）。</p>
<h2 id="boost-asio-io-service"><a href="#boost-asio-io-service" class="headerlink" title="boost::asio::io_service"></a>boost::asio::io_service</h2><p><code>io_service</code>类在多线程编程里面提供了<code>任务队列</code>和<code>任务分发</code>功能，在socket、io编程里主要作为一个事件驱动器(完成端口、select、poll、epoll等)。</p>
<p><img data-src="/images/2020/02/asio_io_service.png" alt="asio_io_service"></p>
<blockquote>
<p><code>io_service</code>都一个公有任务队列，和多个私有任务队列，公有队列由各个线程共享，私有队列则是每个线程独享</p>
</blockquote>
<ol>
<li>调用run方法，进入主loop；</li>
<li>判断公有队列是否为空，不为空则取出任务并执行，当任务数大于1时同时唤醒其他空闲线程；</li>
<li>任务执行结束，把各个线程的私有队里面的任务移动到公有任务队列里面；</li>
<li>触发reactor，linux下面一般是<code>epoll</code>，当有事件时，把相应的事件的任务放到私有队列里。</li>
<li>当队列为空时，把当前线程加到空闲线程队列里面，同时进入wait状态，等待其他线程的唤醒（task_operation）。</li>
<li>当用户调用post时，任务是直接投递到公有队列op_queue里面。</li>
</ol>
<h2 id="Anbox-IO模型"><a href="#Anbox-IO模型" class="headerlink" title="Anbox IO模型"></a>Anbox IO模型</h2><p>Anbox 的 I&#x2F;O 模型基于 boost.asio 构建。Anbox 中所有的 I&#x2F;O 事件，在一个线程池中，通过一个<code>boost::asio::io_service</code>对象来派发并处理。Anbox 用<code>anbox::Runtime</code>类封装一个 <code>boost::asio::io_service</code>对象，并管理执行任务的<code>线程池</code>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> anbox &#123;</span><br><span class="line"><span class="comment">// We bundle our &quot;global&quot; runtime dependencies here, specifically</span></span><br><span class="line"><span class="comment">// a dispatcher to decouple multiple in-process providers from one</span></span><br><span class="line"><span class="comment">// another , forcing execution to a well known set of threads.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Runtime</span> : <span class="keyword">public</span> DoNotCopyOrMove,</span><br><span class="line">                <span class="keyword">public</span> std::enable_shared_from_this&lt;Runtime&gt; &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// Our default concurrency setup.</span></span><br><span class="line">  <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">const</span> std::<span class="type">uint32_t</span> worker_threads = <span class="number">8</span>;</span><br><span class="line">  <span class="comment">// create returns a Runtime instance with pool_size worker threads</span></span><br><span class="line">  <span class="comment">// executing the underlying service.</span></span><br><span class="line">  <span class="function"><span class="type">static</span> std::shared_ptr&lt;Runtime&gt; <span class="title">create</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      std::<span class="type">uint32_t</span> pool_size = worker_threads)</span></span>;</span><br><span class="line">  <span class="comment">// Tears down the runtime, stopping all worker threads.</span></span><br><span class="line">  ~<span class="built_in">Runtime</span>() <span class="built_in">noexcept</span>(<span class="literal">true</span>);</span><br><span class="line">  <span class="comment">// start executes the underlying io_service on a thread pool with</span></span><br><span class="line">  <span class="comment">// the size configured at creation time.</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="comment">// stop cleanly shuts down a Runtime instance.</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">stop</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="comment">// to_dispatcher_functional returns a function for integration</span></span><br><span class="line">  <span class="comment">// with components that expect a dispatcher for operation.</span></span><br><span class="line">  std::function&lt;<span class="type">void</span>(std::function&lt;<span class="type">void</span>()&gt;)&gt; <span class="built_in">to_dispatcher_functional</span>();</span><br><span class="line">  <span class="comment">// service returns the underlying boost::asio::io_service that is executed</span></span><br><span class="line">  <span class="comment">// by the Runtime.</span></span><br><span class="line">  boost::<span class="function">asio::io_service&amp; <span class="title">service</span><span class="params">()</span></span>;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// Runtime constructs a new instance, firing up pool_size</span></span><br><span class="line">  <span class="comment">// worker threads.</span></span><br><span class="line">  <span class="built_in">Runtime</span>(std::<span class="type">uint32_t</span> pool_size);</span><br><span class="line">  std::<span class="type">uint32_t</span> pool_size_;</span><br><span class="line">  boost::asio::io_service service_;</span><br><span class="line">  boost::asio::io_service::strand strand_;</span><br><span class="line">  boost::asio::io_service::work keep_alive_;</span><br><span class="line">  std::vector&lt;std::thread&gt; workers_;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;  <span class="comment">// namespace anbox</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>file: anbox&#x2F;src&#x2F;anbox&#x2F;runtime.h</p>
</blockquote>
<p><code>anbox::Runtime</code> 类封装了一个 <code>boost::asio::io_service</code> 对象及多个工作线程 <code>std::thread</code>，它还继承 <code>std::enable_shared_from_this</code> 以获得从 <code>this</code> 指针创建智能指针 <code>std::shared_ptr</code> 的能力，同时继承了 <code>DoNotCopyOrMove</code>，以禁掉类的拷贝和移动操作。</p>
<p><code>anbox::Runtime</code> 类有两大职责:</p>
<ul>
<li>一是 <code>boost::asio::io_service</code> 对象的生命周期管理；</li>
<li>二是向 <code>boost::asio::io_service</code> 中提交任务。</li>
</ul>
<p>在 <code>anbox::Runtime::start()</code> 函数中创建并启动多个线程，执行一个执行 <code>boost::asio::io_service::run()</code> 函数的函数 <code>exception_safe_run()</code>。在 <code>anbox::Runtime::stop()</code> 函数中停掉 <code>boost::asio::io_service</code> 的执行。<code>anbox::Runtime</code> 的析够函数中，还会调用 <code>stop()</code> 函数停掉 <code>boost::asio::io_service</code> 的执行。<code>anbox::Runtime</code> 的类型为 <code>boost::asio::io_service::work</code> 的成员变量 <code>keep_alive_</code> 也是用于管理 <code>boost::asio::io_service</code> 对象的生命周期的，该对象在析够时也会停掉 <code>boost::asio::io_service</code> 的执行。</p>
<p>Anbox 的 I&#x2F;O 模型可以理解为，底层有一个多路复用器或事件循环 <code>boost::asio::io_service</code>，有一个包含了 8 个线程的线程池基于此 <code>boost::asio::io_service</code> 运行，处理 I&#x2F;O 事件及其它各种类型的任务。</p>
<p>Anbox 需要处理如下这样一些网络 I&#x2F;O 过程：</p>
<ul>
<li>监听 Unix 域 Socket 接受连接。Anbox 的 SessionManager 通过 Unix 域 Socket 与 ContainerManager 进行通信，同时也通过 Unix 域 Socket 与 ContainerManager 启动的 Android 容器内的应用程序通信。首先 ContainerManager 监听在特定位置的 Unix 域 Socket 上。随后 SessionManager 监听几个位置上的 Unix 域 Socket，然后请求 ContainerManager 启动 Android 容器，并将这几个 Unix 域 Socket 映射到容器内的 <code>/dev/</code> 目录下。Android 容器启动后，一些进程，如 surfaceflinger、cameraservice 等连接这些 Unix 域 Socket，并通过这些 Unix 域 Socket 与 SessionManager 通信，进而操作宿主机的硬件设备。</li>
<li>监听 TCP Socket 接受连接。Anbox 的 SessionManager 作为容器中运行的 Android 与 ADB 进行通信的桥梁，它在与容器中运行的 Android 通过 Unix 域 Socket 通信的同时，也需要与宿主机上的 ADB 通信。SessionManager 通过 TCP 与宿主机上的 ADB 守护进程通信。如同模拟器等 Android 设备一样，SessionManager 遵从 ADB 的通信协议，在发起与 ADB 之间的 TCP 连接的同时，也需要监听一个 TCP 端口，等待 ADB 守护进程发起的连接，以完成整个 ADB 协议。</li>
<li>处理从监听的 Unix 域 Socket 接受的 Unix 域 Socket。监听的 Unix 域 Socket 接受新连接之后，需要将新创建的 Unix 域 Socket 提交给底层的 I&#x2F;O 多路复用器，并为该 Socket 提供读写等 I&#x2F;O 事件处理处理回调，以完成 Anbox 的应用逻辑。</li>
<li>处理从监听的 TCP Scoket 接受的 TCP Socket。监听的 TCP Socket 接受新连接之后，需要将新创建的 TCP Socket 提交给底层的 I&#x2F;O 多路复用器，并为该 Socket 提供读写等 I&#x2F;O 事件处理处理回调，以完成 Anbox 的应用逻辑。</li>
<li>发起一个到 TCP 服务器的连接。如前面提到的，Anbox 的 SessionManager 通过 TCP 连接与 ADB 守护进程通信，它会先发起一个到 ADB 守护进程的 TCP 连接。</li>
<li>发起一个到 Unix 域 Socket 服务的连接。Anbox 的 SessionManager 与 ContainerManager 之间通过 Unix 域 Socket 通信，SessionManager 会发起到 ContainerManager 监听的 Unix 域 Socket 服务的连接。</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><span class="exturl" data-url="aHR0cDovL2NoYXJldHRlLm5vLWlwLmNvbTo4MS9wcm9ncmFtbWluZy9kb3h5Z2VuL2Jvb3N0L2NsYXNzYm9vc3RfMV8xYXNpb18xXzFpb19fc2VydmljZV8xXzFzdHJhbmQuaHRtbA==">boost::asio::io_service::strand Class Reference<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuYm9vc3Qub3JnL2RvYy9saWJzLzFfNzJfMC9kb2MvaHRtbC9ib29zdF9hc2lvLmh0bWw=">Boost.Asio<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9tbW9hYXkuZ2l0Ym9va3MuaW8vYm9vc3QtYXNpby1jcHAtbmV0d29yay1wcm9ncmFtbWluZy1jaGluZXNlL2NvbnRlbnQvQ2hhcHRlcjEuaHRtbA==">Boost.Asio入门<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>程序设计</category>
        <category>C++</category>
      </categories>
      <tags>
        <tag>anbox</tag>
        <tag>数据传输</tag>
        <tag>c++</tag>
        <tag>asio</tag>
      </tags>
  </entry>
  <entry>
    <title>vs与gcc编译器之间的差别</title>
    <url>/post/2f341d0b.html</url>
    <content><![CDATA[<p>最近在做一些移植的工作时，相同的代码使用gcc编译全部正常。但是在windows下使用VS2019进行编译时，出现一些语法错误，主要有下面几种：</p>
<span id="more"></span>


<h2 id="“void-”-unknown-size"><a href="#“void-”-unknown-size" class="headerlink" title="“void *”: unknown size"></a>“void *”: unknown size</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">shuffle</span><span class="params">(<span class="type">void</span> *arr, <span class="type">size_t</span> n, <span class="type">size_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">memcpy</span>(arr+(i*size), swp,  size);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>void *</code>执行指针算术运算，因为void没有定义大小，进行偏移操作无法确定偏移的单位，因此出现错误提示</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">memcpy</span>((<span class="type">char</span>*)arr+(i*size), swp,  size);</span><br></pre></td></tr></table></figure>

<p><strong>注</strong>：这种修改解决了编译报错的问题，但是与gcc的编译不兼容</p>
<h2 id="small关键字"><a href="#small关键字" class="headerlink" title="small关键字"></a>small关键字</h2><blockquote>
<p>在编译的代码中定义了<code>small</code>变量名，但是其在VS中属于一个关键字,是<code>char</code>类型的别名</p>
</blockquote>
<p>在头文件<code>#include &lt;windows.h&gt;</code>中包含的<code>&lt;rpcndr.h&gt;</code>头文件中定义了<code>small</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> small char</span></span><br></pre></td></tr></table></figure>

<p>解决方法：</p>
<ol>
<li>将<code>samll</code>的定义去掉：<code>#undef small</code></li>
<li>修改代码<code>small</code>变量名</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMjExNjU4OTEvaXMtc21hbGwtYS1rZXl3b3JkLWluLWM=">Is “small” a keyword in c?<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNTg3NDIxNS93aGF0LWlzLXJwY25kci1o">What is RpcNdr.h<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>程序设计</category>
        <category>gcc</category>
      </categories>
      <tags>
        <tag>gcc</tag>
        <tag>vs</tag>
      </tags>
  </entry>
  <entry>
    <title>[转]GCC下itoa函数的演变：itoa with GCC</title>
    <url>/post/60077.html</url>
    <content><![CDATA[<p>转载链接：<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTMwNzQ0NjUvYXJ0aWNsZS9kZXRhaWxzLzQ2NDk5OTU5">https://blog.csdn.net/u013074465/article/details/46499959<i class="fa fa-external-link-alt"></i></span></p>
<p>原文：<span class="exturl" data-url="aHR0cDovL3d3dy5zdHJ1ZGVsLm9yZy51ay9pdG9hLw==">http://www.strudel.org.uk/itoa/<i class="fa fa-external-link-alt"></i></span></p>
<p>这篇文章中有对部分函数的具体分析：对itoa函数的分析。</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote>
<p>我怎么在GCC下使用<code>itoa()</code>？</p>
</blockquote>
<p>啊，C&#x2F;C++！itoa()不是<code>ANSI C</code>标准而且它不能在linux下的GCC中工作（至少我使用的版本是这样的）。这是很让人沮丧的，特别是当你想让代码跨平台可用时（Windows&#x2F;Linux&#x2F;Solaris或其他任何机器）。</p>
<p>很多人说可以使用sprintf来写字符串但是sprintf不满足itoa()的一个特征：itoa函数<code>允许将int转换为除十进制以外其他进制的形式</code>。该文章包含一系列itoa函数实现的演化版本。较老的版本在文章后边。请确认你用的是最新版本。</p>
<span id="more"></span>

<h2 id="贡献"><a href="#贡献" class="headerlink" title="贡献"></a>贡献</h2><p>在我们继续之前，我要感谢以下为解决方案作出贡献的人。这个函数是由以下人员贡献的：Stuart Lowe (本文作者)，Robert Jan Schaper，Ray-Yuan Sheu， Rodrigo de Salvo Braz，Wes Garland，John Maloney，Brian Hunt，Fernando Corradi and Lukás Chmela。</p>
<h2 id="演变过程"><a href="#演变过程" class="headerlink" title="演变过程"></a>演变过程</h2><p>以下是早期的一个版本，由Robert Jan Schaper表述于Google groups：</p>
<h3 id="char-version-0-1"><a href="#char-version-0-1" class="headerlink" title="char* version 0.1"></a>char* version 0.1</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span>* <span class="title function_">itoa</span><span class="params">(<span class="type">int</span> val, <span class="type">int</span> base)</span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> buf[<span class="number">32</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">30</span>;</span><br><span class="line">	<span class="keyword">for</span>(; val &amp;&amp; i ; --i, val /= base)</span><br><span class="line">	    buf[i] = <span class="string">&quot;0123456789abcdef&quot;</span>[val % base];</span><br><span class="line">	<span class="keyword">return</span> &amp;buf[i+<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我所使用的版本和这个版本看起来不太一样，它更像是这样的形式：itoa(int value, char* buffer, int radix)。在最后，我给出了我自己使用std::string代替字符串的版本。</p>
<h3 id="std-string-version-0-1"><a href="#std-string-version-0-1" class="headerlink" title="std::string version 0.1"></a>std::string version 0.1</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">my_itoa</span><span class="params">(<span class="type">int</span> value, <span class="built_in">std</span>::<span class="built_in">string</span>&amp; buf, <span class="type">int</span> base)</span>&#123;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">30</span>;</span><br><span class="line">	buf = <span class="string">&quot;&quot;</span>;</span><br><span class="line">	<span class="keyword">for</span>(; value &amp;&amp; i ; --i, value /= base)</span><br><span class="line">        buf = <span class="string">&quot;0123456789abcdef&quot;</span>[value % base] + buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更新：(2005&#x2F;02&#x2F;11)</p>
<p>Ray-Yuan Sheu发邮件给我，他提出了一个更新版本：做了更多错误检测，例如基底base越界、负整数等。</p>
<p>更新：(2005&#x2F;04&#x2F;08)</p>
<p>Rodrigo de Salvo Braz指出了一个bug：当输入为0时没有返回。现在函数返回0。Luc Gallant也指出了这个bug。</p>
<h3 id="std-string-version-0-2"><a href="#std-string-version-0-2" class="headerlink" title="std::string version 0.2"></a>std::string version 0.2</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * C++ version std::string style &quot;itoa&quot;:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title function_">itoa</span><span class="params">(<span class="type">int</span> value, <span class="type">unsigned</span> <span class="type">int</span> base)</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> digitMap[] = <span class="string">&quot;0123456789abcdef&quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> buf;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Guard:</span></span><br><span class="line">    <span class="keyword">if</span> (base == <span class="number">0</span> || base &gt; <span class="number">16</span>) &#123;</span><br><span class="line">        <span class="comment">// Error: may add more trace/log output here</span></span><br><span class="line">        <span class="keyword">return</span> buf;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Take care of negative int:</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> sign;</span><br><span class="line">    <span class="type">int</span> _value = value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check for case when input is zero:</span></span><br><span class="line">    <span class="keyword">if</span> (_value == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (value &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        _value = -value;</span><br><span class="line">        sign = <span class="string">&quot;-&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Translating number to string with base:</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">30</span>; _value &amp;&amp; i ; --i) &#123;</span><br><span class="line">        buf = digitMap[ _value % base ] + buf;</span><br><span class="line">        _value /= base;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sign.append(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更新：(2005&#x2F;05&#x2F;07)</p>
<p>Wes Garland指出lltostr函数在Solaris和其他linux变体中存在。函数应该返回long long的<code>char *</code>形式处理多种数基。还有针对无符号数值的ulltostr函数。</p>
<p>更新：(2005&#x2F;05&#x2F;30)</p>
<p>John Maloney指出了之前函数的多个问题。一个主要问题是函数包含大量栈分配。他建议尽可能移除栈分配以加快算法速度。char* 版本比上述的代码快至少10倍。新版本的std::string比原来的快3倍。尽管char*版本更快，但是你必须检查以确保为函数输出分配了足够的空间。</p>
<h3 id="std-string-version-0-3"><a href="#std-string-version-0-3" class="headerlink" title="std::string version 0.3"></a>std::string version 0.3</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * C++ version std::string style &quot;itoa&quot;:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title function_">itoa</span><span class="params">(<span class="type">int</span> value, <span class="type">int</span> base)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span> kMaxDigits = <span class="number">35</span> &#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> buf;</span><br><span class="line">    buf.reserve( kMaxDigits ); <span class="comment">// Pre-allocate enough space.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// check that the base if valid</span></span><br><span class="line">    <span class="keyword">if</span> (base &lt; <span class="number">2</span> || base &gt; <span class="number">16</span>) <span class="keyword">return</span> buf;</span><br><span class="line">    <span class="type">int</span> quotient = value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Translating number to string with base:</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        buf += <span class="string">&quot;0123456789abcdef&quot;</span>[ <span class="built_in">std</span>::<span class="built_in">abs</span>( quotient % base ) ];</span><br><span class="line">        quotient /= base;</span><br><span class="line">    &#125; <span class="keyword">while</span> ( quotient );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Append the negative sign for base 10</span></span><br><span class="line">    <span class="keyword">if</span> ( value &lt; <span class="number">0</span> &amp;&amp; base == <span class="number">10</span>) buf += <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">    <span class="built_in">std</span>::reverse( buf.begin(), buf.end() );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="char-version-0-2"><a href="#char-version-0-2" class="headerlink" title="char *version 0.2"></a>char *version 0.2</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * C++ version char* style &quot;itoa&quot;:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">char</span>* <span class="title function_">itoa</span><span class="params">( <span class="type">int</span> value, <span class="type">char</span>* result, <span class="type">int</span> base )</span> &#123;</span><br><span class="line">    <span class="comment">// check that the base if valid</span></span><br><span class="line">    <span class="keyword">if</span> (base &lt; <span class="number">2</span> || base &gt; <span class="number">16</span>) &#123; *result = <span class="number">0</span>; <span class="keyword">return</span> result; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span>* out = result;</span><br><span class="line">    <span class="type">int</span> quotient = value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        *out = <span class="string">&quot;0123456789abcdef&quot;</span>[ <span class="built_in">std</span>::<span class="built_in">abs</span>( quotient % base ) ];</span><br><span class="line">        ++out;</span><br><span class="line">        quotient /= base;</span><br><span class="line">    &#125; <span class="keyword">while</span> ( quotient );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Only apply negative sign for base 10</span></span><br><span class="line">    <span class="keyword">if</span> ( value &lt; <span class="number">0</span> &amp;&amp; base == <span class="number">10</span>) *out++ = <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">    <span class="built_in">std</span>::reverse( result, out );</span><br><span class="line">    *out = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更新：(2006&#x2F;10&#x2F;15)</p>
<p>Luiz Gon?lves告诉我：尽管itoa不是ANSI标准函数，但是该函数来自很多开发包并且被写进了很多教科书。他提出了一个来自于Kernighan &amp; Ritchie’sAnsi C的完全基于ANSI C的版本。基底base错误通过返回空字符来表述，并且没有分配内存。这个std::string版本和C++的<code>char* itoa()</code>版本在下方提供，做了一些细微的修改。</p>
<p>*** 译注：下面的方法是最容易想到的：***</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Ansi C &quot;itoa&quot; based on Kernighan &amp; Ritchie&#x27;s &quot;Ansi C&quot;:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">strreverse</span><span class="params">(<span class="type">char</span>* begin, <span class="type">char</span>* end)</span> &#123;</span><br><span class="line">	<span class="type">char</span> aux;</span><br><span class="line">	<span class="keyword">while</span>(end&gt;begin)</span><br><span class="line">		aux=*end, *end--=*begin, *begin++=aux;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">itoa</span><span class="params">(<span class="type">int</span> value, <span class="type">char</span>* str, <span class="type">int</span> base)</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> num[] = <span class="string">&quot;0123456789abcdefghijklmnopqrstuvwxyz&quot;</span>;</span><br><span class="line">    <span class="type">char</span>* wstr=str;</span><br><span class="line">    <span class="type">int</span> sign;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Validate base</span></span><br><span class="line">    <span class="keyword">if</span> (base&lt;<span class="number">2</span> || base&gt;<span class="number">35</span>)&#123; *wstr=<span class="string">&#x27;\0&#x27;</span>; <span class="keyword">return</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Take care of sign</span></span><br><span class="line">    <span class="keyword">if</span> ((sign=value) &lt; <span class="number">0</span>) value = -value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Conversion. Number is reversed.</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        *wstr++ = num[value%base];</span><br><span class="line">    &#125; <span class="keyword">while</span>(value/=base);</span><br><span class="line">    <span class="keyword">if</span>(sign&lt;<span class="number">0</span>) *wstr++=<span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">    *wstr=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Reverse string</span></span><br><span class="line">    strreverse(str,wstr<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Ansi C &quot;itoa&quot; based on Kernighan &amp; Ritchie&#x27;s &quot;Ansi C&quot;</span></span><br><span class="line"><span class="comment"> * with slight modification to optimize for specific architecture:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">strreverse</span><span class="params">(<span class="type">char</span>* begin, <span class="type">char</span>* end)</span> &#123;</span><br><span class="line">	<span class="type">char</span> aux;</span><br><span class="line">	<span class="keyword">while</span>(end&gt;begin)</span><br><span class="line">		aux=*end, *end--=*begin, *begin++=aux;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">itoa</span><span class="params">(<span class="type">int</span> value, <span class="type">char</span>* str, <span class="type">int</span> base)</span> &#123;</span><br><span class="line">	<span class="type">static</span> <span class="type">char</span> num[] = <span class="string">&quot;0123456789abcdefghijklmnopqrstuvwxyz&quot;</span>;</span><br><span class="line">	<span class="type">char</span>* wstr=str;</span><br><span class="line">	<span class="type">int</span> sign;</span><br><span class="line">	<span class="type">div_t</span> res;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Validate base</span></span><br><span class="line">	<span class="keyword">if</span> (base&lt;<span class="number">2</span> || base&gt;<span class="number">35</span>)&#123; *wstr=<span class="string">&#x27;\0&#x27;</span>; <span class="keyword">return</span>; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Take care of sign</span></span><br><span class="line">	<span class="keyword">if</span> ((sign=value) &lt; <span class="number">0</span>) value = -value;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Conversion. Number is reversed.</span></span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		res = div(value,base);</span><br><span class="line">		*wstr++ = num[res.rem];</span><br><span class="line">	&#125;<span class="keyword">while</span>(value=res.quot);</span><br><span class="line">	<span class="keyword">if</span>(sign&lt;<span class="number">0</span>) *wstr++=<span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">	*wstr=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Reverse string</span></span><br><span class="line">	strreverse(str,wstr<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更新：(2009&#x2F;07&#x2F;08)</p>
<p>过去一年我收到了一些改进<code>std::string</code>和<code>char *</code>版本的代码。我最终有时间测试了这些代码。在std::string版本中，Brian Hunt建议将reverse移到base的检查之后，保存内存分配。这样可以加快速度。</p>
<h3 id="std-string-version-0-4"><a href="#std-string-version-0-4" class="headerlink" title="std::string version 0.4"></a>std::string version 0.4</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * C++ version 0.4 std::string style &quot;itoa&quot;:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title function_">itoa</span><span class="params">(<span class="type">int</span> value, <span class="type">int</span> base)</span> &#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">string</span> buf;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// check that the base if valid</span></span><br><span class="line">	<span class="keyword">if</span> (base &lt; <span class="number">2</span> || base &gt; <span class="number">16</span>) <span class="keyword">return</span> buf;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">enum</span> &#123;</span> kMaxDigits = <span class="number">35</span> &#125;;</span><br><span class="line">	buf.reserve( kMaxDigits ); <span class="comment">// Pre-allocate enough space.</span></span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> quotient = value;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Translating number to string with base:</span></span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		buf += <span class="string">&quot;0123456789abcdef&quot;</span>[ <span class="built_in">std</span>::<span class="built_in">abs</span>( quotient % base ) ];</span><br><span class="line">		quotient /= base;</span><br><span class="line">	&#125; <span class="keyword">while</span> ( quotient );</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Append the negative sign</span></span><br><span class="line">	<span class="keyword">if</span> ( value &lt; <span class="number">0</span>) buf += <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">std</span>::reverse( buf.begin(), buf.end() );</span><br><span class="line">	<span class="keyword">return</span> buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还有一些针对char*版本的建议。Fernando Corradi提议使用abs()因为仅仅使用一次，不使用取余操作（%）而是通过手动计算除数。这样可以加快速度：</p>
<h3 id="char-version-0-3"><a href="#char-version-0-3" class="headerlink" title="char  *version 0.3"></a>char  *version 0.3</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * C++ version 0.3 char* style &quot;itoa&quot;:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">char</span>* <span class="title function_">itoa</span><span class="params">( <span class="type">int</span> value, <span class="type">char</span>* result, <span class="type">int</span> base )</span> &#123;</span><br><span class="line">	<span class="comment">// check that the base if valid</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (base &lt; <span class="number">2</span> || base &gt; <span class="number">16</span>) &#123; *result = <span class="number">0</span>; <span class="keyword">return</span> result; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">char</span>* out = result;</span><br><span class="line">	<span class="type">int</span> quotient = <span class="built_in">abs</span>(value);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		<span class="type">const</span> <span class="type">int</span> tmp = quotient / base;</span><br><span class="line">		*out = <span class="string">&quot;0123456789abcdef&quot;</span>[ quotient - (tmp*base) ];</span><br><span class="line">		++out;</span><br><span class="line">		quotient = tmp;</span><br><span class="line">	&#125; <span class="keyword">while</span> ( quotient );</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Apply negative sign</span></span><br><span class="line">	<span class="keyword">if</span> ( value &lt; <span class="number">0</span>) *out++ = <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">std</span>::reverse( result, out );</span><br><span class="line">	*out = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="char-version-0-4"><a href="#char-version-0-4" class="headerlink" title="char* version 0.4"></a>char* version 0.4</h3><p>Lukás Chmela重写了代码，该函数不再有“最小负数”bug：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * C++ version 0.4 char* style &quot;itoa&quot;:</span></span><br><span class="line"><span class="comment"> * Written by Lukás Chmela</span></span><br><span class="line"><span class="comment"> * Released under GPLv3.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">char</span>* <span class="title function_">itoa</span><span class="params">(<span class="type">int</span> value, <span class="type">char</span>* result, <span class="type">int</span> base)</span> &#123;</span><br><span class="line">    <span class="comment">// check that the base if valid</span></span><br><span class="line">    <span class="keyword">if</span> (base &lt; <span class="number">2</span> || base &gt; <span class="number">36</span>) &#123; *result = <span class="string">&#x27;\0&#x27;</span>; <span class="keyword">return</span> result; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span>* ptr = result, *ptr1 = result, tmp_char;</span><br><span class="line">    <span class="type">int</span> tmp_value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        tmp_value = value;</span><br><span class="line">        value /= base;</span><br><span class="line">        *ptr++ = <span class="string">&quot;zyxwvutsrqponmlkjihgfedcba9876543210123456789</span></span><br><span class="line"><span class="string">            abcdefghijklmnopqrstuvwxyz&quot;</span> [<span class="number">35</span> + (tmp_value - value * base)];</span><br><span class="line">    &#125; <span class="keyword">while</span> ( value );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Apply negative sign</span></span><br><span class="line">    <span class="keyword">if</span> (tmp_value &lt; <span class="number">0</span>) *ptr++ = <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">    *ptr-- = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">while</span>(ptr1 &lt; ptr) &#123;</span><br><span class="line">        tmp_char = *ptr;</span><br><span class="line">        *ptr--= *ptr1;</span><br><span class="line">        *ptr1++ = tmp_char;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="最新版本"><a href="#最新版本" class="headerlink" title="最新版本"></a>最新版本</h2><p>下面是最新版本的itoa，你可以根据喜好选择char*或std::string版本。我没有将基于Kernighan &amp; Ritchie的版本放在这个部分，因为我不确定其版权的状态。然而，下列函数已经被上述提到的人开发并且是可以使用的。</p>
<h3 id="std-string-version-0-4-1"><a href="#std-string-version-0-4-1" class="headerlink" title="std::string version 0.4"></a>std::string version 0.4</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * C++ version 0.4 std::string style &quot;itoa&quot;:</span></span><br><span class="line"><span class="comment"> * Contributions from Stuart Lowe, Ray-Yuan Sheu,</span></span><br><span class="line"><span class="comment"> * Rodrigo de Salvo Braz, Luc Gallant, John Maloney</span></span><br><span class="line"><span class="comment"> * and Brian Hunt</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title function_">itoa</span><span class="params">(<span class="type">int</span> value, <span class="type">int</span> base)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> buf;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// check that the base if valid</span></span><br><span class="line">    <span class="keyword">if</span> (base &lt; <span class="number">2</span> || base &gt; <span class="number">16</span>) <span class="keyword">return</span> buf;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span> kMaxDigits = <span class="number">35</span> &#125;;</span><br><span class="line">    buf.reserve( kMaxDigits ); <span class="comment">// Pre-allocate enough space.</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> quotient = value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Translating number to string with base:</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        buf += <span class="string">&quot;0123456789abcdef&quot;</span>[ <span class="built_in">std</span>::<span class="built_in">abs</span>( quotient % base ) ];</span><br><span class="line">        quotient /= base;</span><br><span class="line">    &#125; <span class="keyword">while</span> ( quotient );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Append the negative sign</span></span><br><span class="line">    <span class="keyword">if</span> ( value &lt; <span class="number">0</span>) buf += <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::reverse( buf.begin(), buf.end() );</span><br><span class="line">    <span class="keyword">return</span> buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="char-version-0-4-1"><a href="#char-version-0-4-1" class="headerlink" title="char* version 0.4"></a>char* version 0.4</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * C++ version 0.4 char* style &quot;itoa&quot;:</span></span><br><span class="line"><span class="comment"> * Written by Lukás Chmela</span></span><br><span class="line"><span class="comment"> * Released under GPLv3.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">char</span>* <span class="title function_">itoa</span><span class="params">(<span class="type">int</span> value, <span class="type">char</span>* result, <span class="type">int</span> base)</span> &#123;</span><br><span class="line">    <span class="comment">// check that the base if valid</span></span><br><span class="line">    <span class="keyword">if</span> (base &lt; <span class="number">2</span> || base &gt; <span class="number">36</span>) &#123; *result = <span class="string">&#x27;\0&#x27;</span>; <span class="keyword">return</span> result; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span>* ptr = result, *ptr1 = result, tmp_char;</span><br><span class="line">    <span class="type">int</span> tmp_value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        tmp_value = value;</span><br><span class="line">        value /= base;</span><br><span class="line">        *ptr++ = <span class="string">&quot;zyxwvutsrqponmlkjihgfedcba9876543210123456789</span></span><br><span class="line"><span class="string">            abcdefghijklmnopqrstuvwxyz&quot;</span> [<span class="number">35</span> + (tmp_value - value * base)];</span><br><span class="line">    &#125; <span class="keyword">while</span> ( value );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Apply negative sign</span></span><br><span class="line">    <span class="keyword">if</span> (tmp_value &lt; <span class="number">0</span>) *ptr++ = <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">    *ptr-- = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">while</span>(ptr1 &lt; ptr) &#123;</span><br><span class="line">        tmp_char = *ptr;</span><br><span class="line">        *ptr--= *ptr1;</span><br><span class="line">        *ptr1++ = tmp_char;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="性能对比"><a href="#性能对比" class="headerlink" title="性能对比"></a>性能对比</h2><p>我已经对itoa的各个版本做了测试，研究其转换-32768到32768之间整数，基底在2到20之间时所需要的平均时间（代码仅仅在基底最高位16有效，因此其余的base仅仅是作为测试）。测试结果如下表所示：</p>
<table>
<thead>
<tr>
<th align="left">function</th>
<th align="center">relative time</th>
</tr>
</thead>
<tbody><tr>
<td align="left">char* style “itoa” (v 0.2) <br/> char* itoa(int value, char* result, int base)</td>
<td align="center">1.0 (XP, Cygwin, g++)</td>
</tr>
<tr>
<td align="left">char* style “itoa” (v 0.3) <br/> char* itoa(int value, char* result, int base)</td>
<td align="center">0.93</td>
</tr>
<tr>
<td align="left">char* style “itoa” (v 0.4) <br/> char* itoa(int value, char* result, int base)</td>
<td align="center">0.72</td>
</tr>
<tr>
<td align="left">Ansi C “itoa” based on Kernighan &amp; Ritchie’s “Ansi C” with modification to optimize for specific architecture <br/>void itoa(int value, char* str, int base)</td>
<td align="center">0.92</td>
</tr>
<tr>
<td align="left">std::string style “itoa” (v 0.3) <br/> std::string itoa(int value, int base)</td>
<td align="center">41.5</td>
</tr>
<tr>
<td align="left">std::string style “itoa” (v 0.4) <br/> std::string itoa(int value, int base)</td>
<td align="center">40.8</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>程序设计</category>
        <category>gcc</category>
      </categories>
      <tags>
        <tag>gcc</tag>
        <tag>itoa</tag>
      </tags>
  </entry>
  <entry>
    <title>AVX VMOVDQA slower than two SSE MOVDQA?</title>
    <url>/post/40199.html</url>
    <content><![CDATA[<blockquote>
<p>转载于： <span class="exturl" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTM5NzU1NDYvYXZ4LXZtb3ZkcWEtc2xvd2VyLXRoYW4tdHdvLXNzZS1tb3ZkcWE=">https://stackoverflow.com/questions/13975546/avx-vmovdqa-slower-than-two-sse-movdqa<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<span id="more"></span>

<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><p>While I was working on my fast ADD loop (Speed up x64 assembler ADD loop), I was testing memory access with SSE and AVX instructions. To add I have to read two inputs and produce one output. So I wrote a dummy routine that reads two x64 values into registers and write one back to memory without doing any operation. This is of course useless, I only did it for benchmarking.</p>
<p>当我正在进行快速ADD循环（加速x64汇编ADD循环）时，我使用SSE和AVX指令测试内存访问。我必须读取两个输入并产生一个输出。 所以我编写了一个虚拟例程，它将两个x64值读入寄存器，然后将其写回存储器而不进行任何操作。 这当然没用，我只做了基准测试。</p>
<p>I use an unrolled loop that handles 64 bytes per loop. It is comprised of 8 blocks like this:</p>
<p>我使用一个展开的循环，每个循环处理64个字节。 它由8个块组成，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov rax, QWORD PTR [rdx+r11*8-64]</span><br><span class="line">mov r10, QWORD PTR [r8+r11*8-64]</span><br><span class="line">mov QWORD PTR [rcx+r11*8-64], rax</span><br></pre></td></tr></table></figure>

<p>Then I upgraded it to SSE2. Now I use 4 blocks like this:</p>
<p>然后我将其升级到SSE2。 现在我使用4个这样的块：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">movdqa xmm0, XMMWORD PTR [rdx+r11*8-64]</span><br><span class="line">movdqa xmm1, XMMWORD PTR [r8+r11*8-64]</span><br><span class="line">movdqa XMMWORD PTR [rcx+r11*8-64], xmm0</span><br></pre></td></tr></table></figure>

<p>And later on I used AVX (256 bit per register). I have 2 blocks like this:</p>
<p>后来我使用了AVX（每个寄存器256位）。 我有2个这样的块：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vmovdqa ymm0, YMMWORD PTR [rdx+r11*8-64]</span><br><span class="line">vmovdqa ymm1, YMMWORD PTR [r8+r11*8-64]</span><br><span class="line">vmovdqa YMMWORD PTR [rcx+r11*8-64], ymm0</span><br></pre></td></tr></table></figure>

<p>So far, so not-so-extremely-spectacular. What is interesting is the benchmarking result: When I run the three different approaches on 1k+1k&#x3D;1k 64-bit words (i.e. two times 8 kb of input and one time 8kb of output) I get strange results. Each of the following timings is for processing two times 64 bytes input into 64 bytes of output.</p>
<p>到目前为止，还不那么引人注目。 有趣的是基准测试结果：当我在1k + 1k &#x3D; 1k 64位字（即两次8kb输入和一次8kb输出）上运行三种不同方法时，我得到奇怪的结果。 以下每个时序用于处理两次64字节输入到64字节输出。</p>
<ul>
<li>The x64 register method runs at about 15 cycles&#x2F;64 bytes</li>
<li>x64寄存器方法以大约15个周期&#x2F; 64个字节运行</li>
<li>The SSE2 method runs at about 8.5 cycles&#x2F;64 bytes</li>
<li>SSE2方法以大约8.5个周期&#x2F; 64个字节运行</li>
<li>The AVX method runs at about 9 cycles&#x2F;64 bytes</li>
<li>AVX方法以大约9个周期&#x2F; 64个字节运行</li>
</ul>
<p>My question is: how come the AVX method is slower (though not a lot) than the SSE2 method? I expected it to be at least on par. Does using the YMM registers cost so much extra time? The memory was aligned (you get GPF’s otherwise).</p>
<p>我的问题是：为什么AVX方法比SSE2方法慢（虽然不是很多）？ 我预计它至少会与之相提并论。 使用YMM寄存器会花费多少额外的时间吗？ 内存已对齐（否则会获得GPF）。</p>
<h2 id="Answer"><a href="#Answer" class="headerlink" title="Answer"></a>Answer</h2><p>On Sandybridge&#x2F;Ivybridge, 256b AVX loads and stores are cracked into two 128b ops [as Peter Cordes notes, these aren’t quite µops, but it requires two cycles for the operation to clear the port] in the load&#x2F;store execution units, so there’s no reason to expect the version using those instructions to be much faster.</p>
<p>在Sandybridge &#x2F; Ivybridge上，256b AVX加载和存储被破解为两个128b操作[正如Peter Cordes所说，这些不是很好，但在加载&#x2F;存储执行单元中需要两个周期来清除端口]， 因此没有理由期望使用这些指令的版本更快</p>
<p>Why is it slower? Two possibilities come to mind:</p>
<p>它为什么慢？ 我想到了两种可能性：</p>
<ul>
<li><p>for base + index + offset addressing, the latency of a 128b load is 6 cycles, whereas the latency of a 256b load is 7 cycles (Table 2-8 in the Intel Optimization Manual). Although your benchmark should be bound by thoughput and not latency, the longer latency means that the processor takes longer to recover from any hiccups (pipeline bubbles or prediction misses or interrupt servicing or …), which does have some impact.</p>
</li>
<li><p>对于基数+索引+偏移量寻址，128b负载的延迟为6个周期，而256b负载的延迟为7个周期（英特尔优化手册中的表2-8）。 尽管您的基准测试应该受到吞吐量而非延迟的限制，但延迟时间越长意味着处理器需要更长时间才能从任何暂停（流水线气泡或预测未命中或服务中断或……）中恢复，这确实会产生一些影响。</p>
</li>
<li><p>in 11.6.2 of the same document, Intel suggests that the penalty for cache line and page crossing may be larger for 256b loads than it is for 128b loads. If your loads are not all 32-byte aligned, this may also explain the slowdown you are seeing when using the 256b load&#x2F;store operations:</p>
</li>
<li><p>在同一文档的11.6.2中，英特尔提示对256b的加载可能比128b的加载在缓存行和页面交叉方面更不利。 如果您的加载不是全部32字节对齐，这也可以解释您在使用256b加载&#x2F;存储操作时看到的速度减慢：</p>
</li>
</ul>
<blockquote>
<p>Example 11-12 shows two implementations for SAXPY with unaligned addresses. Alternative 1 uses 32 byte loads and alternative 2 uses 16 byte loads. These code samples are executed with two source buffers, src1, src2, at 4 byte offset from 32- Byte alignment, and a destination buffer, DST, that is 32-Byte aligned. Using two 16- byte memory operations in lieu of 32-byte memory access performs faster.</p>
</blockquote>
<blockquote>
<p>例11-12显示了具有未对齐地址的SAXPY的两种实现。 备选1使用32字节加载，备选2使用16字节加载。 这些代码示例使用两个源缓冲区src1，src2执行，以32字节对齐的4字节偏移量和32字节对齐的目标缓冲区DST执行。 使用两个16字节内存操作代替32字节内存访问执行速度更快。</p>
</blockquote>
]]></content>
      <categories>
        <category>程序设计</category>
        <category>simd</category>
      </categories>
      <tags>
        <tag>simd</tag>
      </tags>
  </entry>
  <entry>
    <title>X86平台下的SIMD运算</title>
    <url>/post/50180.html</url>
    <content><![CDATA[<blockquote>
<p><code>SSE</code>的全称是 Sreaming SIMD Extensions， 它是一组Intel CPU指令，用于像信号处理、科学计算或者3D图形计算一样的应用。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;mmintrin.h&gt;    //MMX  64bits</span><br><span class="line">#include &lt;xmmintrin.h&gt;   //SSE  128bits</span><br><span class="line">#include &lt;emmintrin.h&gt;   //SSE2</span><br><span class="line">#include &lt;immintrin.h&gt;   //AVX  256bits</span><br></pre></td></tr></table></figure>
<ul>
<li><code>immintrin.h</code>: (Intel(R) AVX compiler intrinsics  256bit)</li>
<li><code>emmintrin.h</code>: Principal header file for Intel(R) Pentium(R) 4 processor SSE2 intrinsics</li>
</ul>
<span id="more"></span>

<h2 id="XMM、SSE、AVX关系？？"><a href="#XMM、SSE、AVX关系？？" class="headerlink" title="XMM、SSE、AVX关系？？"></a>XMM、SSE、AVX关系？？</h2><ul>
<li><code>MMX</code>是由英特尔开发的一种SIMD多媒体指令集，共有57条指令。</li>
<li><code>SSE</code>(Sreaming SIMD Extensions)是继MMX的扩充指令集。SSE 指令集提供了 70 条新指令。</li>
<li><code>AVX</code>(Advanced Vector Extensions) 是Intel的SSE延伸架构，如IA16至IA32般的把暂存器XMM 128bit提升至YMM 256bit，以增加一倍的运算效率。</li>
</ul>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><table>
<thead>
<tr>
<th align="center">关键字</th>
<th align="center">说明</th>
<th align="center">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>__m64</code></td>
<td align="center">64位紧缩整数（MMX）</td>
<td align="center">一个MMX寄存器,表示封装了8个8bit,4个16bit,2个32bit,1个64bit的整数</td>
</tr>
<tr>
<td align="center"><code>__m128</code></td>
<td align="center">128位紧缩单精度（SSE）</td>
<td align="center">封装4个32bit的单精度浮点数</td>
</tr>
<tr>
<td align="center"><code>__m128d</code></td>
<td align="center">128位紧缩双精度（SSE2）</td>
<td align="center">封装2个64bit的双精度浮点数</td>
</tr>
<tr>
<td align="center"><code>__m128i</code></td>
<td align="center">128位紧缩整数（SSE2）</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><code>__m256</code></td>
<td align="center">256位紧缩单精度（AVX）</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><code>__m256d</code></td>
<td align="center">256位紧缩双精度（AVX）</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><code>__m256i</code></td>
<td align="center">256位紧缩整数（AVX）</td>
<td align="center"></td>
</tr>
</tbody></table>
<blockquote>
<p><strong>注</strong>： 紧缩整数包括了8位、16位、32位、64位的带符号和无符号整数。</p>
</blockquote>
<h2 id="SSE指令集"><a href="#SSE指令集" class="headerlink" title="SSE指令集"></a>SSE指令集</h2><ul>
<li>数据传输：<span class="exturl" data-url="aHR0cDovL3d3dy50b21tZXNhbmkuY29tL2luZGV4LnBocC9jb21wb25lbnQvY29udGVudC9hcnRpY2xlLzItc2ltZC81OS1zc2UtZGF0YS1tb3ZlbWVudC5odG1s">Data movement instructions<i class="fa fa-external-link-alt"></i></span></li>
<li>算术运算：<span class="exturl" data-url="aHR0cDovL3RvbW1lc2FuaS5jb20vaW5kZXgucGhwL2NvbXBvbmVudC9jb250ZW50L2FydGljbGUvMi1zaW1kLzQ2LXNzZS1hcml0aG1ldGljLmh0bWw=">Arithmetic instructions<i class="fa fa-external-link-alt"></i></span></li>
<li>倒数运算：<span class="exturl" data-url="aHR0cDovL3d3dy50b21tZXNhbmkuY29tL2luZGV4LnBocC9jb21wb25lbnQvY29udGVudC9hcnRpY2xlLzItc2ltZC82MS1zc2UtcmVjaXByb2NhbC5odG1s">Reciprocal instructions<i class="fa fa-external-link-alt"></i></span></li>
<li>比较运算：<span class="exturl" data-url="aHR0cDovL3d3dy50b21tZXNhbmkuY29tL2luZGV4LnBocC9jb21wb25lbnQvY29udGVudC9hcnRpY2xlLzItc2ltZC81Ny1zc2UtY29tcGFyaXNvbi5odG1s">Comparison instructions<i class="fa fa-external-link-alt"></i></span></li>
<li>数据转换：<span class="exturl" data-url="aHR0cDovL3d3dy50b21tZXNhbmkuY29tL2luZGV4LnBocC9jb21wb25lbnQvY29udGVudC9hcnRpY2xlLzItc2ltZC81OC1zc2UtY29udmVyc2lvbi5odG1s">Conversion instructions<i class="fa fa-external-link-alt"></i></span></li>
<li>逻辑运算：<span class="exturl" data-url="aHR0cDovL3d3dy50b21tZXNhbmkuY29tL2luZGV4LnBocC9jb21wb25lbnQvY29udGVudC9hcnRpY2xlLzItc2ltZC82MC1zc2UtbG9naWNhbC5odG1s">Logical instructions<i class="fa fa-external-link-alt"></i></span></li>
<li>整数运算：<span class="exturl" data-url="aHR0cDovL3RvbW1lc2FuaS5jb20vaW5kZXgucGhwL2NvbXBvbmVudC9jb250ZW50L2FydGljbGUvMi1zaW1kLzM2LXNzZS1wcmltZXIuaHRtbA==">Additional SIMD integer instructions (SSE Primer)<i class="fa fa-external-link-alt"></i></span></li>
<li>字节乱排：<span class="exturl" data-url="aHR0cDovL3d3dy50b21tZXNhbmkuY29tL2luZGV4LnBocC9jb21wb25lbnQvY29udGVudC9hcnRpY2xlLzItc2ltZC82Mi1zc2Utc2h1ZmZsZS5odG1s">Shuffle instructions<i class="fa fa-external-link-alt"></i></span></li>
<li>状态管理：<span class="exturl" data-url="aHR0cDovL3d3dy50b21tZXNhbmkuY29tL2luZGV4LnBocC9jb21wb25lbnQvY29udGVudC9hcnRpY2xlLzItc2ltZC82My1zc2Utc3RhdGUtbWFuYWdlbWVudC5odG1s">State Management instructions<i class="fa fa-external-link-alt"></i></span></li>
<li>缓存控制：<span class="exturl" data-url="aHR0cDovL3d3dy50b21tZXNhbmkuY29tL2luZGV4LnBocC9jb21wb25lbnQvY29udGVudC9hcnRpY2xlLzItc2ltZC81Ni1zc2UtY2FjaGVhYmlsaXR5LWNvbnRyb2wuaHRtbA==">Cacheability Control instructions<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<h2 id="指令函数"><a href="#指令函数" class="headerlink" title="指令函数"></a>指令函数</h2><blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9zb2Z0d2FyZS5pbnRlbC5jb20vc2l0ZXMvbGFuZGluZ3BhZ2UvSW50cmluc2ljc0d1aWRlLyM=">Intel intrinsic<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<h2 id="操作码汇总表中的指令列"><a href="#操作码汇总表中的指令列" class="headerlink" title="操作码汇总表中的指令列"></a>操作码汇总表中的指令列</h2><ul>
<li><strong>mm</strong> — An MMX register. The 64-bit MMX registers are: MM0 through MM7.</li>
<li><strong>xmm</strong> — An XMM register. The 128-bit XMM registers are: XMM0 through XMM7; XMM8 through XMM15 are<br>available using REX.R in 64-bit mode.</li>
<li><strong>ymm</strong> — A YMM register. The 256-bit YMM registers are: YMM0 through YMM7; YMM8 through YMM15 are<br>available in 64-bit mode.</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZlbmdiaW5nY2h1bi9hcnRpY2xlL2RldGFpbHMvMTg0NjAxOTk=">SSE2 Intrinsics各函数介绍<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuaWJtLmNvbS9kZXZlbG9wZXJ3b3Jrcy9jbi9saW51eC9sLWdjY3NpbWQ=">GCC中SIMD指令的应用方法<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTQ3MTM4MTkvYXJ0aWNsZS9kZXRhaWxzLzM4NDMzODc5">mmintrin.h与MMX指令集 Intrinsics函数<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RlcmNlbF96aGFuZy9hcnRpY2xlL2RldGFpbHMvODA2OTQ1NzM=">SIMD指令初学<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vd2FuZ2d1Y2hhbmdxaW5nL3AvNTQ2NjMwMS5odG1s">SSE指令集学习：Compiler Intrinsic<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cucGVkaXkuY29tL2tzc2QvcGVkaXkxMC83ODEyMS5odG1s">深入浅出指令编码之四：指令核心<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY3JpLmVuc21wLmZyL2NsYXNzZW1lbnQvZG9jL0UtMjcyLnBkZg==">An evaluation of the automatic generation of parallel X86 SIMD<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuaW50ZWwuY29tL2NvbnRlbnQvZGFtL3d3dy9wdWJsaWMvdXMvZW4vZG9jdW1lbnRzL21hbnVhbHMvNjQtaWEtMzItYXJjaGl0ZWN0dXJlcy1zb2Z0d2FyZS1kZXZlbG9wZXItaW5zdHJ1Y3Rpb24tc2V0LXJlZmVyZW5jZS1tYW51YWwtMzI1MzgzLnBkZg==">Intel® 64 and IA-32 ArchitecturesSoftware Developer’s Manual<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>程序设计</category>
        <category>simd</category>
      </categories>
      <tags>
        <tag>simd</tag>
      </tags>
  </entry>
  <entry>
    <title>性能优化---指令预取</title>
    <url>/post/35506.html</url>
    <content><![CDATA[<p><strong>指令预取</strong>: 是指提前将所需要的数据取出来，在使用时可用。</p>
<blockquote>
<p>具体方法就是在不命中时，当数据从主存储器中取出送往CPU的同时，把主存储器相邻几个单元中的数据（称为一个数据块）都取出来送入Cache中。</p>
</blockquote>
<p>CPU在cache不命中的情况下，将从内存读取一个连续的cacheline大小数据。</p>
<ul>
<li>如果访问数据地址连续，CPU产生Cache不命中的情况少，省时</li>
<li>如果访问数据地址不连续，CPU产生的Cache不命中的情况多，耗时</li>
</ul>
<span id="more"></span>

<h2 id="示例–矩阵乘法"><a href="#示例–矩阵乘法" class="headerlink" title="示例–矩阵乘法"></a>示例–矩阵乘法</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __aarch64__</span></span><br><span class="line">  <span class="meta">#<span class="keyword">define</span> nop asm(<span class="string">&quot;nop&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="meta">#<span class="keyword">define</span> nop</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> i, j, k;</span><br><span class="line">    <span class="type">int</span> N = <span class="number">700</span>;</span><br><span class="line">    <span class="type">int</span> res[N][N], mul1[N][N], mul2[N][N];</span><br><span class="line">    <span class="type">clock_t</span> start, end;</span><br><span class="line">    <span class="type">long</span> time1 = <span class="number">0</span>, time2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; N; ++j) &#123;</span><br><span class="line">            mul1[i][j] = (i + <span class="number">1</span>) * j;</span><br><span class="line">            mul2[i][j] = i * j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    start = clock();</span><br><span class="line">    <span class="comment">/* mul2的地址空间不是连续的</span></span><br><span class="line"><span class="comment">     * 初始化时mul2[0][x], 一行一行赋值，地址连续</span></span><br><span class="line"><span class="comment">     * 执行读取mul2[x][0], 一列一列读取，地址不连续*/</span></span><br><span class="line">    nop;nop;nop;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; N; ++j) &#123;</span><br><span class="line">            <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; N; ++k) &#123;</span><br><span class="line">                <span class="comment">// 行 x 列</span></span><br><span class="line">                res[i][j] += mul1[i][k] * mul2[k][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    nop;nop;nop;</span><br><span class="line">    end = clock();</span><br><span class="line">    time1 = end - start;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Run Time1 %f s\n&quot;</span>, (<span class="type">double</span>)time1 / CLOCKS_PER_SEC);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> tmp[N][N];</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; N; ++j) &#123;</span><br><span class="line">            mul1[i][j] = (i + <span class="number">1</span>) * j;</span><br><span class="line">            mul2[i][j] = i * j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    start = clock();</span><br><span class="line">    <span class="comment">// 矩阵转换，列变换（列变行）</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; N; ++j) &#123;</span><br><span class="line">            tmp[i][j] = mul2[j][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* CPU读取连续的tmp地址时，使用指令预取（硬件）</span></span><br><span class="line"><span class="comment">     * DCache 命中效率*/</span></span><br><span class="line">    nop;nop;nop;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; N; ++j) &#123;</span><br><span class="line">            <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; N; ++k) &#123;</span><br><span class="line">                res[i][j] += mul1[i][k] * tmp[j][k];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    nop;nop;nop;</span><br><span class="line">    end = clock();</span><br><span class="line">    time2 = end - start;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Run Time2 %f s\n&quot;</span>, (<span class="type">double</span>)time2 / CLOCKS_PER_SEC);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Time2 and Time1 upgrade %f %\n&quot;</span>, (<span class="type">double</span>)(time1 - time2) / time1 * <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>结果–arm平台</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[shell@localhost:/]$ ./prefetch</span><br><span class="line">Run Time1 5.966075 s</span><br><span class="line">Run Time2 4.530201 s</span><br><span class="line">Time2 and Time1 upgrade 24.067314 %</span><br></pre></td></tr></table></figure>
<blockquote>
<p>代码运行速度提升<code>24%</code></p>
</blockquote>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><ul>
<li>Cache命中率</li>
<li>乘法运算与赋值运算的效率</li>
</ul>
]]></content>
      <categories>
        <category>程序设计</category>
        <category>simd</category>
      </categories>
      <tags>
        <tag>指令</tag>
      </tags>
  </entry>
  <entry>
    <title>X86---汇编&amp;内嵌汇编</title>
    <url>/post/1816.html</url>
    <content><![CDATA[<p>基本格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">__asm__ __volatile__ (</span><br><span class="line">    &quot;assembler template&quot;</span><br><span class="line">    : output operands                  /* optional */</span><br><span class="line">    : input operands                   /* optional */</span><br><span class="line">    : list of clobbered registers      /* optional */</span><br><span class="line">    );</span><br></pre></td></tr></table></figure>
<span id="more"></span>


<h2 id="汇编指令"><a href="#汇编指令" class="headerlink" title="汇编指令"></a>汇编指令</h2><blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cuZmVsaXhjbG91dGllci5jb20veDg2L2luZGV4Lmh0bWw=">x86 and amd64 instruction reference<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">操作码</th>
<th align="left">作用</th>
<th align="left">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="center">movdqa</td>
<td align="left">移动对齐的双四字(2*64)</td>
<td align="left">Move Aligned Packed Integer Values</td>
</tr>
<tr>
<td align="center">movdqu</td>
<td align="left">移动不对齐的双四字</td>
<td align="left">Move Unaligned Packed Integer Values</td>
</tr>
<tr>
<td align="center"><code>XMMWORD</code></td>
<td align="left">用于具有MMX和SSE（XMM）指令的128位多媒体操作数，<br/> XMMWORD旨在表示与__m128相同的类型。</td>
<td align="left">movdqa   xmm0, xmmword ptr [ebx]</td>
</tr>
<tr>
<td align="center">punpcklwd</td>
<td align="left">打开低数据包装</td>
<td align="left"></td>
</tr>
<tr>
<td align="center">punpckhwd</td>
<td align="left">打开高数据包装</td>
<td align="left"></td>
</tr>
</tbody></table>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vd2h1dHpob3UvYXJ0aWNsZXMvMjYzODQ5OC5odG1s">【转】GCC 嵌入汇编代码<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL2Jsb2cuY2hpbmF1bml4Lm5ldC91aWQtMjE2MDI4MzctaWQtMTgyMzYzMS5odG1s">linux中X86的内联汇编<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL3d3dy5lZ3IudW5sdi5lZHUvfmVkL2Fzc2VtYmx5NjQucGRm">x86-64 Assembly Language Programming with Ubuntu<i class="fa fa-external-link-alt"></i></span> —— Ed Jorgensen (PDF)</li>
<li><span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpYm9va3Mub3JnL3dpa2kvWDg2X0Fzc2VtYmx5">x86 Assembly<i class="fa fa-external-link-alt"></i></span> —— Wikibooks</li>
</ul>
]]></content>
      <categories>
        <category>程序设计</category>
        <category>x86</category>
      </categories>
      <tags>
        <tag>汇编</tag>
        <tag>x86</tag>
      </tags>
  </entry>
  <entry>
    <title>代码风格格式化--Astyle</title>
    <url>/post/62371.html</url>
    <content><![CDATA[<p><code>Astyle</code>是一个用来对C&#x2F;C++代码进行格式化</p>
<blockquote>
<p>文档: <span class="exturl" data-url="aHR0cDovL2FzdHlsZS5zb3VyY2Vmb3JnZS5uZXQvYXN0eWxlLmh0bWw=">Artistic Style 3.1<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<span id="more"></span>


<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$sudo apt install astyle</span><br></pre></td></tr></table></figure>

<h2 id="预定风格"><a href="#预定风格" class="headerlink" title="预定风格"></a>预定风格</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">default brace style</span><br><span class="line">If no brace style is requested, the opening braces will not be</span><br><span class="line">changed and closing braces will be broken from the preceding line.</span><br><span class="line"></span><br><span class="line">--style=allman  OR  --style=bsd  OR  --style=break  OR  -A1</span><br><span class="line">Allman style formatting/indenting.</span><br><span class="line">Broken braces.</span><br><span class="line"></span><br><span class="line">--style=java  OR  --style=attach  OR  -A2</span><br><span class="line">Java style formatting/indenting.</span><br><span class="line">Attached braces.</span><br><span class="line"></span><br><span class="line">--style=kr  OR  --style=k&amp;r  OR  --style=k/r  OR  -A3</span><br><span class="line">Kernighan &amp; Ritchie style formatting/indenting.</span><br><span class="line">Linux braces.</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">--style=gnu  OR  -A7</span><br><span class="line">GNU style formatting/indenting.</span><br><span class="line">Broken braces, indented blocks.</span><br><span class="line"></span><br><span class="line">--style=linux  OR  --style=knf  OR  -A8</span><br><span class="line">Linux style formatting/indenting.</span><br><span class="line">Linux braces, minimum conditional indent is one-half indent.</span><br><span class="line"></span><br><span class="line">--style=horstmann  OR  --style=run-in  OR  -A9</span><br><span class="line">Horstmann style formatting/indenting.</span><br><span class="line">Run-in braces, indented switches.</span><br><span class="line"></span><br><span class="line">--style=1tbs  OR  --style=otbs  OR  -A10</span><br><span class="line">One True Brace Style formatting/indenting.</span><br><span class="line">Linux braces, add braces to all conditionals.</span><br><span class="line"></span><br><span class="line">--style=google  OR  -A14</span><br><span class="line">Google style formatting/indenting.</span><br><span class="line">Attached braces, indented class modifiers.</span><br></pre></td></tr></table></figure>

<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">astyle --style=linux -n ./*.c</span><br></pre></td></tr></table></figure>
<ul>
<li><code>--style=linux</code> : linux风格缩进</li>
<li><code>-n</code> : 不保存备份</li>
</ul>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;astyle --style=linux --indent=force-tab=4 --convert-tabs --pad-oper --unpad-paren --break-blocks=all --delete-empty-lines *.c *.h</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="递归格式化"><a href="#递归格式化" class="headerlink" title="递归格式化"></a>递归格式化</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">astyle --style=linux --recursive *.c,*.h</span><br></pre></td></tr></table></figure>
<blockquote>
<p>必须中间加<code>,</code></p>
</blockquote>
<h2 id="自定义规则"><a href="#自定义规则" class="headerlink" title="自定义规则"></a>自定义规则</h2><blockquote>
<p>在<code>--style=linux</code>的基础上修改,只做必要改动</p>
</blockquote>
<h3 id="缩进Tab"><a href="#缩进Tab" class="headerlink" title="缩进Tab"></a>缩进Tab</h3><p>默认tab是4个空格.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--indent=force-tab=#  OR  -T#</span><br></pre></td></tr></table></figure>
<blockquote>
<p>优先采用空格缩进, 这样配置后同vim中的tab缩进配置4个空格相同,格式化后的代码相当于vim中的<code>gg=G</code></p>
</blockquote>
<h3 id="switch缩进"><a href="#switch缩进" class="headerlink" title="switch缩进"></a>switch缩进</h3><p>默认</p>
<h3 id="操作符两边加空格"><a href="#操作符两边加空格" class="headerlink" title="操作符两边加空格"></a>操作符两边加空格</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--pad-oper  OR  -p</span><br></pre></td></tr></table></figure>
<h3 id="删除括号-两边多余空格"><a href="#删除括号-两边多余空格" class="headerlink" title="删除括号()两边多余空格"></a>删除括号()两边多余空格</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--unpad-paren  OR  -U</span><br></pre></td></tr></table></figure>
<h3 id="空行分隔没有关系的块-类-标签-不包括函数块"><a href="#空行分隔没有关系的块-类-标签-不包括函数块" class="headerlink" title="空行分隔没有关系的块,类,标签(不包括函数块)"></a>空行分隔没有关系的块,类,标签(不包括函数块)</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--break-blocks  OR  -f</span><br></pre></td></tr></table></figure>
<h3 id="空行分隔无关系的块-包括else-catch等"><a href="#空行分隔无关系的块-包括else-catch等" class="headerlink" title="空行分隔无关系的块,包括else catch等"></a>空行分隔无关系的块,包括else catch等</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--break-blocks=all  OR  -F</span><br></pre></td></tr></table></figure>
<h3 id="删除多余空行"><a href="#删除多余空行" class="headerlink" title="删除多余空行"></a>删除多余空行</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--delete-empty-lines  OR  -x</span><br></pre></td></tr></table></figure>
<h3 id="Tab转换为空格"><a href="#Tab转换为空格" class="headerlink" title="Tab转换为空格"></a>Tab转换为空格</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--convert-tabs  OR  -c</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><span class="exturl" data-url="aHR0cDovL3d3dy5jbmJsb2dzLmNvbS90ZmFuYWx5c2lzL2FydGljbGVzLzQ4NzQ3OTMuaHRtbA==">Astyle编程语言格式化工具的中文说明<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>程序设计</category>
        <category>代码风格</category>
      </categories>
      <tags>
        <tag>编码</tag>
      </tags>
  </entry>
  <entry>
    <title>【转】micro2440 移植boa服务器</title>
    <url>/post/62852.html</url>
    <content><![CDATA[<p>Boa是一种非常小巧的Web服务器，其可执行代码只有大约60KB左右。作为一种单任务Web服务器，Boa只能依次完成用户的请求，而不会fork出新的进程来处理并发连接请求。但Boa支持CGI，能够为CGI程序fork出一个进程来执行。Boa的设计目标是速度和安全。<br>　　<br>下面结合网上一些文档,及自己的实验给大家介绍一下Boa服务器移植的具体操作步骤。<br>　　<br>环境<br>    主机：redhat linux<br>    目标：Micro2440开发板</p>
 <!---more--->
<h3 id="1-下载Boa源码"><a href="#1-下载Boa源码" class="headerlink" title="1.下载Boa源码"></a>1.下载Boa源码</h3><p>下载地址: <span class="exturl" data-url="aHR0cDovL3d3dy5ib2Eub3JnLw==">http://www.boa.org/<i class="fa fa-external-link-alt"></i></span><br>最新发行版本： 0.94.13<br>下载 boa-0.94.13.tar.gz<br>将其拷贝到&#x2F;opt&#x2F;FriendlyARM&#x2F;boa文件夹（自己创建的FriendlyARM&#x2F;boa目录）解压：# tar xzf boa-0.94.13.tar.gz</p>
<h3 id="2-修改文件"><a href="#2-修改文件" class="headerlink" title="2.修改文件"></a>2.修改文件</h3><h4 id="1-修改boa-0-94-13的-src-x2F-compat-h文件"><a href="#1-修改boa-0-94-13的-src-x2F-compat-h文件" class="headerlink" title="(1)修改boa-0.94.13的 src&#x2F;compat.h文件"></a>(1)修改boa-0.94.13的 src&#x2F;compat.h文件</h4><p>　　找到</p>
<pre><code>    #define TIMEZONE_OFFSET(foo) foo##-&gt;tm_gmtoff
</code></pre>
<p>　　修改成</p>
<pre><code>    #define TIMEZONE_OFFSET(foo) (foo)-&gt;tm_gmtoff
</code></pre>
<p>　　否则会出现错误：</p>
<pre><code>    util.c:100:1: error: pasting &quot;t&quot; and &quot;-&gt;&quot; does not give a valid preprocessing token make: *** [util.o] 错误 1
</code></pre>
<h4 id="2-修改boa-0-94-13的src-x2F-log-c"><a href="#2-修改boa-0-94-13的src-x2F-log-c" class="headerlink" title="(2)修改boa-0.94.13的src&#x2F;log.c"></a>(2)修改boa-0.94.13的src&#x2F;log.c</h4><p>　　注释掉</p>
<pre><code>    if (dup2(error_log, STDERR_FILENO) == -1) &#123;
        DIE(&quot;unable to dup2 the error log&quot;);
    &#125;
</code></pre>
<p>　　为：</p>
<pre><code>    /*if (dup2(error_log, STDERR_FILENO) == -1) &#123;
    DIE(&quot;unable to dup2 the error log&quot;);
    &#125;*/
</code></pre>
<p>　　否则会出现错误：</p>
<pre><code>    log.c:73 unable to dup2 the error log:bad file deor
</code></pre>
<h4 id="3-修改boa-0-94-13的src-x2F-boa-c"><a href="#3-修改boa-0-94-13的src-x2F-boa-c" class="headerlink" title="(3)修改boa-0.94.13的src&#x2F;boa.c"></a>(3)修改boa-0.94.13的src&#x2F;boa.c</h4><p>　　注释掉下面两句话：</p>
<pre><code>    if (passwdbuf == NULL) &#123;
        DIE(”getpwuid”);
    &#125;
    if (initgroups(passwdbuf-&gt;pw_name, passwdbuf-&gt;pw_gid) == -1) &#123;
        DIE(”initgroups”);
    &#125;
</code></pre>
<p>　　为</p>
<pre><code>    #if 0
    if (passwdbuf == NULL) &#123;
        DIE(”getpwuid”);
    &#125;
    if (initgroups(passwdbuf-&gt;pw_name, passwdbuf-&gt;pw_gid) == -1) &#123;
        DIE(”initgroups”);
    &#125;
    #endif
</code></pre>
<p>　　否则会出现错误：</p>
<pre><code>    boa.c:211 - getpwuid: No such file or directory
</code></pre>
<p>　　注释掉下面语句：</p>
<pre><code>    if (setuid(0) != -1) &#123;
        DIE(”icky Linux kernel bug!”);
    &#125;
</code></pre>
<p>　　为<br>        #if 0<br>        if (setuid(0) !&#x3D; -1) {<br>            DIE(”icky Linux kernel bug!”);<br>        }<br>        #endif<br>　　否则会出现问题：<br>        boa.c:228 - icky Linux kernel bug!: No such file or directory</p>
<h3 id="3、生成Makefile文件"><a href="#3、生成Makefile文件" class="headerlink" title="3、生成Makefile文件"></a>3、生成Makefile文件</h3><p>　　执行：</p>
<p>　　#cd &#x2F;opt&#x2F;FriendlyARM&#x2F;boa&#x2F;boa-0.94.13&#x2F;src<br>　　#.&#x2F;configure</p>
<h3 id="4、修改Makefile"><a href="#4、修改Makefile" class="headerlink" title="4、修改Makefile"></a>4、修改Makefile</h3><p>　　#cd &#x2F;opt&#x2F;FriendlyARM&#x2F;boa&#x2F;boa-0.94.13&#x2F;src</p>
<p>　　vim Makefile</p>
<p>　　修改CC &#x3D; gcc 为 CC &#x3D; arm-linux-gcc<br>　　修改CPP &#x3D; gcc -E 为 CC &#x3D; arm-linux-gcc -E</p>
<h3 id="5、编译"><a href="#5、编译" class="headerlink" title="5、编译"></a>5、编译</h3><p>　　还是在&#x2F;opt&#x2F;FriendlyARM&#x2F;boa&#x2F;boa-0.94.13&#x2F;src目录下</p>
<pre><code>    #make

    ls -l boa
    -rwxr-xr-x 1 root root 189223 Jun 26 09:02 boa
</code></pre>
<p>　　然后为生成的二进制文件boa瘦身</p>
<pre><code>    arm-linux-strip boa

    ls -l boa
    -rwxr-xr-x 1 root root 59120 Jun 26 09:03 boa
</code></pre>
<p>　　可以发现boa的大小前后差距很大这为我们节省了很大的空间</p>
<h3 id="6、Boa的配置"><a href="#6、Boa的配置" class="headerlink" title="6、Boa的配置"></a>6、Boa的配置</h3><p>　　这一步的工作也在电脑虚拟机上完成。<br>　　在boa-0.94.13目录下已有一个示例boa.conf，可以在其基础上进行修改。如下：</p>
<p>　　#vi boa.conf</p>
<h4 id="1-Group的修改"><a href="#1-Group的修改" class="headerlink" title="(1)Group的修改"></a>(1)Group的修改</h4><p>　　修改 Group nogroup<br>　　为 Group 0</p>
<h4 id="2-user的修改"><a href="#2-user的修改" class="headerlink" title="(2)user的修改"></a>(2)user的修改</h4><p>　　修改 User nobody<br>　　为 User 0<br>    或者统一设置为<br>        User root<br>        Group root</p>
<h4 id="3-ScriptAlias的修改"><a href="#3-ScriptAlias的修改" class="headerlink" title="(3)ScriptAlias的修改"></a>(3)ScriptAlias的修改</h4><p>　　修改ScriptAlias&#x2F;cgi-bin&#x2F; &#x2F;usr&#x2F;lib&#x2F;cgi-bin&#x2F;<br>　　为 ScriptAlias&#x2F;cgi-bin&#x2F; &#x2F;www&#x2F;cgi-bin&#x2F;</p>
<h4 id="5-DoucmentRoot的修改"><a href="#5-DoucmentRoot的修改" class="headerlink" title="(5)DoucmentRoot的修改"></a>(5)DoucmentRoot的修改</h4><p>　　修改DoucmentRoot &#x2F;var&#x2F;www<br>　　为DoucmentRoot &#x2F;www</p>
<h4 id="6-ServerName的设置"><a href="#6-ServerName的设置" class="headerlink" title="(6)ServerName的设置"></a>(6)ServerName的设置</h4><p>　　修改#ServerName <span class="exturl" data-url="aHR0cDovL3d3dy55b3VyLm9yZy5oZXJlLw==">www.your.org.here<i class="fa fa-external-link-alt"></i></span><br>　　为 ServerName <span class="exturl" data-url="aHR0cDovL3d3dy55b3VyLm9yZy5oZXJlLw==">www.your.org.here<i class="fa fa-external-link-alt"></i></span><br>　　否则会出现错误“gethostbyname::No such file or directory”</p>
<h4 id="7-AccessLog修改"><a href="#7-AccessLog修改" class="headerlink" title="(7)AccessLog修改"></a>(7)AccessLog修改</h4><p>　　修改AccessLog &#x2F;var&#x2F;log&#x2F;boa&#x2F;access_log<br>　　为#AccessLog &#x2F;var&#x2F;log&#x2F;boa&#x2F;access_log<br>否则会出现错误提示：“unable to dup2 the error log: Bad file deor”</p>
<h3 id="7、以下配置和boa-conf的配置有关，都是在mini2440开发板的ARM根文件系统中创建："><a href="#7、以下配置和boa-conf的配置有关，都是在mini2440开发板的ARM根文件系统中创建：" class="headerlink" title="7、以下配置和boa.conf的配置有关，都是在mini2440开发板的ARM根文件系统中创建："></a>7、以下配置和boa.conf的配置有关，都是在mini2440开发板的ARM根文件系统中创建：</h3><p>　　创建目录&#x2F;etc&#x2F;boa并且把主机的boa可执行文件（&#x2F;opt&#x2F;FriendlyARM&#x2F;boa&#x2F;boa-0.94.13&#x2F;src） 和 boa.conf（&#x2F;opt&#x2F;FriendlyARM&#x2F;boa&#x2F;boa-0.94.13）拷贝到这个目录下</p>
<p>　　#mkdir &#x2F;etc&#x2F;boa</p>
<p><strong>注</strong>：boa.conf配置文件必须放在&#x2F;etc&#x2F;boa中。boa可执行文件位置可随意，否则启动boa将报错。</p>
<blockquote>
<p>Could not chdir to “&#x2F;etc&#x2F;boa”: aborting</p>
</blockquote>
<p>　　创建HTML文档的主目录&#x2F;www</p>
<p>　　#mkdir &#x2F;www</p>
<p>　　创建CGI脚本所在录 &#x2F;www&#x2F;cgi-bin</p>
<pre><code>    #mkdir /www/cgi-bin

在www下添加测试主页index.html

    &lt;head&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot;&gt;
    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=gb2312&quot; /&gt;
    &lt;title&gt;Test Boa&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        Hello BOA&lt;br&gt;
    &lt;/body&gt;
    &lt;/html&gt;


创建日志文件夹 /var/log

    #mkdir /var/log
</code></pre>
<h3 id="8-执行boa服务器"><a href="#8-执行boa服务器" class="headerlink" title="8.执行boa服务器"></a>8.执行boa服务器</h3><p>进入&#x2F;etc&#x2F;boa目录，修改boa的执行权限，</p>
<pre><code>    #chmod +x boa
    #./boa
</code></pre>
<p>开启boa</p>
<h3 id="9-在windows-xp-ie输入开发板的ip（http-192-168-1-230）地址，即可访问到mini2440的默认网页。"><a href="#9-在windows-xp-ie输入开发板的ip（http-192-168-1-230）地址，即可访问到mini2440的默认网页。" class="headerlink" title="9.在windows xp ie输入开发板的ip（http://192.168.1.230）地址，即可访问到mini2440的默认网页。"></a>9.在windows xp ie输入开发板的ip（<span class="exturl" data-url="aHR0cDovLzE5Mi4xNjguMS4yMzAp5Zyw5Z2ALOWNs+WPr+iuv+mXruWIsG1pbmkyNDQw55qE6buY6K6k572R6aG1Li8=">http://192.168.1.230）地址，即可访问到mini2440的默认网页。<i class="fa fa-external-link-alt"></i></span></h3>]]></content>
      <categories>
        <category>系统应用</category>
        <category>boa</category>
      </categories>
      <tags>
        <tag>arm</tag>
        <tag>boa</tag>
      </tags>
  </entry>
  <entry>
    <title>boa服务器的配置与cgic移植</title>
    <url>/post/54877.html</url>
    <content><![CDATA[<p>上次在开发板上成功移植完boa服务器，最近使用C语言进行CGI编程，只在宿主机上搭建CGI的测试环境。</p>
<h3 id="BOA服务器的配置："><a href="#BOA服务器的配置：" class="headerlink" title="BOA服务器的配置："></a>BOA服务器的配置：</h3><blockquote>
<p>Port：boa服务器监听的端口，默认的端口是80。如果端口小于1024，则必须是  root用户启动服务器。</p>
</blockquote>
<blockquote>
<p>Listen：绑定的ip地址。不使用这个参数时，将绑定所有的地址。</p>
</blockquote>
<blockquote>
<p><strong>User</strong>：连接到服务器的客户端的身份，可以是用户名或UID。</p>
</blockquote>
<blockquote>
<p><strong>Group</strong>：连接到服务器的客户端的组，可以是组名或GID。</p>
</blockquote>
<blockquote>
<p>ServerAdmin：服务器出故障时要通知的邮箱地址。</p>
</blockquote>
<!---more--->

<blockquote>
<p>ErrorLog：指定错误日志文件。如果路径没有以”&#x2F;“开始，则相对于ServerRoot路径。没有配置时默 认的文件是&#x2F;dev&#x2F;stderr。若不想记录日志，指定文件为&#x2F;dev&#x2F;null。</p>
</blockquote>
<blockquote>
<p><strong>AccessLog</strong>：设置存取日志文件，与ErrorLog类似。</p>
</blockquote>
<blockquote>
<p>UseLocaltime：设置使用本地时间，使用UTC时注释这个参数。这个参数没有值。</p>
</blockquote>
<blockquote>
<p>VerboseCGILogs：在错误日志文件中记录CGI启动和停止时间，若不记录，注释这个参数。这个参数没有值。</p>
</blockquote>
<blockquote>
<p>ServerName：指定服务器的名称，当客户端使用gethostname + gethostbyname时返回给客户端。</p>
</blockquote>
<blockquote>
<p>VirtualHost：虚拟主机开关。使用此参数，则会在DocumentRoot设定的目录添加一个ip地址作为新的DocumentRoot来处理客户端的请求。如DocumentRoot设置为&#x2F;var&#x2F;www，则<span class="exturl" data-url="aHR0cDovL2xvY2FsaG9zdC8lRTglQkQlQUMlRTYlOEQlQTI=">http://localhost/转换<i class="fa fa-external-link-alt"></i></span> 成&#x2F;var&#x2F;www&#x2F;127.0.0.1&#x2F;，若注释此参数，则为&#x2F;var&#x2F;www&#x2F;。</p>
</blockquote>
<blockquote>
<p><strong>DocumentRoot</strong>：HTML文件的根目录（也就是网站的目录,使用yum安装的话，为&#x2F;var&#x2F;www&#x2F;boa&#x2F;html）。</p>
</blockquote>
<blockquote>
<p>DirectoryIndex：网站访问的第一个网页，默认是index.html（如果使用yum安装的话，地址为：&#x2F;var&#x2F;www&#x2F;boa&#x2F;html&#x2F;index.html ）</p>
</blockquote>
<blockquote>
<p>UserDir：指定用户目录。</p>
</blockquote>
<blockquote>
<p>DirectoryIndex：指定预生成目录信息的文件，注释此变量将使用DirectoryMaker变量。这个变量也就是设置默认主页的文件名。</p>
</blockquote>
<blockquote>
<p>DirectoryMaker：指定用于生成目录的程序，注释此变量将不允许列目录。</p>
</blockquote>
<blockquote>
<p>DirectoryCache：当DirectoryIndex文件不存在，而DirecotryMaker又被注释掉时，将列出这个参数指定目录给客户端。</p>
</blockquote>
<blockquote>
<p>KeepAliveMax：每个连接允许的请求数量。如果将此值设为” 0 “，将不限制请求的数目。</p>
</blockquote>
<blockquote>
<p>KeepAliveTimeOut：在关闭持久连接前等待下一个请求的秒数。（秒）。</p>
</blockquote>
<blockquote>
<p>MimeTypes：设置包含mimetypes信息的文件，一般是&#x2F;etc&#x2F;mime.types。</p>
</blockquote>
<blockquote>
<p>DefaultType：默认的mimetype类型，一般是text&#x2F;html。</p>
</blockquote>
<blockquote>
<p>CGIPath：相当于给CGI程序使用的$PATH变量。</p>
</blockquote>
<blockquote>
<p>SinglePostLimit：一次POST允许最大的字节数，默认是1MB。</p>
</blockquote>
<blockquote>
<p>AddType: 增加MimeType没有指定的类型，例: AddType type extension [extension …]。要使用cgi，必须添加cgi类型：AddType application&#x2F;x-httpd-cgi cgi</p>
</blockquote>
<blockquote>
<p>Redirect：重定向文件。</p>
</blockquote>
<blockquote>
<p>Aliases：指定路径的别名。</p>
</blockquote>
<blockquote>
<p><em><strong>ScriptAlias</strong></em>：指定脚本路径的虚拟路径。</p>
</blockquote>
<p>移植boa配置文件只修改强调的部分，具体修改方法参考转载的上文。</p>
<h2 id="移植CGIC库"><a href="#移植CGIC库" class="headerlink" title="移植CGIC库"></a>移植CGIC库</h2><h3 id="1-下载cgic库源码"><a href="#1-下载cgic库源码" class="headerlink" title="1.下载cgic库源码"></a>1.<a href="/src/cgic205.tar.gz">下载</a>cgic库源码</h3><h3 id="2-解压"><a href="#2-解压" class="headerlink" title="2.解压"></a>2.解压</h3><pre><code>    #tar zxvf cgic205.tar.gz
</code></pre>
<h3 id="3-修改Markfile"><a href="#3-修改Markfile" class="headerlink" title="3.修改Markfile"></a>3.修改Markfile</h3><h4 id="编译器"><a href="#编译器" class="headerlink" title="编译器"></a>编译器</h4><h5 id="ARM开发板移植"><a href="#ARM开发板移植" class="headerlink" title="ARM开发板移植"></a>ARM开发板移植</h5><pre><code>    CC=arm-linux-gcc
    AR=arm-linux-ar
    RANLIB=arm-linux-ranlib
</code></pre>
<h5 id="宿主机测试"><a href="#宿主机测试" class="headerlink" title="宿主机测试"></a>宿主机测试</h5><pre><code>    CC=gcc
    AR=ar
    RANLIB=ranlib
</code></pre>
<h4 id="markfile部分"><a href="#markfile部分" class="headerlink" title="markfile部分"></a>markfile部分</h4><pre><code>    gcc cgictest.o -o cgictest.cgi $&#123;LIBS&#125;
</code></pre>
<p>修改为：</p>
<pre><code>    $(CC) $(CFLAGS) cgictest.o -o cgictest.cgi $&#123;LIBS&#125;

    gcc capture.o -o capture $&#123;LIBS&#125;
</code></pre>
<p>修改为：</p>
<pre><code>    $(CC) $(CFLAGS) capture.o -o capture $&#123;LIBS&#125;
</code></pre>
<p>宿主机测试只是为了练习CGI编写。</p>
<h2 id="遇到的错误"><a href="#遇到的错误" class="headerlink" title="遇到的错误"></a>遇到的错误</h2><h3 id="1-在宿主机上测试安装CGIC时，修改了Markfile的编译器CC选项为arm-linux-gcc"><a href="#1-在宿主机上测试安装CGIC时，修改了Markfile的编译器CC选项为arm-linux-gcc" class="headerlink" title="1.在宿主机上测试安装CGIC时，修改了Markfile的编译器CC选项为arm-linux-gcc"></a>1.在宿主机上测试安装CGIC时，修改了Markfile的编译器CC选项为arm-linux-gcc</h3><blockquote>
<p>出现502错误：The CGI was not CGI&#x2F;1.1 compliant.</p>
</blockquote>
<p>整了我好长时间<br>主要还是不细心，同时在遇到问题解决问题的时候不应该盲目，为了解决错误而去找答案<br>应该先捋一捋自己做事的过程，看看有没有出差。</p>
]]></content>
      <categories>
        <category>系统应用</category>
        <category>boa</category>
      </categories>
      <tags>
        <tag>boa</tag>
        <tag>cgic</tag>
      </tags>
  </entry>
  <entry>
    <title>用户空间的GPIO操作</title>
    <url>/post/50599.html</url>
    <content><![CDATA[<p>用户空间的GPIO的操作</p>
<span id="more"></span>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">cd</span> sys/class/gpio/</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">ls</span></span></span><br><span class="line">export      gpiochip0   gpiochip32  gpiochip64  gpiochip96  unexport</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">echo</span> 33 &gt; <span class="built_in">export</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">ls</span></span></span><br><span class="line">export      gpiochip0   gpiochip64  unexport</span><br><span class="line">gpio33      gpiochip32  gpiochip96</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">cd</span> gpio33/</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">ls</span></span></span><br><span class="line">active_low  edge        subsystem   value</span><br><span class="line">direction   power       uevent</span><br></pre></td></tr></table></figure>

<h2 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h2><blockquote>
<p>support “in” and “out”</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo &quot;in&quot; &gt; direction</span><br></pre></td></tr></table></figure>

<h2 id="GPIO中断"><a href="#GPIO中断" class="headerlink" title="GPIO中断"></a>GPIO中断</h2><blockquote>
<p>support “both” or “none”, “rising”, “falling” edge trigger”</p>
</blockquote>
<p>上升沿中断</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo &quot;rising&quot; &gt; edge</span><br></pre></td></tr></table></figure>

<p>下降沿中断</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo &quot;falling&quot; &gt; edge</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>系统应用</category>
        <category>gpio</category>
      </categories>
      <tags>
        <tag>gpio</tag>
      </tags>
  </entry>
  <entry>
    <title>mini2440基于boa服务器通过web控制gpio</title>
    <url>/post/63421.html</url>
    <content><![CDATA[<p>本文是基于BOA服务器，通过CGI（通用网管接口）控制开发板的GPIO。CGI通用网关接口是一个Web服务器主机提供信息服务的标准接口。通过CGI接口，Web服务器就能够获取客户端提交的信息，转交给服务器端的CGI程序进行处理，最后返回结果给客户端。</p>
<p>在这里以控制LED为例。</p>
<p><img data-src="/images/boa-led.png" alt="led控制图"></p>
<!---more--->

<h3 id="1-客户端控制界面"><a href="#1-客户端控制界面" class="headerlink" title="1.客户端控制界面"></a>1.客户端控制界面</h3><p>采用CGI将浏览器端的控制信息传到boa服务器端,index.html文件</p>
<pre><code>    &lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;
    &lt;head&gt;
    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;
    &lt;title&gt;web控制mini2440开发板led&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
    &lt;h1 align=&quot;center&quot;&gt;基于mini2440的web控制GPIO口&lt;/h1&gt;
    &lt;form action=&quot;/cgi-bin/cgi_led.cgi&quot; method=&quot;get&quot;&gt;
    &lt;p align=&quot;center&quot;&gt;led的测试工作&lt;/p&gt;
    &lt;p align=&quot;center&quot;&gt;请输入需要控制的led &lt;input type=&quot;text&quot; name=&quot;led_control&quot;/&gt;&lt;/p&gt;
    &lt;p align=&quot;center&quot;&gt;请输入控制led的动作 &lt;input type=&quot;text&quot; name=&quot;led_state&quot;/&gt;&lt;/p&gt;
    &lt;p align=&quot;center&quot;&gt;&lt;input type=&quot;submit&quot; value=&quot;sure&quot;/&gt;
    &lt;input type=&quot;reset&quot; value=&quot;back&quot;/&gt;
    &lt;/p&gt;
    &lt;/form&gt;
    &lt;/body&gt;
    &lt;/html&gt;
</code></pre>
<p><img data-src="/images/boa-led-web.png" alt="web截图"></p>
<h3 id="2-服务器端数据处理"><a href="#2-服务器端数据处理" class="headerlink" title="2.服务器端数据处理"></a>2.服务器端数据处理</h3><p>通过客户端浏览器的from表单将，控制信息提交到服务器，服务器获取数据并通过有名管道将控制数据传给调用LED驱动的控制程序。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MYFIFO <span class="string">&quot;/www/myfifo&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_BUFFER_SIZE PIPE_BUF</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span>* data;   <span class="comment">//定义一个指针用于指向QUERY_STRING存放的内容</span></span><br><span class="line">    <span class="type">char</span> buff[MAX_BUFFER_SIZE];</span><br><span class="line">    <span class="type">int</span> fd, nwrite;</span><br><span class="line">    <span class="type">int</span> led_control, led_state;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Content-type: text/html\n\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&lt;html&gt;\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&lt;head&gt;&lt;title&gt;cgi led demo&lt;/title&gt;&lt;/head&gt;\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&lt;body&gt;\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&lt;p&gt;led is setted successful! you can watch the led&#x27;s change&lt;/p&gt;\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&lt;p&gt;&lt;a herf=index.html&gt;&lt;button&gt;get back&lt;/button&gt;&lt;/a&gt;&lt;/p&gt;\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&lt;/body&gt;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    data = getenv(<span class="string">&quot;QUERY_STRING&quot;</span>);   <span class="comment">//getenv()读取环境变量的当前值的函数</span></span><br><span class="line">    <span class="built_in">strcpy</span>(buff, data);</span><br><span class="line">    fd = open(MYFIFO, O_WRONLY);</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span> == fd)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Open fifo file error\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>((nwrite = write(fd, buff, <span class="keyword">sizeof</span>(buff))) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\nWrite data error\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">sscanf</span>(buff,<span class="string">&quot;led_control=%d&amp;led_state=%d&quot;</span>,&amp;led_control,&amp;led_state)!=<span class="number">2</span>)</span><br><span class="line">    &#123;   <span class="comment">//利用sscnaf（）函数的特点将环境变量分别提取出led_control和led_state这两个值</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;&lt;p&gt;please input right&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;&lt;/p&gt;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&lt;p&gt;led_control = %d,led_state =  %d&lt;/p&gt;&quot;</span>, led_control, led_state);</span><br><span class="line">    <span class="keyword">if</span>(led_control&gt;<span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;&lt;p&gt;Please input 0&lt;=led_control&lt;=3!&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;&lt;/p&gt;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(led_state&gt;<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;&lt;p&gt;Please input 0&lt;=led_state&lt;=1!&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;&lt;/p&gt;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&lt;/html&gt;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-控制端（GPIO驱动调用）"><a href="#3-控制端（GPIO驱动调用）" class="headerlink" title="3.控制端（GPIO驱动调用）"></a>3.控制端（GPIO驱动调用）</h3><p>通过管道接受到控制数据，调用驱动程序实现对LED灯的控制</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/micro2440_leds.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MYFIFO <span class="string">&quot;/www/myfifo&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LEDS_DEVICE  <span class="string">&quot;/dev/led4s&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_BUFFER_SIZE PIPE_BUF</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> led_fd, fifo_fd, led_control,led_state, nread;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">leds_stat</span> <span class="title">oneStat</span>;</span></span><br><span class="line">    <span class="type">char</span> buff[MAX_BUFFER_SIZE];  <span class="comment">//定义一个指针用于指向QUERY_STRING存放的内容</span></span><br><span class="line">    led_fd = open(LEDS_DEVICE, O_RDWR);  <span class="comment">//打开led设备</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span> == led_fd)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;open led device&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span> == access(MYFIFO, F_OK))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>((mkfifo(MYFIFO, <span class="number">0666</span>) &lt; <span class="number">0</span>) &amp;&amp; (errno != EEXIST))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Connot create fifo file\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    fifo_fd = open(MYFIFO, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span> == fifo_fd)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;open fifo file error\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//memset(buff, 0, sizeof(buff));使用会使控制数据出错</span></span><br><span class="line">        <span class="keyword">if</span>((nread = read(fifo_fd, buff, <span class="keyword">sizeof</span>(buff))) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;Read data error&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">sscanf</span>(buff,<span class="string">&quot;led_control=%d&amp;led_state=%d&quot;</span>,&amp;led_control,&amp;led_state)!=<span class="number">2</span>)</span><br><span class="line">        &#123;   <span class="comment">//利用sscnaf（）函数的特点将环境变量分别提取出led_control和led_state这两个值</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;please input right \n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(led_control&gt;<span class="number">3</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Please input 0&lt;=led_control&lt;=3!&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(led_state&gt;<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Please input 0&lt;=led_state&lt;=1!&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        oneStat.led_nr = led_control;</span><br><span class="line">        oneStat.led_st = led_state;</span><br><span class="line">        ioctl(led_fd, LEDS_SET_ONE, &amp;oneStat);</span><br><span class="line">    &#125;</span><br><span class="line">    close(led_fd);</span><br><span class="line">    close(fifo_fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h3><p>本文主要参考<span class="exturl" data-url="aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcnd6aG91MS9hcnRpY2xlL2RldGFpbHMvMjMzODE4MTE=">http://blog.csdn.net/rwzhou1/article/details/23381811<i class="fa fa-external-link-alt"></i></span>，采用管道的方式将数据的获取与功能的实现分离，更有利于对GPIO的控制。由于对LED驱动自己编写的跟上文中的有所不同，只有通过管道的方式实现。</p>
<p>在使用GET获取环境变量时，只能将getenv(“QUERY_STRING”);赋予字符指针，不能使用使用字符数组。</p>
<p>在使用管道的时候，由于管道数据传输为半双通因此在管道的两端只能赋予某一种权限，如读端以只读权限打开，写端以只写权限打开。如果某一端以读写权限打开程序将一直阻塞数据无法传输（刚开始习惯性的当做文件，直接以读写权限打开出错）。</p>
<p>控制端从管道读取数据时，将数据保存到字符数组中。在读取之前不能使用memset(buff, 0, sizeof(buff));函数将数组清零，如果数组清零接受到的数据与发送的数据信息相同，但大小不同会在数据解析的时候会出错，无法实现控制。</p>
]]></content>
      <categories>
        <category>系统应用</category>
        <category>s3c2440</category>
      </categories>
      <tags>
        <tag>boa</tag>
        <tag>s3c2440</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title>rt73网卡的移植</title>
    <url>/post/58471.html</url>
    <content><![CDATA[<p>经过对RT73类网卡驱动源码的几次编译，修改了多出报错信息之后，还是无法完成移植。最终还是用了友善之臂提供的<a href="/src/toolchains/usb-wifi-kits-for-mini2440-linux-2.6.32.2-20100728.tar.gz">usb-wifi-kits-for-mini2440-linux-2.6.32.2-20100728.tar.gz</a>工具集。</p>
<pre><code>#tar zxvf usb-wifi-kits-for-mini2440-linux-2.6.32.2-20100728.tar.gz -C /
</code></pre>
<!---more--->
<p>根据友善之臂提供的<a href="/src/toolchains/%E5%9F%BA%E4%BA%8Emini2440%E7%9A%84USB%E6%97%A0%E7%BA%BF%E7%BD%91%E5%8D%A1%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97-20100729.pdf">文档</a>，解压完直接使用scan-wifi、start-wifi等命令就可以使用该无线网卡，可是我使用scan-wifi时搜索不到任何热点。</p>
<p>最后在网上找根据这篇<span class="exturl" data-url="aHR0cDovL2xpbnV4LmNoaW5hdW5peC5uZXQvdGVjaGRvYy9pbnN0YWxsLzIwMDkvMDMvMjYvMTEwNTg1OC5zaHRtbA==">文章<i class="fa fa-external-link-alt"></i></span>,给开发板安装了<a href="/src/toolchains/wireless_tools.29.tar.gz">iwconfig</a>工具，并重新配置了一下。</p>
<pre><code># ifconfig rausb0 inet 192.168.1.77 up
# route add default gw 192.168.1.1
# iwconfig rausb0 essid &quot;linuxer&quot;
# iwconfig rausb0 mode mananed
# iwconfig rausb0 channel 6
</code></pre>
<p>scan-wifi成功</p>
<p>这里做简单的记录为保存这几个工具，以备日后再用</p>
]]></content>
      <categories>
        <category>系统应用</category>
        <category>rt73</category>
      </categories>
      <tags>
        <tag>arm</tag>
        <tag>网卡</tag>
        <tag>rt73</tag>
      </tags>
  </entry>
  <entry>
    <title>NTP服务</title>
    <url>/post/12403.html</url>
    <content><![CDATA[<p>NTP是网络时间协议(Network Time Protocol)，它是用来同步网络中各个计算机的时间的协议。<br>通俗：Ntp是一种授时的软件<br>用途是把计算机的时钟同步到世界协调时UTC，其精度在<code>局域网内可达0.1ms</code>，在互联网上绝大多数的地方其精度可以达到<code>1-50ms</code>。</p>
<span id="more"></span>

<h2 id="搭建NTP-Server"><a href="#搭建NTP-Server" class="headerlink" title="搭建NTP Server"></a>搭建NTP Server</h2><h3 id="ubuntu-x2F-deepin平台安装"><a href="#ubuntu-x2F-deepin平台安装" class="headerlink" title="ubuntu&#x2F;deepin平台安装"></a>ubuntu&#x2F;deepin平台安装</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get install ntp</span><br></pre></td></tr></table></figure>

<h3 id="配置NTP"><a href="#配置NTP" class="headerlink" title="配置NTP"></a>配置NTP</h3><p>修改<code>/etc/ntp.conf</code>文件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/ntp.conf</span><br><span class="line"></span><br><span class="line">driftfile /var/lib/ntp/ntp.drift</span><br><span class="line">statistics loopstats peerstats clockstats</span><br><span class="line">filegen loopstats file loopstats type day enable</span><br><span class="line">filegen peerstats file peerstats type day enable</span><br><span class="line">filegen clockstats file clockstats type day enable</span><br><span class="line">server ntp.ubuntu.com</span><br><span class="line">restrict -4 default kod notrap nomodify nopeer noquery</span><br><span class="line">restrict -6 default kod notrap nomodify nopeer noquery</span><br><span class="line">restrict 192.168.1.0 mask 255.255.255.0 nomodify   #&lt;+++++主要是允许能同步的服务器所在的内部网段</span><br><span class="line">restrict 127.0.0.1</span><br><span class="line">restrict ::1V</span><br></pre></td></tr></table></figure>

<h4 id="权限设定部分"><a href="#权限设定部分" class="headerlink" title="权限设定部分"></a>权限设定部分</h4><p>权限设定主要以<code>restrict</code>这个参数来设定，主要的语法为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">restrict IP mask netmask_IP parameter</span><br></pre></td></tr></table></figure>
<blockquote>
<p>其中IP可以是软体位址，也可以是 default ，default 就类似0.0.0.0<br>如果 paramter完全没有设定，那就表示该 IP (或网域) 『没有任何限制！』</p>
</blockquote>
<p>paramter:</p>
<ul>
<li>ignore：关闭所有的NTP 连线服务</li>
<li>nomodify：表示Client 端不能更改 Server 端的时间参数，不过Client端仍然可以透过Server 端來进行网络较时。</li>
<li>notrust：该 Client 除非通过认证，否则该 Client 来源将被视为不信任网域</li>
<li>noquery：不提供 Client 端的时间查询</li>
</ul>
<h3 id="重启NTP服务"><a href="#重启NTP服务" class="headerlink" title="重启NTP服务"></a>重启NTP服务</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo /etc/init.d/ntp restart</span><br></pre></td></tr></table></figure>

<h3 id="使用-对时"><a href="#使用-对时" class="headerlink" title="使用-对时"></a>使用-对时</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ntpdate cn.pool.ntp.org</span><br></pre></td></tr></table></figure>

<h2 id="移植NTP服务"><a href="#移植NTP服务" class="headerlink" title="移植NTP服务"></a>移植NTP服务</h2><p>移植其中包括客户端和服务端</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">wget https://www.eecis.udel.edu/~ntp/ntp_spool/ntp4/ntp-4.2/ntp-4.2.8p11.tar.gz</span><br><span class="line">tar zxvf ntp-4.2.8p11.tar.gz</span><br><span class="line">cd ntp-4.2.8p11</span><br><span class="line">PWD=`pwd`</span><br><span class="line">echo &quot;xxxxxxxxxxxx$PWD&quot;</span><br><span class="line">rm $PWD/install -rf</span><br><span class="line">mkdir $PWD/install</span><br><span class="line">echo &quot;./configure --host=arm-linux CC=arm-gcc49-linux-gnueabi-gcc --prefix=$PWD/install/  --with-yielding-select=yes&quot;</span><br><span class="line">./configure --host=arm-linux CC=arm-gcc49-linux-gnueabi-gcc --prefix=$PWD/install/  --with-yielding-select=yes</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>

<h3 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ntpdate 192.168.1.11</span><br></pre></td></tr></table></figure>

<h3 id="修改时区"><a href="#修改时区" class="headerlink" title="修改时区"></a>修改时区</h3><blockquote>
<p>注意：用<code>date</code>命令查看之后显示的是UTC时间（世界标准时间），比北京时间（CST&#x3D;UTC+8）相差8个小时，所以需要设置时区</p>
</blockquote>
<p>设置时区为CST时间, 把redhat或者ubuntu系统目录<code>/usr/share/zoneinfo/Asia</code>中的文件<code>Shanghai</code>拷贝到开发板目录&#x2F;etc中并且改名为<code>localtime</code>之后，用命令reboot重启即可</p>
<h2 id="busybox–ntpd"><a href="#busybox–ntpd" class="headerlink" title="busybox–ntpd"></a>busybox–ntpd</h2><p><span class="exturl" data-url="aHR0cHM6Ly9lbGl4aXIuYm9vdGxpbi5jb20vYnVzeWJveC8xLjI4LjQvc291cmNlL2V4YW1wbGVzL3Zhcl9zZXJ2aWNlL250cGQ=">busybox:ntpd<i class="fa fa-external-link-alt"></i></span></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BusyBox v1.25.1 (2018-05-24 14:59:56 CST) multi-call binary.</span><br><span class="line"></span><br><span class="line">Usage: ntpd [-dnqNwl -I IFACE] [-S PROG] [-p PEER]...</span><br><span class="line"></span><br><span class="line">NTP client/server</span><br><span class="line"></span><br><span class="line">        -d      Verbose</span><br><span class="line">        -n      Do not daemonize</span><br><span class="line">        -q      Quit after clock is set</span><br><span class="line">        -N      Run at high priority</span><br><span class="line">        -w      Do not set time (only query peers), implies -n</span><br><span class="line">        -S PROG Run PROG after stepping time, stratum change, and every 11 mins</span><br><span class="line">        -p PEER Obtain time from PEER (may be repeated)</span><br><span class="line">        -l      Also run as server on port 123</span><br><span class="line">        -I IFACE Bind server to IFACE, implies -l</span><br></pre></td></tr></table></figure>

<h3 id="clinet"><a href="#clinet" class="headerlink" title="clinet"></a>clinet</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ntpd -p 192.168.1.11 -qNn</span><br></pre></td></tr></table></figure>
<h3 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ntpd -ddnNl</span><br></pre></td></tr></table></figure>

<h2 id="应用–RTP网络延时"><a href="#应用–RTP网络延时" class="headerlink" title="应用–RTP网络延时"></a>应用–RTP网络延时</h2><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><p>有A和B两个开发板并且通过WIFI直连（P2P）使用TCP协议搭建了RTP，使用RTP进行视频传输，计算其中的网络延时</p>
<blockquote>
<p>A — 服务器 — 接收端 — R<br>B — 客户端 — 发射端 — S</p>
</blockquote>
<h3 id="时间戳"><a href="#时间戳" class="headerlink" title="时间戳"></a>时间戳</h3><h4 id="打时间戳"><a href="#打时间戳" class="headerlink" title="打时间戳"></a>打时间戳</h4><p><code>gettimeofday</code>获取的时间存放在<code>unsigned long long</code>中需要64bit的空间</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">now</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> rtp_time_r = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">gettimeofday(&amp;now, <span class="literal">NULL</span>);</span><br><span class="line">rtp_time_r = <span class="number">1000000</span> * now.tv_sec + now.tv_usec;</span><br></pre></td></tr></table></figure>

<h4 id="long-long和char转换"><a href="#long-long和char转换" class="headerlink" title="long long和char转换"></a>long long和char转换</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> dst[<span class="number">30</span>];</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> rtpTime = <span class="number">0x1234567898765</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> rtp_time_s = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">56</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">memset</span>(dst, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="type">char</span>) * <span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>;  i &lt; <span class="keyword">sizeof</span>(rtpTime);  i++) &#123;</span><br><span class="line">		dst[<span class="number">19</span> - i] = （<span class="type">unsigned</span> <span class="type">char</span>）((rtpTime &gt;&gt; j) &amp; <span class="number">0xFF</span>);</span><br><span class="line">		<span class="comment">//printf(&quot;===&gt; func: %s, line: %d, rtpTime: %016llx, %d, dst[%d]=%02x\n&quot;,</span></span><br><span class="line">				__func__, __LINE__, (rtpTime &gt;&gt; j) &amp; <span class="number">0xFF</span>, j, <span class="number">19</span> - i, dst[<span class="number">19</span> - i]);</span><br><span class="line">		j -= <span class="number">8</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//printf(&quot;===&gt; func: %s, line: %d\n&quot;, __func__, __LINE__);</span></span><br><span class="line">	j = <span class="number">56</span>;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>;  i &lt; <span class="keyword">sizeof</span>(rtp_time_s);  i++) &#123;</span><br><span class="line">		rtp_time_s |= (<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>)dst[<span class="number">19</span> - i] &lt;&lt; j;</span><br><span class="line">		j -= <span class="number">8</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;===&gt; func: %s, line: %d,  old: %016llx\n&quot;</span>, __func__, __LINE__, rtpTime);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;===&gt; func: %s, line: %d,  new: %016llx\n&quot;</span>, __func__, __LINE__, rtp_time_s);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>不同的gcc编译器，编译完的运行结果不一样，测试<code>gcc version 6.4.0 20170724 (Debian 6.4.0-2)</code>编译运行结果错误</p>
</blockquote>
<p>在嵌入式交叉编译中，测试结果正常：</p>
<blockquote>
<p>&#x3D;&#x3D;&#x3D;&gt; func: main, line: 38,  old: 0001234567898765<br>&#x3D;&#x3D;&#x3D;&gt; func: main, line: 39,  new: 0001234567898765</p>
</blockquote>
<h3 id="测试方法"><a href="#测试方法" class="headerlink" title="测试方法"></a>测试方法</h3><blockquote>
<p>一帧数据将会被拆分成多个RTP包进行传输</p>
</blockquote>
<ol>
<li>在S端对每一帧数据中的RTP打入相同的时间戳Ts</li>
<li>在R端将接收到的S端头中的时间戳解析Ts，并且此时获取R端的时间戳Tr</li>
<li>判断一帧的数据，并计算R和S的网络延时</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">t_count_t</span> = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> t_count_r = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> t_count_s = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> time_sum_r = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> time_sum_s = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">rtp_time_s_t</span> = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">rtp_time_r_t</span> = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> rtp_time_diff = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> rtp_time_max = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> rtp_time_min = <span class="number">0xffffff</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">parse_rtp_head_time</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *data, <span class="type">int</span> line)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">now</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> rtp_time_r = <span class="number">0</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> rtp_time_s = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1. 获取Ｓ端的时间戳</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">56</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>;  i &lt; <span class="keyword">sizeof</span>(rtp_time_s);  i++) &#123;</span><br><span class="line">        rtp_time_s |= (<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>)data[<span class="number">19</span> - i] &lt;&lt; j;</span><br><span class="line">        j -= <span class="number">8</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//2. 获取Ｒ端的时间戳</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;now, <span class="number">0</span>, <span class="keyword">sizeof</span>(now));</span><br><span class="line">    gettimeofday(&amp;now, <span class="literal">NULL</span>);</span><br><span class="line">    rtp_time_r = <span class="number">1000000</span> * now.tv_sec + now.tv_usec;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//3. 判断并计算一帧数据的时间</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="type">rtp_time_s_t</span> != rtp_time_s) &#123;</span><br><span class="line">        <span class="type">t_count_t</span>++;</span><br><span class="line">        <span class="keyword">if</span> (<span class="type">t_count_t</span> &gt; <span class="number">3000</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="type">rtp_time_r_t</span> &gt;= <span class="type">rtp_time_s_t</span>) &#123;</span><br><span class="line">                t_count_r++;</span><br><span class="line">                rtp_time_diff = <span class="type">rtp_time_r_t</span> - <span class="type">rtp_time_s_t</span>;</span><br><span class="line">                time_sum_r += rtp_time_diff;</span><br><span class="line">                rtp_time_max = (rtp_time_max &gt; rtp_time_diff) ? rtp_time_max : rtp_time_diff;</span><br><span class="line">                rtp_time_min = (rtp_time_min &lt; rtp_time_diff) ? rtp_time_min : rtp_time_diff;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                t_count_s++;</span><br><span class="line">                time_sum_s += (<span class="type">rtp_time_s_t</span> - <span class="type">rtp_time_r_t</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">rtp_time_s_t</span> = rtp_time_s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">rtp_time_r_t</span> = rtp_time_r;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//4. 判断一万帧数据后打印结果</span></span><br><span class="line">    <span class="keyword">if</span> (!(<span class="type">t_count_t</span> % <span class="number">10000</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%llu, t_count_r=%llu, time_sum_r=%llu, v=%llu, max:%llu, min:%llu\n&quot;</span>,</span><br><span class="line">                <span class="type">t_count_t</span>, t_count_r, time_sum_r, (t_count_r != <span class="number">0</span>) ? (time_sum_r / t_count_r):<span class="number">111111</span>, rtp_time_max, rtp_time_min);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%llu, t_count_s=%llu, time_sum_s=%llu, v=%llu\n&quot;</span>,</span><br><span class="line">                <span class="type">t_count_t</span>, t_count_s, time_sum_s, (t_count_s != <span class="number">0</span>) ? (time_sum_s / t_count_s):<span class="number">111111</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="操作流程"><a href="#操作流程" class="headerlink" title="操作流程"></a>操作流程</h3><ol>
<li>先启动Ｒ，并进行授时</li>
<li>启动Ｓ端，并进行授时</li>
<li>视频传输，等待计算结果</li>
</ol>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li>R端必须先启动授时，然后启动S端进行授时，方可进行正常的测试</li>
<li><strong>如果S端先进行授时，而R端后进行授时，那么在R端解析到的S端时间有可能比R端的时间小，导致计算出现负数（越界），最后的结果偏差离谱</strong></li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pncmprZmxta3ljL2FydGljbGUvZGV0YWlscy80NTA5ODgzMQ==">移植ntp服务到arm-linux平台<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vc21hcnR4dWNoYW8vcC82NDQwNTI0Lmh0bWw=">So Easy-Ntp嵌入式软件移植<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21tel94aWFva29uZy9hcnRpY2xlL2RldGFpbHMvODcwMDk3OQ==">ubuntu搭建NTP服务器<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>系统服务</category>
        <category>ntp</category>
      </categories>
      <tags>
        <tag>ntp</tag>
      </tags>
  </entry>
  <entry>
    <title>arm交叉编译工具</title>
    <url>/post/64642.html</url>
    <content><![CDATA[<h2 id="编译工具命名规则"><a href="#编译工具命名规则" class="headerlink" title="编译工具命名规则"></a>编译工具命名规则</h2><blockquote>
<p>交叉编译工具链的命名规则为：arch [-vendor] [-os] [-(gnu)eabi]</p>
</blockquote>
<ul>
<li>arch - 体系架构，如ARM，MIPS</li>
<li>vendor - 工具链提供商</li>
<li>os - 目标操作系统</li>
<li>eabi - 嵌入式应用二进制接口（Embedded Application Binary Interface）</li>
</ul>
<p>根据对操作系统的支持与否，ARM GCC可分为支持和不支持操作系统，如</p>
<!---more--->

<h3 id="arm-none-eabi："><a href="#arm-none-eabi：" class="headerlink" title="arm-none-eabi："></a>arm-none-eabi：</h3><p>这个是没有操作系统的，自然不可能支持那些跟操作系统关系密切的函数，比如fork(2)。他使用的是newlib这个专用于嵌入式系统的C库。<br>arm-none-linux-eabi：用于Linux的，使用Glibc</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="arm-none-eabi-gcc"><a href="#arm-none-eabi-gcc" class="headerlink" title="arm-none-eabi-gcc"></a>arm-none-eabi-gcc</h3><p>（ARM architecture，no vendor，not target an operating system，complies with the ARM EABI）<br>用于编译 ARM 架构的裸机系统（包括 ARM Linux 的 boot、kernel，不适用编译 Linux 应用 Application），一般适合 ARM7、Cortex-M 和 Cortex-R 内核的芯片使用，所以不支持那些跟操作系统关系密切的函数，比如fork(2)，他使用的是 newlib 这个专用于嵌入式系统的C库。</p>
<h3 id="arm-none-linux-gnueabi-gcc"><a href="#arm-none-linux-gnueabi-gcc" class="headerlink" title="arm-none-linux-gnueabi-gcc"></a>arm-none-linux-gnueabi-gcc</h3><p>(ARM architecture, no vendor, creates binaries that run on the Linux operating system, and uses the GNU EABI)<br>主要用于基于ARM架构的Linux系统，可用于编译 ARM 架构的 u-boot、Linux内核、linux应用等。arm-none-linux-gnueabi基于GCC，使用Glibc库，经过 Codesourcery 公司优化过推出的编译器。arm-none-linux-gnueabi-xxx 交叉编译工具的浮点运算非常优秀。一般ARM9、ARM11、Cortex-A 内核，带有 Linux 操作系统的会用到。</p>
<h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><h3 id="arm-none-eabi-gcc-1"><a href="#arm-none-eabi-gcc-1" class="headerlink" title="arm-none-eabi-gcc"></a>arm-none-eabi-gcc</h3><p>地址：<span class="exturl" data-url="aHR0cHM6Ly9sYXVuY2hwYWQubmV0L2djYy1hcm0tZW1iZWRkZWQ=">https://launchpad.net/gcc-arm-embedded<i class="fa fa-external-link-alt"></i></span><br><strong>注</strong>:在a8中使用该编译工具（gcc-arm-none-eabi-5_4-2016q2），编译uboot在uboot启动时，对nand进行初始化无法成功。</p>
<h3 id="arm-none-linux-gnueabi-gcc-1"><a href="#arm-none-linux-gnueabi-gcc-1" class="headerlink" title="arm-none-linux-gnueabi-gcc"></a>arm-none-linux-gnueabi-gcc</h3><p>Mentor官方下载地址（需要注册，注册之后官方会发送一个下载地址到邮箱里面）<br>地址：<span class="exturl" data-url="aHR0cDovL3d3dy5tZW50b3IuY29tL2VtYmVkZGVkLXNvZnR3YXJlL3NvdXJjZXJ5LXRvb2xzL3NvdXJjZXJ5LWNvZGViZW5jaC9ldmFsdWF0aW9ucy8=">http://www.mentor.com/embedded-software/sourcery-tools/sourcery-codebench/evaluations<i class="fa fa-external-link-alt"></i></span><br>网盘下载：<span class="exturl" data-url="aHR0cDovL3d3dy52ZXJ5YXJtLmNvbS9hcm0tbm9uZS1saW51eC1nbnVlYWJpLWdjYw==">http://www.veryarm.com/arm-none-linux-gnueabi-gcc<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>编译工具</category>
        <category>arm</category>
      </categories>
      <tags>
        <tag>arm</tag>
        <tag>交叉编译工具</tag>
      </tags>
  </entry>
  <entry>
    <title>Cmake中Build生成可执行文件与Install后可执行文件不是同一个文件</title>
    <url>/post/331f1334.html</url>
    <content><![CDATA[<p>cmake编译生成的可执行文件与Install后的文件不同：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ md5sum build/lib/libenc.so packages/aarch64/Debug/lib/libenc.so</span><br><span class="line">6bd8b76c426515112ab697db589dc229  build/lib/libenc.so</span><br><span class="line">8125674eaa256ece0e08373e758e3013  packages/aarch64/Debug/lib/libenc.so</span><br><span class="line"></span><br><span class="line">$ md5sum build/bin/enc_test packages/aarch64/Debug/bin/enc_test</span><br><span class="line">0753ff4ffe4a41e19058628dd3627de9  build/bin/enc_test</span><br><span class="line">1073ccf878e004045bc733630952e6c3  packages/aarch64/Debug/bin/enc_test</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>一般情况下这两个文件应该是相同的，Install时只是做了简单的文件拷贝。</p>
<p>这里存在差异主要原因是cmake时，对elf文件进行了修改将其中的<code>RUNPATH</code>移除了。</p>
<p><code>RUNPATH</code>: 指定运行时搜索库的路径。</p>
<h2 id="不用RUNPATH"><a href="#不用RUNPATH" class="headerlink" title="不用RUNPATH"></a>不用RUNPATH</h2><p>在cmake编译时，默认会添加<code>RUNPATH</code>，添加以下配置可以在Build阶段移除</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set(CMAKE_SKIP_BUILD_RPATH TRUE</span><br></pre></td></tr></table></figure>
<blockquote>
<p>将CMAKE_SKIP_BUILD_RPATH使能后，Build和Install后的elf文件将完全相同，都不包含<code>RUNPATH</code>配置</p>
</blockquote>
<p>在Cmake中相关RPATH的默认配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set(CMAKE_SKIP_BUILD_RPATH FALSE)                 # 编译时加上RPATH</span><br><span class="line">set(CMAKE_BUILD_WITH_INSTALL_RPATH FALSE)         # 编译时RPATH不使用安装的RPATH</span><br><span class="line">set(CMAKE_INSTALL_RPATH &quot;&quot;)                       # 安装RPATH为空</span><br><span class="line">set(CMAKE_INSTALL_RPATH_USE_LINK_PATH FALSE)      # 安装的执行文件不加上RPATH</span><br></pre></td></tr></table></figure>

<h2 id="patchelf"><a href="#patchelf" class="headerlink" title="patchelf"></a>patchelf</h2><p>可以使用<code>patchelf</code>工具对elf的RPATH进行设置或查看。</p>
<h2 id="动态库的加载顺序"><a href="#动态库的加载顺序" class="headerlink" title="动态库的加载顺序"></a>动态库的加载顺序</h2><p><code>man ld</code> ELF文件的链接顺序：</p>
<blockquote>
<p>The linker uses the following search paths to locate required shared libraries:</p>
<ol>
<li>Any directories specified by -rpath-link options.</li>
</ol>
</blockquote>
<pre><code>2.  Any directories specified by -rpath options.  The difference between -rpath and -rpath-link is that directories specified by -rpath options are included in the executable and used at runtime, whereas the -rpath-link option is only effective at link time. Searching -rpath in this way is only supported by native linkers and cross linkers which have been configured with the --with-sysroot option.
</code></pre>
<blockquote>
<ol start="3">
<li><p>On an ELF system, for native linkers, if the -rpath and -rpath-link options were not used, search the contents of the environment variable “LD_RUN_PATH”.</p>
</li>
<li><p>On SunOS, if the -rpath option was not used, search any directories specified using -L options.</p>
</li>
<li><p>For a native linker, search the contents of the environment variable “LD_LIBRARY_PATH”.</p>
</li>
<li><p>For a native ELF linker, the directories in “DT_RUNPATH” or “DT_RPATH” of a shared library are searched for shared libraries needed by it. The “DT_RPATH” entries are ignored if “DT_RUNPATH” entries exist.</p>
</li>
<li><p>The default directories, normally &#x2F;lib and &#x2F;usr&#x2F;lib.</p>
</li>
<li><p>For a native linker on an ELF system, if the file &#x2F;etc&#x2F;ld.so.conf exists, the list of directories found in that file.</p>
</li>
</ol>
<p> If the required shared library is not found, the linker will issue a warning and continue with the link.</p>
</blockquote>
]]></content>
      <categories>
        <category>编译工具</category>
        <category>cmake</category>
      </categories>
      <tags>
        <tag>cmake</tag>
      </tags>
  </entry>
  <entry>
    <title>GCC编译器的优化： fprefetch-loop-arrays</title>
    <url>/post/14105.html</url>
    <content><![CDATA[<blockquote>
<p>以MIPS架构为基础进行分析<br>预取指令：<code>pref</code></p>
</blockquote>
<p>指令预取，是指提前将所需要的数据取出来，在使用时可用</p>
<span id="more"></span>

<h2 id="for-loop"><a href="#for-loop" class="headerlink" title="for loop"></a>for loop</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">char</span> aa[<span class="number">4096</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">func</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">	__asm__ __volatile__(<span class="string">&quot;ssnop\n\t&quot;</span>);</span><br><span class="line">	__asm__ __volatile__(<span class="string">&quot;ssnop\n\t&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">4096</span>; i++) &#123;</span><br><span class="line">		aa[i] = i;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	__asm__ __volatile__(<span class="string">&quot;ssnop\n\t&quot;</span>);</span><br><span class="line">	__asm__ __volatile__(<span class="string">&quot;ssnop\n\t&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="编译："><a href="#编译：" class="headerlink" title="编译："></a>编译：</h3><blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;mips-linux-gnu-gcc -c for_loop.c -o for_loop.o</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="反汇编："><a href="#反汇编：" class="headerlink" title="反汇编："></a>反汇编：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mips-linux-gnu-objdump -d for_loop.o &gt; for_loop.s</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00000000 &lt;func&gt;:</span><br><span class="line">   0:   27bdffe8    addiu   sp,sp,-24</span><br><span class="line">   4:   afbe0014    sw  s8,20(sp)</span><br><span class="line">   8:   03a0f025    move    s8,sp</span><br><span class="line">   c:   00000040    ssnop</span><br><span class="line">  10:   00000040    ssnop</span><br><span class="line">  14:   afc00008    sw  zero,8(s8)</span><br><span class="line">  18:   1000000b    b   48 &lt;func+0x48&gt;</span><br><span class="line">  1c:   00000000    nop</span><br><span class="line">  20:   8fc20008    lw  v0,8(s8)</span><br><span class="line">  24:   304300ff    andi    v1,v0,0xff</span><br><span class="line">  28:   3c020000    lui v0,0x0</span><br><span class="line">  2c:   24440000    addiu   a0,v0,0</span><br><span class="line">  30:   8fc20008    lw  v0,8(s8)</span><br><span class="line">  34:   00821021    addu    v0,a0,v0</span><br><span class="line">  38:   a0430000    sb  v1,0(v0)</span><br><span class="line">  3c:   8fc20008    lw  v0,8(s8)</span><br><span class="line">  40:   24420001    addiu   v0,v0,1</span><br><span class="line">  44:   afc20008    sw  v0,8(s8)</span><br><span class="line">  48:   8fc20008    lw  v0,8(s8)</span><br><span class="line">  4c:   28421000    slti    v0,v0,4096</span><br><span class="line">  50:   1440fff3    bnez    v0,20 &lt;func+0x20&gt;</span><br><span class="line">  54:   00000000    nop</span><br><span class="line">  58:   00000040    ssnop</span><br><span class="line">  5c:   00000040    ssnop</span><br><span class="line">  60:   00001025    move    v0,zero</span><br><span class="line">  64:   03c0e825    move    sp,s8</span><br><span class="line">  68:   8fbe0014    lw  s8,20(sp)</span><br><span class="line">  6c:   27bd0018    addiu   sp,sp,24</span><br><span class="line">  70:   03e00008    jr  ra</span><br><span class="line">  74:   00000000    nop</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>for循环的优化，对大数组的赋值</p>
<p><code>-fprefetch-loop-arrays</code> 生成数组预读取指令，对于使用巨大数组的程序可以加快代码执行速度，适合数据库相关的大型软件等</p>
<p>gcc默认没有开预取指令的优化，需要通过<code>-O3</code></p>
<h3 id="编译：-1"><a href="#编译：-1" class="headerlink" title="编译："></a>编译：</h3><blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;mips-linux-gnu-gcc -c for_loop.c -o for_loop.o -O3 -fprefetch-loop-arrays</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="反汇编：-1"><a href="#反汇编：-1" class="headerlink" title="反汇编："></a>反汇编：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00000000 &lt;func&gt;:</span><br><span class="line">   0:   27bdff00    addiu   sp,sp,-256</span><br><span class="line">   4:   afbe00fc    sw  s8,252(sp)</span><br><span class="line">   ...</span><br><span class="line">  24:   afb000dc    sw  s0,220(sp)</span><br><span class="line">  28:   00000040    ssnop</span><br><span class="line">  2c:   00000040    ssnop</span><br><span class="line">  30:   3c020000    lui v0,0x0</span><br><span class="line">  34:   00002025    move    a0,zero</span><br><span class="line">  38:   00001825    move    v1,zero</span><br><span class="line">  3c:   24460000    addiu   a2,v0,0</span><br><span class="line">  40:   306200ff    andi    v0,v1,0xff</span><br><span class="line">  44:   afa20008    sw  v0,8(sp)</span><br><span class="line">  ...</span><br><span class="line">  a0:   afbe0054    sw  s8,84(sp)</span><br><span class="line">  a4:   24960019    addiu   s6,a0,25</span><br><span class="line">  a8:   00d7f021    addu    s8,a2,s7</span><br><span class="line">  ac:   93b70010    lbu s7,16(sp)</span><br><span class="line">  b0:   24820004    addiu   v0,a0,4</span><br><span class="line">  ...</span><br><span class="line">  424:   a0b40000    sb  s4,0(a1)</span><br><span class="line">  428:   8fa500a8    lw  a1,168(sp)</span><br><span class="line">  42c:   93b40010    lbu s4,16(sp)</span><br><span class="line">  430:   a0b40000    sb  s4,0(a1)</span><br><span class="line">  434:   8fa500ac    lw  a1,172(sp)</span><br><span class="line">  ...</span><br><span class="line">  474:   a12a0000    sb  t2,0(t1)</span><br><span class="line">  478:   a0e80000    sb  t0,0(a3)</span><br><span class="line">  47c:   a0450000    sb  a1,0(v0)</span><br><span class="line">  480:   24020fe0    li  v0,4064</span><br><span class="line">  484:   1462feee    bne v1,v0,40 &lt;func+0x40&gt;</span><br><span class="line">  488:   24051000    li  a1,4096</span><br><span class="line">  48c:   304400ff    andi    a0,v0,0xff</span><br><span class="line">  490:   00c21821    addu    v1,a2,v0</span><br><span class="line">  494:   24420001    addiu   v0,v0,1</span><br><span class="line">  498:   1445fffc    bne v0,a1,48c &lt;func+0x48c&gt;</span><br><span class="line">  49c:   a0640000    sb  a0,0(v1)</span><br><span class="line">  4a0:   00000040    ssnop</span><br><span class="line">  4a4:   00000040    ssnop</span><br><span class="line">  4a8:   00001025    move    v0,zero</span><br><span class="line">  4ac:   8fbe00fc    lw  s8,252(sp)</span><br><span class="line">  4b0:   8fb700f8    lw  s7,248(sp)</span><br><span class="line">  ...</span><br><span class="line">  4cc:   8fb000dc    lw  s0,220(sp)</span><br><span class="line">  4d0:   03e00008    jr  ra</span><br><span class="line">  4d4:   27bd0100    addiu   sp,sp,256</span><br><span class="line">   ...</span><br></pre></td></tr></table></figure>

<h2 id="for语句汇编"><a href="#for语句汇编" class="headerlink" title="for语句汇编"></a>for语句汇编</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, a;</span><br><span class="line"></span><br><span class="line">    __asm__  __volatile__(<span class="string">&quot;ssnop\n\t&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">88</span>; i++)</span><br><span class="line">        a = i;</span><br><span class="line">    __asm__  __volatile__(<span class="string">&quot;ssnop\n\t&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00000000 &lt;func&gt;:</span><br><span class="line">   0:   27bdffe8    addiu   sp,sp,-24</span><br><span class="line">   4:   afbe0014    sw  s8,20(sp)</span><br><span class="line">   8:   03a0f025    move    s8,sp</span><br><span class="line">   c:   00000040    ssnop</span><br><span class="line">  10:   afc00008    sw  zero,8(s8)		//1. i = 0;</span><br><span class="line">  14:   10000006    b   30 &lt;func+0x30&gt;	//2. 跳转到0x30，判断i,如果小于88进行（4）循环</span><br><span class="line">  18:   00000000    nop</span><br><span class="line">  1c:   8fc20008    lw  v0,8(s8)</span><br><span class="line">  20:   afc2000c    sw  v0,12(s8)</span><br><span class="line">  24:   8fc20008    lw  v0,8(s8)</span><br><span class="line">  28:   24420001    addiu   v0,v0,1	//3. i++</span><br><span class="line">  2c:   afc20008    sw  v0,8(s8)</span><br><span class="line">  30:   8fc20008    lw  v0,8(s8)</span><br><span class="line">  34:   28420058    slti    v0,v0,88</span><br><span class="line">  38:   1440fff8    bnez    v0,1c &lt;func+0x1c&gt;	//4. 如果i小于88,跳转到0x1c进行循环</span><br><span class="line">  3c:   00000000    nop</span><br><span class="line">  40:   00000040    ssnop</span><br><span class="line">  44:   00000000    nop</span><br><span class="line">  48:   03c0e825    move    sp,s8</span><br><span class="line">  4c:   8fbe0014    lw  s8,20(sp)</span><br><span class="line">  50:   27bd0018    addiu   sp,sp,24</span><br><span class="line">  54:   03e00008    jr  ra</span><br><span class="line">  58:   00000000    nop</span><br><span class="line">  5c:   00000000    nop</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>编译工具</category>
        <category>gcc</category>
      </categories>
      <tags>
        <tag>gcc</tag>
      </tags>
  </entry>
  <entry>
    <title>GCC</title>
    <url>/post/54464.html</url>
    <content><![CDATA[<p>GCC的使用和相关特性。</p>
<span id="more"></span>

<h2 id="API接口导出"><a href="#API接口导出" class="headerlink" title="API接口导出"></a>API接口导出</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">__attribute__((visibility(&quot;default&quot;)))</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> __GNUC__ &gt;= 4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TST_DLL_IMPORT __attribute__((visibility(<span class="string">&quot;default&quot;</span>)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TST_DLL_EXPORT __attribute__((visibility(<span class="string">&quot;default&quot;</span>)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TST_DLL_IMPORT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TST_DLL_EXPORT</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TST_API        TST_DLL_EXPORT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TST_API_IMPORT TST_DLL_IMPORT</span></span><br></pre></td></tr></table></figure>


<h2 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__builtin_xxx(x)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>GCC includes built-in versions of many of the functions in the standard C library. The versions prefixed with <code>__builtin_</code> will always be treated as having the same meaning as the C library function even if you specify the <code>-fno-builtin</code> option.</p>
</blockquote>
<p><span class="exturl" data-url="aHR0cDovL2djYy5nbnUub3JnL29ubGluZWRvY3MvZ2NjL090aGVyLUJ1aWx0aW5zLmh0bWw=">gcc内置函数<i class="fa fa-external-link-alt"></i></span></p>
<table>
<thead>
<tr>
<th align="left">函数</th>
<th align="left">作用</th>
<th align="left">示例</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>void __builtin___clear_cache (void *begin, void *end)</code></td>
<td align="left">刷新指令Cache (iCache), MIPS使用<code>synci</code>指令</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>int __builtin_clz (unsigned int x)</code></td>
<td align="left">从最高有效位开始，返回x中前导0位的数量。 如果x为0，则结果未定义</td>
<td align="left">a &#x3D; __builtin_clz(5) &#x3D; 29</td>
</tr>
<tr>
<td align="left"><code>int __builtin_popcount (unsigned int x)</code></td>
<td align="left">返回x中1的个数</td>
<td align="left">a &#x3D; __builtin_popcount(5) &#x3D; 2</td>
</tr>
</tbody></table>
<h2 id="编译时警告信息"><a href="#编译时警告信息" class="headerlink" title="编译时警告信息"></a>编译时警告信息</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set(CMAKE_CXX_FLAGS &quot;$&#123;CMAKE_CXX_FLAGS&#125; -g&quot;)</span><br><span class="line">set(CMAKE_CXX_FLAGS &quot;$&#123;CMAKE_CXX_FLAGS&#125; -O3&quot;)</span><br><span class="line">set(CMAKE_CXX_FLAGS &quot;$&#123;CMAKE_CXX_FLAGS&#125; -Wl,--no-as-needed&quot;)</span><br><span class="line"></span><br><span class="line">set(CMAKE_C_FLAGS &quot;$&#123;CMAKE_C_FLAGS&#125; -std=gnu99&quot;)</span><br><span class="line">set(CMAKE_C_FLAGS &quot;$&#123;CMAKE_C_FLAGS&#125; -g&quot;)</span><br><span class="line">set(CMAKE_C_FLAGS &quot;$&#123;CMAKE_C_FLAGS&#125; -O3&quot;)</span><br><span class="line">set(CMAKE_C_FLAGS &quot;$&#123;CMAKE_C_FLAGS&#125; -W&quot;)</span><br><span class="line">set(CMAKE_C_FLAGS &quot;$&#123;CMAKE_C_FLAGS&#125; -Wall&quot;)</span><br><span class="line">set(CMAKE_C_FLAGS &quot;$&#123;CMAKE_C_FLAGS&#125; -Wextra&quot;)</span><br><span class="line">set(CMAKE_C_FLAGS &quot;$&#123;CMAKE_C_FLAGS&#125; -Wno-unused&quot;)</span><br><span class="line">set(CMAKE_C_FLAGS &quot;$&#123;CMAKE_C_FLAGS&#125; -Wno-unused-parameter&quot;)</span><br><span class="line">set(CMAKE_C_FLAGS &quot;$&#123;CMAKE_C_FLAGS&#125; -D_GNU_SOURCE&quot;)</span><br></pre></td></tr></table></figure>
<p>详细参数信息说明及更多的参数<span class="exturl" data-url="aHR0cHM6Ly9nY2MuZ251Lm9yZy9vbmxpbmVkb2NzL2djYy9XYXJuaW5nLU9wdGlvbnMuaHRtbCNXYXJuaW5nLU9wdGlvbnM=">Options to Request or Suppress Warnings<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="Optimization-Levels（优化等级）"><a href="#Optimization-Levels（优化等级）" class="headerlink" title="Optimization Levels（优化等级）"></a>Optimization Levels（优化等级）</h2><p>启用优化会使编译器尝试以牺牲编译时间和调试程序的能力为代价来提高性能和&#x2F;或代码大小。如果您使用多个<code>-O</code>选项，无论是否有级别编号，最后一个这样的选项是有效的。</p>
<p>默认是优化关闭。 这导致了最快的编译时间，但 GNAT 绝对不尝试优化，并且生成的程序比启用优化时更大更慢。 您可以使用 -O 开关（允许的形式是 -O0、-O1 -O2、-O3 和 -Os）到 gcc 来控制优化级别：</p>
<table>
<thead>
<tr>
<th align="center">等级</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>-O0</code></td>
<td align="left">无优化（默认）； 生成未优化的代码，但编译时间最快。请注意，即使指定了“无优化”，许多其他编译器也会进行大量优化。 对于 gcc，如果执行时间有任何问题，将 -O0 用于生产是非常不寻常的，因为 -O0 意味着（几乎）没有优化。 在进行性能比较时，应该记住 gcc 和其他编译器之间的这种差异。</td>
</tr>
<tr>
<td align="center"><code>-O1</code></td>
<td align="left">适度优化； 优化得相当好，但不会显着缩短编译时间。</td>
</tr>
<tr>
<td align="center"><code>-O2</code></td>
<td align="left">全面优化； 生成高度优化的代码并具有最慢的编译时间。</td>
</tr>
<tr>
<td align="center"><code>-O3</code></td>
<td align="left"><code>-O2</code>的完全优化； 还使用更积极的自动内联单元内的子程序（子程序内联）并尝试矢量化循环。</td>
</tr>
<tr>
<td align="center"><code>-Os</code></td>
<td align="left">优化结果程序的空间使用（代码和数据）。</td>
</tr>
</tbody></table>
<blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9nY2MuZ251Lm9yZy9vbmxpbmVkb2NzL2djYy0xMS4xLjAvZ25hdF91Z24vT3B0aW1pemF0aW9uLUxldmVscy5odG1sI09wdGltaXphdGlvbi1MZXZlbHM=">https://gcc.gnu.org/onlinedocs/gcc-11.1.0/gnat_ugn/Optimization-Levels.html#Optimization-Levels<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<h3 id="优化参数的具体优化范围"><a href="#优化参数的具体优化范围" class="headerlink" title="优化参数的具体优化范围"></a>优化参数的具体优化范围</h3><p>通过<code>gcc -Q --help=optimizers</code>命令可以查询优化等级的具体做了哪些优化</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">gcc -Q --<span class="built_in">help</span>=optimizers -O3</span></span><br><span class="line">The following options control optimizations:</span><br><span class="line">  -O&lt;number&gt;</span><br><span class="line">  -Ofast</span><br><span class="line">  -Og</span><br><span class="line">  -Os</span><br><span class="line">  -faggressive-loop-optimizations 	[enabled]</span><br><span class="line">  -falign-functions           		[enabled]</span><br><span class="line">  -falign-jumps               		[enabled]</span><br><span class="line">  -falign-labels              		[enabled]</span><br><span class="line">  -falign-loops               		[enabled]</span><br><span class="line">  -fasynchronous-unwind-tables 		[enabled]</span><br><span class="line">  -fbranch-count-reg          		[enabled]</span><br><span class="line">  -fbranch-probabilities      		[disabled]</span><br><span class="line">  -fbranch-target-load-optimize 	[disabled]</span><br><span class="line">  -fbranch-target-load-optimize2 	[disabled]</span><br><span class="line">  -fbtr-bb-exclusive          		[disabled]</span><br><span class="line">  -fcaller-saves              		[enabled]</span><br><span class="line">  -fcombine-stack-adjustments 		[enabled]</span><br><span class="line">  -fcommon                    		[enabled]</span><br><span class="line">  -fcompare-elim              		[enabled]</span><br><span class="line">  -fconserve-stack            		[disabled]</span><br><span class="line">  -fcprop-registers           		[enabled]</span><br><span class="line">  -fcrossjumping              		[enabled]</span><br><span class="line">  -fcse-follow-jumps          		[enabled]</span><br><span class="line">  -fcx-fortran-rules          		[disabled]</span><br><span class="line">  -fcx-limited-range          		[disabled]</span><br><span class="line">  -fdata-sections             		[disabled]</span><br><span class="line">  -fdce                       		[enabled]</span><br><span class="line">  -fdefer-pop                 		[enabled]</span><br><span class="line">  -fdelayed-branch            		[disabled]</span><br><span class="line">  -fdelete-null-pointer-checks 		[enabled]</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>
<p>有关gcc优化的更多详细信息，请参考gcc的官方文档:</p>
<blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9nY2MuZ251Lm9yZy9vbmxpbmVkb2NzL2djYy9PcHRpbWl6ZS1PcHRpb25zLmh0bWwjT3B0aW1pemUtT3B0aW9ucw==">https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html#Optimize-Options<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<h2 id="Compiler-Switches"><a href="#Compiler-Switches" class="headerlink" title="Compiler Switches"></a>Compiler Switches</h2><blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9nY2MuZ251Lm9yZy9vbmxpbmVkb2NzL2djYy0xMS4xLjAvZ25hdF91Z24vQWxwaGFiZXRpY2FsLUxpc3Qtb2YtQWxsLVN3aXRjaGVzLmh0bWwjQWxwaGFiZXRpY2FsLUxpc3Qtb2YtQWxsLVN3aXRjaGVz">https://gcc.gnu.org/onlinedocs/gcc-11.1.0/gnat_ugn/Alphabetical-List-of-All-Switches.html#Alphabetical-List-of-All-Switches<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9nY2MuZ251Lm9yZy9vbmxpbmVkb2NzL2djYy9pbmRleC5odG1sI1NFQ19Db250ZW50cw==">Using the GNU Compiler Collection (GCC)<i class="fa fa-external-link-alt"></i></span>—gcc在线文档</li>
<li><span class="exturl" data-url="aHR0cHM6Ly9nY2MuZ251Lm9yZy9vbmxpbmVkb2NzL2djYy05LjQuMC9nbmF0X3Vnbi5wZGY=">GNAT User’s Guide for Native Platforms<i class="fa fa-external-link-alt"></i></span> — gcc编译参数</li>
</ul>
]]></content>
      <categories>
        <category>编译工具</category>
        <category>gcc</category>
      </categories>
      <tags>
        <tag>gcc</tag>
        <tag>builtin_xxx</tag>
      </tags>
  </entry>
  <entry>
    <title>网络调试--tcpdump</title>
    <url>/post/18035.html</url>
    <content><![CDATA[<p>网络调试的手段工具：<code>tcpdump</code>、<code>wireshark</code></p>
<span id="more"></span>


<h2 id="抓包–tcpdump"><a href="#抓包–tcpdump" class="headerlink" title="抓包–tcpdump"></a>抓包–tcpdump</h2><p>下载：<span class="exturl" data-url="aHR0cDovL3d3dy50Y3BkdW1wLm9yZy8=">http://www.tcpdump.org<i class="fa fa-external-link-alt"></i></span></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tcpdump -i wlan0 -p  -w file.pcap</span><br></pre></td></tr></table></figure>
<p>常用参数：</p>
<table>
<thead>
<tr>
<th align="center">arg</th>
<th align="left"></th>
</tr>
</thead>
<tbody><tr>
<td align="center">-p</td>
<td align="left">将网卡设置为非混杂模式</td>
</tr>
<tr>
<td align="center">-n</td>
<td align="left">对地址以数字方式显式，否则显式为主机名，也就是说-n选项不做主机名解析。</td>
</tr>
<tr>
<td align="center">-nn</td>
<td align="left">除了-n的作用外，还把端口显示为数值，否则显示端口服务名。</td>
</tr>
<tr>
<td align="center">-c</td>
<td align="left">指定要抓取的包数量</td>
</tr>
<tr>
<td align="center">-v</td>
<td align="left">当分析和打印的时候，产生详细的输出</td>
</tr>
<tr>
<td align="center">-vv</td>
<td align="left">产生比-v更详细的输出</td>
</tr>
<tr>
<td align="center">-w</td>
<td align="left">将抓包数据输出到文件中而不是标准输出。可以同时配合<code>-G time</code>选项使得输出文件每time秒就自动切换到另一个文件</td>
</tr>
</tbody></table>
<h3 id="Install-for-arm"><a href="#Install-for-arm" class="headerlink" title="Install for arm"></a>Install for arm</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">host</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="keyword">for</span> libpcap error: configure: error: Neither flex nor lex was found.</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">sudo apt install flex bison</span></span><br><span class="line"></span><br><span class="line">PWD=$(pwd)</span><br><span class="line"></span><br><span class="line">TCPDUMP=&quot;tcpdump-4.9.2&quot;</span><br><span class="line">LIBPCAP=&quot;libpcap-1.9.0&quot;</span><br><span class="line"></span><br><span class="line">export CC=arm-linux-gnueabihf-gcc</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">http://www.tcpdump.org</span></span><br><span class="line"></span><br><span class="line">for software in $&#123;TCPDUMP&#125; $&#123;LIBPCAP&#125;</span><br><span class="line">do</span><br><span class="line">	echo &quot;Download $software ...&quot;</span><br><span class="line">	echo &quot;wget http://www.tcpdump.org/release/$&#123;software&#125;.tar.gz&quot;</span><br><span class="line">	wget http://www.tcpdump.org/release/$&#123;software&#125;.tar.gz</span><br><span class="line">	echo &quot;tar xvf $&#123;software&#125;.tar.gz&quot;</span><br><span class="line">	tar xvf $&#123;software&#125;.tar.gz</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">cd $&#123;LIBPCAP&#125;</span><br><span class="line">./configure --host=arm-linux --with-pcap=linux --prefix=$&#123;PWD&#125;/out</span><br><span class="line">make; make install</span><br><span class="line">cd -</span><br><span class="line"></span><br><span class="line">cd $&#123;TCPDUMP&#125;</span><br><span class="line">./configure --host=arm-linux --with-system-libpcap=$&#123;PWD&#125;/../$&#123;LIBPCAP&#125;/out/lib --prefix=$&#123;PWD&#125;/out</span><br><span class="line">make; make install</span><br><span class="line">cd -</span><br><span class="line"></span><br><span class="line">cp $&#123;PWD&#125;/$&#123;TCPDUMP&#125;/out/sbin/tcpdump .</span><br></pre></td></tr></table></figure>

<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><blockquote>
<p><code>-n</code>：直接打印，<code>-w</code>：保存文件</p>
</blockquote>
<ul>
<li><p>抓取wlan0中的所有数据包</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">tcpdump -i wlan0 -v -n</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>抓取wlan0中的udp包</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">tcpdump -i wlan0 -v -n udp</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>抓取wlan中的5个udp包</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">tcpdump -i wlan0 -v -n udp -c 5</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>指定端口号</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tcpdump -i wlan0 tcp port 7236 -w rrrr.pcap</span><br></pre></td></tr></table></figure>
<h2 id="分析–wireshark"><a href="#分析–wireshark" class="headerlink" title="分析–wireshark"></a>分析–wireshark</h2></li>
</ul>
<h2 id="netstat"><a href="#netstat" class="headerlink" title="netstat"></a>netstat</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># netstat -n</span><br><span class="line">Active Internet connections (w/o servers)</span><br><span class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State</span><br><span class="line">tcp        0      0 192.168.100.3:40964     192.168.100.2:7236      ESTABLISHED</span><br><span class="line">udp        0      0 239.0.0.11:15550        192.168.100.2:*         ESTABLISHED</span><br><span class="line">udp        0      0 239.0.0.11:15551        192.168.100.2:1         ESTABLISHED</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>网络</category>
        <category>debug</category>
      </categories>
      <tags>
        <tag>debug</tag>
      </tags>
  </entry>
  <entry>
    <title>DHCP之udhcpc</title>
    <url>/post/18609.html</url>
    <content><![CDATA[<blockquote>
<p>动态主机设置协议（英语：Dynamic Host Configuration Protocol，DHCP）是一个局域网的网络协议，使用UDP协议工作，主要有两个用途：</p>
<ul>
<li>用于内部网或网络服务供应商自动分配IP地址；</li>
<li>给用户用于内部网管理员作为对所有计算机作中央管理的手段。</li>
</ul>
</blockquote>
<p>DHCP从一个IP地址池中提供IP地址，该池有DHCP服务器数据库定义，称为scope。如果客户端接受这一地址，则它可在一个预定义的期限内使用该地址，称为<code>租约</code>。如果客户端无法从DHCP服务器获取IP地址，它就无法正常初始化TCP&#x2F;IP。</p>
<p><strong>DHCP采用的C&#x2F;S架构,客户端有<code>udhcpc</code></strong></p>
<span id="more"></span>

<h2 id="udhcpc"><a href="#udhcpc" class="headerlink" title="udhcpc"></a>udhcpc</h2><p>busybox中提供的简易的<code>udhcp client</code></p>
<p>文档:<span class="exturl" data-url="aHR0cDovL3VkaGNwLmJ1c3lib3gubmV0L1JFQURNRS51ZGhjcGM=">http://udhcp.busybox.net/README.udhcpc<i class="fa fa-external-link-alt"></i></span></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">udhcpc -b -i eth0 -p /var/run/udhcpc.pid</span><br></pre></td></tr></table></figure>
<ul>
<li><code>-b</code>:切换到后台指令</li>
<li><code>-i</code>:指定网络接口</li>
<li><code>-p</code>:守护进程ID存储在文件中</li>
<li><code>-s</code>:在DHCP的event中,执行脚本(default:&#x2F;usr&#x2F;share&#x2F;udhcpc&#x2F;default.script)</li>
</ul>
<h2 id="udhcpc执行脚本"><a href="#udhcpc执行脚本" class="headerlink" title="udhcpc执行脚本"></a>udhcpc执行脚本</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line">[ -z &quot;$1&quot; ] &amp;&amp; echo &quot;Error: should be called from udhcpc&quot; &amp;&amp; exit 1</span><br><span class="line"></span><br><span class="line">RESOLV_CONF=&quot;/etc/resolv.conf&quot;</span><br><span class="line">[ -n &quot;$broadcast&quot; ] &amp;&amp; BROADCAST=&quot;broadcast $broadcast&quot;</span><br><span class="line">[ -n &quot;$subnet&quot; ] &amp;&amp; NETMASK=&quot;netmask $subnet&quot;</span><br><span class="line"></span><br><span class="line">case &quot;$1&quot; in</span><br><span class="line">        deconfig)</span><br><span class="line">                /sbin/ifconfig $interface 0.0.0.0</span><br><span class="line">                ;;</span><br><span class="line"></span><br><span class="line">        renew|bound)</span><br><span class="line">                /sbin/ifconfig $interface $ip $BROADCAST $NETMASK</span><br><span class="line"></span><br><span class="line">                if [ -n &quot;$router&quot; ] ; then</span><br><span class="line">                        echo &quot;deleting routers&quot;</span><br><span class="line">                        while route del default gw 0.0.0.0 dev $interface ; do</span><br><span class="line">                                :</span><br><span class="line">                        done</span><br><span class="line">                        for i in $router ; do</span><br><span class="line">                                route add default gw $i dev $interface</span><br><span class="line">                        done</span><br><span class="line">                fi</span><br><span class="line"></span><br><span class="line">                echo -n &gt; $RESOLV_CONF</span><br><span class="line">                [ -n &quot;$domain&quot; ] &amp;&amp; echo search $domain &gt;&gt; $RESOLV_CONF</span><br><span class="line">                for i in $dns ; do</span><br><span class="line">                        echo adding dns $i</span><br><span class="line">                        echo nameserver $i &gt;&gt; $RESOLV_CONF</span><br><span class="line">                done</span><br><span class="line">                ;;</span><br><span class="line">esac</span><br><span class="line">exit 0</span><br></pre></td></tr></table></figure>

<h2 id="dhcpcd配置静态IP"><a href="#dhcpcd配置静态IP" class="headerlink" title="dhcpcd配置静态IP"></a>dhcpcd配置静态IP</h2><p>配置文件<code>/etc/dhcpcd.conf</code></p>
<p>追加IP配置信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface eth0</span><br><span class="line">static ip_address=172.16.xx.xx/24       #配置IP地址</span><br><span class="line">static routers=172.16.xx.xx             #网关</span><br><span class="line">static domain_name_servers=172.16.xx.xx #DNS</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly93aXphcmRmb3JjZWwuZ2l0Ym9va3MuaW8vbmV0d29yay1iYXNpYy9jb250ZW50LzMwLmh0bWw=">网络基本功（三十一）：细说DHCP<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>网络</category>
        <category>dhcp</category>
      </categories>
      <tags>
        <tag>dhcp</tag>
      </tags>
  </entry>
  <entry>
    <title>组播--IGMPv2</title>
    <url>/post/39626.html</url>
    <content><![CDATA[<blockquote>
<p>IGMP 是Internet Group Management Protocol（互联网组管理协议）的简称。它是TCP&#x2F;IP 协议族中负责IP 组播成员管理的协议，用来在IP 主机和与其直接相邻的组播路由器之间建立、维护组播组成员关系。</p>
</blockquote>
<span id="more"></span>

<ul>
<li>IGMPv1（由<span class="exturl" data-url="aHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzExMTIudHh0">RFC 1112<i class="fa fa-external-link-alt"></i></span> 定义）</li>
<li>IGMPv2（由<span class="exturl" data-url="aHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzIyMzYudHh0">RFC 2236<i class="fa fa-external-link-alt"></i></span> 定义）</li>
<li>IGMPv3（由<span class="exturl" data-url="aHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzMzNzYudHh0">RFC 3376<i class="fa fa-external-link-alt"></i></span> 定义）</li>
</ul>
<p>所有版本的IGMP都支持ASM（Any-Source Multicast，任意信源组播）模型；IGMPv3可以直接应用于SSM（Source-Specific Multicast，指定信源组播）模型，而IGMPv1和IGMPv2则需要在IGMP SSM Mapping技术的支持下才能应用于SSM模型。</p>
<h2 id="IGMP工作原理"><a href="#IGMP工作原理" class="headerlink" title="IGMP工作原理"></a>IGMP工作原理</h2><ul>
<li><p>第一阶段： 当某个主机加入新的组播时，该主机应向多播租的多播地址发送一个IGMP报文，声明自己要成为该租的成员。本地的多播路由器收到IGMP报文后，还要利用多播路由选择协议把这种组成员关系转发给因特网上的其他多播路由器。</p>
</li>
<li><p>第二阶段： 组成员关系是动态的。本地多播路由器要周期性地探询本地局域网上的主机，以便知道这些主机是否还继续是组成员。只要有一个主机对某个组响应，那么多播路由器就认为这个组是活跃的。但一个组在经过几次的探询后仍然没有一个主机响应，多播路由器就认为本网络上的主机已经都离开了这个组，因此也就不再把这个组的成员关系转发给其他的多播路由器。</p>
</li>
</ul>
<h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><h2 id="IGMP-snooping-和-IGMP-proxy"><a href="#IGMP-snooping-和-IGMP-proxy" class="headerlink" title="IGMP snooping 和 IGMP proxy"></a>IGMP snooping 和 IGMP proxy</h2><h3 id="IGMP-snooping"><a href="#IGMP-snooping" class="headerlink" title="IGMP snooping"></a>IGMP snooping</h3><blockquote>
<p>是运行在二层设备上的组播约束的机制，用于管理和控制组播组。</p>
</blockquote>
<h3 id="IGMP-proxy"><a href="#IGMP-proxy" class="headerlink" title="IGMP proxy"></a>IGMP proxy</h3><blockquote>
<p>是靠拦截用户和路由器之间的IGMP报文建立组播表，Proxy设备的上联端口执行主机的角色，下联端口执行路由器的角色。</p>
</blockquote>
<h2 id="IGMPv1"><a href="#IGMPv1" class="headerlink" title="IGMPv1"></a>IGMPv1</h2><p>IGMPv1 主要基于查询和响应机制来完成对组播组成员的管理。</p>
<p>当一个网段内有多台组播路由器时，由于它们都能从主机那里收到IGMP 成员关系报告报文（Membership Report Message），因此只需要其中一台路由器发送IGMP 查询报文（Query Message）就足够了。这就需要有一个查询器（Querier）的选举机制来确定由哪台路由器作为IGMP查询器。</p>
<p>对于IGMPv1 来说，由组播路由协议（如PIM）选举出唯一的组播信息转发者DR（Designated Router，指定路由器）作为IGMP 查询器</p>
<p><img data-src="/images/net/multicast/igmpv1.jpg" alt="IGMPv1"></p>
<p>IGMPv1 没有专门定义<code>离开组播组</code>的报文。当运行IGMPv1 的主机离开某组播组时，将不会向其要离开的组播组发送报告报文。当网段中不再存在该组播组的成员后，IGMP 路由器将收不到任何发往该组播组的报告报文，于是IGMP 路由器在一段时间之后便删&gt;除该组播组所对应的组播转发项。</p>
<h2 id="IGMPv2"><a href="#IGMPv2" class="headerlink" title="IGMPv2"></a>IGMPv2</h2><p>与IGMPv1 相比，IGMPv2 增加了<code>查询器选举机制</code>和<code>离开组机制</code>。</p>
<h3 id="查询器选举机制"><a href="#查询器选举机制" class="headerlink" title="查询器选举机制"></a>查询器选举机制</h3><p>在IGMPv1 中，当某共享网段上存在多个组播路由器时，由组播路由协议（如PIM）选举的指定路由器充当查询器。</p>
<p>在IGMPv2 中，增加了独立的查询器选举机制，其选举过程如下：</p>
<ol>
<li>所有IGMPv2路由器在初始时都认为自己是查询器，并向本地网段内的所有主机和路由器发送IGMP普遍组查询（General Query）报文（目的地址为224.0.0.1）；</li>
<li>本地网段中的其它IGMPv2路由器在收到该报文后，将报文的源IP地址与自己的接口地址作比较。通过比较， IP地址最小的路由器将成为查询器，其它路由器成为非查询器（Non-Querier）；</li>
<li>所有非查询器上都会启动一个定时器（即其它查询器存在时间定时器Other Querier Present Timer）。在该定时器超时前，如果收到了来自查询器的IGMP 查询报文，则重置该定时器；否则，就认为原查询器失效，并发起新的查询器选举过程。</li>
</ol>
<h3 id="离开组机制"><a href="#离开组机制" class="headerlink" title="离开组机制"></a>离开组机制</h3><p>在IGMPv1 中，主机离开组播组时不会向组播路由器发出任何通知，导致组播路由器只能依靠组播组成员查询的响应超时来获知组播组成员的离开。</p>
<p>而在IGMPv2中，当一个主机离开某组播组时：</p>
<ol>
<li>该主机向本地网段内的所有组播路由器（目的地址为224.0.0.2）发送离开组（Leave Group）报文；</li>
<li>当查询器收到该报文后， 向该主机所声明要离开的那个组播组发送特定组查询（Group-Specific Query）报文（目的地址字段和组地址字段均填充为所要查询的组播组地址）；</li>
<li>如果该网段内还有该组播组的其它成员，则这些成员在收到特定组查询报文后，会在该报文中所设定的最大响应时间（Max Response Time）内发送成员关系报告报文；</li>
<li>如果在最大响应时间内收到了该组播组其它成员发送的成员关系报告报文，查询器就会继续维护该组播组的成员关系；否则，查询器将认为该网段内已无该组播组的成员，于是不再维护这个组播组的成员关系。</li>
</ol>
<h3 id="IGMPv2报文格式"><a href="#IGMPv2报文格式" class="headerlink" title="IGMPv2报文格式"></a>IGMPv2报文格式</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0             7 8             1516                             31</span><br><span class="line">+--------------+---------------+-------------------------------+-++</span><br><span class="line">|    Type      | max_resp_time |           CheckSum            | |</span><br><span class="line">+--------------+---------------+-------------------------------+ 8Byte</span><br><span class="line">|                    Group Address                             | |</span><br><span class="line">+--------------------------------------------------------------+-++</span><br></pre></td></tr></table></figure>

<ul>
<li><code>Type</code> :</li>
</ul>
<table>
<thead>
<tr>
<th align="center">Type</th>
<th align="center"></th>
</tr>
</thead>
<tbody><tr>
<td align="center">0x11</td>
<td align="center">Membership Query(成员查询)</td>
</tr>
<tr>
<td align="center">0X12</td>
<td align="center">Version 1 Membership Report(版本1成员报告)</td>
</tr>
<tr>
<td align="center">0X16</td>
<td align="center">Version 2 Membership Report(版本2成员报告)</td>
</tr>
<tr>
<td align="center">0X17</td>
<td align="center">Leave Group(离开组)</td>
</tr>
</tbody></table>
<ul>
<li><code>max_resp_time</code>: 在发出响应报告前的以1&#x2F;10秒为单位的最长时间，<code>缺省值为10秒</code>。新的最大响应时间（以1&#x2F;10秒为单位）字段允许查询用路由器为它的查询报文指定准确的查询间隔响应时间。IGMP版本2主机在随机选择它们的应时间值时以此作为上限。</li>
</ul>
<blockquote>
<p>从路由器接收到一条查询消息后，主机会为其所属的每个组播组都配置一个计时器。计时器的值在 0 到最大响应时间之间随机选定。当其中任何一个计时器的值减为 0时，主机就会发送该组播组的成员报告消息。合理配置最大响应时间，可以使主机快速响应查询信息，路由器也就能快速地掌握组播组成员的存在状况。</p>
</blockquote>
<ul>
<li><code>Group Address</code>: 组地址</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Internet Group Management Protocol</span><br><span class="line">    [IGMP Version: 2]</span><br><span class="line">    Type: Membership Report (0x16)</span><br><span class="line">    Max Resp Time: 0.0 sec (0x00)</span><br><span class="line">    Checksum: 0xfaf3 [correct]</span><br><span class="line">    [Checksum Status: Good]</span><br><span class="line">    Multicast Address: 239.0.0.11</span><br></pre></td></tr></table></figure>

<h3 id="设置max-resp-time"><a href="#设置max-resp-time" class="headerlink" title="设置max_resp_time"></a>设置max_resp_time</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ip igmp snooping query-max-response-time seconds</span><br></pre></td></tr></table></figure>

<h2 id="IGMPv3"><a href="#IGMPv3" class="headerlink" title="IGMPv3"></a>IGMPv3</h2><p>IGMPv3 在兼容和继承IGMPv1 和IGMPv2 的基础上，进一步增强了主机的控制能力，并增强了查询和报告报文的功能。</p>
<h2 id="IGMP-snooping查询器"><a href="#IGMP-snooping查询器" class="headerlink" title="IGMP snooping查询器"></a>IGMP snooping查询器</h2><p>在运行了IGMP的组播网络中，会有一台三层组播设备充当IGMP查询器，负责发送<code>IGMP查询报文</code>，使三层组播设备能够在网络层<code>建立并维护组播转发表项，从而在网络层正常转发组播数据</code>。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpdmVseWxpdHRsZWZpc2gvYXJ0aWNsZS9kZXRhaWxzLzQyODYxNDI=">IGMP技术总结<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NoYW56aGl6aS9hcnRpY2xlL2RldGFpbHMvNzY0NTMzMA==">IGMPv3协议报文格式参考<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pbmd6em5ldC9hcnRpY2xlL2RldGFpbHMvOTI1MzYwNw==">IGMP Snooping概念和配置方法—交换<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL2Jsb2cuc2luYS5jb20uY24vcy9ibG9nX2MwNzlkNTllMDEwMndoamcuaHRtbA==">IGMPV2基本原理<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FjaGVqcS9hcnRpY2xlL2RldGFpbHMvNzM0NzIxNA==">IGMP Snooping技术学习笔记<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL2Jsb2cuNTFjdG8uY29tL3JvbmdzaHUvMTkwMDE4Mg==">H3C F1000-S防火墙基础配置及telnet登录！<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL3d3dy5oM2MuY29tL2NuL2RfMjAwODA1LzYwNTgzOF8zMDAwM18wLmh0bQ==">IGMP Snooping技术介绍<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RvZGQ5MTEvYXJ0aWNsZS9kZXRhaWxzLzM4Njg5Njgx">《TCP&#x2F;IP详解卷2：实现》笔记–IGMP:Internet组管理协议<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>网络</category>
        <category>igmp</category>
      </categories>
      <tags>
        <tag>network</tag>
        <tag>igmp</tag>
      </tags>
  </entry>
  <entry>
    <title>OSI七层网络模型</title>
    <url>/post/51171.html</url>
    <content><![CDATA[<p>一张非常强大的OSI七层模型图解:</p>
<span id="more"></span>

<p><img data-src="/images/net/OSI_network_model.gif" alt="OSI七层网络模型"></p>
<table>
<thead>
<tr>
<th align="center">Later</th>
<th align="center"></th>
</tr>
</thead>
<tbody><tr>
<td align="center">应用层</td>
<td align="center">DHCP · DNS · FTP · Gopher · HTTP · IMAP4 · IRC · NNTP · XMPP · POP3 · SIP · SMTP · SNMP · SSH · TELNET · RPC · RTCP · RTP ·RTSP · SDP · SOAP · GTP · STUN · NTP · SSDP</td>
</tr>
<tr>
<td align="center">表示层</td>
<td align="center">HTTP&#x2F;HTML · FTP · Telnet · ASN.1（具有表示层功能）</td>
</tr>
<tr>
<td align="center">会话层</td>
<td align="center">ADSP·ASP·H.245·ISO-SP·iSNS·NetBIOS·PAP·RPC·RTCP·SMPP·SCP·SSH·ZIP·SDP（具有会话层功能）</td>
</tr>
<tr>
<td align="center">传输层</td>
<td align="center">TCP · UDP · TLS · DCCP · SCTP ·RSVP · PPTP</td>
</tr>
<tr>
<td align="center">网络层</td>
<td align="center">IP (IPv4 · IPv6) · ICMP · ICMPv6 · IGMP ·IS-IS · IPsec · BGP · RIP · OSPF ·ARP · RARP</td>
</tr>
<tr>
<td align="center">数据链路层</td>
<td align="center">Wi-Fi(IEEE 802.11) · WiMAX(IEEE 802.16) ·ATM · DTM · 令牌环 · 以太网路 · FDDI · 帧中继 · GPRS · EVDO · HSPA · HDLC · PPP · L2TP · ISDN ·STP</td>
</tr>
<tr>
<td align="center">物理层</td>
<td align="center">以太网路卡 · 调制解调器 · 电力线通信(PLC) · SONET&#x2F;SDH（光同步数字传输网） · G.709（光传输网络）· 光导纤维 · 同轴电缆 · 双绞线</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>网络</category>
        <category>network</category>
      </categories>
      <tags>
        <tag>network</tag>
      </tags>
  </entry>
  <entry>
    <title>UDP调用connect的作用</title>
    <url>/post/33300.html</url>
    <content><![CDATA[<blockquote>
<p>问： UDP中可以使用<code>connect</code>系统调用吗?</p>
</blockquote>
<blockquote>
<p>答： 可以</p>
</blockquote>
<blockquote>
<p>问： 为什么使用？</p>
</blockquote>
<blockquote>
<p>答： 提高效率</p>
</blockquote>
<span id="more"></span>

<h2 id="UDP中connect操作与TCP中connect操作有着本质区别？"><a href="#UDP中connect操作与TCP中connect操作有着本质区别？" class="headerlink" title="UDP中connect操作与TCP中connect操作有着本质区别？"></a>UDP中connect操作与TCP中connect操作有着本质区别？</h2><blockquote>
<ol>
<li>TCP中调用connect会引起三次握手,client与server建立连结</li>
<li>UDP中调用connect内核仅仅把对端<code>ip&amp;port</code>记录下来.</li>
</ol>
</blockquote>
<h2 id="UDP中可以多次调用connect-TCP只能调用一次onnect"><a href="#UDP中可以多次调用connect-TCP只能调用一次onnect" class="headerlink" title="UDP中可以多次调用connect,TCP只能调用一次onnect"></a>UDP中可以<code>多次</code>调用connect,TCP只能调用<code>一次</code>onnect</h2><blockquote>
<p>UDP多次调用connect有两种用途:</p>
<blockquote>
<ol>
<li>指定一个新的ip&amp;port连结.</li>
<li>断开和之前的ip&amp;port的连结.</li>
</ol>
</blockquote>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">remoteAddr</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(remoteAddr.sin_zero, <span class="number">0</span>, <span class="keyword">sizeof</span>(remoteAddr.sin_zero));</span><br><span class="line">remoteAddr.sin_family = AF_INET;  <span class="comment">/* 建立新的连接 */</span></span><br><span class="line"><span class="comment">//remoteAddr.sin_family = AF_INET;  /* 断开旧的连接 */</span></span><br><span class="line">inet_pton(AF_INET,player-&gt;rtpUdp.rip, &amp;remoteAddr.sin_addr);</span><br><span class="line">remoteAddr.sin_port = htons(player-&gt;rtpUdp.rport);</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    ret = connect(player-&gt;rtpUdp.fd,(<span class="keyword">struct</span> sockaddr *)&amp;remoteAddr,remoteAddrLen);</span><br><span class="line">&#125; <span class="keyword">while</span>(ret == <span class="number">-1</span> &amp;&amp; errno == EINTR);</span><br></pre></td></tr></table></figure>

<h2 id="UDP中使用connect可以提高效率原因"><a href="#UDP中使用connect可以提高效率原因" class="headerlink" title="UDP中使用connect可以提高效率原因"></a>UDP中使用connect可以提高效率原因</h2><ul>
<li>普通的UDP发送两个报文内核处理如下:<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#1:建立连结 -&gt; #2:发送报文 -&gt; #3:断开连结 -&gt; #4:建立连结 -&gt; #5:发送报文 -&gt; #6:断开连结</span><br></pre></td></tr></table></figure></li>
<li>采用connect方式的UDP发送两个报文内核处理如下：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#1:建立连结 -&gt; #2:发送报文 -&gt; #3:发送另外一个报文</span><br></pre></td></tr></table></figure>
<blockquote>
<p>每次发送报文内核都由可能要做路由查询</p>
</blockquote>
</li>
</ul>
<h2 id="UDP中使用connect的好处："><a href="#UDP中使用connect的好处：" class="headerlink" title="UDP中使用connect的好处："></a>UDP中使用connect的好处：</h2><ol>
<li>会提升效率</li>
<li>高并发服务中会增加系统稳定性.<blockquote>
<p>原因: ???</p>
<p>假设client A 通过非connect的UDP与server B,C通信.B,C提供相同服务.为了负载均衡,我们让A与B,C交替通信.A 与 B通信IPa:PORTa —- IPb:PORTb；</p>
<p>A 与 C通信IPa:PORTa’— IPc:PORTc</p>
<p>假设PORTa 与 PORTa’相同了(在大并发情况下会发生这种情况),那么就有可能出现A等待B的报文,却收到了C的报文.导致收报错误.解决方法内就是采用connect的UDP通信方式.在A中创建两个udp,然后分别connect到B,C.</p>
</blockquote>
</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTM5MjAwODUvYXJ0aWNsZS9kZXRhaWxzLzQ0ODM0ODE1">UDP 调用 connect<i class="fa fa-external-link-alt"></i></span></li>
</ol>
]]></content>
      <categories>
        <category>网络</category>
        <category>udp</category>
      </categories>
      <tags>
        <tag>udp</tag>
      </tags>
  </entry>
  <entry>
    <title>WIFI配置中涉及到的相关名词</title>
    <url>/post/1797.html</url>
    <content><![CDATA[<p>AP配置中遇到的相关名词，作用及含义：</p>
<span id="more"></span>

<ul>
<li><code>AP模式</code>: Access Point，提供无线接入服务，允许其它无线设备接入，提供数据访问，一般的无线路由&#x2F;网桥工作在该模式下。AP和AP之间允许相互连接</li>
<li><code>sta模式</code>: Station, 类似于无线终端，sta本身并不接受无线的接入，它可以连接到AP，一般无线网卡即工作在该模式</li>
</ul>
<h2 id="WMM"><a href="#WMM" class="headerlink" title="WMM"></a>WMM</h2><p><code>WMM</code>是一个英文缩写，是指<code>Wi-Fi多媒体</code></p>
<h2 id="u-apsd"><a href="#u-apsd" class="headerlink" title="u-apsd"></a>u-apsd</h2><h2 id="AAA"><a href="#AAA" class="headerlink" title="AAA"></a>AAA</h2><p>AAA是<code>认证（Authentication）</code>、<code>授权（Authorization）</code>和<code>计费（Accounting）</code>的简称，是网络安全中进行访问控制的一种安全管理机制，提供认证、授权和计费三种安全服务。</p>
<ul>
<li>认证（Authentication）：是对用户的身份进行验证，判断其是否为合法用户。</li>
<li>授权（Authorization）：是对通过认证的用户，授权其可以使用哪些服务。</li>
<li>计费（Accounting）：是记录用户使用网络服务的资源情况，这些信息将作为计费的依据。</li>
</ul>
<h2 id="EDCA"><a href="#EDCA" class="headerlink" title="EDCA"></a>EDCA</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpbl9zaHVxaW5nL2FydGljbGUvZGV0YWlscy83NTA5OTA0Nw==">EDCA机制详解<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<h2 id="频宽-（20MHz、40MHz、80MHz）"><a href="#频宽-（20MHz、40MHz、80MHz）" class="headerlink" title="频宽 （20MHz、40MHz、80MHz）"></a>频宽 （20MHz、40MHz、80MHz）</h2><p>指的是你的路由器的<code>发射频率宽度</code>， 也就是<code>信道带宽</code>。</p>
<p>频宽越大，传输中受到的干扰也就越大；但是频宽大时，数据传输带宽也会变大。</p>
<table>
<thead>
<tr>
<th align="center">频宽</th>
<th align="center">传输带宽</th>
</tr>
</thead>
<tbody><tr>
<td align="center">20MHz</td>
<td align="center">65M</td>
</tr>
<tr>
<td align="center">40MHz</td>
<td align="center">150M</td>
</tr>
<tr>
<td align="center">80MHz</td>
<td align="center">-</td>
</tr>
</tbody></table>
<h2 id="802-11ac"><a href="#802-11ac" class="headerlink" title="802.11ac"></a>802.11ac</h2><p>IEEE 802.11ac，是一个802.11无线局域网（WLAN）通信标准，它通过<code>5GHz频带</code>（也是其得名原因）进行通信。理论上，它能够提供最多1Gbps带宽进行多站式无线局域网通信，或是最少500Mbps的单一连接传输带宽。</p>
<h2 id="穿透性"><a href="#穿透性" class="headerlink" title="穿透性"></a>穿透性</h2><p>5GHz信号的波长要比2.4GHz信号的要短，而<code>波长越短的电磁波穿透力就越强</code>。但因为 <strong>频率越高消耗在穿透上的能量越大，导致信号浪费，设备接受到的反而是反射衍射过来的信号</strong>。2.4Ghz下，衍射和反射比5Ghz要多，因此设备接受到的信号反而强。</p>
<h2 id="协议标准"><a href="#协议标准" class="headerlink" title="协议标准"></a>协议标准</h2><table>
<thead>
<tr>
<th align="center">标准号</th>
<th align="center">IEEE 802.11b</th>
<th align="center">IEEE 802.11a</th>
<th align="center">IEEE 802.11g</th>
<th align="center">IEEE 802.11n</th>
</tr>
</thead>
<tbody><tr>
<td align="center">标准发布时间</td>
<td align="center">1999年9月</td>
<td align="center">1999年9月</td>
<td align="center">2003年6月</td>
<td align="center">2009年9月</td>
</tr>
<tr>
<td align="center">工作频率范围</td>
<td align="center">2.4－2.4835GHz</td>
<td align="center">5.150－5.350GHz 5.475－5.725GHz 5.725－5.850GHz</td>
<td align="center">2.4－2.4835GHz</td>
<td align="center">2.4－2.4835GHz 5.150－5.850GHz</td>
</tr>
<tr>
<td align="center">非重叠信道数</td>
<td align="center">3</td>
<td align="center">24</td>
<td align="center">3</td>
<td align="center">15</td>
</tr>
<tr>
<td align="center">物理速率（Mbps）</td>
<td align="center">11</td>
<td align="center">54</td>
<td align="center">54</td>
<td align="center">600</td>
</tr>
<tr>
<td align="center">实际吞吐量（Mbps）</td>
<td align="center">6</td>
<td align="center">24</td>
<td align="center">24</td>
<td align="center">100以上</td>
</tr>
<tr>
<td align="center">频宽（MHz）</td>
<td align="center">20</td>
<td align="center">20</td>
<td align="center">20</td>
<td align="center">20&#x2F;40</td>
</tr>
<tr>
<td align="center">调制方式</td>
<td align="center">CCK&#x2F;DSSS</td>
<td align="center">OFDM</td>
<td align="center">CCK&#x2F;DSSS&#x2F;OFDM</td>
<td align="center">MIMO-OFDM&#x2F;DSSS&#x2F;CCK</td>
</tr>
<tr>
<td align="center">兼容性</td>
<td align="center">802.11b</td>
<td align="center">802.11a</td>
<td align="center">802.11b&#x2F;g</td>
<td align="center">802.11a&#x2F;b&#x2F;g&#x2F;n</td>
</tr>
</tbody></table>
<h2 id="2-4G频段"><a href="#2-4G频段" class="headerlink" title="2.4G频段"></a>2.4G频段</h2><p>WiFi总共有14个信道<br><img data-src="/images/2018/08/net_wifi_sig_chl.png" alt="net_wifi_sig_chl"></p>
<blockquote>
<ul>
<li>IEEE 802.11b&#x2F;g标准工作在2.4G频段，频率范围为2.400—2.4835GHz，共<code>83.5M</code>带宽</li>
<li>划分为14个子信道</li>
<li>每个子信道宽度为<code>22MHz</code>, 有效带宽为<code>20MHz</code>, 另外还有<code>2MHz</code>的强制隔离频带（类似于公路上的隔离带）</li>
<li>相邻信道的中心频点间隔<code>5MHz</code></li>
<li>相邻的多个信道存在频率重叠(如1信道与2、3、4、5信道有频率重叠)</li>
<li>整个频段内只有<code>3个（1、6、11）</code>互不干扰信道</li>
</ul>
</blockquote>
<p><strong><code>802.11b</code>和<code>802.11g</code>的工作频段在2.4GHz（2.4GHz-2.4835GHz），其可用带宽为83.5MHz，<code>中国划分为13个信道</code>，每个信道带宽为22MHz</strong></p>
<h3 id="信道划分"><a href="#信道划分" class="headerlink" title="信道划分"></a>信道划分</h3><p><code>信道</code>也称作<code>通道(Channel)</code>、<code>频段</code>，是以无线信号（电磁波）作为传输载体的数据信号传送通道。无线网络（路由器、AP热点、电脑无线网卡）可在多个信道上运行。在无线信号覆盖范围内的各种无线网络设备应该尽量使用不同的信道，以避免信号之间的干扰。</p>
<p>中心频率为<code>2412MHz</code>的1信道，其频率范围为<code>2401~2423MHz</code></p>
<blockquote>
<p>freq &#x3D; 2400 + 20&#x2F;2 + 2 + 5 * (channel - 1) MHz</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">信道</th>
<th align="center">中心频率</th>
<th align="center">信道</th>
<th align="center">中心频率</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">2412MHz</td>
<td align="center">8</td>
<td align="center">2447MHz</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">2417MHz</td>
<td align="center">9</td>
<td align="center">2452MHz</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">2422MHz</td>
<td align="center">10</td>
<td align="center">2457MHz</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">2427MHz</td>
<td align="center">11</td>
<td align="center">2462MHz</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">2432MHz</td>
<td align="center">12</td>
<td align="center">2467MHz</td>
</tr>
<tr>
<td align="center">6</td>
<td align="center">2437MHz</td>
<td align="center">13</td>
<td align="center">2472MHz</td>
</tr>
<tr>
<td align="center">7</td>
<td align="center">2442MHz</td>
<td align="center">-</td>
<td align="center">-</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>在WiFi的世界中，有一条原则雷打不动，那就是在同一信道范围内，同一时刻，只有一台设备可以发信号，其他设备都需要等待。</strong></p>
</blockquote>
<p><img data-src="/images/2018/11/wifi_channel_2_4g.png" alt="wifi_channel_2.4G"></p>
<h2 id="5G频段"><a href="#5G频段" class="headerlink" title="5G频段"></a>5G频段</h2><blockquote>
<p>freq &#x3D; 5000 + 5 * channel</p>
</blockquote>
<p><img data-src="/images/2018/11/wifi_channel_5g.png" alt="wifi_channel_5G"></p>
<h2 id="网络划分："><a href="#网络划分：" class="headerlink" title="网络划分："></a>网络划分：</h2><p>在ISO&#x2F;IEC 8802规范划分数据链路层（Data Link Layer）而得到的<code>Logic Link Control Sub Layer（简称LLC）</code>和<code>Medium Acess Control Sub Layer（简称MAC）</code>。</p>
<p><img data-src="/images/2018/08/net_80211_data_link_layer.png" alt="net_80211_data_link_layer"></p>
<ul>
<li><code>MAC Sub Layer</code>（Media Acess Control SubLayer：媒介访问控制子层）：该子层的目的是为了解决局域网（Local Area Network，以后简写为LAN）中<code>共用信道的使用产生竞争时</code>，如何分配信道的使用权问题。目前LAN中常用的媒介访问控制方法是CSMA&#x2F;CD（争用型介质访问控制）。由于无线网络的特殊性，MAC的控制方法略有不同。我们将在下文介绍相关内容。</li>
<li><code>LLC Sub Layer</code>（逻辑链路控制子层）：该子层实现了两个站点之间帧的交换，实现端到端（源到目的），<code>无差错的帧传输和应答功能及流量控制功能</code>。</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1Z3VvaHUyMDA2L2FydGljbGUvZGV0YWlscy81MjI1MDExOQ==">WIFI的传输信道与标准WIFI的频道传输能力<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2lubm9zdC9hcnRpY2xlL2RldGFpbHMvMjA2NTE0NDU=">《深入理解Android：Wi-Fi，NFC和GPS》章节连载[节选]–第三章 Wi-Fi基础知识<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2R4cHF4Yi9hcnRpY2xlL2RldGFpbHMvODA5Njk3NjA=">世界各个地区WIFI 2.4G及5G信道划分表（附无线通信频率分配表）<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>网络</category>
        <category>wifi</category>
      </categories>
      <tags>
        <tag>wifi</tag>
      </tags>
  </entry>
  <entry>
    <title>关于WIFI的工作模式--AP MODE/STATION MODE/P2P MODE</title>
    <url>/post/49326.html</url>
    <content><![CDATA[<p>WiFi的共存模式：</p>
<ul>
<li>station mode + station mode</li>
<li>station mode + ap mode</li>
<li>station mode + p2p mode</li>
<li>p2p mode + ap mode</li>
</ul>
<span id="more"></span>


<h2 id="ap-mode"><a href="#ap-mode" class="headerlink" title="ap mode"></a>ap mode</h2><p><code>ap mode</code>通用应用在无线局域网成员设备（即客户端）的加入，即<code>网络下行</code>。它提供以无线方式组建无线局域网WLAN，相当际WLAN的中心设备。</p>
<h2 id="station-mode"><a href="#station-mode" class="headerlink" title="station mode"></a>station mode</h2><p><code>station mode</code>即工作站模式，可以理解为某个网格中的一个工作站即客户端。那当一个WIFI芯片提供这个功能时，它就可以连到另外的一个网络当中，如家用路由器。通常用于提供网络的数据<code>上行服务</code></p>
<h2 id="p2p-mode"><a href="#p2p-mode" class="headerlink" title="p2p mode"></a>p2p mode</h2><p><code>p2p mode</code>也为Wi-Fi Direct</p>
<p>Wi-Fi Direct是一种点对点连接技术，它可以在两台station之间直接建立tcp&#x2F;ip链接，并不需要AP的参与；其中一台station会起到传统意义上的AP的作用，称为<code>Group Owner(GO)</code>,另外一台station则称为<code>Group Client(GC)</code>，像连接AP一样连接到GO。GO和GC不仅可以是一对一，也可以是一对多；比如，一台GO可以同时连接着多台GC</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dpcmVsZXNzZGlzcGxheS9hcnRpY2xlL2RldGFpbHMvNTMzNjUzNzc=">WIFI Direct&#x2F;WIFI P2P<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>网络</category>
        <category>wifi</category>
      </categories>
      <tags>
        <tag>wifi</tag>
      </tags>
  </entry>
  <entry>
    <title>【转】网络库libevent、libev、libuv对比</title>
    <url>/post/12060.html</url>
    <content><![CDATA[<p>地址：<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpamlucWkxOTg3L2FydGljbGUvZGV0YWlscy83MTIxNDk3NA==">https://blog.csdn.net/lijinqi1987/article/details/71214974<i class="fa fa-external-link-alt"></i></span></p>
<blockquote>
<p>三者都是*异步事件库（Asynchronous event library）。</p>
</blockquote>
<span id="more"></span>

<h2 id="异步事件库"><a href="#异步事件库" class="headerlink" title="异步事件库"></a>异步事件库</h2><ol>
<li>异步事件通知</li>
<li>可移植</li>
</ol>
<p>异步事件库本质上是提供异步事件通知（Asynchronous Event Notification，AEN）的。可移植（Portable）、可扩展（Scalable）这些特性只是为了使库更通用、易用，并非必须。</p>
<h3 id="异步事件通知"><a href="#异步事件通知" class="headerlink" title="异步事件通知"></a>异步事件通知</h3><p>异步事件通知机制就是根据发生的事件，调用相应的回调函数进行处理。</p>
<ol>
<li>事件（Event）：事件是异步事件通知机制的核心，比如fd事件、超时事件、信号事件、<br>定时器事件。有时候也称事件为事件处理器（Event Handler），这个名称更形象，因为Handler本身表示了包含处理所需数据（或数据的地址）和处理的方法（回调函数），更像是面向对象思想中的称谓。<ul>
<li>数据（Data）：提供给回调函数的输入数据，可以是实际的数据，也可以指针，为了提供统一的API，一般为 void * 指针。</li>
<li>回调函数（Callback Function）：事件发生时调用的方法。注意回调只是一种机制，跟异步没有太大关系，同步也可以采用回调机制（API）。</li>
</ul>
</li>
<li>事件循环（Event Loop）：等待并分发事件。事件循环用于管理事件。</li>
</ol>
<p>对于应用程序来说，这些只是异步事件库提供的API，封装了异步事件库跟操作系统的交互，异步事件库会选择一种操作系统提供的机制来实现某一种事件，比如利用Unix&#x2F;Linux平台的epoll机制实现网络IO事件，在同时存在多种机制可以利用时，异步事件库会采用最优机制。</p>
<h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><h3 id="事件种类"><a href="#事件种类" class="headerlink" title="事件种类"></a>事件种类</h3><table>
<thead>
<tr>
<th align="left">type</th>
<th align="left">libevent</th>
<th align="left">libev</th>
<th align="left">libuv</th>
</tr>
</thead>
<tbody><tr>
<td align="left">IO</td>
<td align="left">fd</td>
<td align="left">io</td>
<td align="left">fs_event</td>
</tr>
<tr>
<td align="left">计时器（mono clock）</td>
<td align="left">timer</td>
<td align="left">timer</td>
<td align="left">timter</td>
</tr>
<tr>
<td align="left">计时器（wall clock）</td>
<td align="left">–</td>
<td align="left">periodic</td>
<td align="left">–</td>
</tr>
<tr>
<td align="left">信号</td>
<td align="left">signal</td>
<td align="left">signal</td>
<td align="left">signal</td>
</tr>
<tr>
<td align="left">进程控制</td>
<td align="left">–</td>
<td align="left">child</td>
<td align="left">process</td>
</tr>
<tr>
<td align="left">文件stat</td>
<td align="left">–</td>
<td align="left">stat</td>
<td align="left">fs_poll</td>
</tr>
<tr>
<td align="left">每次循环都会执行的Idle事件</td>
<td align="left">–</td>
<td align="left">idle</td>
<td align="left">idle</td>
</tr>
<tr>
<td align="left">循环block之前执行</td>
<td align="left">–</td>
<td align="left">prepare</td>
<td align="left">prepare</td>
</tr>
<tr>
<td align="left">循环blcck之后执行</td>
<td align="left">–</td>
<td align="left">check</td>
<td align="left">check</td>
</tr>
<tr>
<td align="left">嵌套loop</td>
<td align="left">–</td>
<td align="left">embed</td>
<td align="left">–</td>
</tr>
<tr>
<td align="left">fork</td>
<td align="left">–</td>
<td align="left">fork</td>
<td align="left">–</td>
</tr>
<tr>
<td align="left">loop销毁之前的清理工作</td>
<td align="left">–</td>
<td align="left">cleanup</td>
<td align="left">–</td>
</tr>
<tr>
<td align="left">操作另一个线程中的loop</td>
<td align="left">–</td>
<td align="left">async</td>
<td align="left">async</td>
</tr>
<tr>
<td align="left">双向通信</td>
<td align="left">–</td>
<td align="left">–</td>
<td align="left">stream ( tcp, pipe, tty )</td>
</tr>
</tbody></table>
<p>这个对比对于libev和libuv更有意义，对于libevent，很多都是跟其设计思想有关的。<br>libev中的embed很少用，libuv没有也没关系；cleanup完全可以用libuv中的async_exit来替代；libuv没有fork事件。</p>
<h3 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h3><p>在libevent中，激活的事件是组织在优先级队列中的，各类事件默认的优先级是相同的，可以通过设置事件的优先级使其优先被处理。</p>
<p>libev也通过优先级队列来管理激活的时间，也可以设置事件的优先级。</p>
<p>libuv没有优先级的概念，而是按照固定的顺序访问各类事件。</p>
<h3 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h3><h4 id="略有不同"><a href="#略有不同" class="headerlink" title="略有不同"></a>略有不同</h4><p>对于事件循环，libev和libuv是相同的，即管理事件（等待并分发事件）。</p>
<p>但是在libevent里还有一个概念是event_base，是用于管理事件的，而lievent中的loop只是一个执行过程（仅仅是函数），并非一个实体（数据和函数）。</p>
<blockquote>
<p>Before you can use any interesting Libevent function, you need to allocate one or more event_base structures. Each event_base structure holds a set of events and can poll to determine which events are active.</p>
</blockquote>
<blockquote>
<p>If an event_base is set up to use locking, it is safe to access it between multiple threads. Its loop can only be run in a single thread, however. If you want to have multiple threads polling for IO, you need to have an event_base for each thread.</p>
</blockquote>
<blockquote>
<p>Tip</p>
</blockquote>
<blockquote>
<p>[A future version of Libevent may have support for event_bases that run events across multiple threads.]</p>
</blockquote>
<p>根据官网的介绍（不考虑其中提到的特殊版本），并对照源码中event_base_loop的实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">event_base_loop</span><span class="params">(<span class="keyword">struct</span> event_base *base, <span class="type">int</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Grab the lock.  We will release it inside evsel.dispatch, and again</span></span><br><span class="line"><span class="comment">	* as we invoke user callbacks. */</span></span><br><span class="line">	EVBASE_ACQUIRE_LOCK(base, th_base_lock);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (base-&gt;running_loop) &#123;</span><br><span class="line">	event_warnx(<span class="string">&quot;%s: reentrant invocation.  Only one event_base_loop&quot;</span></span><br><span class="line">	    <span class="string">&quot; can run on each event_base at once.&quot;</span>, __func__);</span><br><span class="line">	EVBASE_RELEASE_LOCK(base, th_base_lock);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	done:</span><br><span class="line">	clear_time_cache(base);</span><br><span class="line">	base-&gt;running_loop = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	EVBASE_RELEASE_LOCK(base, th_base_lock);</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在loop执行过程中，传入的base已被加锁，是不能用于其他执行过程的。</p>
<p>所以基本上libev和libuv里的loop相当于libevent中的loop函数和event_base的结合。</p>
<p>下文中提到的loop仅指libev和libuv中的loop。</p>
<h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><p>libevent、libev、libuv里的event_base和loop都不是线程安全的，也就是说一个event_base或loop实例只能在用户的一个线程内访问（一般是主线程），注册到event_base或loop的event都是串行访问的，即每个执行过程中，会按照优先级顺序访问已经激活的事件，执行其回调函数。所以在仅使用一个event_base或loop的情况下，回调函数的执行不存在并行关系。</p>
<p>如果应用程序除了主loop外，没有自己启动任何线程，那么不用担心回调里的“临界区”。</p>
<p>如果使用了多个event_base或loop（一般每个线程一个event_base或loop），需要考虑共享数据的同步问题。</p>
<h2 id="可移植"><a href="#可移植" class="headerlink" title="可移植"></a>可移植</h2><h3 id="支持的操作系统"><a href="#支持的操作系统" class="headerlink" title="支持的操作系统"></a>支持的操作系统</h3><p>三个库都支持Linux, *BSD, Mac OS X, Solaris, Windows</p>
<table>
<thead>
<tr>
<th align="left">type</th>
<th align="left">libevent</th>
<th align="left">libev</th>
<th align="left">libuv</th>
</tr>
</thead>
<tbody><tr>
<td align="left">dev&#x2F;poll (Solaris)</td>
<td align="left">y</td>
<td align="left">y</td>
<td align="left">y</td>
</tr>
<tr>
<td align="left">event ports</td>
<td align="left">y</td>
<td align="left">y</td>
<td align="left">y</td>
</tr>
<tr>
<td align="left">kqueue (*BSD)</td>
<td align="left">y</td>
<td align="left">y</td>
<td align="left">y</td>
</tr>
<tr>
<td align="left">POSIX select</td>
<td align="left">y</td>
<td align="left">y</td>
<td align="left">y</td>
</tr>
<tr>
<td align="left">Windows select</td>
<td align="left">y</td>
<td align="left">y</td>
<td align="left">y</td>
</tr>
<tr>
<td align="left">Windows IOCP</td>
<td align="left">y</td>
<td align="left">N</td>
<td align="left">y</td>
</tr>
<tr>
<td align="left">poll</td>
<td align="left">y</td>
<td align="left">y</td>
<td align="left">y</td>
</tr>
<tr>
<td align="left">epoll</td>
<td align="left">y</td>
<td align="left">y</td>
<td align="left">y</td>
</tr>
</tbody></table>
<p>对于Unix&#x2F;Linux平台，没有什么大不同，优先选择epoll，对于windows，libevent、libev都使用select检测和分发事件（不I&#x2F;O），libuv在windows下使用IOCP。libevent有一个socket handle, 在windows上使用IOCP进行读写。libev没有类似的。但是libevent的IOCP支持也不是很好（性能不高）。所以如果是在windows平台下，使用原生的IOCP进行I&#x2F;O，或者使用libuv。</p>
<h2 id="异步架构程序设计原则"><a href="#异步架构程序设计原则" class="headerlink" title="异步架构程序设计原则"></a>异步架构程序设计原则</h2><ol>
<li>回调函数不可以执行过长时间，因为一个loop中可能包含其他事件，尤其是会影响一些准确度要求比较高的timer。</li>
<li>尽量采用库中所缓存的时间，有时候需要根据时间差来执行timeout之类的操作。当然能够利用库中的timer最好。</li>
</ol>
]]></content>
      <categories>
        <category>网络</category>
        <category>事件</category>
      </categories>
      <tags>
        <tag>事件</tag>
        <tag>event</tag>
      </tags>
  </entry>
  <entry>
    <title>组播（多播）</title>
    <url>/post/18736.html</url>
    <content><![CDATA[<blockquote>
<p>组播是指在IP网络中将数据包以尽力传送的形式发送到某个确定的节点集合（即组播组），其基本思想是：源主机（即组播源）只发送一份数据，其目的地址为组播组地址；组播组中的所有接收者都可收到同样的数据拷贝，并且只有组播组内的主机可以接收该数据，而其它主机则不能收到。</p>
</blockquote>
<p>组播技术有效地解决了<code>单点发送、多点接收</code>的问题，实现了IP网络中点到多点的高效数据传送，能够大量节约网络带宽、降低网络负载。作为一种与单播和广播并列的通信方式，组播的意义不仅在于此。更重要的是，可以利用网络的组播特性方便地提供一些新的增值业务，包括在线直播、网络电视、远程教育、远程医疗、网络电台、实时视频会议等互联网的信息服务领域</p>
<p><img data-src="/images/net/multicast/multicast.png" alt="组播"></p>
<span id="more"></span>

<h2 id="组播技术实现"><a href="#组播技术实现" class="headerlink" title="组播技术实现"></a>组播技术实现</h2><p>组播技术的实现需要解决以下几方面问题：</p>
<ol>
<li>组播源向一组确定的接收者发送信息，而如何来标识这组确定的接收者？——这需要用到<code>组播地址机制</code>；</li>
<li>接收者通过加入组播组来实现对组播信息的接收，而接收者是如何动态地加入或离开组播组的？——即如何进行<code>组成员关系管理</code>；</li>
<li>组播报文在网络中是如何被转发并最终到达接收者的？——即<code>组播报文转发</code>的过程；</li>
<li>组播报文的转发路径（即组播转发树）是如何构建的？——这是由各<code>组播路由协议</code>来完成的。</li>
</ol>
<h2 id="组播地址机制"><a href="#组播地址机制" class="headerlink" title="组播地址机制"></a>组播地址机制</h2><h3 id="IP组播地址"><a href="#IP组播地址" class="headerlink" title="IP组播地址"></a>IP组播地址</h3><p><img data-src="/images/net/multicast/ip_format.gif" alt="ip format"></p>
<p>IP组播地址前四位均为“1110”</p>
<p>IP组播地址用于标识一个IP组播组。IANA把D类地址空间分配给组播使用，范围从<code>224.0.0.0</code>到<code>239.255.255.255</code>。</p>
<p><img data-src="/images/net/multicast/ip_class.gif" alt="ip class"></p>
<p><strong>组播地址划分:</strong></p>
<ol>
<li>224.0.0.0到224.0.0.255被IANA预留，地址224.0.0.0保留不做分配，其它地址供路由协议及拓扑查找和维护协议使用。该范围内的地址属于局部范畴，不论TTL为多少，都不会被路由器转发；</li>
<li>224.0.1.0到238.255.255.255为用户可用的组播地址，在全网范围内有效。其中232.0.0.0&#x2F;8为SSM组地址，而其余则属于ASM组地址。有关ASM和SSM的详细介绍，请参见“2.5  组播模型分类”一节；</li>
<li>239.0.0.0到239.255.255.255为本地管理组播地址，仅在特定的本地范围内有效，也属于ASM组地址。使用本地管理组地址可以灵活定义组播域的范围，以实现不同组播域之间的地址隔离，从而有助于在不同组播域内重复使用相同组播地址而不会引起冲突。</li>
</ol>
<p><em><strong>说明：</strong></em></p>
<blockquote>
<p><code>224.0.1.0/24</code>网段内的一些组播地址也被IANA预留给了某些组播应用。譬如，<code>224.0.1.1</code>被预留给NTP（Network Time Protocol，网络时间协议）所使用。</p>
</blockquote>
<h2 id="组成员关系管理"><a href="#组成员关系管理" class="headerlink" title="组成员关系管理"></a>组成员关系管理</h2><p>组成员关系管理是指在<code>路由器/交换机</code>上建立直联网段内的组成员关系信息，具体说，就是各接口&#x2F;端口下有哪些组播组的成员。</p>
<h3 id="IGMP"><a href="#IGMP" class="headerlink" title="IGMP"></a>IGMP</h3><p>IGMP运行于<code>主机和与主机直连的路由器</code>之间，其实现的功能是双向的：</p>
<ul>
<li>一方面，主机通过IGMP通知路由器希望接收某个特定组播组的信息；</li>
<li>另一方面，路由器通过IGMP周期性地查询局域网内的组播组成员是否处于活动状态，实现所连网段组成员关系的收集与维护。</li>
</ul>
<p>通过IGMP，在路由器中记录的信息是某个组播组是否在本地有组成员，而不是组播组与主机之间的对应关系。</p>
<p>目前IGMP有以下三个版本：</p>
<ol>
<li><code>IGMPv1（RFC 1112）</code>中定义了基本的组成员查询和报告过程；</li>
<li><code>IGMPv2（RFC 2236）</code>在IGMPv1的基础上添加了组成员快速离开的机制等；</li>
<li><code>IGMPv3（RFC 3376）</code>中增加的主要功能是成员可以指定接收或拒绝来自某些组播源的报文，以实现对SSM模型的支持。</li>
</ol>
<h4 id="IGMPv2的工作原理"><a href="#IGMPv2的工作原理" class="headerlink" title="IGMPv2的工作原理"></a>IGMPv2的工作原理</h4><p><img data-src="/images/net/multicast/IGMPv2.gif" alt="IGMPv2"></p>
<p>当同一个网段内有多个IGMP路由器时，IGMPv2通过查询器选举机制从中选举出唯一的查询器。查询器周期性地发送普遍组查询消息进行成员关系查询，主机通过发送报告消息来响应查询。而作为组成员的路由器，其行为也与普通主机一样，响应其它路由器的查询。</p>
<p>当主机要加入组播组时，不必等待查询消息，而是主动发送报告消息；当主机要离开组播组时，也会主动发送离开组消息，查询器收到离开组消息后，会发送特定组查询消息来确定该组的所有组成员是否都已离开。</p>
<p>通过上述机制，在路由器里建立起一张表，其中记录了路由器各接口所对应子网上都有哪些组的成员。当路由器收到发往组G的组播数据后，只向那些有G的成员的接口转发该数据。至于组播数据在路由器之间如何转发则由组播路由协议决定，而不是IGMP的功能。</p>
<h4 id="抓包信息"><a href="#抓包信息" class="headerlink" title="抓包信息"></a>抓包信息</h4><p><img data-src="/images/net/multicast/multicast_start_package.png" alt="组播初始化数据包"></p>
<p><em><strong>IGMPv2 destination address</strong></em></p>
<table>
<thead>
<tr>
<th align="center">Message Type</th>
<th align="center">Multicast Address</th>
</tr>
</thead>
<tbody><tr>
<td align="center">General Query</td>
<td align="center">All hosts (224.0.0.1)</td>
</tr>
<tr>
<td align="center">Group-Specific Query</td>
<td align="center">The group being queried</td>
</tr>
<tr>
<td align="center">Membership Report</td>
<td align="center">The group being reported</td>
</tr>
<tr>
<td align="center">Leave Group	All</td>
<td align="center">routers (224.0.0.2)</td>
</tr>
</tbody></table>
<p>组播相关的含义：</p>
<ol>
<li><p>IGMPv2: Membership Query, general</p>
<blockquote>
<p>发给所有主机</p>
</blockquote>
</li>
<li><p>IGMPv2: Membership Report group 239.0.0.11</p>
<blockquote>
<p>收到后，回应组播地址</p>
</blockquote>
</li>
</ol>
<h3 id="IGMP-Snooping"><a href="#IGMP-Snooping" class="headerlink" title="IGMP Snooping"></a>IGMP Snooping</h3><p>IGMP是针对IP层设计的，只能记录路由器上的三层接口与IP组播地址的对应关系。但在很多情况下，组播报文不可避免地要经过一些交换机，如果没有一种机制将二层端口与组播MAC地址对应起来，组播报文就会转发给交换机的所有端口，这显然会浪费大量的系统资源。</p>
<p>IGMP Snooping的出现就可以解决这个问题，其工作原理为：主机发往IGMP查询器的报告消息经过交换机时，交换机对这个消息进行监听并记录下来，为端口和组播MAC地址建立起映射关系；当交换机收到组播数据时，根据这样的映射关系，只向连有组成员的端口转发组播数据。</p>
<h2 id="组播编程"><a href="#组播编程" class="headerlink" title="组播编程"></a>组播编程</h2><p>多播的程序设计使用setsockopt()函数和getsockopt()函数来实现，组播的选项是<code>IP层</code>的，其选项值和含义</p>
<table>
<thead>
<tr>
<th align="center">getsockopt()&#x2F;setsockopt()的选项</th>
<th align="center">含    义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">IP_MULTICAST_TTL</td>
<td align="center">设置多播组数据的TTL值</td>
</tr>
<tr>
<td align="center">IP_ADD_MEMBERSHIP</td>
<td align="center">在指定接口上加入组播组</td>
</tr>
<tr>
<td align="center">IP_DROP_MEMBERSHIP</td>
<td align="center">退出组播组</td>
</tr>
<tr>
<td align="center">IP_MULTICAST_IF</td>
<td align="center">获取默认接口或设置接口</td>
</tr>
<tr>
<td align="center">IP_MULTICAST_LOOP</td>
<td align="center">禁止组播数据回送</td>
</tr>
</tbody></table>
<h2 id="实例–视频会议"><a href="#实例–视频会议" class="headerlink" title="实例–视频会议"></a>实例–视频会议</h2><p><img data-src="/images/net/multicast/multicast_r_s_samp.png" alt="组播实例"></p>
<ol>
<li>路由器新建两个AP（AP-S和AP-R），其中均开启组播功能，为什么建两个，作用，关系</li>
<li>R1和R2两个加入组播（239.0.0.1）</li>
</ol>
<h3 id="S"><a href="#S" class="headerlink" title="S"></a>S</h3><ol>
<li><p>建立socket</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">fd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>绑定</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> sockaddr_in localAddr</span><br><span class="line"><span class="title function_">memset</span><span class="params">(localAddr.sin_zero, <span class="number">0</span>, <span class="keyword">sizeof</span>(localAddr.sin_zero))</span>;</span><br><span class="line">localAddr.sin_family = AF_INET;</span><br><span class="line">localAddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">localAddr.sin_port = htons(netParam-&gt;local_port);	<span class="comment">//port(Random): Pick an even integer in range [1024, 65534)</span></span><br><span class="line">bind(fd, (<span class="type">const</span> <span class="keyword">struct</span> sockaddr *)&amp;localAddr, <span class="keyword">sizeof</span>(localAddr));</span><br></pre></td></tr></table></figure>
</li>
<li><p>连接</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">remoteAddr</span>;</span></span><br><span class="line"><span class="built_in">memset</span>(remoteAddr.sin_zero, <span class="number">0</span>, <span class="keyword">sizeof</span>(remoteAddr.sin_zero));</span><br><span class="line">remoteAddr.sin_family = AF_INET;</span><br><span class="line">remoteAddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">remoteAddr.sin_port = htons(netParam-&gt;remote_port); 	<span class="comment">//port: 15550</span></span><br><span class="line">ret = inet_pton(AF_INET, netParam-&gt;remoteip, &amp;remoteAddr.sin_addr);	<span class="comment">//remoteip: 239.0.0.1</span></span><br><span class="line">ret = connect(fd, (<span class="type">const</span> <span class="keyword">struct</span> sockaddr *)&amp;remoteAddr, <span class="keyword">sizeof</span>(remoteAddr));</span><br></pre></td></tr></table></figure>
<blockquote>
<p>通过connect指定了连接的IP和端口后，可以通过<code>netstat</code>命令查看</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;# netstat -n</span><br><span class="line">Active Internet connections (w/o servers)</span><br><span class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State</span><br><span class="line">tcp        0      0 192.168.100.2:7236      192.168.100.3:37536     ESTABLISHED</span><br><span class="line">udp        0      0 192.168.100.2:55226     239.0.0.11:15550        ESTABLISHED</span><br><span class="line">udp        0      0 192.168.100.2:55227     239.0.0.11:15551        ESTABLISHED</span><br></pre></td></tr></table></figure></blockquote>
</li>
</ol>
<h3 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h3><blockquote>
<p>为啥建立两个AP？</p>
</blockquote>
<h3 id="R"><a href="#R" class="headerlink" title="R"></a>R</h3><blockquote>
<p>测试代码实现</p>
</blockquote>
<p>在绑定后使用connect进行指定ip和port连接</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">remoteAddr</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(remoteAddr.sin_zero, <span class="number">0</span>, <span class="keyword">sizeof</span>(remoteAddr.sin_zero));</span><br><span class="line">remoteAddr.sin_family = AF_INET;  <span class="comment">/* 建立新的连接 */</span></span><br><span class="line"><span class="comment">//remoteAddr.sin_family = AF_INET;  /* 断开旧的连接 */</span></span><br><span class="line">inet_pton(AF_INET,player-&gt;rtpUdp.rip, &amp;remoteAddr.sin_addr);</span><br><span class="line">remoteAddr.sin_port = htons(player-&gt;rtpUdp.rport);   <span class="comment">//port: 0</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    ret = connect(player-&gt;rtpUdp.fd,(<span class="keyword">struct</span> sockaddr *)&amp;remoteAddr,remoteAddrLen);</span><br><span class="line">&#125; <span class="keyword">while</span>(ret == <span class="number">-1</span> &amp;&amp; errno == EINTR);</span><br></pre></td></tr></table></figure>


<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># netstat -n</span><br><span class="line">Active Internet connections (w/o servers)</span><br><span class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State</span><br><span class="line">tcp        0      0 192.168.100.3:40964     192.168.100.2:7236      ESTABLISHED</span><br><span class="line">udp        0      0 239.0.0.11:15550        192.168.100.2:*         ESTABLISHED   #Foreign port: 0</span><br><span class="line">udp        0      0 239.0.0.11:15551        192.168.100.2:1         ESTABLISHED</span><br></pre></td></tr></table></figure>


<h2 id="注意–无法得到数据原因"><a href="#注意–无法得到数据原因" class="headerlink" title="注意–无法得到数据原因"></a>注意–无法得到数据原因</h2><blockquote>
<p>select一直出现timeout</p>
</blockquote>
<ol>
<li>接收组播的网络端口（也就是R端），必须设置该组播的IP，负责接收不到组播数据</li>
<li>数据包被操作系统过滤掉了，所以系统调用socket无法看到数据包。</li>
</ol>
<h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><h3 id="ifconfig-–-判断是支持组播"><a href="#ifconfig-–-判断是支持组播" class="headerlink" title="ifconfig – 判断是支持组播"></a>ifconfig – 判断是支持组播</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ifconfig</span></span><br><span class="line">wlan0     Link encap:Ethernet  HWaddr 04:E6:76:C3:63:DC</span><br><span class="line">          inet addr:192.168.100.2  Bcast:192.168.100.255  Mask:255.255.255.0</span><br><span class="line">          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1</span><br><span class="line">          RX packets:1413 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:316 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:1000</span><br><span class="line">          RX bytes:88628 (86.5 KiB)  TX bytes:40942 (39.9 KiB)</span><br></pre></td></tr></table></figure>


<ul>
<li><code>UP</code>: 代表网卡开启状态</li>
<li><code>BROADCAST</code>: 支持广播</li>
<li><code>RUNNING</code>: 代表网卡的网线被接上</li>
<li><code>MULTICAST</code>: 支持组播</li>
<li><code>RX packets</code>和<code>TX packets</code>: 表示网卡接收和发送的数据包个数，<em><strong>但是由于端口的错误等，可能导致select或recv超时或者接收不到数据</strong></em></li>
<li><code>RX bytes</code>和<code>TX bytes</code>: 表示接收和发送的数据大小</li>
</ul>
<h2 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h2><p>R端加入组播的实现： Client</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL1dpbmRkb2luZy9Db2RlV2hlZWwvbWFzdGVyL3NvY2tldC9tdWx0aWNhc3QvbXVsdGljYXN0LXRzdC5j">Code：<i class="fa fa-external-link-alt"></i></span></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFLEN 255</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VX_RTP_MUL_IP	<span class="string">&quot;239.0.0.11&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VX_RTP_LOCAL_PORT 15550</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VX_RTP_MUL_IP	<span class="string">&quot;225.0.0.37&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VX_RTP_LOCAL_PORT 12345</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">socket_set_nonblock</span><span class="params">(<span class="type">int</span> s)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> flags, res;</span><br><span class="line"></span><br><span class="line">	flags = fcntl(s, F_GETFL, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (flags &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		flags = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	res = fcntl(s, F_SETFL, flags | O_NONBLOCK);</span><br><span class="line">	<span class="keyword">if</span> (res &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>( <span class="string">&quot;fcntl return err:%d!\n&quot;</span>, res);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> fd = <span class="number">-1</span>;</span><br><span class="line">	<span class="type">int</span> ret = <span class="number">-1</span>, n = <span class="number">0</span>, sock_len = <span class="number">0</span>;</span><br><span class="line">	<span class="type">char</span> recmsg[BUFLEN + <span class="number">1</span>];</span><br><span class="line">	fd_set rfds;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ip_mreq</span> <span class="title">mreq</span>;</span></span><br><span class="line">	<span class="type">int</span> yes=<span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> loop = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*UDP*/</span></span><br><span class="line">	fd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span>(fd == <span class="number">-1</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;create udp socket error %d&quot;</span>, -errno);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	socket_set_nonblock(fd);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 允许多个应用绑定同一个本地端口接收数据包 */</span></span><br><span class="line">	ret = setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &amp;yes,<span class="keyword">sizeof</span>(yes));</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;setsockopt: SO_REUSEADDR error, ret=%d\n&quot;</span>, ret);</span><br><span class="line">		<span class="keyword">goto</span> failed;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 禁止组播数据回环 */</span></span><br><span class="line">	<span class="keyword">if</span>( setsockopt(fd, IPPROTO_IP, IP_MULTICAST_LOOP, (<span class="type">char</span> *)&amp;loop, <span class="keyword">sizeof</span>(loop)) &lt; <span class="number">0</span> )&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;setsockopt: IP_MULTICAST_LOOP error, ret=%d\n&quot;</span>, ret);</span><br><span class="line">		<span class="keyword">goto</span> failed;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 加入组播 */</span></span><br><span class="line">	mreq.imr_multiaddr.s_addr=inet_addr(VX_RTP_MUL_IP);</span><br><span class="line">	mreq.imr_interface.s_addr=htonl(INADDR_ANY);</span><br><span class="line">	ret = setsockopt(fd,IPPROTO_IP,IP_ADD_MEMBERSHIP,&amp;mreq,<span class="keyword">sizeof</span>(mreq));</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;setsockopt: IP_ADD_MEMBERSHIP error, ret=%d\n&quot;</span>, ret);</span><br><span class="line">		<span class="keyword">goto</span> failed;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">memset</span>(addr.sin_zero, <span class="number">0</span>, <span class="keyword">sizeof</span>(addr.sin_zero));</span><br><span class="line">	addr.sin_family = AF_INET;</span><br><span class="line">	addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">	addr.sin_port = htons(VX_RTP_LOCAL_PORT);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 设置网卡的组播IP !!! */</span></span><br><span class="line">	ret = inet_pton(AF_INET, VX_RTP_MUL_IP, &amp;addr.sin_addr);</span><br><span class="line">	<span class="keyword">if</span> (ret &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Set network card multicast ip error, ret=%d\n&quot;</span>, ret);</span><br><span class="line">		<span class="keyword">goto</span> failed;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 绑定网卡 */</span></span><br><span class="line">	ret = bind(fd, (<span class="type">const</span> <span class="keyword">struct</span> sockaddr *)&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Bind socket error, ret=%d\n&quot;</span>, ret);</span><br><span class="line">		<span class="keyword">goto</span> failed;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;create rtp udp socket %d ok\n&quot;</span>,fd);</span><br><span class="line"></span><br><span class="line">	sock_len = <span class="keyword">sizeof</span>(addr);</span><br><span class="line">	<span class="comment">/* 循环接收网络上来的组播消息 */</span></span><br><span class="line">	<span class="keyword">for</span> (;;)</span><br><span class="line">	&#123;</span><br><span class="line">		tv.tv_sec = <span class="number">1</span>;</span><br><span class="line">		tv.tv_usec = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		FD_ZERO(&amp;rfds);</span><br><span class="line">		FD_SET(fd, &amp;rfds);</span><br><span class="line"></span><br><span class="line">		ret = select(fd + <span class="number">1</span>, &amp;rfds, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;tv);</span><br><span class="line">		<span class="keyword">if</span> (<span class="number">-1</span> == ret) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;===&gt; func: %s, line: %d, Socket select error\n&quot;</span>, __func__, __LINE__);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">0</span> == ret) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;===&gt; func: %s, line: %d, select timeout\n&quot;</span>, __func__, __LINE__);</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//struct sockaddr_in tmp_addr;</span></span><br><span class="line">		<span class="comment">//socklen_t addr_len = sizeof(tmp_addr);</span></span><br><span class="line">		<span class="comment">//bzero (recmsg, BUFLEN + 1);</span></span><br><span class="line"></span><br><span class="line">eagain:</span><br><span class="line">		<span class="comment">//n = recvfrom(fd, recmsg, BUFLEN, 0, (struct sockaddr*) &amp;addr, (socklen_t*)&amp;sock_len);</span></span><br><span class="line">		<span class="comment">//n = recvfrom(fd, recmsg, BUFLEN, 0, (struct sockaddr*) &amp;tmp_addr, &amp;addr_len);</span></span><br><span class="line">		n = recv(fd, recmsg, BUFLEN, <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;recvfrom err in udptalk!, n: %d, errno: %d\n&quot;</span>, n, -errno);</span><br><span class="line">			<span class="keyword">if</span> (EAGAIN == errno)</span><br><span class="line">				<span class="keyword">goto</span> eagain;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;recv data siez: %d\n&quot;</span>, n);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">/* 成功接收到数据报 */</span></span><br><span class="line">			<span class="type">unsigned</span> <span class="type">int</span> * tmp = (<span class="type">unsigned</span> <span class="type">int</span>*)recmsg;</span><br><span class="line"></span><br><span class="line">			<span class="built_in">printf</span> (<span class="string">&quot;s: %d, peer: 0x%08x\n&quot;</span>, n, tmp[<span class="number">0</span>]);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">failed:</span><br><span class="line">	<span class="keyword">if</span>(fd &gt; <span class="number">0</span>)</span><br><span class="line">		close(fd);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Server：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HELLO_PORT 12345</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HELLO_GROUP <span class="string">&quot;225.0.0.37&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">	<span class="type">int</span> fd;</span><br><span class="line">	<span class="type">char</span> *message=<span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* create what looks like an ordinary UDP socket */</span></span><br><span class="line">	<span class="keyword">if</span> ((fd=socket(AF_INET,SOCK_DGRAM,<span class="number">0</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* set up destination address */</span></span><br><span class="line">	<span class="built_in">memset</span>(&amp;addr,<span class="number">0</span>,<span class="keyword">sizeof</span>(addr));</span><br><span class="line">	addr.sin_family=AF_INET;</span><br><span class="line">	addr.sin_addr.s_addr=inet_addr(HELLO_GROUP);</span><br><span class="line">	addr.sin_port=htons(HELLO_PORT);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;message: %s, (HEX: 0x%08x)\n&quot;</span>, message, *(<span class="type">unsigned</span> <span class="type">int</span>*)message);</span><br><span class="line">	<span class="comment">/* now just sendto() our destination! */</span></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (sendto(fd,message, <span class="built_in">strlen</span>(message), <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr *) &amp;addr, <span class="keyword">sizeof</span>(addr)) &lt; <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			perror(<span class="string">&quot;sendto&quot;</span>);</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		sleep(<span class="number">1</span>); <span class="comment">//会影响接受端select的超时时间，延时越大，select的超时越大</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ppYW5jaGFvbHYvYXJ0aWNsZS9kZXRhaWxzLzc5MDk5NDg=">组播技术<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NhbXRhb3lzL2FydGljbGUvZGV0YWlscy81MTk4MTMyMw==">组播学习笔记<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL2NvbG9idS5jb20vMjAxNC8xMC8yMS91ZHAtYW5kLXVuaWNhc3QtbXVsdGljYXN0LWJyb2FkY2FzdC1hbnljYXN0LyMwLXRzaW5hLTEtNjcwMDAtMzk3MjMyODE5ZmY5YTQ3YTdiN2U4MGE0MDYxM2NmZTE=">单播，组播(多播)，广播以及任播<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vZ2hqMTk3Ni9wLzUyNzY0NTIuaHRtbA==">组播（Multicast）传输<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL2Jsb2cuY2hpbmF1bml4Lm5ldC91aWQtMjg0NTg4MDEtaWQtNTA4NTA5OS5odG1s">多播,IP_MULTICAST_TTL,IP_ADD_MEMBERSHIP,IP_MULTICAST_IF,IP_DROP_MEMBERSHIP<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>网络</category>
        <category>组播</category>
      </categories>
      <tags>
        <tag>组播</tag>
      </tags>
  </entry>
  <entry>
    <title>网络带宽测试</title>
    <url>/post/21135.html</url>
    <content><![CDATA[<p><code>iperf</code>是一个网络性能测试工具。Iperf可以测试TCP和UDP带宽质量。Iperf可以测量最大TCP带宽，具有多种参数和UDP特性。 Iperf可以报告带宽，延迟抖动和数据包丢失。利用Iperf这一特性，可以用来测试一些网络设备如路由器，防火墙，交换机等的性能。</p>
<span id="more"></span>

<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="PC"><a href="#PC" class="headerlink" title="PC"></a>PC</h3><p>下载地址： <span class="exturl" data-url="aHR0cHM6Ly9pcGVyZi5mci9pcGVyZi1kb3dubG9hZC5waHA=">here<i class="fa fa-external-link-alt"></i></span></p>
<h3 id="交叉编译"><a href="#交叉编译" class="headerlink" title="交叉编译"></a>交叉编译</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">IPERF_VERSION=&quot;3.1.3&quot;</span><br><span class="line">ARM_GCC=&quot;arm-linux-gnueabihf-gcc&quot;</span><br><span class="line">PWD=`pwd`</span><br><span class="line"></span><br><span class="line">wget https://iperf.fr/download/source/iperf-$&#123;IPERF_VERSION&#125;-source.tar.gz</span><br><span class="line"></span><br><span class="line">tar zxvf iperf-$&#123;IPERF_VERSION&#125;-source.tar.gz</span><br><span class="line"></span><br><span class="line">cd iperf-$&#123;IPERF_VERSION&#125;/</span><br><span class="line">mkdir install</span><br><span class="line"></span><br><span class="line">./configure  --host=arm-linux CC=$&#123;ARM_GCC&#125; --prefix=$&#123;PWD&#125;/install</span><br><span class="line"></span><br><span class="line">make</span><br><span class="line"></span><br><span class="line">make install</span><br></pre></td></tr></table></figure>

<h2 id="iperf"><a href="#iperf" class="headerlink" title="iperf"></a>iperf</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">iperf --<span class="built_in">help</span></span></span><br><span class="line">Usage: iperf [-s|-c host] [options]</span><br><span class="line">       iperf [-h|--help] [-v|--version]</span><br><span class="line"></span><br><span class="line">Client/Server:</span><br><span class="line">  -f, --format    [kmKM]   format to report: Kbits, Mbits, KBytes, MBytes</span><br><span class="line">  -i, --interval  #        seconds between periodic bandwidth reports</span><br><span class="line">  -l, --len       #[KM]    length of buffer to read or write (default 8 KB)</span><br><span class="line">  -m, --print_mss          print TCP maximum segment size (MTU - TCP/IP header)</span><br><span class="line">  -o, --output    &lt;filename&gt; output the report or error message to this specified file</span><br><span class="line">  -p, --port      #        server port to listen on/connect to</span><br><span class="line">  -u, --udp                use UDP rather than TCP</span><br><span class="line">  -w, --window    #[KM]    TCP window size (socket buffer size)</span><br><span class="line">  -B, --bind      &lt;host&gt;   bind to &lt;host&gt;, an interface or multicast address</span><br><span class="line">  -C, --compatibility      for use with older versions does not sent extra msgs</span><br><span class="line">  -M, --mss       #        set TCP maximum segment size (MTU - 40 bytes)</span><br><span class="line">  -N, --nodelay            set TCP no delay, disabling Nagle&#x27;s Algorithm</span><br><span class="line">  -V, --IPv6Version        Set the domain to IPv6</span><br><span class="line"></span><br><span class="line">Server specific:</span><br><span class="line">  -s, --server             run in server mode</span><br><span class="line">  -U, --single_udp         run in single threaded UDP mode</span><br><span class="line">  -D, --daemon             run the server as a daemon</span><br><span class="line"></span><br><span class="line">Client specific:</span><br><span class="line">  -b, --bandwidth #[KM]    for UDP, bandwidth to send at in bits/sec</span><br><span class="line">                           (default 1 Mbit/sec, implies -u)</span><br><span class="line">  -c, --client    &lt;host&gt;   run in client mode, connecting to &lt;host&gt;</span><br><span class="line">  -d, --dualtest           Do a bidirectional test simultaneously</span><br><span class="line">  -n, --num       #[KM]    number of bytes to transmit (instead of -t)</span><br><span class="line">  -r, --tradeoff           Do a bidirectional test individually</span><br><span class="line">  -t, --time      #        time in seconds to transmit for (default 10 secs)</span><br><span class="line">  -F, --fileinput &lt;name&gt;   input the data to be transmitted from a file</span><br><span class="line">  -I, --stdin              input the data to be transmitted from stdin</span><br><span class="line">  -L, --listenport #       port to receive bidirectional tests back on</span><br><span class="line">  -P, --parallel  #        number of parallel client threads to run</span><br><span class="line">  -T, --ttl       #        time-to-live, for multicast (default 1)</span><br><span class="line">  -Z, --linux-congestion &lt;algo&gt;  set TCP congestion control algorithm (Linux only)</span><br><span class="line"></span><br><span class="line">Miscellaneous:</span><br><span class="line">  -x, --reportexclude [CDMSV]   exclude C(connection) D(data) M(multicast) S(settings) V(server) reports</span><br><span class="line">  -y, --reportstyle C      report as a Comma-Separated Values</span><br><span class="line">  -h, --help               print this message and quit</span><br><span class="line">  -v, --version            print version information and quit</span><br><span class="line"></span><br><span class="line">[KM] Indicates options that support a K or M suffix for kilo- or mega-</span><br><span class="line"></span><br><span class="line">The TCP window size option can be set by the environment variable</span><br><span class="line">TCP_WINDOW_SIZE. Most other options can be set by an environment variable</span><br><span class="line">IPERF_&lt;long option name&gt;, such as IPERF_BANDWIDTH.</span><br><span class="line"></span><br><span class="line">Report bugs to &lt;iperf-users@lists.sourceforge.net&gt;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th align="left">命令行选项</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">-i, –interval</td>
<td align="left">设置每次报告之间的时间间隔，单位为秒。如果设置为非零值，就会按照此时间间隔输出测试报告。默认值为零。</td>
</tr>
<tr>
<td align="left">-l, –len #[KM]</td>
<td align="left">设置读写缓冲区的长度。TCP方式默认为8KB，UDP方式默认为1470字节。</td>
</tr>
<tr>
<td align="left">-p, –port</td>
<td align="left">设置端口，与服务器端的监听端口一致。默认是5001端口，与ttcp的一样。</td>
</tr>
<tr>
<td align="left">-u, –udp</td>
<td align="left">使用UDP方式而不是TCP方式。参看-b选项。</td>
</tr>
<tr>
<td align="left">Server</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">-s, –server</td>
<td align="left">Iperf服务器模式</td>
</tr>
<tr>
<td align="left">-c, –client host</td>
<td align="left">如果Iperf运行在服务器模式，并且用-c参数指定一个主机，那么Iperf将只接受指定主机的连接。此参数不能工作于UDP模式。</td>
</tr>
<tr>
<td align="left">Client</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">-c, –client host</td>
<td align="left">运行Iperf的客户端模式，连接到指定的Iperf服务器端。</td>
</tr>
<tr>
<td align="left">-t, –time #</td>
<td align="left">设置传输的总时间。Iperf在指定的时间内，重复的发送指定长度的数据包。默认是10秒钟。参考-l与-n选项。</td>
</tr>
<tr>
<td align="left">-P, –parallel #</td>
<td align="left">线程数。指定客户端与服务端之间使用的线程数。默认是1线程。需要客户端与服务器端同时使用此参数。</td>
</tr>
<tr>
<td align="left">-d, –dualtest</td>
<td align="left">运行双测试模式。这将使服务器端反向连接到客户端，使用-L 参数中指定的端口（或默认使用客户端连接到服务器端的端口）。这些在操作的同时就立即完成了。如果你想要一个交互的测试，请尝试-r参数。</td>
</tr>
</tbody></table>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>带宽测试通常采用<code>UDP模式</code>，因为能测出极限带宽、时延抖动、丢包率。在进行测试时，首先以链路理论带宽作为数据发送速率进行测试，例如，从客户端到服务器之间的链路的理论带宽为100Mbps，先用<code>-b 100M</code>进行测试，然后根据测试结果（包括实际带宽，时延抖动和丢包率），再以实际带宽作为数据发送速率进行测试，会发现时延抖动和丢包率比第一次好很多，重复测试几次，就能得出稳定的实际带宽。</p>
<h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><p>服务器端：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">iperf -s</span><br></pre></td></tr></table></figure>
<p>客户端：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">iperf -c 192.168.1.1 -t 60</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在tcp模式下，客户端到服务器192.168.1.1上传带宽测试，测试时间为60秒。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">iperf -c 192.168.1.1  -P 30 -t 60</span><br></pre></td></tr></table></figure>
<blockquote>
<p>客户端同时向服务器端发起30个连接线程。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">iperf -c 192.168.1.1  -d -t 60</span><br></pre></td></tr></table></figure>
<blockquote>
<p>进行上下行带宽测试。</p>
</blockquote>
<h3 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h3><p>服务器端：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">iperf -u -s</span><br></pre></td></tr></table></figure>

<p>客户端：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">iperf -u -c 192.168.1.1 -b 100M -t 60</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在udp模式下，以100Mbps为数据发送速率，客户端到服务器192.168.1.1上传带宽测试，测试时间为60秒。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">iperf -u -c 192.168.1.1 -b 5M -P 30 -t 60</span><br></pre></td></tr></table></figure>
<blockquote>
<p>客户端同时向服务器端发起30个连接线程，以5Mbps为数据发送速率。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">iperf -u -c 192.168.1.1 -b 100M -d -t 60</span><br></pre></td></tr></table></figure>
<blockquote>
<p>以100M为数据发送速率，进行上下行带宽测试。</p>
</blockquote>
]]></content>
      <categories>
        <category>网络</category>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>Socket recv —— Connection reset by peer (104)</title>
    <url>/post/33577.html</url>
    <content><![CDATA[<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">n = recv(socket_fd, buf, len, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>在接收数据时:</p>
<p>有时<code>recv</code>的返回值<code>n&lt;0</code>，错误码：<code>104（Connection reset by peer）</code>，为啥？</p>
<p>有时<code>recv</code>的返回值<code>n=0</code>,对端socket关闭，如果对端socket没有关闭，为啥<code>n=0</code>？</p>
<span id="more"></span>

<h2 id="Connection-reset-by-peer-ECONNRESET-104"><a href="#Connection-reset-by-peer-ECONNRESET-104" class="headerlink" title="Connection reset by peer : (ECONNRESET 104)"></a>Connection reset by peer : (ECONNRESET 104)</h2><p>socket <code>read/recv</code>过程中，对方socket中断，<code>read/recv</code>会先返回已经发送的字节数,再次write时返回-1,errno号为<code>ECONNRESET(104)</code>.即：<strong>read&#x2F;recv 一个已收到<code>RST</code>的socket，系统会发SIGPIPE信号给该进程，如果将这个信号交给系统处理或者直接忽略掉了，read&#x2F;recv都返回EPIPE错误</strong>.因此对于socket通信一定要捕获此信号，进行适当处理 ，否则程序的异常退出将会给你带来灾难。</p>
<blockquote>
<p>The client’s call to <code>readline</code> may happen before the server’s RST is received by the client, or it may happen after.<br>If the readline happens before the RST is received, as we’ve shown in our example, the result is an unexpected EOF in the client.<br>But if the RST arrives first, the result is an <code>ECONNRESET (&quot;Connection reset by peer&quot;)</code> error return from readline.<br>What happens if the client ignores the error return from readline and writes more data to the server?<br>This can happen, for example, if the client needs to perform two writes to the server before reading anything back, with the first write eliciting the RST.<br>The rule that applies is: When a process writes to a socket that has received an RST, the SIGPIPE signal is sent to the process.<br>The default action of this signal is to terminate the process, so the process must catch the signal to avoid being involuntarily terminated.<br>If the process either catches the signal and returns from the signal handler, or ignores the signal, the write operation returns EPIPE.</p>
</blockquote>
<h3 id="tcp-syncookies"><a href="#tcp-syncookies" class="headerlink" title="tcp_syncookies"></a>tcp_syncookies</h3><p>在高并发的情况下，内核会认为系统受到了SYN flood攻击，会发送cookies（possible SYN flooding on port 80. Sending cookies），这样会减慢影响请求的速度，所以在应用服务武器上设置下这个参数为0禁用系统保护就可以进行大并发测试了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">net.ipv4.tcp_syncookies = 0</span><br></pre></td></tr></table></figure>

<h2 id="返回值-n-x3D-x3D-0"><a href="#返回值-n-x3D-x3D-0" class="headerlink" title="返回值: n&#x3D;&#x3D;0"></a>返回值: n&#x3D;&#x3D;0</h2><blockquote>
<p>When a stream socket peer has performed an orderly shutdown, the return value will be 0 (the traditional “end-of-file” return).<br>Datagram sockets in various domains (e.g., the UNIX and Internet domains) permit zero-length datagrams.  When such a datagram is received, the return value is 0.</p>
<blockquote>
<p>form <code>man recv</code></p>
</blockquote>
</blockquote>
<ul>
<li><p>产生的原因：<br>对端socket关闭，但是在实际的使用中对端的socket没有进行close的情况下有时也会返回<code>0</code>，这个可能就是数据传输中对端发送了长度为<code>0</code>的数据</p>
</li>
<li><p>解决方法：<br>在实际应用开发中我们需要进行错误处理时，将返回值小于等于0的状态进行统一处理。也就是在<code>accept</code>建立一个新的连接后，创建一个独立的线程进行数据的收发，如果在收发的过程中返回值出现错误时，关闭该socket和线程进入主进程重新建立一个连接继续进行数据收发（注意C&#x2F;S端均得进行这样的处理）</p>
</li>
</ul>
<p><img data-src="/images/2020/10/socket_tcp.png" alt="Socket TCP"></p>
<blockquote>
<p>在Server端其实存在两socket连接，listen监听的是主的socket描述符(一直存在直到主动关闭)，而当每一次accept时将会重新创建一个新的socket描述符用于数据的收发</p>
</blockquote>
<ul>
<li><p>client端创建一个单独的线程进行数据处理，比如进行数据读取，<code>connect</code>建立连接后，通过<code>recvfrom</code>进行读取，如果在读取数据正常没有出现任何异常时，利用<code>recvfrom</code>函数的阻塞功能将该线程阻塞住直到对端再一次发送数据，但是如果出现任何异常（函数返回值&lt;&#x3D;0）时,退出重新与对端建立新的连接后，继续数据读取</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">do_readn_sync</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *buffer, <span class="type">size_t</span> n, <span class="type">int</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">ssize_t</span> numRead;   <span class="comment">/* # of bytes fetched by last read() */</span></span><br><span class="line">    <span class="type">size_t</span> totRead;    <span class="comment">/* Total # of bytes read so far */</span></span><br><span class="line">    <span class="type">char</span> *buf;</span><br><span class="line"></span><br><span class="line">    buf = buffer;</span><br><span class="line">    <span class="keyword">for</span>(totRead = <span class="number">0</span>; totRead &lt; n;) &#123;</span><br><span class="line">        numRead = recvfrom(fd, buf, n - totRead, flags, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(numRead == <span class="number">0</span>)        <span class="comment">/* EOF */</span></span><br><span class="line">            <span class="keyword">return</span> totRead;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(numRead == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(errno == EINTR)</span><br><span class="line">                <span class="keyword">continue</span>;       <span class="comment">/* Interrupted -- restart read() */</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;      <span class="comment">/* Other error */</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        totRead += numRead;</span><br><span class="line">        buf += numRead;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> totRead;             <span class="comment">/* Must be &#x27;n&#x27; bytes if we get here */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Returns number of bytes read, 0 on EOF, or -1 on error</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">readn_sync</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *buffer, <span class="type">size_t</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> do_readn_sync(fd, buffer, n, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> _do_data_read()</span><br><span class="line">&#123;</span><br><span class="line">    #业务数据判断满足的读取条件</span><br><span class="line">:next</span><br><span class="line">    fd = socket();</span><br><span class="line">    connect()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      ret = readn(vm_input_fd, (<span class="type">void</span> *)buff, datalen);</span><br><span class="line">    &#125; <span class="keyword">while</span>(ret&gt;<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fd) &#123;</span><br><span class="line">      close(fd);</span><br><span class="line">      fd = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">goto</span> next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>server端： 在<code>accept</code>建立一个新的连接后，创建一个独立的线程进行数据的收发，如果在收发的过程中返回值出现错误时，关闭该socket和线程进入主进程重新建立一个连接继续进行数据收发</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"># 伪代码</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> _do_data_write(<span class="type">void</span> *arg)</span><br><span class="line">&#123;</span><br><span class="line">    ret = send()</span><br><span class="line">    <span class="keyword">if</span> (ret &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">      close(arg)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    fd = socket();</span><br><span class="line">    bind();</span><br><span class="line">    listen();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        new_fd = accept();</span><br><span class="line"></span><br><span class="line">        #也可以fork出一个进程进行处理</span><br><span class="line">        pthread_create(&amp;tid, &amp;attr, _do_data_write, (<span class="type">void</span> *)new_fd);</span><br><span class="line">        pthread_attr_destroy(&amp;attr);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="TCP-NODELAY"><a href="#TCP-NODELAY" class="headerlink" title="TCP_NODELAY"></a>TCP_NODELAY</h2><blockquote>
<p>socket编程中，<code>TCP_NODELAY</code>选项是用来控制是否开启<code>Nagle算法</code>，该算法是为了提高较慢的广域网传输效率，减小小分组的报文个数</p>
</blockquote>
<p>在TCP数据传输中，如果需要提高数据的实时性需要将<code>Nagle算法</code>关闭</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Disable Nagle */</span></span><br><span class="line"><span class="type">int</span> disable_nagle;</span><br><span class="line"><span class="type">int</span> nagleopt_len = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="number">0</span> != getsockopt(sockfd, IPPROTO_TCP, TCP_NODELAY, &amp;disable_nagle, &amp;nagleopt_len)) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;getsockopt TCP_NODELAY fail: %s\n&quot;</span>, strerror(errno));</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//printf(&quot;old TCP_NODELAY: %d\n&quot;, disable_nagle);</span></span><br><span class="line">&#125;</span><br><span class="line">disable_nagle = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="number">0</span> != setsockopt(sockfd, IPPROTO_TCP, TCP_NODELAY, &amp;disable_nagle, <span class="number">4</span>)) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;setsockopt TCP_NODELAY fail: %s\n&quot;</span>, strerror(errno));</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//printf(&quot;new TCP_NODELAY: %d\n&quot;, disable_nagle);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hndWlzdS9hcnRpY2xlL2RldGFpbHMvMzg3MDA4OTk=">TCP连接的状态详解以及故障排查<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Vlc3RjX2h1YW4vYXJ0aWNsZS9kZXRhaWxzLzU4NjM2MTQ=">Linux网络编程socket错误分析<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL3htYXJrZXIuYmxvZy4xNjMuY29tL2Jsb2cvc3RhdGljLzIyNjQ4NDA1NzIwMTQ2MjI2MzgxNTc4My8=">apache ab压力测试报错（apr_socket_recv: Connection reset by peer (104)）<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20va2V4MW4vcC83NDYxMTI0Lmh0bWw=">socket recv阻塞与非阻塞error总结<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>网络</category>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>libvirt源码分析——virsh</title>
    <url>/post/dec26e6d.html</url>
    <content><![CDATA[<p>libvirt是用来管理虚拟机或虚拟化功能的软件集合，主要包括：<code>libvirt API</code>，<code>libvirtd进程</code>和<code>virsh</code>工具集三部分。最初的目的是为不同的hypervisor提供统一的管理接口</p>
<blockquote>
<p><code>libvirt</code>是将最底层的直接在shell中输入命令来完成的操作进行了抽象封装，给应用程序开发人员提供了统一的，易用的接口。</p>
</blockquote>
<span id="more"></span>

<p>libvirt版本：<code>libvirt-4.9.0</code></p>
<h2 id="libvirt层次体系结构"><a href="#libvirt层次体系结构" class="headerlink" title="libvirt层次体系结构"></a>libvirt层次体系结构</h2><p><img data-src="/images/2020/09/libviry_api.png" alt="libviry_api"></p>
<p>参照上图，来理一下通过virsh命令或接口创建虚拟机实例的代码执行路径：</p>
<ol>
<li><p>virsh命令或API接口c创建虚拟机 —— 接口层</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">virsh create vm.xml 或者 virDomainPtr virDomainCreateXML (virConnectPtr conn, const char * xmlDesc, unsigned int flags)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>file: src&#x2F;libvirt-domain.c</p>
</blockquote>
</li>
<li><p>调用libvirt提供的统一接口 —— 抽象驱动层</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">conn-&gt;driver-&gt;domainCreateXML(conn, xmlDesc, flags);  //此处的domainCreateXML即抽象的统一接口，这里并不需要关心底层的driver是kvm，还是xen</span><br></pre></td></tr></table></figure>
</li>
<li><p>调用底层的相应虚拟化技术的接口 —— 具体驱动层</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">domainCreateXML = qemuDomainCreateXML; //如果driver=qemu，那么此处即调用的qemu注册到抽象驱动层上的函数qemuDomainCreateXML</span><br></pre></td></tr></table></figure>
</li>
<li><p>拼装shell命令，并执行</p>
</li>
</ol>
<h3 id="抽象驱动层"><a href="#抽象驱动层" class="headerlink" title="抽象驱动层"></a>抽象驱动层</h3><p>目前，libvirt以下几种类型的抽象驱动，每一种类型的驱动代表某以功能模块的抽象封装：</p>
<ul>
<li>虚拟化驱动(virDriverPtr)</li>
<li>虚拟网络驱动(virNetworkDriverPtr)</li>
<li>物理网卡驱(virInterfaceDriverPtr)</li>
<li>存储驱动(virStorageDriverPtr)</li>
<li>监控驱动(virDeviceMonitorPtr)</li>
<li>安全驱动(virSecretDriverPtr)</li>
<li>过滤驱动(virNWFilterDriverPtr)</li>
<li>状态驱动(virStateDriverPtr)</li>
</ul>
<h3 id="virsh-start-vm-name"><a href="#virsh-start-vm-name" class="headerlink" title="virsh start vm-name"></a>virsh start vm-name</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">virsh start vm-name</span><br></pre></td></tr></table></figure>
<blockquote>
<p>启动一个虚拟机</p>
</blockquote>
<h2 id="daemon进程（libvirtd-）"><a href="#daemon进程（libvirtd-）" class="headerlink" title="daemon进程（libvirtd ）"></a>daemon进程（libvirtd ）</h2><p>该后台进程主要实现以下功能：</p>
<ol>
<li>远程代理<br>   所有remote client发送来的命令，由该进程监测执行</li>
<li>本地环境初始化<br>   libvirt服务的启停，用户connection的响应等</li>
<li>根据环境注册各种Driver（qemu, xen, storage…）的实现<br>  不同虚拟化技术以Driver的形式实现，由于libvirt对外提供的是统一的接口，所以各个Driver就是实现这些接口， 即将Driver注册到libvirt中</li>
</ol>
<h2 id="virsh-API调用"><a href="#virsh-API调用" class="headerlink" title="virsh API调用"></a>virsh API调用</h2><blockquote>
<p>将libvirt API封装，以Command Line Interface提供的对外接口</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">virsh define /path-vm-xml/vm_name.xml</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">virst start vm-name</span></span><br></pre></td></tr></table></figure>

<p>virsh命令与代码结构之间的关系：</p>
<table>
<thead>
<tr>
<th>文件名</th>
<th>对应vshCmdDef变量</th>
<th>对应virsh命令</th>
</tr>
</thead>
<tbody><tr>
<td>virsh-domain-monitor.c</td>
<td>domMonitoringCmds</td>
<td>virsh XX(虚拟机监控)</td>
</tr>
<tr>
<td>virsh-domain.c</td>
<td>domManagementCmds</td>
<td>virsh XX(虚拟机操作)</td>
</tr>
<tr>
<td>virsh-host.c</td>
<td>hostAndHypervisorCmds</td>
<td>virsh XX(虚拟机配置)</td>
</tr>
<tr>
<td>virsh-interface.c</td>
<td>ifaceCmds</td>
<td>virsh iface-XX</td>
</tr>
<tr>
<td>virsh-network.c</td>
<td>networkCmds</td>
<td>virsh net-XX</td>
</tr>
<tr>
<td>virsh-nodedev.c</td>
<td>nodedevCmds</td>
<td>virsh net-XX</td>
</tr>
<tr>
<td>virsh-nwfilter.c</td>
<td>nwfilterCmds</td>
<td>virsh nwfilter-XX</td>
</tr>
<tr>
<td>virsh-pool.c</td>
<td>storagePoolCmds</td>
<td>virsh pool-XX</td>
</tr>
<tr>
<td>virsh-secret.c</td>
<td>secretCmds</td>
<td>virsh secret-XX</td>
</tr>
<tr>
<td>virsh-snapshot.c</td>
<td>snapshotCmds</td>
<td>virsh snapshot-XX</td>
</tr>
<tr>
<td>virsh-volume.c</td>
<td>storageVolCmds</td>
<td>virsh vol-XX</td>
</tr>
</tbody></table>
<p>有了上面的表格我们就能够根据使用的<strong>virsh命令</strong>找到对应文件的对应<strong>vshCmdDef变量</strong>，在virsh中相关命令实现与具体API的调用文件相对于<code>tools/virsh-domain.c</code> &lt;&#x3D;&gt; <code>src/libvirt-domain.c</code></p>
<blockquote>
<p>一个<code>vshCmdDef</code>结构对应一个<code>virsh</code>命令，其中<code>vshCmdOptDef</code>定义了命令的参数，<code>vshCmdInfo</code>定义了命令的帮助信息，<code>bool (*handler) (vshControl *, const vshCmd *)</code>定义了命令的处理函数。</p>
</blockquote>
<h3 id="domManagementCmds"><a href="#domManagementCmds" class="headerlink" title="domManagementCmds"></a>domManagementCmds</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> vshCmdDef domManagementCmds[] = &#123;</span><br><span class="line">    &#123;.name = <span class="string">&quot;attach-device&quot;</span>,</span><br><span class="line">     .handler = cmdAttachDevice,</span><br><span class="line">     .opts = opts_attach_device,</span><br><span class="line">     .info = info_attach_device,</span><br><span class="line">     .flags = <span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    ...</span><br><span class="line">    &#123;.name = <span class="string">&quot;start&quot;</span>,</span><br><span class="line">     .handler = cmdStart,</span><br><span class="line">     .opts = opts_start,</span><br><span class="line">     .info = info_start,</span><br><span class="line">     .flags = <span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<blockquote>
<p>file: tools&#x2F;virsh-domain.c</p>
</blockquote>
<p>启动虚拟机的主要工作：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">virst start vm-name</span><br></pre></td></tr></table></figure>
<p>start命令的处理流程是<code>cmdStart</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">bool</span></span><br><span class="line"><span class="title function_">cmdStart</span><span class="params">(vshControl *ctl, <span class="type">const</span> vshCmd *cmd)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> ((nfds ?</span><br><span class="line">         virDomainCreateWithFiles(dom, nfds, fds, flags) :</span><br><span class="line">         virDomainCreateWithFlags(dom, flags)) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> started;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>virDomainCreateWithFiles</code>: 启动已定义的域。如果调用成功，则域将从已定义的域池移动到正在运行的域池</li>
<li><code>virDomainCreateWithFlags</code>: 启动已定义的域。如果调用成功，则域将从已定义的域池移动到正在运行的域池</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">virDomainCreateWithFiles</span><br><span class="line">  \-&gt; conn-&gt;driver-&gt;domainCreateWithFiles</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">virDomainCreateWithFlags</span><br><span class="line">  \-&gt; conn-&gt;driver-&gt;domainCreateWithFlags</span><br><span class="line">      \-&gt; qemuDomainCreateWithFlags</span><br><span class="line">        \-&gt; qemuProcessStart</span><br><span class="line">          \-&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>file: src&#x2F;qemu&#x2F;qemu_driver.c</p>
</blockquote>
<h2 id="libvirt-for-qemu"><a href="#libvirt-for-qemu" class="headerlink" title="libvirt for qemu"></a>libvirt for qemu</h2><p>由于libvirt是将最底层需要执行的shell命令进行了抽象封装，供上层应用使用。因此在其封装的借口中必须存在一个<code>shell运行环境</code></p>
<ul>
<li>底层qemu的命令何时被创建？</li>
<li>底层shell环境的搭建？</li>
<li>如何执行的该命令？</li>
</ul>
<h2 id="配置QEMU环境变量与参数"><a href="#配置QEMU环境变量与参数" class="headerlink" title="配置QEMU环境变量与参数"></a>配置QEMU环境变量与参数</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">domain</span> <span class="attr">type</span>=<span class="string">&#x27;kvm&#x27;</span> <span class="attr">xmlns:qemu</span>=<span class="string">&#x27;http://libvirt.org/schemas/domain/qemu/1.0&#x27;</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="tag">&lt;<span class="name">devices</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">emulator</span>&gt;</span>/usr/bin/qemu-system-x86_64<span class="tag">&lt;/<span class="name">emulator</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">devices</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">qemu:commandline</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">qemu:arg</span> <span class="attr">value</span>=<span class="string">&#x27;-newarg&#x27;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">qemu:env</span> <span class="attr">name</span>=<span class="string">&#x27;QEMU_ENV&#x27;</span> <span class="attr">value</span>=<span class="string">&#x27;VAL&#x27;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">qemu:commandline</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">domain</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">qemu:commandline</span> <span class="attr">xmlns:qemu</span>=<span class="string">&#x27;http://libvirt.org/schemas/domain/qemu/1.0&#x27;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">qemu:arg</span> <span class="attr">value</span>=<span class="string">&#x27;ARGUMENT&#x27;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">qemu:commandline</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在xml配置文件中必须指定<code>&lt;domain type=&#39;kvm&#39; xmlns:qemu=&#39;http://libvirt.org/schemas/domain/qemu/1.0&#39;&gt;</code>,因为默认的<code>&lt;domain type=&#39;kvm&#39;&gt;</code>不支持<code>qemu:commandline</code>的标签</p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9saWJ2aXJ0Lm9yZy9kcnZxZW11Lmh0bWwjcWVtdWNvbW1hbmQ=">https://libvirt.org/drvqemu.html#qemucommand<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><span class="exturl" data-url="aHR0cDovL2Jsb2cuY2hpbmF1bml4Lm5ldC91aWQtMjYxMzM4MTctaWQtNDkwOTIxNi5odG1s">libvirt架构及源码分析<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9jb21wdXRpbmdmb3JnZWVrcy5jb20vdmlyc2gtY29tbWFuZHMtY2hlYXRzaGVldC8=">virsh commands cheatsheet to manage KVM guest virtual machines<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL2Jsb2cudm1zcGxpY2UubmV0LzIwMTEvMDQvaG93LXRvLXBhc3MtcWVtdS1jb21tYW5kLWxpbmUtb3B0aW9ucy5odG1s">How to pass QEMU command-line options through libvirt<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93aWtpLmxpYnZpcnQub3JnL3BhZ2UvUUVNVVN3aXRjaFRvTGlidmlydCMtc18y">QEMUSwitchToLibvirt(-s)<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>虚拟化</category>
        <category>libvirt</category>
      </categories>
      <tags>
        <tag>libvirt</tag>
        <tag>virsh</tag>
      </tags>
  </entry>
  <entry>
    <title>libvirt透传qemu参数</title>
    <url>/post/549bb2ea.html</url>
    <content><![CDATA[<p>在使用virsh通过libvirt接口创建虚拟机时，存在一些qemu的启动参数或者系统环境变量而libvirt接口不支持，因此需要将参数直接透传到qemu的启动命令。</p>
<p>新创建的每一个虚拟机都有一个<code>xml配置文件</code>，用来定义该虚拟机的配置，因此可以直接在该xml文件中利用<code>qemu:commandline </code>标记添加需要透传的<code>参数</code>或<code>环境变量</code></p>
<span id="more"></span>

<h2 id="编辑XML文件"><a href="#编辑XML文件" class="headerlink" title="编辑XML文件"></a>编辑XML文件</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">domain</span> <span class="attr">type</span>=<span class="string">&#x27;kvm&#x27;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>QEMUGuest1<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">uuid</span>&gt;</span>c7a5fdbd-edaf-9455-926a-d65c16db1809<span class="tag">&lt;/<span class="name">uuid</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="tag">&lt;<span class="name">commandline</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://libvirt.org/schemas/domain/qemu/1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">qemu:arg</span> <span class="attr">value</span>=<span class="string">&#x27;-newarg&#x27;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">qemu:arg</span> <span class="attr">value</span>=<span class="string">&#x27;parameter&#x27;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">qemu:env</span> <span class="attr">name</span>=<span class="string">&#x27;ID&#x27;</span> <span class="attr">value</span>=<span class="string">&#x27;wibble&#x27;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">qemu:env</span> <span class="attr">name</span>=<span class="string">&#x27;BAR&#x27;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">commandline</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">domain</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="virt-xml"><a href="#virt-xml" class="headerlink" title="virt-xml"></a>virt-xml</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">virt-xml <span class="variable">$DOMAIN</span> --edit --confirm --qemu-commandline <span class="string">&#x27;-newarg parameter&#x27;</span></span></span><br></pre></td></tr></table></figure>

<h2 id="libvirt函数接口添加"><a href="#libvirt函数接口添加" class="headerlink" title="libvirt函数接口添加"></a>libvirt函数接口添加</h2><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cubGlidmlydC5vcmcva2Jhc2UvcWVtdS1wYXNzdGhyb3VnaC1zZWN1cml0eS5odG1s">QEMU command-line passthrough<i class="fa fa-external-link-alt"></i></span></li>
<li><a href="http://blog.vmsplice.net/2011/04/how-to-pass-qemu-command-line-options.html"></a></li>
</ul>
]]></content>
      <categories>
        <category>虚拟化</category>
        <category>libvirt</category>
      </categories>
      <tags>
        <tag>qemu</tag>
        <tag>libvirt</tag>
      </tags>
  </entry>
  <entry>
    <title>WebVirtMgr for Qemu</title>
    <url>/post/32f26c86.html</url>
    <content><![CDATA[<p><code>WebVirtMgr</code>采用几乎纯Python开发，其前端是基于Python的Django，后端是基于Libvirt的Python接口，将日常kvm的管理操作变的更加的可视化。</p>
<span id="more"></span>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><span class="exturl" data-url="aHR0cDovL3JldHNwZW4uZ2l0aHViLmlvLw==">WebVirtMgr<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3JldHNwZW4vd2VidmlydG1ncg==">github-webvirtmgr<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC80OTEyMDU1OQ==">KVM 虚拟化环境搭建 - WebVirtMgr<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>虚拟化</category>
        <category>libvirt</category>
      </categories>
      <tags>
        <tag>qemu</tag>
        <tag>libvirt</tag>
        <tag>webvirtmgr</tag>
      </tags>
  </entry>
  <entry>
    <title>libvirt for qemu</title>
    <url>/post/de22fd34.html</url>
    <content><![CDATA[<blockquote>
<p><code>libvirt</code>是目前使用最为广泛的针对KVM虚拟机进行管理的工具和API。<code>libvirtd</code>是一个daemon进程，可以被本地和远程的virsh(命令行工具)调用，Libvirtd通过调用qemu-kvm操作管理虚拟机。libvirt 由应用程序编程接口 (API) 库、一个守护进程 (libvirtd)，和默认命令行实用工具<code>(virsh)</code>等部分组成</p>
</blockquote>
<span id="more"></span>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install -y qemu-kvm qemu-kvm-tools libvirt virt-install</span><br></pre></td></tr></table></figure>

<h1 id="libvirtd"><a href="#libvirtd" class="headerlink" title="libvirtd"></a>libvirtd</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl status libvirtd.service</span><br><span class="line">● libvirtd.service - Virtualization daemon</span><br><span class="line">     Loaded: loaded (/lib/systemd/system/libvirtd.service; enabled; vendor preset: enabled)</span><br><span class="line">     Active: active (running) since Mon 2020-08-24 09:22:15 CST; 7h ago</span><br><span class="line">TriggeredBy: ● libvirtd-admin.socket</span><br><span class="line">             ● libvirtd.socket</span><br><span class="line">             ● libvirtd-ro.socket</span><br><span class="line">       Docs: man:libvirtd(8)</span><br><span class="line">             https://libvirt.org</span><br><span class="line">   Main PID: 1022 (libvirtd)</span><br><span class="line">      Tasks: 20 (limit: 32768)</span><br><span class="line">     Memory: 65.7M</span><br><span class="line">     CGroup: /system.slice/libvirtd.service</span><br><span class="line">             ├─1022 /usr/sbin/libvirtd</span><br><span class="line">             ├─1412 /usr/sbin/dnsmasq --conf-file=/var/lib/libvirt/dnsmasq/default.conf --leasefile-ro --dhcp-script=/usr/lib/libvirt/libvirt_leaseshelper</span><br><span class="line">             └─1413 /usr/sbin/dnsmasq --conf-file=/var/lib/libvirt/dnsmasq/default.conf --leasefile-ro --dhcp-script=/usr/lib/libvirt/libvirt_leaseshelper</span><br></pre></td></tr></table></figure>

<p>主要提供的功能包括：</p>
<ul>
<li>虚拟机生命周期管理：包括不同的领域生命周期操作，比如：启动、停止、暂停、保存、恢复和迁移。支持多种设备类型的热插拔操作，包括：磁盘、网卡、内存和CPU。</li>
<li>本地&amp;&amp;远程访问：通过在本地运行libvirt daemon,本机和远程机器，都可以访问并使用libvirt的功能。远程一般通过简单配置SSH即可。</li>
<li>存储管理：除了虚拟机管理，任何运行了libvirt daemon的主机都可以用来管理不同类型的存储：创建不同格式的文件镜像（qcow2、vmdk、raw等）、挂接NFS共享、列出现有的LVM卷组、创建新的LVM卷组和逻辑卷、对未处理过的磁盘设备分区、挂接iSCSI共享等。</li>
<li>虚拟网络管理：可以用来管理和创建虚拟网络，管理物理和逻辑的网络接口。</li>
</ul>
<h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>libvirtd服务的配置文件: <code>/etc/libvirt/libvirtd.conf</code></p>
<p>客户端主配置文件: <code>/etc/libvirt/libvirt.conf</code></p>
<p>qemu的主配置文件: <code>/etc/libvirt/qemu.conf</code></p>
<h3 id="libvirtd-conf"><a href="#libvirtd-conf" class="headerlink" title="libvirtd.conf"></a>libvirtd.conf</h3><ul>
<li>日志配置</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">log_filters=&quot;1:libvirt 1:util 1:qemu&quot;</span><br><span class="line">log_outputs=&quot;1:file:/var/log/libvirt/libvirtd.log&quot;</span><br></pre></td></tr></table></figure>

<h1 id="qemu"><a href="#qemu" class="headerlink" title="qemu"></a>qemu</h1><h2 id="libvirt与qemu如何绑定"><a href="#libvirt与qemu如何绑定" class="headerlink" title="libvirt与qemu如何绑定"></a>libvirt与qemu如何绑定</h2><blockquote>
<p>通过最新qemu源码编译的qemu-kvm，被libvirt进行管理</p>
</blockquote>
<p>virsh编辑配置文件的<code>emulator</code>部分：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">emulator</span>&gt;</span>/usr/local/bin/qemu-system-x86_64<span class="tag">&lt;/<span class="name">emulator</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>修改后使其生效时，会出现权限错误：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">virsh define ./qemu/win10.xml</span></span><br><span class="line">error: Failed to define domain from ./qemu/win10.xml</span><br><span class="line">error: internal error: Failed to start QEMU binary /usr/local/bin/qemu-system-x86_64 for probing: libvirt:  error : cannot execute binary /usr/local/bin/qemu-system-x86_64: Permission denied</span><br></pre></td></tr></table></figure>

<p>解决方法：</p>
<blockquote>
<p>在<code>/etc/apparmor.d/usr.sbin.libvirtd</code>文件中，添加一行:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/usr/local/bin/* PUx,</span><br><span class="line">...</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">force the use of virt-aa-helper</span></span><br><span class="line">...</span><br><span class="line">/usr/local/bin/* rmix,</span><br></pre></td></tr></table></figure>

<p>使能生效：<code>sudo systemctl reload apparmor</code>或<code>sudo systemctl restart apparmor.service</code></p>
</blockquote>
<p>原因： <code>libvirtd</code>应用的权限被<code>apparmor-profiles</code>所控制，而<code>/usr/local/bin</code>目录下的可执行文件，没有被添加到apparmor-profiles的配置中，因此使用时检测到没有权限。</p>
<ul>
<li>AppArmor 是一款与SeLinux类似的安全框架&#x2F;工具，其主要作用是控制应用程序的各种权限，例如对某个目录&#x2F;文件的读&#x2F;写，对网络端口的打开&#x2F;读&#x2F;写等</li>
<li>Ubuntu的默认选择</li>
<li>在<code>centos</code>中如果出现该错误，可以通过临时禁用SELinux进行测试: <code>setenforce 0</code></li>
</ul>
<p><code>apparmor-profiles</code>的状态：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apparmor_status</span><br></pre></td></tr></table></figure>

<p>开启虚拟机时，出现无法执行错误：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">error: internal error: process exited while connecting to monitor: libvirt:  error : cannot execute binary /usr/local/bin/qemu-system-x86_64: Permission denied</span><br></pre></td></tr></table></figure>
<p>原因：不能在<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2l0ZXllXzEyNjc1L2FydGljbGUvZGV0YWlscy84MjUxOTM5OQ==">apparmor禁用<i class="fa fa-external-link-alt"></i></span><code>usr.sbin.libvirtd</code>，<code>usr.lib.libvirt.virt-aa-helper</code>,也就是将其生成软连接到<code>/etc/apparmor.d/disable</code>.如果要禁掉可能必须重新编译libvirt同时添加<code>--without-apparmor</code>选项(未测试)</p>
<h3 id="其他apparmor权限的问题"><a href="#其他apparmor权限的问题" class="headerlink" title="其他apparmor权限的问题"></a>其他apparmor权限的问题</h3><p>在libvirtd中对qemu的运行存在一些权限的设置，为了方便调试，将权限控制禁用。在配置文件<code>/etc/libvirt/qemu.conf</code>中添加下行代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">security_driver = &quot;none&quot;</span><br></pre></td></tr></table></figure>

<p>重启<code>libvirtd.service</code>服务:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo systemctl restart libvirtd.service</span><br></pre></td></tr></table></figure>


<h1 id="virsh"><a href="#virsh" class="headerlink" title="virsh"></a>virsh</h1><h2 id="查看虚拟机状态"><a href="#查看虚拟机状态" class="headerlink" title="查看虚拟机状态"></a>查看虚拟机状态</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">virsh list --all</span></span><br><span class="line"> Id   Name          State</span><br><span class="line"> ------------------------------</span><br><span class="line">  -    ubuntu20.04   shut off</span><br><span class="line">  -    win10         shut off</span><br></pre></td></tr></table></figure>

<h2 id="显示虚拟机的XML配置"><a href="#显示虚拟机的XML配置" class="headerlink" title="显示虚拟机的XML配置"></a>显示虚拟机的XML配置</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">virsh dumpxml ubuntu20.04</span></span><br></pre></td></tr></table></figure>

<h2 id="编辑虚拟机的XML配置文件"><a href="#编辑虚拟机的XML配置文件" class="headerlink" title="编辑虚拟机的XML配置文件"></a>编辑虚拟机的XML配置文件</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">virsh edit ubuntu20.04</span><br></pre></td></tr></table></figure>

<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>virsh list</code></td>
<td>显示正在运行的虚拟机</td>
</tr>
<tr>
<td><code>virsh list --all</code></td>
<td>显示所有的虚拟机</td>
</tr>
<tr>
<td><code>virsh start vm-name</code></td>
<td>启动vm-name虚拟机</td>
</tr>
<tr>
<td><code>virsh shutdown vm-name</code></td>
<td>关闭vm-name虚拟机</td>
</tr>
<tr>
<td><code>virsh destroy vm-name</code></td>
<td>虚拟机vm-name强制断电</td>
</tr>
<tr>
<td><code>virsh suspend vm-name</code></td>
<td>挂起vm-name虚拟机</td>
</tr>
<tr>
<td><code>virsh define vm-name</code></td>
<td>将domain注册，但是没有启动,下次启动时生效</td>
</tr>
<tr>
<td><code>virsh undefine vm-name</code></td>
<td>删除虚拟机，慎用</td>
</tr>
<tr>
<td><code>virsh dominfo vm-name</code></td>
<td>查看虚拟机的配置信息</td>
</tr>
<tr>
<td><code>virsh domiflist</code></td>
<td>查看网卡配置信息</td>
</tr>
<tr>
<td><code>virsh domblklist vm-name</code></td>
<td>查看该虚拟机的磁盘位置</td>
</tr>
<tr>
<td><code>virsh edit vm-name</code></td>
<td>修改vm-name的xml配置文件</td>
</tr>
<tr>
<td><code>virsh dumpxml vm-name</code></td>
<td>查看KVM虚拟机当前配置</td>
</tr>
<tr>
<td><code>virsh autostart vm-name</code></td>
<td>KVM物理机开机自启动虚拟机，配置后会在此目录生成配置文件&#x2F;etc&#x2F;libvirt&#x2F;qemu&#x2F;autostart&#x2F;vm-name.xml</td>
</tr>
<tr>
<td><code>virsh autostart --disable vm-name</code></td>
<td>取消开机自启动</td>
</tr>
</tbody></table>
<h1 id="命令行参数转XML配置文件"><a href="#命令行参数转XML配置文件" class="headerlink" title="命令行参数转XML配置文件"></a>命令行参数转XML配置文件</h1><h2 id="domxml-from-native"><a href="#domxml-from-native" class="headerlink" title="domxml-from-native"></a>domxml-from-native</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo virsh domxml-from-native qemu-argv aa.txt</span><br></pre></td></tr></table></figure>

<p>错误：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">error: this function is not supported by the connection driver: virConnectDomainXMLFromNative</span><br></pre></td></tr></table></figure>
<blockquote>
<p>最新qemu中删除了该功能，因为在实践中它过于不可靠和不完整而无用</p>
</blockquote>
<h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><h2 id="添加显卡显示SDL"><a href="#添加显卡显示SDL" class="headerlink" title="添加显卡显示SDL"></a>添加显卡显示SDL</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;graphics type=&#x27;sdl&#x27; display=&#x27;:0.0&#x27; xauth=&#x27;/root/.Xauthority&#x27;&gt;</span><br><span class="line">    &lt;gl enable=&#x27;yes&#x27;/&gt;</span><br><span class="line">&lt;/graphics&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>以上配置在<code>Xfce</code>桌面环境下可以生效</strong></p>
</blockquote>
<h3 id="权限错误"><a href="#权限错误" class="headerlink" title="权限错误:"></a>权限错误:</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">error: internal error: cannot load AppArmor profile &#x27;libvirt-39466e8a-545d-420e-ba0f-b942d09a5bdb&#x27;</span><br></pre></td></tr></table></figure>
<p>解决方法：在<code>/etc/apparmor.d/usr.sbin.libvirtd</code>配置文件中添加<code>/usr/local/bin/* rmix,</code></p>
<h3 id="SDL"><a href="#SDL" class="headerlink" title="SDL"></a>SDL</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Could not initialize SDL(x11 not available) - exiting</span><br></pre></td></tr></table></figure>
<p>原因：未找到<br>解决方法：安装xfce桌面环境<br>  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum groups install Xfce</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>for centos7.8</p>
</blockquote>
<h2 id="编译使能SDL"><a href="#编译使能SDL" class="headerlink" title="编译使能SDL"></a>编译使能SDL</h2><p>在配置中使能SDL：<code>--enable-sdl</code></p>
<h2 id="异常错误"><a href="#异常错误" class="headerlink" title="异常错误"></a>异常错误</h2><h3 id="mlock"><a href="#mlock" class="headerlink" title="mlock"></a>mlock</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">qemu-system-x86_64: -realtime mlock=off: warning: &#x27;-realtime mlock=...&#x27; is deprecated, please use &#x27;-overcommit mem-lock=...&#x27; instead</span><br></pre></td></tr></table></figure>

<h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><p>虚拟机配置文件：<a href="/src/ubuntu20.04.xml">ubuntu20.04</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">## 域——domain</span><br><span class="line"></span><br><span class="line">## 池——pool</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 升级libvirt</span><br><span class="line"></span><br><span class="line">## libvirt5.0.0 for centos7</span><br><span class="line"></span><br><span class="line">``` shell</span><br><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">#url=&quot;http://mirror.centos.org/centos/7.8.2003/virt/x86_64/libvirt-latest/&quot;</span><br><span class="line">url=&quot;http://mirrors.huaweicloud.com/centos/7/virt/x86_64/libvirt-latest/&quot;</span><br><span class="line"></span><br><span class="line">curl $url &gt; page.txt</span><br><span class="line"></span><br><span class="line">grep &quot;5.0.0-1.el7.x86_64&quot; page.txt &gt; fff.txt</span><br><span class="line"></span><br><span class="line">while read line</span><br><span class="line">do</span><br><span class="line">    #截取href前多余字符串</span><br><span class="line">    aaa=$&#123;line: 24&#125;</span><br><span class="line">    #截取title后多余字符串</span><br><span class="line">    bbb=$&#123;aaa%title*&#125;</span><br><span class="line">    #设置为href变量</span><br><span class="line">    export $bbb</span><br><span class="line">    #去掉变量值两边的引号</span><br><span class="line">    ccc=`echo $href | sed &#x27;s/\&quot;//g&#x27;`</span><br><span class="line"></span><br><span class="line">    echo $url$ccc</span><br><span class="line">    wget $url$ccc</span><br><span class="line"></span><br><span class="line">done &lt; fff.txt</span><br><span class="line"></span><br><span class="line">rm page.txt fff.txt -rf</span><br><span class="line"></span><br><span class="line">#yum install ./*</span><br></pre></td></tr></table></figure>


<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9saWJ2aXJ0Lm9yZy9mb3JtYXRkb21haW4uaHRtbA==">Domain XML format<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93aWtpLmxpYnZpcnQub3JnL3BhZ2UvUUVNVVN3aXRjaFRvTGlidmlydA==">QEMUSwitchToLibvirt<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vd24xbS9wLzExMjgwNjA1Lmh0bWw=">libvirt原理<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly91bml4LnN0YWNrZXhjaGFuZ2UuY29tL3F1ZXN0aW9ucy80NzEzNDUvY2hhbmdpbmctbGlidmlydC1lbXVsYXRvci1wZXJtaXNzaW9uLWRlbmllZA==">Changing libvirt emulator: Permission denied<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vcWl1aG9tLTE4NzQvcC8xMzUwODIzMS5odG1s">虚拟化技术之kvm管理工具virsh常用基础命令（一）<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ppdXp1aWRvbmdwby9hcnRpY2xlL2RldGFpbHMvNDQzNDI1MDk=">编译qemu和libvirt使支持SDL<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9kaXNjb3Vyc2UudWJ1bnR1LmNvbS90L3ZpcnR1YWxpemF0aW9uLWxpYnZpcnQvMTE1MjIvMQ==">Virtualization - libvirt<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLjUxY3RvLmNvbS80NzQ2MzE2LzIzMzY1MjQ=">KVM 虚拟机 XML 配置文件详解<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9hY2Nlc3MucmVkaGF0LmNvbS9kb2N1bWVudGF0aW9uL3poLWNuL3JlZF9oYXRfZW50ZXJwcmlzZV9saW51eC83L2h0bWwtc2luZ2xlL3ZpcnR1YWxpemF0aW9uX3R1bmluZ19hbmRfb3B0aW1pemF0aW9uX2d1aWRlL2luZGV4I3NlY3QtVmlydHVhbGl6YXRpb25fVHVuaW5nX09wdGltaXphdGlvbl9HdWlkZS1OVU1BLUF1dG9fTlVNQV9CYWxhbmNpbmc=">虚拟化调试和优化指南<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuZnVudG9vLm9yZy9XaW5kb3dzXzEwX1ZpcnR1YWxpemF0aW9uX3dpdGhfS1ZN">Windows 10 Virtualization with KVM<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>虚拟化</category>
        <category>qemu</category>
      </categories>
      <tags>
        <tag>qemu</tag>
        <tag>libvirt</tag>
      </tags>
  </entry>
  <entry>
    <title>SMP--对称多处理器</title>
    <url>/post/14018.html</url>
    <content><![CDATA[<p>SMP的结构中，在CPU运行时都是“对称”的，没有主次之分。所有的CPU通过同一条总线共享同一个内存以及外设。为了减少内存访问的冲突，SMP结构中的各干CPU通常都有自己的高速缓存。</p>
<p>程序的运行：</p>
<blockquote>
<p>各个CPU动态的从系统的<code>就绪队列</code>中调度进程加以执行，一个进程在不同的时间可以在不同的CPU上运行，中断请求则动态的分配给其中的一个CPU，由这个CPU提供中断服务。除一般的内存共享外，处理器间的通信手段还有进程间通信和处理器间的中断请求。</p>
</blockquote>
<p>SMP中的主要问题：</p>
<ul>
<li>同步</li>
<li>cache一致性</li>
<li>中断</li>
</ul>
<span id="more"></span>

<h2 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h2><blockquote>
<p>进程间的同步实际是对临界资源的互斥操作</p>
</blockquote>
<p>在单处理器结构中，只要能保证在对临界资源的操作中途不发生进程调度，并且不会发生中断，或者即使发生中断也与操作的对象无关，就保证了操作的互斥性。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spin_lock</span><br><span class="line">atomic</span><br></pre></td></tr></table></figure>
<p>一般而言，只要能保证对临界资源操作的“原子性”，互斥性就保证了，在单处理器结构中，能够在单条指令完成的操作就认为是“原子操作”。在CPU的设计中为保证原子操作，设计一些原子指令，“测试并设置”， “测试并清除”。</p>
<p>在SMP结构中，对指令间的执行顺序的依赖会存在很大的风险。必须使用锁使其在一个CPU上执行完毕，不能中断，否则可能导致指令顺序错乱。</p>
<h2 id="Cache一致性"><a href="#Cache一致性" class="headerlink" title="Cache一致性"></a>Cache一致性</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+----+  +----+   +----+  +----+</span><br><span class="line">|CPU0|  |CPU1|   |CPU2|  |CPU3|</span><br><span class="line">+----+  +----+   +----+  +----+</span><br><span class="line">  +-+     +-+     +-+      +-+</span><br><span class="line">    |     |         |      |</span><br><span class="line">+---v-----v--+   +--v------v--+</span><br><span class="line">|   L1 Cache |   |  L2 Cache  |</span><br><span class="line">+------+-----+   +------+-----+</span><br><span class="line">       |                |</span><br><span class="line">+------v----------------v-----+</span><br><span class="line">|         L2 Cache            |</span><br><span class="line">+-----------------------------+</span><br></pre></td></tr></table></figure>

<h2 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h2><h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><h3 id="Cache-line"><a href="#Cache-line" class="headerlink" title="Cache line"></a>Cache line</h3><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li>[Linux内核源代码情景分析]</li>
<li><span class="exturl" data-url="aHR0cDovL2Jsb2cuc2luYS5jb20uY24vcy9ibG9nXzcwZGQxNjkxMDEwMWF4eXcuaHRtbA==">基于多核处理器的RTOS多核扩展分析与研究 一<i class="fa fa-external-link-alt"></i></span></li>
</ol>
]]></content>
      <categories>
        <category>计算机系统</category>
        <category>cpu</category>
      </categories>
      <tags>
        <tag>smp</tag>
        <tag>cpu</tag>
      </tags>
  </entry>
  <entry>
    <title>LTP测试</title>
    <url>/post/39613.html</url>
    <content><![CDATA[<p>LTP套件是由 Linux Test Project 所开发的一套系统测试套件。它基于系统资源的利用率统计开发了一个测试的组合,为系统提供足够的压力。</p>
<p>通过压力测试来判断系统的稳定性和可靠性。</p>
<p>压力测试是一种破坏性的测试,即系统在非正常的、超负荷的条件下的运行情况 。用来评估在超越最大负载的情况下系统将如何运行,是系统在正常的情况下对某种负载强度的承受能力的考验</p>
<p>LTP测试套件对Linux操作系统进行超长时间的测试,重点在于Linux用户环境相关的工作负荷。而并不是致力于证明缺陷。</p>
<span id="more"></span>

<h2 id="LTP测试"><a href="#LTP测试" class="headerlink" title="LTP测试"></a>LTP测试</h2><p>测试分为两个阶段：<code>初始测试</code>，<code>压力测试</code></p>
<h3 id="初始测试"><a href="#初始测试" class="headerlink" title="初始测试"></a>初始测试</h3><blockquote>
<p>是开始测试的必要条件。初始测试包括LTP测试套件在硬件和操作系统上成功运转,这些硬件和操作系统将用于可靠性运转</p>
</blockquote>
<p>测试脚本：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">runalltests.sh(或runltp)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>runltp默认执行的内容与runalltests相同</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd usr; ./runltp</span><br></pre></td></tr></table></figure>
<blockquote>
<p>详细使用见：<a href="/doc/LTP%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E.doc">LTP使用说明</a></p>
</blockquote>
<h2 id="测试单元"><a href="#测试单元" class="headerlink" title="测试单元"></a>测试单元</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /usr; ./runltp -f crashme</span><br></pre></td></tr></table></figure>

<h3 id="crashme"><a href="#crashme" class="headerlink" title="crashme"></a>crashme</h3><p>对系统的极端测试</p>
<table>
<thead>
<tr>
<th align="center">测试项</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">f00f</td>
<td align="center">x86测试</td>
</tr>
<tr>
<td align="center">crash01</td>
<td align="center">生成随机指令进行执行， 申请一块空间写随机值后，将PC跳转至此进行执行，并判断执行结果, 由于指令随机生成可能导致相同卡死，就看相同是否足够强壮，（同时也可能存成内存的泄露）</td>
</tr>
<tr>
<td align="center">crash02</td>
<td align="center">随机进行系统调用（0～127）， 并且系统调用的所有参数全是随机值， 由于随机的系统调用可以进行内存分配，而不会释放，也可能存在内存泄露</td>
</tr>
<tr>
<td align="center">mem01</td>
<td align="center">根据系统中可以内存的大小，随机或线性申请内存，别填充释放</td>
</tr>
<tr>
<td align="center">fork12</td>
<td align="center">尽可能的fork子进程，目的是耗尽系统的pid号，主要冲突是pid_max和内存容量</td>
</tr>
</tbody></table>
<h2 id="mm"><a href="#mm" class="headerlink" title="mm"></a>mm</h2><h3 id="max-map-count"><a href="#max-map-count" class="headerlink" title="max_map_count"></a>max_map_count</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># cat /proc/sys/vm/max_map_count</span><br><span class="line">65530</span><br></pre></td></tr></table></figure>
<blockquote>
<p>限制一个进程所拥有的最大内存区域(64MB)</p>
</blockquote>
<h3 id="min-free-kbytes"><a href="#min-free-kbytes" class="headerlink" title="min_free_kbytes"></a>min_free_kbytes</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># cat /proc/sys/vm/min_free_kbytes</span><br><span class="line">1961</span><br></pre></td></tr></table></figure>
<blockquote>
<p>表示系统所保留空闲内存的最低限</p>
</blockquote>
<h3 id="压力测试"><a href="#压力测试" class="headerlink" title="压力测试"></a>压力测试</h3><blockquote>
<p>验证产品在系统高使用率时的健壮性。</p>
</blockquote>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><span class="exturl" data-url="aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdHJvY2hpbHVzZXMvYXJ0aWNsZS9kZXRhaWxzLzEwMDYxNTEz">LTP–linux稳定性测试,性能测试和压力测试<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuaWJtLmNvbS9kZXZlbG9wZXJ3b3Jrcy9jbi9saW51eC9sLXJlbC8=">测试 Linux 的可靠性<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL2x0cC5zb3VyY2Vmb3JnZS5uZXQvZG9jdW1lbnRhdGlvbi90ZWNobmljYWxfcGFwZXJzL2x0cC1vbHMtMjAwOC1wYXBlci5wZGY=">Building a Robust Linux kernel piggybacking The Linux Test Project
<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vbXVhaGFvL3AvNjUzMjUyNy5odG1s">[kernel]—-理解kswapd的低水位min_free_kbytes<i class="fa fa-external-link-alt"></i></span></li>
</ol>
]]></content>
      <categories>
        <category>计算机系统</category>
        <category>ltp</category>
      </categories>
      <tags>
        <tag>kernel</tag>
        <tag>ltp</tag>
      </tags>
  </entry>
  <entry>
    <title>SMP多核启动</title>
    <url>/post/49009.html</url>
    <content><![CDATA[<p>smp的多核启动：</p>
<blockquote>
<p>MIPS框架下的启动流程</p>
</blockquote>
<span id="more"></span>

<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">plat_smp_ops</span> &#123;</span></span><br><span class="line">	<span class="type">void</span> (*send_ipi_single)(<span class="type">int</span> cpu, <span class="type">unsigned</span> <span class="type">int</span> action);</span><br><span class="line">    <span class="type">void</span> (*send_ipi_mask)(<span class="type">const</span> <span class="keyword">struct</span> cpumask *mask, <span class="type">unsigned</span> <span class="type">int</span> action);</span><br><span class="line">    <span class="type">void</span> (*init_secondary)(<span class="type">void</span>);</span><br><span class="line">    <span class="type">void</span> (*smp_finish)(<span class="type">void</span>);</span><br><span class="line">    <span class="type">void</span> (*cpus_done)(<span class="type">void</span>);</span><br><span class="line">    <span class="type">void</span> (*boot_secondary)(<span class="type">int</span> cpu, <span class="keyword">struct</span> task_struct *idle);</span><br><span class="line">    <span class="type">void</span> (*smp_setup)(<span class="type">void</span>);</span><br><span class="line">    <span class="type">void</span> (*prepare_cpus)(<span class="type">unsigned</span> <span class="type">int</span> max_cpus);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_HOTPLUG_CPU</span></span><br><span class="line">    <span class="type">int</span> (*cpu_disable)(<span class="type">void</span>);</span><br><span class="line">    <span class="type">void</span> (*cpu_die)(<span class="type">unsigned</span> <span class="type">int</span> cpu);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="smp-init"><a href="#smp-init" class="headerlink" title="smp init"></a>smp init</h3><p><img data-src="/images/smp/smp-init.png" alt="smp_init"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">smp_prepare_cpus  --&gt; (.prepare_cpus)</span><br><span class="line">	|</span><br><span class="line">1. 初始化mailbox并申请mailbox中断</span><br><span class="line">2. 制造每个核启动时的初始化代码</span><br><span class="line">3. 将初始化代码写入reset entry</span><br><span class="line">4. 刷cache</span><br></pre></td></tr></table></figure>

<blockquote>
<p>将CCU中的相应CPU进行reset后， 相应的CPU PC将跳入reset entry执行代码</p>
</blockquote>
<h3 id="init-secondary"><a href="#init-secondary" class="headerlink" title="init_secondary"></a>init_secondary</h3><p>在boot_secondary中，将per CPU进行reset后，系统所有CPU依次启动</p>
<p><img data-src="/images/smp/smp-init-secondary.png" alt="smp_init"></p>
<h2 id="系统启动"><a href="#系统启动" class="headerlink" title="系统启动"></a>系统启动</h2><p>系统上电后，boot CPU启动，执行<code>start_kernel</code>（init&#x2F;main.c），并分别调用<code>boot_cpu_init</code>和<code>setup_arch</code>两个接口，进行possible CPU相关的初始化。</p>
<p><img data-src="/images/smp/smp-booting.png" alt="smp-booting"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *	Activate the first processor.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __init <span class="title function_">boot_cpu_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> cpu = smp_processor_id();</span><br><span class="line">	<span class="comment">/* Mark the boot cpu &quot;present&quot;, &quot;online&quot; etc for SMP and UP case */</span></span><br><span class="line">	set_cpu_online(cpu, <span class="literal">true</span>);</span><br><span class="line">	set_cpu_active(cpu, <span class="literal">true</span>);</span><br><span class="line">	set_cpu_present(cpu, <span class="literal">true</span>);</span><br><span class="line">	set_cpu_possible(cpu, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>set_cpu_xxx接口，可以将指定的CPU设置为（或者清除）指定的状态。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"> * The following particular system cpumasks and operations manage</span><br><span class="line"> * possible, present, active and online cpus.</span><br><span class="line"> *</span><br><span class="line"> *     cpu_possible_mask- has bit &#x27;cpu&#x27; set iff cpu is populatable</span><br><span class="line"> *     cpu_present_mask - has bit &#x27;cpu&#x27; set iff cpu is populated</span><br><span class="line"> *     cpu_online_mask  - has bit &#x27;cpu&#x27; set iff cpu available to scheduler</span><br><span class="line"> *     cpu_active_mask  - has bit &#x27;cpu&#x27; set iff cpu available to migration</span><br><span class="line"> *</span><br><span class="line"> *  If !CONFIG_HOTPLUG_CPU, present == possible, and active == online.</span><br><span class="line"> *</span><br><span class="line"> *  The cpu_possible_mask is fixed at boot time, as the set of CPU id&#x27;s</span><br><span class="line"> *  that it is possible might ever be plugged in at anytime during the</span><br><span class="line"> *  life of that system boot.  The cpu_present_mask is dynamic(*),</span><br><span class="line"> *  representing which CPUs are currently plugged in.  And</span><br><span class="line"> *  cpu_online_mask is the dynamic subset of cpu_present_mask,</span><br><span class="line"> *  indicating those CPUs available for scheduling.</span><br><span class="line"> *</span><br><span class="line"> *  If HOTPLUG is enabled, then cpu_possible_mask is forced to have</span><br><span class="line"> *  all NR_CPUS bits set, otherwise it is just the set of CPUs that</span><br><span class="line"> *  ACPI reports present at boot.</span><br><span class="line"> *</span><br><span class="line"> *  If HOTPLUG is enabled, then cpu_present_mask varies dynamically,</span><br><span class="line"> *  depending on what ACPI reports as currently plugged in, otherwise</span><br><span class="line"> *  cpu_present_mask is just a copy of cpu_possible_mask.</span><br><span class="line"> *</span><br><span class="line"> *  (*) Well, cpu_present_mask is dynamic in the hotplug case.  If not</span><br><span class="line"> *      hotplug, it&#x27;s a copy of cpu_possible_mask, hence fixed at boot.</span><br><span class="line"> *</span><br><span class="line"> * Subtleties:</span><br><span class="line"> * 1) UP arch&#x27;s (NR_CPUS == 1, CONFIG_SMP not defined) hardcode</span><br><span class="line"> *    assumption that their single CPU is online.  The UP</span><br><span class="line"> *    cpu_&#123;online,possible,present&#125;_masks are placebos.  Changing them</span><br><span class="line"> *    will have no useful affect on the following num_*_cpus()</span><br><span class="line"> *    and cpu_*() macros in the UP case.  This ugliness is a UP</span><br><span class="line"> *    optimization - don&#x27;t waste any instructions or memory references</span><br><span class="line"> *    asking if you&#x27;re online or how many CPUs there are if there is</span><br><span class="line"> *    only one CPU.</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">状态</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">online</td>
<td align="center">可以被调度的</td>
</tr>
<tr>
<td align="center">active</td>
<td align="center">可以被迁移的</td>
</tr>
<tr>
<td align="center">present</td>
<td align="center">内核已接管的</td>
</tr>
<tr>
<td align="center">possible</td>
<td align="center">系统存在的CPU，但没有被内核接管</td>
</tr>
</tbody></table>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> __init <span class="title function_">setup_arch</span><span class="params">(<span class="type">char</span> **cmdline_p)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_EARLY_PRINTK</span></span><br><span class="line">	setup_early_printk();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	cpu_probe();</span><br><span class="line">	prom_init();</span><br><span class="line"></span><br><span class="line">	cpu_report();</span><br><span class="line">	check_bugs_early();</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_VT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_VGA_CONSOLE)</span></span><br><span class="line">	conswitchp = &amp;vga_con;</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined(CONFIG_DUMMY_CONSOLE)</span></span><br><span class="line">	conswitchp = &amp;dummy_con;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	arch_mem_init(cmdline_p);</span><br><span class="line"></span><br><span class="line">	resource_init();</span><br><span class="line">	plat_smp_setup();</span><br><span class="line"></span><br><span class="line">	cpu_cache_init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>file: arch&#x2F;mips&#x2F;kernel&#x2F;setup.c</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> __init <span class="title function_">prom_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	prom_init_cmdline((<span class="type">int</span>)fw_arg0, (<span class="type">char</span> **)fw_arg1);</span><br><span class="line">	mips_machtype = MACH_XBURST;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line">	register_smp_ops(&amp;xburst2_smp_ops);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>file: arch&#x2F;mips&#x2F;xburst2&#x2F;core&#x2F;prom.c</p>
</blockquote>
<p>将<code>struct plat_smp_ops</code>结构体注册SMP框架</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* preload SMP state for boot cpu */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">smp_prepare_boot_cpu</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	set_cpu_possible(<span class="number">0</span>, <span class="literal">true</span>);</span><br><span class="line">	set_cpu_online(<span class="number">0</span>, <span class="literal">true</span>);</span><br><span class="line">	cpu_set(<span class="number">0</span>, cpu_callin_map);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>file: arch&#x2F;mips&#x2F;kernel&#x2F;smp.c</p>
</blockquote>
<h2 id="开关核"><a href="#开关核" class="headerlink" title="开关核"></a>开关核</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo 0 &gt; /sys/devices/system/cpu/cpu1/online //关</span><br><span class="line">echo 1 &gt; /sys/devices/system/cpu/cpu1/online //开</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> __ref <span class="title function_">store_online</span><span class="params">(<span class="keyword">struct</span> device *dev,</span></span><br><span class="line"><span class="params">				  <span class="keyword">struct</span> device_attribute *attr,</span></span><br><span class="line"><span class="params">				  <span class="type">const</span> <span class="type">char</span> *buf, <span class="type">size_t</span> count)</span></span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">	cpu_hotplug_driver_lock();</span><br><span class="line">	<span class="keyword">switch</span> (buf[<span class="number">0</span>]) &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;0&#x27;</span>:</span><br><span class="line">		ret = cpu_down(cpuid);</span><br><span class="line">		...</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;1&#x27;</span>:</span><br><span class="line">		from_nid = cpu_to_node(cpuid);</span><br><span class="line">		ret = cpu_up(cpuid);</span><br><span class="line">		...</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		ret = -EINVAL;</span><br><span class="line">	&#125;</span><br><span class="line">	cpu_hotplug_driver_unlock();</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="title function_">DEVICE_ATTR</span><span class="params">(online, <span class="number">0644</span>, show_online, store_online)</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>file: drivers&#x2F;base&#x2F;cpu.c</p>
</blockquote>
<h3 id="echo-0-gt-online"><a href="#echo-0-gt-online" class="headerlink" title="echo 0 &gt; online"></a>echo 0 &gt; online</h3><p>实现接口：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_HOTPLUG_CPU</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> __cpu_disable(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">plat_smp_ops</span> *<span class="title">mp_ops</span>;</span> <span class="comment">/* private */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mp_ops-&gt;cpu_disable();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> __cpu_die(<span class="type">unsigned</span> <span class="type">int</span> cpu)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">plat_smp_ops</span> *<span class="title">mp_ops</span>;</span> <span class="comment">/* private */</span></span><br><span class="line"></span><br><span class="line">    mp_ops-&gt;cpu_die(cpu);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">play_dead</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>file: arch&#x2F;mips&#x2F;include&#x2F;asm&#x2F;smp.h</p>
</blockquote>
<p>调用关系：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cpu_down</span><br><span class="line">	\-&gt;_cpu_down(cpu, 0)</span><br><span class="line">		\-&gt;take_cpu_down</span><br><span class="line">			\-&gt;__cpu_disable()</span><br><span class="line">				\-&gt;mp_ops-&gt;cpu_disable()</span><br><span class="line">        \-&gt;__cpu_die(cpu)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>file: &#x2F;kernel&#x2F;cpu.c</p>
</blockquote>
<p>将被关闭的CPU的中断迁移走后，使其处理完成最后的（飞行状态）任务，进入idle模式，在idle模式判断自己是否需要关闭，如果需要将执行到<code>play_dead</code>将自己杀掉（关闭中断）。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">cpu_idle_loop</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cpu_is_offline(smp_processor_id()))</span><br><span class="line">            arch_cpu_idle_dead();</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>file: kernel&#x2F;cpu&#x2F;idle.c</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_HOTPLUG_CPU</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">arch_cpu_idle_dead</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* What the heck is this check doing ? */</span></span><br><span class="line">	<span class="keyword">if</span> (!cpu_isset(smp_processor_id(), cpu_callin_map))</span><br><span class="line">		play_dead();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>file: arch&#x2F;mips&#x2F;kernel&#x2F;process.c</p>
</blockquote>
<h3 id="echo-1-gt-online"><a href="#echo-1-gt-online" class="headerlink" title="echo 1 &gt; online"></a>echo 1 &gt; online</h3><p>调用被开核的<code>boot_secondary</code>,重新走一次启动时的第二阶段。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cpu_up</span><br><span class="line">	\-&gt;_cpu_up</span><br><span class="line">		\-&gt;__cpu_up</span><br><span class="line">			\-&gt;mp_ops-&gt;boot_secondary(cpu, tidle)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>file: &#x2F;kernel&#x2F;cpu.c</p>
</blockquote>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><span class="exturl" data-url="aHR0cHM6Ly9mcmVlLWVsZWN0cm9ucy5jb20vcHViL2NvbmZlcmVuY2VzLzIwMTQvZWxjL2NsZW1lbnQtc21wLWJyaW5nLXVwLW9uLWFybS1zb2MvY2xlbWVudC1zbXAtYnJpbmctdXAtb24tYXJtLXNvYy5wZGY="> clement-smp-bring-up-on-arm-soc.pdf<i class="fa fa-external-link-alt"></i></span></li>
</ol>
]]></content>
      <categories>
        <category>计算机系统</category>
        <category>smp</category>
      </categories>
      <tags>
        <tag>smp</tag>
      </tags>
  </entry>
  <entry>
    <title>任务调度</title>
    <url>/post/65317.html</url>
    <content><![CDATA[<div class="note info"><p>调度器 </p>
</div>

<p>多任务操作系统分为非抢占式多任务和抢占式多任务。与大多数现代操作系统一样，Linux采用的是抢占式多任务模式。这表示对CPU的占用时间由操作系统决定的，具体为操作系统中的调度器。调度器决定了什么时候停止一个进程以便让其他进程有机会运行，同时挑选出一个其他的进程开始运行</p>
<ol>
<li>schedule</li>
<li>抢占</li>
</ol>
<span id="more"></span>

<h2 id="调度时机"><a href="#调度时机" class="headerlink" title="调度时机"></a>调度时机</h2><blockquote>
<p>调度什么时候发生？schedule()函数什么时候被调用</p>
</blockquote>
<p>调度方式：</p>
<ul>
<li><p>主动式调度（自愿调度）<br>在内核中进程直接调用<code>schelule()</code>, 当进程需要等待资源而暂时停止运行时，会把进程状态置为挂起（睡眠），并主动请求调度，让出CPU。</p>
</li>
<li><p>被动式调度（抢占调度）<br>内核抢占和用户抢占</p>
</li>
</ul>
<ol>
<li><p>用户抢占<br>当内核即将返回用户空间时, 内核会检查<code>need_resched</code>是否设置, 如果设置, 则调用schedule(), 此时,发生用户抢占.</p>
</li>
<li><p>内核抢占<br>内核抢占就是指一个在内核态运行的进程, 可能在执行内核函数期间被另一个进程取代.</p>
</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><span class="exturl" data-url="aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ2F0aWVtZS9hcnRpY2xlL2RldGFpbHMvNTE4NzI2MTg=">Linux用户抢占和内核抢占详解(概念, 实现和触发时机)–Linux进程的管理与调度(二十）)<i class="fa fa-external-link-alt"></i></span></li>
</ol>
]]></content>
      <categories>
        <category>计算机系统</category>
        <category>task</category>
      </categories>
      <tags>
        <tag>schedule</tag>
        <tag>task</tag>
      </tags>
  </entry>
  <entry>
    <title>寄存器和Cache</title>
    <url>/post/12702.html</url>
    <content><![CDATA[<p>在平时的工作中经常进行<code>寄存器</code>和<code>Cache</code>的相关操作，这里主要说明其二者的具体操作和实现的不同</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">*(<span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span>*)(<span class="number">0xb3450000</span> + <span class="number">0x20</span>) = <span class="number">0x5a5a5a5a</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<ol>
<li>写寄存器时经过Cache吗？，为什么？怎么实现的？</li>
<li>如果经常Cache，是CPU进行同步，还是软件进行同步？</li>
</ol>
</blockquote>
<span id="more"></span>

<p><img data-src="/images/cpu_memory_struct.png" alt="cpu_memory_struct"></p>
<h2 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h2><blockquote>
<p>寄存器是中央处理器内的组成部份。寄存器是有限存贮容量的<code>高速存贮部件</code>，它们可用来暂存指令、数据和位址。在中央处理器的控制部件中，包含的寄存器有指令寄存器(IR)和程序计数器(PC)。在中央处理器的算术及逻辑部件中，包含的寄存器有累加器(ACC)。</p>
</blockquote>
<h2 id="Cache"><a href="#Cache" class="headerlink" title="Cache"></a>Cache</h2><blockquote>
<p>即高速缓冲存储器，是位于CPU与主内存间的一种容量较小但速度很高的存储器。由于CPU的速度远高于主内存，CPU直接从内存中存取数据要等待一定时间周期，Cache中保存着CPU刚用过或循环使用的一部分数据，当CPU再次使用该部分数据时可从Cache中直接调用,这样就减少了CPU的等待时间,提高了系统的效率。Cache又分为一级Cache(L1 Cache)和二级Cache(L2 Cache)，L1 Cache集成在CPU内部，L2 Cache早期一般是焊在主板上,现在也都集成在CPU内部，常见的容量有256KB或512KB L2 Cache。</p>
</blockquote>
<h2 id="二者联系？"><a href="#二者联系？" class="headerlink" title="二者联系？"></a>二者联系？</h2>]]></content>
      <categories>
        <category>计算机系统</category>
        <category>寄存器</category>
      </categories>
      <tags>
        <tag>cache</tag>
        <tag>寄存器</tag>
      </tags>
  </entry>
  <entry>
    <title>进程迁移</title>
    <url>/post/62989.html</url>
    <content><![CDATA[<p>进程迁移就是将一个进程从当前位置移动到指定的处理器上。它的基本思想是在进程执行过程中移动它，使得它在另一个计算机上继续存取它的所有资源并继续运行，而且不必知道运行进程或任何与其它相互作用的进程的知识就可以启动进程迁移操作，这意味着迁移是透明的。</p>
<blockquote>
<p>进程迁移是支持负载平衡和高容错性的一种非常有效的手段。</p>
</blockquote>
<span id="more"></span>

<ol>
<li><p>动态负载平衡：将进程迁移到负载轻或空闲的节点上，充分利用可用资源，通过减少节点间负载的差异来全面提高性能。</p>
</li>
<li><p>容错性和高可用性：某节点出现故障时，通过将进程迁移到其它节点继续恢复运行，这将极大的提高系统的可靠性和可用性。在某些关键性应用中，这一点尤为重要。</p>
</li>
<li><p>并行文件IO：将进程迁移到文件服务器上进行IO，而不是通过传统的从文件服务器通过网络将数据传输给进程。对于那些需向文件服务器请求大量数据的进程，这将有效的减少了通讯量，极大的提高效率。</p>
</li>
<li><p>充分利用特殊资源：进程可以通过迁移来利用某节点上独特的硬件或软件能力。</p>
</li>
<li><p>内存导引（Memory Ushering）机制：当一个节点耗尽它的主存时，Memory Ushering机制将允许进程迁移到其它拥有空闲内存的节点，而不是让该节点频繁地进行分页或和外存进行交换。这种方式适合于负载较为均衡，但内存使用存在差异或内存物理配置存在差异的系统。</p>
</li>
</ol>
<h2 id="Task-migration-LTP"><a href="#Task-migration-LTP" class="headerlink" title="Task migration(LTP)"></a>Task migration(LTP)</h2><blockquote>
<p>ltp-full-20140115&#x2F;testcases&#x2F;kernel&#x2F;controllers&#x2F;cpuctl&#x2F;cpuctl_test02.c</p>
</blockquote>
<p>通过cgroup将两个cgroup同两个物理核进行绑定，然后在两个cgroup中的tasks中进行两个进程ID的移动，从而进行进程的迁移</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mount -t cgroup -o cpuset cgroup /mnt</span><br><span class="line">cd /mnt</span><br><span class="line">#创建子cgroup，cpu0, cpu1</span><br><span class="line">mkdir cpu0 cpu1</span><br><span class="line">#将CPU0绑定到子cgroup.cpu0</span><br><span class="line">cd cpu0</span><br><span class="line">echo 0 &gt; cpuset.cpus</span><br><span class="line">#将CPU1绑定到子cgroup.cpu1</span><br><span class="line">cd cpu1</span><br><span class="line">echo 1 &gt; cpuset.cpus</span><br><span class="line"></span><br><span class="line">#进程迁移</span><br><span class="line">echo PID0 &gt; /mnt/cpu0/tasks</span><br><span class="line">或</span><br><span class="line">echo PID1 &gt; /mnt/cpu1/tasks</span><br></pre></td></tr></table></figure>
<h2 id="Cgroup"><a href="#Cgroup" class="headerlink" title="Cgroup"></a><a href="https://winddoing.github.io/2018/02/28/app_cgroup/">Cgroup</a></h2><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><span class="exturl" data-url="aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDAwNjkxNzg4NA==">Linux Cgroup系列（01）：Cgroup概述<i class="fa fa-external-link-alt"></i></span></li>
</ol>
]]></content>
      <categories>
        <category>计算机系统</category>
        <category>进程</category>
      </categories>
      <tags>
        <tag>进程</tag>
        <tag>cgroup</tag>
      </tags>
  </entry>
  <entry>
    <title>ASLR</title>
    <url>/post/4177.html</url>
    <content><![CDATA[<blockquote>
<p><code>ASLR</code>（Address space layout randomization）是一种针对缓冲区溢出的安全保护技术，通过对堆、栈、共享库映射等线性区布局的随机化，通过增加攻击者预测目的地址的难度，防止攻击者直接定位攻击代码位置，达到阻止溢出攻击的目的。</p>
</blockquote>
<span id="more"></span>

<h2 id="控制接口"><a href="#控制接口" class="headerlink" title="控制接口"></a>控制接口</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">/proc/sys/kernel/randomize_va_space</span><br></pre></td></tr></table></figure>

<p><code>randomize_va_space</code>的属性：</p>
<table>
<thead>
<tr>
<th align="center">randomize_va_space</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">关闭</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center"><code>mmap base</code>、<code>stack</code>、<code>vdso page</code>将随机化。这意味着.so文件将被加载到随机地址。链接时指定了<code>-pie</code>选项的可执行程序，其代码段加载地址将被随机化。randomize_va_space缺省为1。此时heap没有随机化</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">在1的基础上增加了<code>heap</code>随机化。配置内核时如果禁用<code>CONFIG_COMPAT_BRK</code>，randomize_va_space缺省为2。</td>
</tr>
</tbody></table>
<h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><h3 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat  /proc/sys/kernel/randomize_va_space</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sysctl -n kernel.randomize_va_space</span><br></pre></td></tr></table></figure>
<h3 id="设置（关闭）"><a href="#设置（关闭）" class="headerlink" title="设置（关闭）"></a>设置（关闭）</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo 0 &gt; /proc/sys/kernel/randomize_va_space</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sysctl -w kernel.randomize_va_space=0</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>*<span class="exturl" data-url="aHR0cHM6Ly93d3cuaW5mb3JzZWMub3JnL3dwLz9wPTEwMDk=">地址空间布局随机化(ASLR)增强研究综述<i class="fa fa-external-link-alt"></i></span><br>*<span class="exturl" data-url="aHR0cDovL3d3Mi5jcy5mc3UuZWR1L355Y2hlbi9wYXBlci9SZW1peF9zbGlkZXMucGRm">Remix: On-demand Live Randomization<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>计算机系统</category>
        <category>进程</category>
      </categories>
      <tags>
        <tag>进程</tag>
        <tag>aslr</tag>
      </tags>
  </entry>
  <entry>
    <title>HID设备--开发板模拟鼠标</title>
    <url>/post/5098.html</url>
    <content><![CDATA[<p>HID</p>
<span id="more"></span>

<h2 id="HID"><a href="#HID" class="headerlink" title="HID"></a>HID</h2><h2 id="鼠标裸数据"><a href="#鼠标裸数据" class="headerlink" title="鼠标裸数据"></a>鼠标裸数据</h2><h3 id="驱动："><a href="#驱动：" class="headerlink" title="驱动："></a>驱动：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Symbol: HIDRAW [=y]</span><br><span class="line">Type  : boolean</span><br><span class="line">Prompt: /dev/hidraw raw HID device support</span><br><span class="line">  Location:</span><br><span class="line">    -&gt; Device Drivers</span><br><span class="line">      -&gt; HID support</span><br><span class="line">        -&gt; HID bus support (HID [=y])</span><br></pre></td></tr></table></figure>

<h3 id="读取数据"><a href="#读取数据" class="headerlink" title="读取数据"></a>读取数据</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">read(uibc-&gt;hid_fd, buf, sizeof(buf));</span><br></pre></td></tr></table></figure>

<h3 id="鼠标数据格式"><a href="#鼠标数据格式" class="headerlink" title="鼠标数据格式"></a>鼠标数据格式</h3><p>鼠标的通信格式：4个字节</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BYTE3 BYTE2 BYTE1 BYTE0</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th align="center">Byte</th>
<th align="center">BIT7</th>
<th align="center">BIT6</th>
<th align="center">BIT5</th>
<th align="center">BIT4</th>
<th align="center">BIT3</th>
<th align="center">BIT2</th>
<th align="center">BIT1</th>
<th align="center">BIT0</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">1 表示Y坐标的变化量超出－256~255的范围, 0表示没有溢出</td>
<td align="center">1表示X坐标的变化量超出－256~255的范围，0表示没有溢出</td>
<td align="center">Y坐标变化的符号位，1表示负数，即鼠标向下移动</td>
<td align="center">X   坐标变化的符号位，1表示负数，即鼠标向左移动</td>
<td align="center">恒为1</td>
<td align="center">1表示中键按下</td>
<td align="center">1表示右键按下</td>
<td align="center">1表示左键按下</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">X坐标变化量，</td>
<td align="center">与byte的</td>
<td align="center">bit4组成</td>
<td align="center">9位符号数,</td>
<td align="center">负数表示向左移，</td>
<td align="center">正数表右移。</td>
<td align="center">用补码</td>
<td align="center">表示变化量</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">Y坐标变化量，</td>
<td align="center">与byte的</td>
<td align="center">bit5组成</td>
<td align="center">9位符号数，</td>
<td align="center">负数表示向下移，</td>
<td align="center">正数表上移。</td>
<td align="center">用补码</td>
<td align="center">表示变化量</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">滚轮变化。</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">-</td>
</tr>
</tbody></table>
<p>鼠标的一次点击，包含<code>按下</code>和<code>抬起</code>两个动作，这两个动作均会上报事件，<code>抬起</code>时上报的全部为<code>0x0</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uibc read device raw data[len: 6]: BIT5~BIT0    //按下左键</span><br><span class="line">                00 00 00 00 00 01</span><br><span class="line">uibc read device raw data[len: 6]: BIT5~BIT0    //抬起左键</span><br><span class="line">                00 00 00 00 00 00</span><br></pre></td></tr></table></figure>

<h2 id="开发板模拟鼠标"><a href="#开发板模拟鼠标" class="headerlink" title="开发板模拟鼠标"></a>开发板模拟鼠标</h2><p>以开发板作为device端,由于鼠标为HID设备，在HID驱动中添加鼠标的device</p>
<p>参考文档：<span class="exturl" data-url="aHR0cHM6Ly9lbGl4aXIuYm9vdGxpbi5jb20vbGludXgvdjMuNC4zNS9zb3VyY2UvRG9jdW1lbnRhdGlvbi91c2IvZ2FkZ2V0X2hpZC50eHQ=">Documentation&#x2F;usb&#x2F;gadget_hid.txt<i class="fa fa-external-link-alt"></i></span>, 其中主要时驱动的添加和测试</p>
<h3 id="Device驱动"><a href="#Device驱动" class="headerlink" title="Device驱动"></a>Device驱动</h3><ul>
<li>hid.c</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*hid descriptor for a mouse*/</span><br><span class="line">static struct hidg_func_descriptor vx_device_mouse_data = &#123;</span><br><span class="line">    .subclass = 0,  /*NO SubClass*/</span><br><span class="line">    .protocol = 2,  /*Mouse*/</span><br><span class="line">    .report_length = 6,</span><br><span class="line">    .report_desc_length = 79,</span><br><span class="line">    .report_desc=&#123;</span><br><span class="line">        0x05,0x01,  /*Usage Page (Generic Desktop Controls)*/</span><br><span class="line">        0x09,0x02,  /*Usage (Mouse)*/</span><br><span class="line">        0xa1,0x01,  /*Collction (Application)*/</span><br><span class="line">        0x09,0x01,  /*Usage (pointer)*/</span><br><span class="line">        0xa1,0x00,  /*Collction (Physical)*/</span><br><span class="line">        0x05,0x09,  /*Usage Page (Button)*/</span><br><span class="line">        0x19,0x01,  /*Usage Minimum(1)*/</span><br><span class="line">        0x29,0x05,  /*Usage Maximum(3) */</span><br><span class="line">        0x15,0x00,  /*Logical Minimum(1)*/</span><br><span class="line">        0x25,0x01,  /*Logical Maximum(1)*/</span><br><span class="line">        0x95,0x05,  /*Report Count(5)  */</span><br><span class="line">        0x75,0x01,  /*Report Size(1)*/</span><br><span class="line">        0x81,0x02,  /*Input (Data,Var,Abs,NWrp,Lin,Pref,NNul,Bit)*/</span><br><span class="line">        0x95,0x01,  /*Report Count(1)*/</span><br><span class="line">        0x75,0x03,  /*Report Size(3) */</span><br><span class="line">        0x81,0x01,  /*Input (Cnst,Ary,Abs) */</span><br><span class="line">        0x05,0x01,  /*Usage Page (Generic Desktop Controls)*/</span><br><span class="line">        0x09,0x30,  /*Usage(x)*/</span><br><span class="line">        0x09,0x31,  /*Usage(y)*/</span><br><span class="line">        0x16,0x00,0xF8,  /*Logical Minimum (-2048)*/</span><br><span class="line">        0x26,0xFF,0x07,  /*Logical Maximum (2047)*/</span><br><span class="line">        0x75,0x0C, /*Report Size(12)*/</span><br><span class="line">        0x95,0x02, /*Report Count(2) */</span><br><span class="line">        0x81,0x06, /*Input (Data,Var,Rel,NWrp,Lin,Pref,NNul,Bit)*/</span><br><span class="line">        0x09,0x38,  /*Usage(Wheel)*/</span><br><span class="line">        0x15,0x81,  /*Logical Minimum(-127)*/</span><br><span class="line">        0x25,0x7f,  /*Logical Maximum(127)*/</span><br><span class="line">        0x75,0x08,  /*Report Size(8)*/</span><br><span class="line">        0x95,0x01,  /*Report Count(1)  */</span><br><span class="line">        0x81,0x06,  /*Input (Data,Var,Rel,NWrp,Lin,Pref,NNul,Bit)*/</span><br><span class="line">        0x05,0x0C, /*Usage Page (Consumer Devices) */</span><br><span class="line">        0x0A,0x38,0x02, /*Usage (AC Pan)*/</span><br><span class="line">        0x95,0x01, /*Report Count (1) */</span><br><span class="line">        0x75,0x08, /*Report Size (8)*/</span><br><span class="line">        0x15,0x81, /*Logical Minimum (-127) */</span><br><span class="line">        0x25,0x7F, /*Logical Maximum (127)*/</span><br><span class="line">        0x81,0x06, /*Input (Data,Var,Rel,NWrp,Lin,Pref,NNul,Bit) */</span><br><span class="line">        0xc0,   /*End Collection*/</span><br><span class="line">        0xc0    /*End Collection*/</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static struct platform_device vx_device_hid_mouse = &#123;</span><br><span class="line">    .name = &quot;hidg&quot;,</span><br><span class="line">    .id            = 1,</span><br><span class="line">    .num_resources = 0,</span><br><span class="line">    .resource    = 0,</span><br><span class="line">    .dev.platform_data = &amp;vx_device_mouse_data,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static int __init hidg_init(void)</span><br><span class="line">&#123;</span><br><span class="line">    int status;</span><br><span class="line"></span><br><span class="line">    status = platform_device_register(&amp;vx_device_hid_mouse);</span><br><span class="line">    if (status &lt; 0) &#123;</span><br><span class="line">        printk(&quot;f:%s, l:%d, platform_driver hid mouse error\n&quot;, __func__, __LINE__);</span><br><span class="line">        return status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">module_init(hidg_init);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>kernel: linux3.4.35, file:drivers&#x2F;usb&#x2F;gadget&#x2F;hid.c</p>
</blockquote>
<ul>
<li>f_hid.c</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Index: f_hid.c</span><br><span class="line">===================================================================</span><br><span class="line">--- f_hid.c	(revision <span class="number">1771</span>)</span><br><span class="line">+++ f_hid.c	(working copy)</span><br><span class="line">@@ <span class="number">-185</span>,<span class="number">12</span> +<span class="number">185</span>,<span class="number">17</span> @@</span><br><span class="line"> 	wake_up(&amp;hidg-&gt;write_queue);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">+<span class="type">static</span> <span class="type">int</span> usb_ep_enable_done = <span class="number">0</span>;</span><br><span class="line">+</span><br><span class="line"> <span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">f_hidg_write</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">const</span> <span class="type">char</span> __user *buffer,</span></span><br><span class="line"><span class="params"> 			    <span class="type">size_t</span> count, <span class="type">loff_t</span> *offp)</span></span><br><span class="line"> &#123;</span><br><span class="line"> 	<span class="class"><span class="keyword">struct</span> <span class="title">f_hidg</span> *<span class="title">hidg</span>  =</span> file-&gt;private_data;</span><br><span class="line"> 	<span class="type">ssize_t</span> status = -ENOMEM;</span><br><span class="line"></span><br><span class="line">+	<span class="keyword">if</span> (!usb_ep_enable_done)</span><br><span class="line">+		<span class="keyword">return</span> -ENODEV;</span><br><span class="line">+</span><br><span class="line"> 	<span class="keyword">if</span> (!access_ok(VERIFY_READ, buffer, count))</span><br><span class="line"> 		<span class="keyword">return</span> -EFAULT;</span><br><span class="line"></span><br><span class="line">@@ <span class="number">-316</span>,<span class="number">6</span> +<span class="number">321</span>,<span class="number">7</span> @@</span><br><span class="line"> 	<span class="class"><span class="keyword">struct</span> <span class="title">usb_request</span>		*<span class="title">req</span>  =</span> cdev-&gt;req;</span><br><span class="line"> 	<span class="type">int</span> status = <span class="number">0</span>;</span><br><span class="line"> 	__u16 value, length;</span><br><span class="line">+	<span class="type">unsigned</span> <span class="type">char</span> report[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"> 	value	= __le16_to_cpu(ctrl-&gt;wValue);</span><br><span class="line"> 	length	= __le16_to_cpu(ctrl-&gt;wLength);</span><br><span class="line">@@ <span class="number">-324</span>,<span class="number">15</span> +<span class="number">330</span>,<span class="number">29</span> @@</span><br><span class="line"> 		<span class="string">&quot;Value:0x%x\n&quot;</span>, ctrl-&gt;bRequestType, ctrl-&gt;bRequest, value);</span><br><span class="line"></span><br><span class="line"> 	<span class="keyword">switch</span> ((ctrl-&gt;bRequestType &lt;&lt; <span class="number">8</span>) | ctrl-&gt;bRequest) &#123;</span><br><span class="line">-	<span class="keyword">case</span> ((USB_DIR_IN | USB_TYPE_CLASS | USB_RECIP_INTERFACE) &lt;&lt; <span class="number">8</span></span><br><span class="line">-		  | HID_REQ_GET_REPORT):</span><br><span class="line">-		VDBG(cdev, <span class="string">&quot;get_report\n&quot;</span>);</span><br><span class="line">-</span><br><span class="line">-		<span class="comment">/* send an empty report */</span></span><br><span class="line">-		length = <span class="type">min_t</span>(<span class="type">unsigned</span>, length, hidg-&gt;report_length);</span><br><span class="line">-		<span class="built_in">memset</span>(req-&gt;buf, <span class="number">0x0</span>, length);</span><br><span class="line">+		<span class="keyword">case</span> ((USB_DIR_IN | USB_TYPE_CLASS | USB_RECIP_INTERFACE) &lt;&lt; <span class="number">8</span></span><br><span class="line">+				| HID_REQ_GET_REPORT):</span><br><span class="line">+			VDBG(cdev, <span class="string">&quot;get_report\n&quot;</span>);</span><br><span class="line">+		<span class="keyword">switch</span> (value &gt;&gt; <span class="number">8</span>) &#123;</span><br><span class="line">+		<span class="keyword">case</span> HID_REQ_GET_PROTOCOL:</span><br><span class="line">+			report[<span class="number">0</span>] = <span class="number">0x02</span>;</span><br><span class="line">+			report[<span class="number">1</span>] = <span class="number">0x0a</span>;</span><br><span class="line">+</span><br><span class="line">+			length = <span class="type">min_t</span>(<span class="type">unsigned</span>, length, <span class="number">2</span>);</span><br><span class="line">+			VDBG(cdev, <span class="string">&quot;HID_REQ_GET_PROTOCOL: REPORT[0x0a, 0x02]\n&quot;</span>);</span><br><span class="line">+			length = <span class="number">2</span>;</span><br><span class="line">+			<span class="built_in">memcpy</span>(req-&gt;buf, report, length);</span><br><span class="line">+			<span class="keyword">goto</span> respond;</span><br><span class="line">+			<span class="keyword">break</span>;</span><br><span class="line">+		<span class="keyword">default</span>:</span><br><span class="line">+			<span class="comment">/* send an empty report */</span></span><br><span class="line">+			length = <span class="type">min_t</span>(<span class="type">unsigned</span>, length, hidg-&gt;report_length);</span><br><span class="line">+			<span class="built_in">memset</span>(req-&gt;buf, <span class="number">0x0</span>, length);</span><br><span class="line">+</span><br><span class="line">+			<span class="keyword">goto</span> respond;</span><br><span class="line">+			<span class="keyword">break</span>;</span><br><span class="line">+		&#125;</span><br><span class="line"></span><br><span class="line">-		<span class="keyword">goto</span> respond;</span><br><span class="line"> 		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"> 	<span class="keyword">case</span> ((USB_DIR_IN | USB_TYPE_CLASS | USB_RECIP_INTERFACE) &lt;&lt; <span class="number">8</span></span><br><span class="line">@@ <span class="number">-381</span>,<span class="number">6</span> +<span class="number">401</span>,<span class="number">15</span> @@</span><br><span class="line"> 		&#125;</span><br><span class="line"> 		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">+	<span class="keyword">case</span> ((USB_DIR_OUT | USB_TYPE_CLASS | USB_RECIP_INTERFACE) &lt;&lt; <span class="number">8</span></span><br><span class="line">+			| USB_REQ_GET_INTERFACE):</span><br><span class="line">+		VDBG(cdev, <span class="string">&quot;get_interface | wLenght=%d\n&quot;</span>, ctrl-&gt;wLength);</span><br><span class="line">+		<span class="comment">/* send an empty report */</span></span><br><span class="line">+		length = <span class="type">min_t</span>(<span class="type">unsigned</span>, length, hidg-&gt;report_length);</span><br><span class="line">+		<span class="built_in">memset</span>(req-&gt;buf, <span class="number">0x0</span>, length);</span><br><span class="line">+		<span class="keyword">goto</span> respond;</span><br><span class="line">+		<span class="keyword">break</span>;</span><br><span class="line">+</span><br><span class="line"> 	<span class="keyword">default</span>:</span><br><span class="line"> 		VDBG(cdev, <span class="string">&quot;Unknown request 0x%x\n&quot;</span>,</span><br><span class="line"> 			 ctrl-&gt;bRequest);</span><br><span class="line">@@ <span class="number">-427</span>,<span class="number">11</span> +<span class="number">456</span>,<span class="number">13</span> @@</span><br><span class="line"> 			ERROR(cdev, <span class="string">&quot;config_ep_by_speed FAILED!\n&quot;</span>);</span><br><span class="line"> 			<span class="keyword">goto</span> fail;</span><br><span class="line"> 		&#125;</span><br><span class="line">+		printk(<span class="string">&quot;%s: usb_ep_enable\n&quot;</span>, __func__);</span><br><span class="line"> 		status = usb_ep_enable(hidg-&gt;in_ep);</span><br><span class="line"> 		<span class="keyword">if</span> (status &lt; <span class="number">0</span>) &#123;</span><br><span class="line"> 			ERROR(cdev, <span class="string">&quot;Enable endpoint FAILED!\n&quot;</span>);</span><br><span class="line"> 			<span class="keyword">goto</span> fail;</span><br><span class="line"> 		&#125;</span><br><span class="line">+		usb_ep_enable_done = <span class="number">1</span>;</span><br><span class="line"> 		hidg-&gt;in_ep-&gt;driver_data = hidg;</span><br><span class="line"> 	&#125;</span><br><span class="line"> fail:</span><br><span class="line">@@ <span class="number">-543</span>,<span class="number">7</span> +<span class="number">574</span>,<span class="number">9</span> @@</span><br><span class="line"> 	cdev_del(&amp;hidg-&gt;cdev);</span><br><span class="line"></span><br><span class="line"> 	<span class="comment">/* disable/free request and end point */</span></span><br><span class="line">+	printk(<span class="string">&quot;%s: usb_ep_disable\n&quot;</span>, __func__);</span><br><span class="line"> 	usb_ep_disable(hidg-&gt;in_ep);</span><br><span class="line">+	usb_ep_enable_done = <span class="number">0</span>;</span><br><span class="line"> 	usb_ep_dequeue(hidg-&gt;in_ep, hidg-&gt;req);</span><br><span class="line"> 	kfree(hidg-&gt;req-&gt;buf);</span><br><span class="line"> 	usb_ep_free_request(hidg-&gt;in_ep, hidg-&gt;req);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>kernel: linux3.4.35, file:drivers&#x2F;usb&#x2F;gadget&#x2F;f_hid.c</p>
</blockquote>
<h3 id="hidg-func-descriptor"><a href="#hidg-func-descriptor" class="headerlink" title="hidg_func_descriptor"></a>hidg_func_descriptor</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct hidg_func_descriptor &#123;</span><br><span class="line">    unsigned char       subclass;</span><br><span class="line">    unsigned char       protocol;</span><br><span class="line">    unsigned short      report_length;</span><br><span class="line">    unsigned short      report_desc_length;</span><br><span class="line">    unsigned char       report_desc[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>file: include&#x2F;linux&#x2F;usb&#x2F;g_hid.h</p>
</blockquote>
<p>主要是一个设备如何填充<code>struct hidg_func_descriptor</code>数据结构。</p>
<blockquote>
<p>You can add as many HID functions as you want, only limited by the amount of interrupt endpoints your gadget driver supports.</p>
</blockquote>
<p>添加<code>hidg</code>设备的个数，受USB的endpoint的限制，如果endpoint只有一对，只能添加一个<code>hidg0</code>设备。</p>
<h3 id="获取USB鼠标HID-Descriptor"><a href="#获取USB鼠标HID-Descriptor" class="headerlink" title="获取USB鼠标HID Descriptor"></a>获取USB鼠标HID Descriptor</h3><ul>
<li>工具：<code>USBlyzer</code></li>
<li>官网下载地址：<span class="exturl" data-url="aHR0cDovL3d3dy51c2JseXplci5jb20vZG93bmxvYWQuaHRt">http://www.usblyzer.com/download.htm<i class="fa fa-external-link-alt"></i></span></li>
<li>下载：<span class="exturl" data-url="aHR0cDovL2Jicy5hcm1mbHkuY29tL2pvYi5waHA/YWN0aW9uPWRvd25sb2FkJmFpZD05OTE5">http://bbs.armfly.com/job.php?action=download&aid=9919<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<h4 id="Device-Descriptor"><a href="#Device-Descriptor" class="headerlink" title="Device Descriptor"></a>Device Descriptor</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Device Descriptor USB OPTICAL MOUSE</span><br><span class="line">Offset Field Size Value Description</span><br><span class="line">0 bLength 1 12h</span><br><span class="line">1 bDescriptorType 1 01h Device</span><br><span class="line">2 bcdUSB 2 0110h USB Spec 1.1</span><br><span class="line">4 bDeviceClass 1 00h Class info in Ifc Descriptors</span><br><span class="line">`5 bDeviceSubClass 1 00h`</span><br><span class="line">6 bDeviceProtocol 1 00h</span><br><span class="line">7 bMaxPacketSize0 1 08h 8 bytes</span><br><span class="line">8 idVendor 2 0101h</span><br><span class="line">10 idProduct 2 0007h</span><br><span class="line">12 bcdDevice 2 0100h 1.00</span><br><span class="line">14 iManufacturer 1 00h</span><br><span class="line">15 iProduct 1 01h &quot;USB OPTICAL MOUSE &quot;</span><br><span class="line">16 iSerialNumber 1 00h</span><br><span class="line">17 bNumConfigurations 1 01h</span><br></pre></td></tr></table></figure>
<h3 id="Interface-Descriptor"><a href="#Interface-Descriptor" class="headerlink" title="Interface Descriptor"></a>Interface Descriptor</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Interface Descriptor 0/0 HID, 1 Endpoint</span><br><span class="line">Offset Field Size Value Description</span><br><span class="line">0 bLength 1 09h</span><br><span class="line">1 bDescriptorType 1 04h Interface</span><br><span class="line">2 bInterfaceNumber 1 00h</span><br><span class="line">3 bAlternateSetting 1 00h</span><br><span class="line">4 bNumEndpoints 1 01h</span><br><span class="line">5 bInterfaceClass 1 03h HID</span><br><span class="line">6 bInterfaceSubClass 1 01h Boot Interface</span><br><span class="line">`7 bInterfaceProtocol 1 02h Mouse`</span><br><span class="line">8 iInterface 1 00h</span><br></pre></td></tr></table></figure>

<h4 id="HID-Descriptor"><a href="#HID-Descriptor" class="headerlink" title="HID Descriptor"></a>HID Descriptor</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HID Descriptor</span><br><span class="line">Offset Field Size Value Description</span><br><span class="line">0 bLength 1 09h</span><br><span class="line">1 bDescriptorType 1 21h HID</span><br><span class="line">2 bcdHID 2 0111h 1.11</span><br><span class="line">4 bCountryCode 1 00h</span><br><span class="line">5 bNumDescriptors 1 01h</span><br><span class="line">6 bDescriptorType 1 22h Report</span><br><span class="line">`7 wDescriptorLength 2 004Fh 79 bytes`</span><br><span class="line"></span><br><span class="line">Endpoint Descriptor 81 1 In, Interrupt, 10 ms</span><br><span class="line">Offset Field Size Value Description</span><br><span class="line">0 bLength 1 07h</span><br><span class="line">1 bDescriptorType 1 05h Endpoint</span><br><span class="line">2 bEndpointAddress 1 81h 1 In</span><br><span class="line">3 bmAttributes 1 03h Interrupt</span><br><span class="line"> 1..0: Transfer Type  ......11  Interrupt</span><br><span class="line"> 7..2: Reserved  000000..</span><br><span class="line">`4 wMaxPacketSize 2 0006h 6 bytes`</span><br><span class="line">6 bInterval 1 0Ah 10 ms</span><br><span class="line"></span><br><span class="line">Interface 0 HID Report Descriptor Mouse</span><br><span class="line">`Item Tag (Value) Raw Data`</span><br><span class="line">Usage Page (Generic Desktop) 05 01</span><br><span class="line">Usage (Mouse) 09 02</span><br><span class="line">Collection (Application) A1 01</span><br><span class="line">    Usage (Pointer) 09 01</span><br><span class="line">    Collection (Physical) A1 00</span><br><span class="line">        Usage Page (Button) 05 09</span><br><span class="line">        Usage Minimum (Button 1) 19 01</span><br><span class="line">        Usage Maximum (Button 5) 29 05</span><br><span class="line">        Logical Minimum (0) 15 00</span><br><span class="line">        Logical Maximum (1) 25 01</span><br><span class="line">        Report Count (5) 95 05</span><br><span class="line">        Report Size (1) 75 01</span><br><span class="line">        Input (Data,Var,Abs,NWrp,Lin,Pref,NNul,Bit) 81 02</span><br><span class="line">        Report Count (1) 95 01</span><br><span class="line">        Report Size (3) 75 03</span><br><span class="line">        Input (Cnst,Ary,Abs) 81 01</span><br><span class="line">        Usage Page (Generic Desktop) 05 01</span><br><span class="line">        Usage (X) 09 30</span><br><span class="line">        Usage (Y) 09 31</span><br><span class="line">        Logical Minimum (-2048) 16 00 F8</span><br><span class="line">        Logical Maximum (2047) 26 FF 07</span><br><span class="line">        Report Size (12) 75 0C</span><br><span class="line">        Report Count (2) 95 02</span><br><span class="line">        Input (Data,Var,Rel,NWrp,Lin,Pref,NNul,Bit) 81 06</span><br><span class="line">        Usage (Wheel) 09 38</span><br><span class="line">        Logical Minimum (-127) 15 81</span><br><span class="line">        Logical Maximum (127) 25 7F</span><br><span class="line">        Report Size (8) 75 08</span><br><span class="line">        Report Count (1) 95 01</span><br><span class="line">        Input (Data,Var,Rel,NWrp,Lin,Pref,NNul,Bit) 81 06</span><br><span class="line">        Usage Page (Consumer Devices) 05 0C</span><br><span class="line">        Usage (AC Pan) 0A 38 02</span><br><span class="line">        Report Count (1) 95 01</span><br><span class="line">        Report Size (8) 75 08</span><br><span class="line">        Logical Minimum (-127) 15 81</span><br><span class="line">        Logical Maximum (127) 25 7F</span><br><span class="line">        Input (Data,Var,Rel,NWrp,Lin,Pref,NNul,Bit) 81 06</span><br><span class="line">    End Collection C0</span><br><span class="line">End Collection C0</span><br></pre></td></tr></table></figure>

<h3 id="hidg-func-descriptor-与-HID-Descriptor"><a href="#hidg-func-descriptor-与-HID-Descriptor" class="headerlink" title="hidg_func_descriptor 与 HID Descriptor"></a>hidg_func_descriptor 与 HID Descriptor</h3><table>
<thead>
<tr>
<th align="center">hidg_func_descriptor</th>
<th align="center">HID Descriptor</th>
</tr>
</thead>
<tbody><tr>
<td align="center">subclass</td>
<td align="center">bDeviceSubClass</td>
</tr>
<tr>
<td align="center">protocol</td>
<td align="center">bInterfaceProtocol</td>
</tr>
<tr>
<td align="center">report_length</td>
<td align="center">wMaxPacketSize</td>
</tr>
<tr>
<td align="center">report_desc_length</td>
<td align="center">wDescriptorLength</td>
</tr>
<tr>
<td align="center">report_desc[]</td>
<td align="center">Item Tag (Value) Raw Data</td>
</tr>
</tbody></table>
<h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><p><code>Bus Hound</code>是一个超级软件总线协议分析器,用于捕捉来自设备的协议包和输入输出操作</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hjbHlkYW8vYXJ0aWNsZS9kZXRhaWxzLzkyODQyMTU=">s3c6410 linux gadget hid驱动<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pYW9wYXNpX1FBUS9hcnRpY2xlL2RldGFpbHMvNDU0Nzk3MDk=">DM816X 实现 USB HID Gadget 鼠标键盘功能<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vbmluZ2NpL3AvNjgwNzY1NC5odG1s">linux 读取 USB HID鼠标坐标和点击 在 LCD上显示<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzNzUwODI2L2FydGljbGUvZGV0YWlscy83OTM5Nzk4NA==">Linux之访问&#x2F;dev&#x2F;hidraw<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N5MzczNDY2MDYyL2FydGljbGUvZGV0YWlscy83ODIyMzU2Mw==">USB与BT HID reports描述符实践与抓包分析<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x1Y2t5d2FuZzExMDMvYXJ0aWNsZS9kZXRhaWxzLzQxMjgyNTUx">usb hid gadget模拟鼠标键盘<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL2Jsb2cuY2hpbmF1bml4Lm5ldC91aWQtMjMyMTUxMjgtaWQtMjUyMTQ3Ny5odG1s">USB&#x2F;HID设备报告描述符详解<i class="fa fa-external-link-alt"></i></span></li>
</ol>
]]></content>
      <categories>
        <category>设备驱动</category>
        <category>USB</category>
      </categories>
      <tags>
        <tag>驱动</tag>
        <tag>hid</tag>
      </tags>
  </entry>
  <entry>
    <title>USB HID Report描述符</title>
    <url>/post/40274.html</url>
    <content><![CDATA[<p>在USB的枚举后，即交互完 设备描述符(device descriptor),配置描述符(configure descriptor),接口描述符(interface descriptor)和终端描述符(endpointer desciptor)。如果是HID设备，即class值为3设备交互还会发送一系统的特殊包来描述HID设备的特性。</p>
<p>这一些描述HID的特性称为Report Descriptor,报告描述符，可以理解它们是HID设备的上传的包，或者接收的包的格式。<code>设备能包含多个report</code>(测试出错)</p>
<p>主要参考官网文档：<span class="exturl" data-url="aHR0cDovL3d3dy51c2Iub3JnL2RldmVsb3BlcnMvaGlkcGFnZSNDbGFzc19EZWZpbml0aW9ucw==">HID Information<i class="fa fa-external-link-alt"></i></span></p>
<span id="more"></span>

<p>对于每种HID动作的编码，HID有一个专用术语usage (用法），USB协议中支持所有编码表称为usage tables.这里有全部编码表<span class="exturl" data-url="aHR0cDovL3d3dy51c2Iub3JnL2RldmVsb3BlcnMvaGlkcGFnZS9IdXQxXzEydjIucGRm">HID Usage Tables 1.12<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="Report-Descriptor"><a href="#Report-Descriptor" class="headerlink" title="Report Descriptor"></a>Report Descriptor</h2><p>在usb.org网站有HID decriptor tools工具下载 可以用创建和解析report descriptor包格式<br><span class="exturl" data-url="aHR0cDovL3d3dy51c2Iub3JnL2RldmVsb3BlcnMvaGlkcGFnZS9kdDJfNC56aXA=">http://www.usb.org/developers/hidpage/dt2_4.zip<i class="fa fa-external-link-alt"></i></span></p>
<blockquote>
<p>一个完整的report 分为二部分，一部分定长的头，另一部分就是变长的定义, 每个collection由若干个usage组成. 在Collection中，每一个组成部分以称为item,item就是usage.<br><code>A1 01</code> 与 <code>C0</code>之间表示<code>Application Collection</code>的.</p>
</blockquote>
<p>| usage 	|  说明		   |<br>| :—: 	| :————: |<br>| input 	| 输入数据格式	|<br>| output	| 输出数据格式	|<br>| Logical Minimum | 取值范围	|<br>| logical_maximum |	取值范围	|<br>| physical_minimum|	取值范围	|<br>| physical_maximum|	取值范围	|<br>| report size | report输入字节宽度	|<br>| report count | report总数	|</p>
<h2 id="获取描述符"><a href="#获取描述符" class="headerlink" title="获取描述符"></a>获取描述符</h2><ul>
<li>工具： <code>USBlyzer</code> （Bus Hound同样也可以抓取，但是需要自己解析）</li>
</ul>
<h2 id="实例分析（鼠标）"><a href="#实例分析（鼠标）" class="headerlink" title="实例分析（鼠标）"></a>实例分析（鼠标）</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HID Descriptor</span><br><span class="line">Offset Field Size Value Description</span><br><span class="line">0 bLength 1 09h</span><br><span class="line">1 bDescriptorType 1 21h HID</span><br><span class="line">2 bcdHID 2 0111h 1.11</span><br><span class="line">4 bCountryCode 1 00h</span><br><span class="line">5 bNumDescriptors 1 01h</span><br><span class="line">6 bDescriptorType 1 22h Report</span><br><span class="line">7 wDescriptorLength 2 002Eh 46 bytes  &lt;-------描述符大小</span><br><span class="line"></span><br><span class="line">Endpoint Descriptor 81 1 In, Interrupt, 10 ms</span><br><span class="line">Offset Field Size Value Description</span><br><span class="line">0 bLength 1 07h</span><br><span class="line">1 bDescriptorType 1 05h Endpoint</span><br><span class="line">2 bEndpointAddress 1 81h 1 In</span><br><span class="line">3 bmAttributes 1 03h Interrupt</span><br><span class="line"> 1..0: Transfer Type  ......11  Interrupt</span><br><span class="line"> 7..2: Reserved  000000..</span><br><span class="line">4 wMaxPacketSize 2 0004h 4 bytes  &lt;-----------包数据宽度</span><br><span class="line">6 bInterval 1 0Ah 10 ms</span><br><span class="line"></span><br><span class="line">Interface 0 HID Report Descriptor Mouse</span><br><span class="line">Item Tag (Value) Raw Data</span><br><span class="line">Usage Page (Generic Desktop) 05 01</span><br><span class="line">Usage (Mouse) 09 02</span><br><span class="line">Collection (Application) A1 01</span><br><span class="line">    Usage (Pointer) 09 01</span><br><span class="line">    Collection (Physical) A1 00</span><br><span class="line">        Usage Page (Button) 05 09</span><br><span class="line">        Usage Minimum (Button 1) 19 01</span><br><span class="line">        Usage Maximum (Button 3) 29 03</span><br><span class="line">        Logical Minimum (0) 15 00</span><br><span class="line">        Logical Maximum (1) 25 01</span><br><span class="line">        Report Count (8) 95 08</span><br><span class="line">        Report Size (1) 75 01</span><br><span class="line">        Input (Data,Var,Abs,NWrp,Lin,Pref,NNul,Bit) 81 02</span><br><span class="line"></span><br><span class="line">        Usage Page (Generic Desktop) 05 01</span><br><span class="line">        Usage (X) 09 30</span><br><span class="line">        Usage (Y) 09 31</span><br><span class="line">        Usage (Wheel) 09 38</span><br><span class="line">        Logical Minimum (-127) 15 81</span><br><span class="line">        Logical Maximum (127) 25 7F</span><br><span class="line">        Report Size (8) 75 08</span><br><span class="line">        Report Count (3) 95 03</span><br><span class="line">        Input (Data,Var,Rel,NWrp,Lin,Pref,NNul,Bit) 81 06</span><br><span class="line">    End Collection C0</span><br><span class="line">End Collection C0</span><br></pre></td></tr></table></figure>

<h3 id="获取数据格式–Input"><a href="#获取数据格式–Input" class="headerlink" title="获取数据格式–Input"></a>获取数据格式–Input</h3><p>从Report描述符可以获取信息，鼠标输入的数据可以分两部分：</p>
<table>
<thead>
<tr>
<th align="center">序号</th>
<th align="center">设备类型</th>
<th align="center">格式</th>
<th align="center">宽度</th>
<th align="center">大小</th>
<th align="center">取值范围</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">Usage Page (Button)</td>
<td align="center">Input (Data,Var,Abs,NWrp,Lin,Pref,NNul,Bit)</td>
<td align="center">Report Size (1)</td>
<td align="center">Report Count (8)</td>
<td align="center">Logical Minimum (0) ~ Logical Maximum (1)</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">Usage Page (Generic Desktop)</td>
<td align="center">Input (Data,Var,Rel,NWrp,Lin,Pref,NNul,Bit)</td>
<td align="center">Report Size (8)</td>
<td align="center">Report Count (3)</td>
<td align="center">Logical Minimum (-127) ~ Logical Maximum (127)</td>
</tr>
</tbody></table>
<p>数据格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+---------------+---------------+--------------------------------+</span><br><span class="line">| Usage (Wheel) |   Usage (Y)   |   Usage (X)   |7|6|5|4|3|2|1||0|</span><br><span class="line">+---------------+---------------+--------------------------+-+--++</span><br><span class="line">                                                           | |  v</span><br><span class="line">                                                           | v  Usage Page (Button)</span><br><span class="line">                                                           v Usage Minimum (Button 1)</span><br><span class="line">                                                           Usage Maximum (Button 3)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>第一部分：一个字节（Byte），其中每个bit代表一种含义, <code>Usage Page (Button)</code>,<code>Usage Minimum (Button 1)</code>,<code>Usage Maximum (Button 3) </code></li>
<li>第二部分：三个字节（Byte），其中一个字节代表一种含义，<code>Usage (X)</code>,<code>Usage (Y)</code>,<code>Usage (Wheel)</code></li>
</ul>
<h2 id="linux下获取HID"><a href="#linux下获取HID" class="headerlink" title="linux下获取HID"></a>linux下获取HID</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">usbhid-dump  | grep -v : | xxd -r -p | hidrd-convert -o spec</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">=====&gt;$usbhid-dump -a1:5 -i0</span><br><span class="line">001:005:000:DESCRIPTOR         1564469117.021395</span><br><span class="line"> 05 01 09 02 A1 01 09 01 A1 00 05 09 19 01 29 03</span><br><span class="line"> 15 00 25 01 95 08 75 01 81 02 05 01 09 30 09 31</span><br><span class="line"> 09 38 15 81 25 7F 75 08 95 03 81 06 C0 C0</span><br><span class="line"></span><br><span class="line">=====&gt;$usbhid-dump -a1:5 -i0 | grep -v : | xxd -r -p | hidrd-convert -o spec</span><br><span class="line">Usage Page (Desktop),               ; Generic desktop controls (01h)</span><br><span class="line">Usage (Mouse),                      ; Mouse (02h, application collection)</span><br><span class="line">Collection (Application),</span><br><span class="line">    Usage (Pointer),                ; Pointer (01h, physical collection)</span><br><span class="line">    Collection (Physical),</span><br><span class="line">        Usage Page (Button),        ; Button (09h)</span><br><span class="line">        Usage Minimum (01h),</span><br><span class="line">        Usage Maximum (03h),</span><br><span class="line">        Logical Minimum (0),</span><br><span class="line">        Logical Maximum (1),</span><br><span class="line">        Report Count (8),</span><br><span class="line">        Report Size (1),</span><br><span class="line">        Input (Variable),</span><br><span class="line">        Usage Page (Desktop),       ; Generic desktop controls (01h)</span><br><span class="line">        Usage (X),                  ; X (30h, dynamic value)</span><br><span class="line">        Usage (Y),                  ; Y (31h, dynamic value)</span><br><span class="line">        Usage (Wheel),              ; Wheel (38h, dynamic value)</span><br><span class="line">        Logical Minimum (-127),</span><br><span class="line">        Logical Maximum (127),</span><br><span class="line">        Report Size (8),</span><br><span class="line">        Report Count (3),</span><br><span class="line">        Input (Variable, Relative),</span><br><span class="line">    End Collection,</span><br><span class="line">End Collection</span><br><span class="line">=====&gt;$usbhid-dump -a1:5 -i0 | grep -v : | xxd -r -p | hidrd-convert -o code</span><br><span class="line">0x05, 0x01, /*  Usage Page (Desktop),               */</span><br><span class="line">0x09, 0x02, /*  Usage (Mouse),                      */</span><br><span class="line">0xA1, 0x01, /*  Collection (Application),           */</span><br><span class="line">0x09, 0x01, /*      Usage (Pointer),                */</span><br><span class="line">0xA1, 0x00, /*      Collection (Physical),          */</span><br><span class="line">0x05, 0x09, /*          Usage Page (Button),        */</span><br><span class="line">0x19, 0x01, /*          Usage Minimum (01h),        */</span><br><span class="line">0x29, 0x03, /*          Usage Maximum (03h),        */</span><br><span class="line">0x15, 0x00, /*          Logical Minimum (0),        */</span><br><span class="line">0x25, 0x01, /*          Logical Maximum (1),        */</span><br><span class="line">0x95, 0x08, /*          Report Count (8),           */</span><br><span class="line">0x75, 0x01, /*          Report Size (1),            */</span><br><span class="line">0x81, 0x02, /*          Input (Variable),           */</span><br><span class="line">0x05, 0x01, /*          Usage Page (Desktop),       */</span><br><span class="line">0x09, 0x30, /*          Usage (X),                  */</span><br><span class="line">0x09, 0x31, /*          Usage (Y),                  */</span><br><span class="line">0x09, 0x38, /*          Usage (Wheel),              */</span><br><span class="line">0x15, 0x81, /*          Logical Minimum (-127),     */</span><br><span class="line">0x25, 0x7F, /*          Logical Maximum (127),      */</span><br><span class="line">0x75, 0x08, /*          Report Size (8),            */</span><br><span class="line">0x95, 0x03, /*          Report Count (3),           */</span><br><span class="line">0x81, 0x06, /*          Input (Variable, Relative), */</span><br><span class="line">0xC0,       /*      End Collection,                 */</span><br><span class="line">0xC0        /*  End Collection                      */</span><br></pre></td></tr></table></figure>
<h2 id="hid设备操作接口"><a href="#hid设备操作接口" class="headerlink" title="hid设备操作接口"></a>hid设备操作接口</h2><p>通过<code>open</code>及<code>ioctl</code>操作HID设备节点<code>dev/hidrawN</code></p>
<blockquote>
<p>头文件：<code>#include &lt;linux/hidraw.h&gt;</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _HIDRAW_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _HIDRAW_H</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/hid.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hidraw_report_descriptor</span> &#123;</span></span><br><span class="line">    __u32 size;</span><br><span class="line">    __u8 value[HID_MAX_DESCRIPTOR_SIZE];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hidraw_devinfo</span> &#123;</span></span><br><span class="line">    __u32 bustype;</span><br><span class="line">    __s16 vendor;</span><br><span class="line">    __s16 product;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ioctl interface */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HIDIOCGRDESCSIZE    _IOR(<span class="string">&#x27;H&#x27;</span>, 0x01, int)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HIDIOCGRDESC        _IOR(<span class="string">&#x27;H&#x27;</span>, 0x02, struct hidraw_report_descriptor)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HIDIOCGRAWINFO      _IOR(<span class="string">&#x27;H&#x27;</span>, 0x03, struct hidraw_devinfo)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HIDIOCGRAWNAME(len)     _IOC(_IOC_READ, <span class="string">&#x27;H&#x27;</span>, 0x04, len)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HIDIOCGRAWPHYS(len)     _IOC(_IOC_READ, <span class="string">&#x27;H&#x27;</span>, 0x05, len)</span></span><br><span class="line"><span class="comment">/* The first byte of SFEATURE and GFEATURE is the report number */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HIDIOCSFEATURE(len)    _IOC(_IOC_WRITE|_IOC_READ, <span class="string">&#x27;H&#x27;</span>, 0x06, len)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HIDIOCGFEATURE(len)    _IOC(_IOC_WRITE|_IOC_READ, <span class="string">&#x27;H&#x27;</span>, 0x07, len)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HIDRAW_FIRST_MINOR 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HIDRAW_MAX_DEVICES 64</span></span><br><span class="line"><span class="comment">/* number of reports to buffer */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HIDRAW_BUFFER_SIZE 64</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* kernel-only API declarations */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* _HIDRAW_H */</span></span></span><br></pre></td></tr></table></figure>

<h2 id="相关文件"><a href="#相关文件" class="headerlink" title="相关文件"></a>相关文件</h2><ul>
<li><span class="exturl" data-url="aHR0cDovL3d3dy51c2Iub3JnL2RldmVsb3BlcnMvaGlkcGFnZS9ISUQxXzExLnBkZg==">Device Class Definition for HID 1.11<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL3d3dy51c2Iub3JnL2RldmVsb3BlcnMvaGlkcGFnZS9IdXQxXzEydjIucGRm">HID Usage Tables 1.12<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL2QxLmFtb2Jicy5jb20vYmJzX3VwbG9hZDc4MjExMS9maWxlc180MS9vdXJkZXZfNjUxMDg4Tlo1RUtXLnBkZg==">USB HID to PS2 Scan Code Translation Table.pdf<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL3d3dy5mcmVlYnNkZGlhcnkub3JnL0FQQy91c2JfaGlkX3VzYWdlcy5waHA=">USB HID usage table<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在设备识别阶段多使用<code>bus hound</code>抓取数据包进行分析，在开发板作device时，host可能会获取部分数据（比如触摸屏，需要得到支持几点的触摸操作，默认单点），此时可能会获取失败。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><span class="exturl" data-url="aHR0cDovL2Jsb2cuY2hpbmF1bml4Lm5ldC94bWxycGMucGhwP3I9YmxvZy9hcnRpY2xlJnVpZD0yMDU4NzkxMiZpZD0yOTg0Mzgw">Linux HID 驱动开发(2) USB HID Report 描述及usage 概念<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9teS5vc2NoaW5hLm5ldC94dXdhL2Jsb2cvMjA2Mg==">USB HID报告及报告描述符简介<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL2Jsb2cuY2hpbmF1bml4Lm5ldC91aWQtMjMxNTkyMzktaWQtMjUzNTExOS5odG1s">浅析linux下usb鼠标和usb键盘usbhid驱动hid_parse_report报告描述符<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>设备驱动</category>
        <category>USB</category>
      </categories>
      <tags>
        <tag>驱动</tag>
        <tag>hid</tag>
      </tags>
  </entry>
  <entry>
    <title>USB中OTG功能的实现</title>
    <url>/post/1467.html</url>
    <content><![CDATA[<blockquote>
<p>usb otg(on-the-go)标准在完全兼容usb2.0标准的基础上，增添了电源管理（节省功耗）功能，它允许设备既可作为主机，也可作为外设操作（两用otg）。otg两用设备完全符合usb2.0标准，并可提供一定的主机检测能力，支持主机通令协议（hnp）和对话请求协议（srp）。在otg中，初始主机设备称为a设备，外设称为b设备。可用电缆的连接方式(id pin)来决定初始角色</p>
</blockquote>
<span id="more"></span>

<h2 id="硬件接口"><a href="#硬件接口" class="headerlink" title="硬件接口"></a>硬件接口</h2><p><img data-src="/images/2019/08/usb_otg_id_pin.png" alt="usb_otg_id_pin"></p>
<h2 id="数据传输"><a href="#数据传输" class="headerlink" title="数据传输"></a>数据传输</h2><h3 id="中断传输"><a href="#中断传输" class="headerlink" title="中断传输"></a>中断传输</h3><blockquote>
<p>An interrupt transfer is complete when the endpoint does one of the following:</p>
<ul>
<li>Has transferred exactly the amount of data expected</li>
<li>Transfers a packet with a payload size less than <code>wMaxPacketSize</code> or transfers a zero-length packet</li>
</ul>
</blockquote>
<p>中断传输完成时，端点执行的操作：</p>
<ul>
<li>已传输完成预期的数据量</li>
<li>传输的有效数据负载小于wMaxPacketSize大小或者传输0长度的数据包（ZLP）</li>
</ul>
<p>在HID设置中对report描述符的传输使用中断传输（数据量小），如果wMaxPacketSize的值为64Byte（控制器可配），而此时该设备的report描述符大小也为64Byte，在数据发送完后需要发送一个ZLP，否则host端无法确定数据是否传输完成。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY2wuY2FtLmFjLnVrL35hdG0yNi9lcGhlbWVyYWwvcnBpL2R3Y19vdGcvZG9jL2h0bWwvbWFpbi5odG1s">DesignWare USB 2.0 OTG Controller (DWC_otg) Device Driver Documentation<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vTG9vbmdFbWJlZGRlZC9wLzUyOTgxNzMuaHRtbA==">USB OTG插入检测识别<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>设备驱动</category>
        <category>USB</category>
      </categories>
      <tags>
        <tag>usb</tag>
        <tag>otg</tag>
      </tags>
  </entry>
  <entry>
    <title>I2C驱动</title>
    <url>/post/28337.html</url>
    <content><![CDATA[<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">                          +---------+</span><br><span class="line">+----------+              |         |</span><br><span class="line">| CPU      |              |  codec1 |</span><br><span class="line">|          |              +-+-----+-+</span><br><span class="line">|      +---+                |     |                       +------+</span><br><span class="line">|      |I2C|                |     |                       |      |</span><br><span class="line">|      |   &lt;----------------------------------------------+ codec|</span><br><span class="line">|      |   &lt;----------------------v-----------------------+      |</span><br><span class="line">|      +---+                                              |      |</span><br><span class="line">|          |                                              +------+</span><br><span class="line">+----------+</span><br></pre></td></tr></table></figure>

<p>I2C: 以1根串行数据线<code>（SDA）</code>和1根串行时钟线<code>（SCL）</code>实 现了双工的同步数据传输。具有接口线少，控制方式简化，器件封装形式小，通信速率较高等优点。在主从通信中，可以有多个I2C总线器件同时接到I2C总线上，通过<code>地址</code>来识别通信对象, <code>应答</code>来互通数据及命令。</p>
<p>速度模式：</p>
<ul>
<li>标准模式下可达到<code>100Kbps</code></li>
<li>快速模式下可达到<code>400Kbps</code></li>
<li>高速模式下达到<code>4Mbps</code></li>
</ul>
<span id="more"></span>

<h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><h2 id="时序"><a href="#时序" class="headerlink" title="时序"></a>时序</h2><h2 id="设备定义（DTS）"><a href="#设备定义（DTS）" class="headerlink" title="设备定义（DTS）"></a>设备定义（DTS）</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&amp;i2c4 &#123;</span><br><span class="line">	status = &quot;okay&quot;;</span><br><span class="line">	clock-frequency = &lt;100000&gt;;</span><br><span class="line">	timeout = &lt;1000&gt;;</span><br><span class="line">	pinctrl-names = &quot;default&quot;;</span><br><span class="line">	pinctrl-0 = &lt;&amp;i2c4_pd&gt;;</span><br><span class="line"></span><br><span class="line">	ak4458: dac@0x10 &#123;</span><br><span class="line">		compatible = &quot;asahi-kasei,ak4458&quot;;</span><br><span class="line">		status = &quot;okay&quot;;</span><br><span class="line">		reg = &lt;0x10&gt;;</span><br><span class="line">		reset-gpios = &lt;&amp;gpd 7 GPIO_ACTIVE_HIGH INGENIC_GPIO_NOBIAS&gt;;</span><br><span class="line">		xxmute-gpios = &lt;&amp;gpc 4 GPIO_ACTIVE_HIGH INGENIC_GPIO_NOBIAS&gt;;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="acpi"><a href="#acpi" class="headerlink" title="acpi"></a>acpi</h2><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><span class="exturl" data-url="aHR0cDovL3d3dy53b3dvdGVjaC5uZXQvbGludXhfa2VucmVsL2kyY19jb25zdW1lci5odG1s">Linux I2C framework(3)_I2C consumer<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FTS0xXL2FydGljbGUvZGV0YWlscy83NzgzNDA3Nw==">示波器分析I2C时序波形图<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NtYWxsbXVvdS9hcnRpY2xlL2RldGFpbHMvNzE4MzY1Ng==">I2C设备调试及波形分析<i class="fa fa-external-link-alt"></i></span></li>
</ol>
]]></content>
      <categories>
        <category>设备驱动</category>
        <category>driver</category>
      </categories>
      <tags>
        <tag>driver</tag>
        <tag>i2c</tag>
      </tags>
  </entry>
  <entry>
    <title>eMMC中的HPI</title>
    <url>/post/14442.html</url>
    <content><![CDATA[<p>在某些情景下，不同类型的数据对于Host来讲可能会有不同的优先级。比如在写指定的数据的时候，由于写数据会消耗掉很多的时间，当用于想要立即进行另外一个操作的时候，就必须项办法抑制住当前的写操作来实现分页操作的需求。</p>
<blockquote>
<p>HPI(High Priority Interrupt)高优先级中断，该机制可以中断一些还没有完成的优先级比较低的操作，来满足对高优先级操作的需求。</p>
</blockquote>
<span id="more"></span>


<p>HPI命令可以从一下两个命令中的任何一个来发送：</p>
<p>1.CMD12 - 基于STOP_TRANSMISSION命令，当HPI标志位置一的时候生效</p>
<p>2.CMD13 - 基于SEND_STATUS命令，当HPI标志位置一的时候生效</p>
<p>当HPI生效的时候，以上两个命令的参数必须设定为:</p>
<table>
<thead>
<tr>
<th align="center">RCA</th>
<th align="center">填充位</th>
<th align="center">HPI</th>
</tr>
</thead>
<tbody><tr>
<td align="center">[31:16]</td>
<td align="center">[15:1]</td>
<td align="center">[0]</td>
</tr>
</tbody></table>
<blockquote>
<p>填充位不影响参数配置</p>
</blockquote>
<p>当在执行WRITE_MULTIPLE_BLOCK命令时(CMD 25)，设备会更新CORRECTLY_PRG_SECTORS_NUM(EXT_CSD[245:242])，这个值会根据目前成功写入的扇区(512B)数量来更新。当HPI生效之后，Host可以根据这个值来重新继续写入数据而不必从头开始写。</p>
<p>如果HPI中断了在Packed write command中的CMD25，CORRECTLY_PRG_SECTORS_NUM返回的是所有写命令积累起来的当前成功写入扇区的总数量，Host应当通过这个值计算出具体的中断的命令和扇区偏移地址。</p>
<p>在使用HPI功能之前，要先把在EXT_CSD里面[161]字节的HPI_MGMT，把HPI_EN置1</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><span class="exturl" data-url="aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcG9sbGV5ODgvYXJ0aWNsZS9kZXRhaWxzLzUwNDU3OTQ2">eMMC当中HPI的作用以及使用方法<i class="fa fa-external-link-alt"></i></span></li>
</ol>
]]></content>
      <categories>
        <category>设备驱动</category>
        <category>emmc</category>
      </categories>
      <tags>
        <tag>emmc</tag>
      </tags>
  </entry>
  <entry>
    <title>emmc的HS200特性</title>
    <url>/post/34668.html</url>
    <content><![CDATA[<p>emmc设备支持的时钟模式:</p>
<table>
<thead>
<tr>
<th align="center">Speed Mode</th>
<th align="center">clock (MHz)</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Default Speed</td>
<td align="center">26</td>
</tr>
<tr>
<td align="center">Hight Speed SDR</td>
<td align="center">52</td>
</tr>
<tr>
<td align="center">Hight Speed DDR</td>
<td align="center">52</td>
</tr>
<tr>
<td align="center">HS200</td>
<td align="center">200</td>
</tr>
<tr>
<td align="center">HS400</td>
<td align="center">200</td>
</tr>
</tbody></table>
<blockquote>
<p>SDR : 单边沿采样<br>DDR : 双边沿采样</p>
</blockquote>
<span id="more"></span>

<h2 id="Hardware-System"><a href="#Hardware-System" class="headerlink" title="Hardware System"></a>Hardware System</h2><p><img data-src="/images/emmc/emmc_hw.png" alt="emmc hardware"></p>
<blockquote>
<p>DS（Data Strobe）：This signal is generated by the device and used for data output and CRC status<br>response output in <code>HS400</code> mode.</p>
</blockquote>
<p><img data-src="/images/emmc/emmc_gpio.png" alt="emmc gpio"></p>
<p><strong>注:</strong> 在电路的设计中需要将<code>RST_n</code>的pin脚可以控制，否则在第一次写数据是容易出现超时错误，因此可以通过mmc驱动控制软件控制，也可以通过硬件的系统reset时控制</p>
<h3 id="Boot的状态转换"><a href="#Boot的状态转换" class="headerlink" title="Boot的状态转换"></a>Boot的状态转换</h3><p><img data-src="/images/emmc/emmc_boot.png" alt="emmc boot"></p>
<blockquote>
<ol>
<li>GO_PRE_IDLE_STATE command (CMD0 with argument of 0xF0F0F0F0) is the software reset command and puts the device into <code>Pre-idle</code> State.</li>
<li>Hardware reset may be used by host resetting a device , moving the device to <code>Pre-idle</code> state and disabling power-on period write protect on blocks that had been set as power-on write protect before the reset was asserted.</li>
</ol>
</blockquote>
<p><code>BOOT_PARTITION_ENABLE</code>配置：</p>
<p>Extended CSD register进行设置，<code>BOOT_PARTITION_ENABLE</code>默认配置为<code>0</code>，（0x0 : Device not boot enabled (default)）</p>
<h2 id="Bus-Speed-Mode"><a href="#Bus-Speed-Mode" class="headerlink" title="Bus Speed Mode"></a>Bus Speed Mode</h2><p><img data-src="/images/emmc/emmc_bus_speed_mode.png" alt="emmc bus speed"></p>
<h3 id="HS200-Bus-Speed-Mode"><a href="#HS200-Bus-Speed-Mode" class="headerlink" title="HS200 Bus Speed Mode"></a><code>HS200</code> Bus Speed Mode</h3><p>The HS200 mode offers the following features:</p>
<ul>
<li><code>SDR</code> Data sampling method</li>
<li>CLK frequency up to <code>200MHz</code> Data rate – up to 200MB&#x2F;s</li>
<li><code>4 or 8-bits bus</code> width supported</li>
<li>Single ended signaling with <code>4 Drive Strengths</code></li>
<li>Signaling levels of <code>1.8V</code> and <code>1.2V</code></li>
<li><code>Tuning concept</code> for Read Operations</li>
</ul>
<h4 id="HS200-System-Block-Diagram"><a href="#HS200-System-Block-Diagram" class="headerlink" title="HS200 System Block Diagram"></a>HS200 System Block Diagram</h4><p><img data-src="/images/emmc/emmc_hs200_block.png" alt="emmc hs200 block"></p>
<blockquote>
<p>After power-on or software reset(CMD0), the interface timing of the device is set as the default “Backward Compatible Timing “. <code>Device shall select HS200 Timing mode if required and perform the Tuning process if needed</code>.</p>
</blockquote>
<h4 id="HS200-Adjustable-Sampling-Host"><a href="#HS200-Adjustable-Sampling-Host" class="headerlink" title="HS200 Adjustable Sampling Host"></a><strong>HS200 Adjustable Sampling Host</strong></h4><blockquote>
<p>The Host may use <code>adjustable sampling</code> to determine the correct sampling point. A predefined tuning block stored in Device may be used by the Host as an aid for finding the optimal data sampling point. The Host can use <code>CMD21 tuning command</code> to read the tuning block.</p>
</blockquote>
<ol>
<li><p>HS200为什么需要tuning， 其作用，好处？</p>
</li>
<li><p>何时发生tuning，tuning的原理？</p>
</li>
</ol>
<h3 id="HS400-Bus-Speed-Mode"><a href="#HS400-Bus-Speed-Mode" class="headerlink" title="HS400 Bus Speed Mode"></a><code>HS400</code> Bus Speed Mode</h3><p>The HS400 mode has the following features:</p>
<ul>
<li><code>DDR</code> Data sampling method</li>
<li>CLK frequency up to <code>200MHz</code>, Data rate is up to 400MB&#x2F;s</li>
<li><code>Only 8-bit bus</code> width supported</li>
<li>Signaling levels of <code>1.8V</code> and <code>1.2V</code></li>
<li>Support up to <code>5 Drive Strengths</code></li>
<li><code>Data strobe signal</code> is toggled only for Data out and CRC response</li>
</ul>
<blockquote>
<p>e•MMC device in HS400 mode while enabling <code>Enhanced Strobe</code> without the need for tuning procedure.</p>
</blockquote>
<h4 id="HS400-System-Block-Diagram"><a href="#HS400-System-Block-Diagram" class="headerlink" title="HS400 System Block Diagram"></a>HS400 System Block Diagram</h4><p><img data-src="/images/emmc/emmc_hs400_block.png" alt="emmc hs400 block"></p>
<blockquote>
<p>For read operations, Data Strobe is generated by device output circuit. Host receives the data which is <code>aligned to the edge of Data Strobe</code>.</p>
</blockquote>
<ol>
<li><p><code>DS</code>信号初始状态啥样、何时、什么情况下发生跳变?</p>
<ul>
<li>DS的初始信号为<code>O/PP</code>， 上拉高电平</li>
<li></li>
</ul>
</li>
<li><p>HOST端接受数据为啥要与<code>DS</code>的边沿对齐?</p>
</li>
<li><p>为啥只支持<code>8bit</code>？</p>
</li>
<li><p>为啥不需要和HS200 mode一样使用tuning?</p>
</li>
<li><p><code>DS</code>和<code>tuning</code>?</p>
</li>
</ol>
]]></content>
      <categories>
        <category>设备驱动</category>
        <category>emmc</category>
      </categories>
      <tags>
        <tag>emmc</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux内核中驱动注册的先后顺序</title>
    <url>/post/47803.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>设备驱动</category>
        <category>kernel</category>
      </categories>
      <tags>
        <tag>kernel</tag>
        <tag>驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>sd卡测速</title>
    <url>/post/11560.html</url>
    <content><![CDATA[<p>测试sd卡的读写速度</p>
<!--- more --->
<h2 id="mmc驱动测速"><a href="#mmc驱动测速" class="headerlink" title="mmc驱动测速"></a>mmc驱动测速</h2><p>结合mmc子系统提供的测试列表进行速度测试和其他相关测试。</p>
<h3 id="添加配置"><a href="#添加配置" class="headerlink" title="添加配置"></a>添加配置</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-&gt;DeviceDriver</span><br><span class="line">    -&gt; MMC/SD/SDIO card support (MMC [=y])</span><br><span class="line">    [*]MMC host test driver</span><br></pre></td></tr></table></figure>

<h3 id="绑定"><a href="#绑定" class="headerlink" title="绑定"></a>绑定</h3><p>编译并启动新编译的linux内核，进入文件系统。</p>
<ul>
<li>进入mmcblk解除绑定</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd sys/bus/mmc/drivers/mmcblk</span><br><span class="line">echo mmc0:e624 &gt; unbind</span><br></pre></td></tr></table></figure>

<ul>
<li>绑定测试</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd sys/bus/mmc/drivers/mmc_test</span><br><span class="line">echo mmc0:e624 &gt; bind</span><br><span class="line">[  17.243808] mmc_test mmc0:e624: Card claimed for testing.</span><br></pre></td></tr></table></figure>

<h3 id="挂载debugfs"><a href="#挂载debugfs" class="headerlink" title="挂载debugfs"></a>挂载debugfs</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># mount -t debugfs none /mnt</span><br></pre></td></tr></table></figure>

<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><ul>
<li>进入测试目录mmc0:e624</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /mnt/mmc0/mmc0:e624</span><br></pre></td></tr></table></figure>

<ul>
<li>查看测试列表</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#cat testlist</span><br><span class="line">	1:      Basic write (no data verification)</span><br><span class="line">	2:      Basic read (no data verification)</span><br><span class="line">	3:      Basic write (with data verification)</span><br><span class="line">	4:      Basic read (with data verification)</span><br><span class="line">	5:      Multi-block write</span><br><span class="line">	6:      Multi-block read</span><br><span class="line">	7:      Power of two block writes</span><br><span class="line">	8:      Power of two block reads</span><br><span class="line">	9:      Weird sized block writes</span><br><span class="line">	10:     Weird sized block reads</span><br><span class="line">	11:     Badly aligned write</span><br><span class="line">	12:     Badly aligned read</span><br><span class="line">	13:     Badly aligned multi-block write</span><br><span class="line">	14:     Badly aligned multi-block read</span><br><span class="line">	15:     Correct xfer_size at write (start failure)</span><br><span class="line">	16:     Correct xfer_size at read (start failure)</span><br><span class="line">	17:     Correct xfer_size at write (midway failure)</span><br><span class="line">	18:     Correct xfer_size at read (midway failure)</span><br><span class="line">	19:     Highmem write</span><br><span class="line">	20:     Highmem read</span><br><span class="line">	21:     Multi-block highmem write</span><br><span class="line">	22:     Multi-block highmem read</span><br><span class="line">	23:     Best-case read performance</span><br><span class="line">	24:     Best-case write performance</span><br><span class="line">	25:     Best-case read performance into scattered pages</span><br><span class="line">	26:     Best-case write performance from scattered pages</span><br><span class="line">	27:     Single read performance by transfer size</span><br><span class="line">	28:     Single write performance by transfer size</span><br><span class="line">	29:     Single trim performance by transfer size</span><br><span class="line">	30:     Consecutive read performance by transfer size</span><br><span class="line">	31:     Consecutive write performance by transfer size</span><br><span class="line">	32:     Consecutive trim performance by transfer size</span><br><span class="line">	33:     Random read performance by transfer size</span><br><span class="line">	34:     Random write performance by transfer size</span><br><span class="line">	35:     Large sequential read into scattered pages</span><br><span class="line">	36:     Large sequential write from scattered pages</span><br><span class="line">	37:     Write performance with blocking req 4k to 4MB</span><br><span class="line">	38:     Write performance with non-blocking req 4k to 4MB</span><br><span class="line">	39:     Read performance with blocking req 4k to 4MB</span><br><span class="line">	40:     Read performance with non-blocking req 4k to 4MB</span><br><span class="line">	41:     Write performance blocking req 1 to 512 sg elems</span><br><span class="line">	42:     Write performance non-blocking req 1 to 512 sg elems</span><br><span class="line">	43:     Read performance blocking req 1 to 512 sg elems</span><br><span class="line">	44:     Read performance non-blocking req 1 to 512 sg elems</span><br><span class="line">	45:     eMMC hardware reset</span><br></pre></td></tr></table></figure>

<ul>
<li>执行测试</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo 34 &gt; test</span><br></pre></td></tr></table></figure>

<h2 id="测试命令-dd"><a href="#测试命令-dd" class="headerlink" title="测试命令  dd"></a>测试命令  dd</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dd if=/dev/zero of=/dev/null</span><br></pre></td></tr></table></figure>

<ul>
<li>输入或输出</li>
</ul>
<blockquote>
<p>dd if&#x3D;[STDIN] of&#x3D;[STDOUT]</p>
</blockquote>
<ul>
<li>强迫输入或输出的Size为多少Bytes</li>
</ul>
<blockquote>
<p>bs: dd -ibs&#x3D;[BYTE] -obs&#x3D;[SIZE]</p>
</blockquote>
<ul>
<li>强迫一次只做多少个 Bytes</li>
</ul>
<blockquote>
<p>bs&#x3D;BYTES</p>
</blockquote>
<ul>
<li>跳过一段以后才输出</li>
</ul>
<blockquote>
<p>seek&#x3D;BLOCKS</p>
</blockquote>
<ul>
<li>跳过一段以后才输入</li>
</ul>
<blockquote>
<p>skip&#x3D;BLOCKS</p>
</blockquote>
<h3 id="写测试"><a href="#写测试" class="headerlink" title="写测试"></a>写测试</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dd if=/dev/zero of=/mnt/sd/test.txt bs=512 count=100</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>写数据量：512*100 &#x2F; 1024 &#x3D; 50Kb</p>
<h3 id="读测试"><a href="#读测试" class="headerlink" title="读测试"></a>读测试</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dd if=/mnt/sd/test.txt of=/dev/null bs=512 count=100</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>读数据量：512*100 &#x2F; 1024 &#x3D; 50Kb</p>
<h2 id="PC测试"><a href="#PC测试" class="headerlink" title="PC测试"></a>PC测试</h2><p>在pc上使用以上命令，将读写的目标改为（&#x2F;dev&#x2F;sdb）即可得到当前的读写速度</p>
<h2 id="开发板测试"><a href="#开发板测试" class="headerlink" title="开发板测试"></a>开发板测试</h2><p>由于在开发板中的文件系统使用busybox编译生成，其中的dd命令无法直接得到读写速度，因此需要结合time命令</p>
<h3 id="写测试-1"><a href="#写测试-1" class="headerlink" title="写测试"></a>写测试</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">time dd if=/dev/zero of=/mnt/sd/test.txt bs=512 count=100</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>写数据量：512*100 &#x2F; 1024 &#x3D; 50Kb</p>
<h3 id="读测试-1"><a href="#读测试-1" class="headerlink" title="读测试"></a>读测试</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">time dd if=/mnt/sd/test.txt of=/dev/null bs=512 count=100</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>读数据量：512*100 &#x2F; 1024 &#x3D; 50Kb</p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol>
<li>在对sd进行测速时，使用以上命令进行读写操作，文件系统会将该数据块进行一定大小（128个block为一个单元，即一个request请求）的分割，并将其传入sd驱动。在mmc驱动中配置msc控制器的block count大小时，其值为VFS层传入的128blk。</li>
</ol>
<p>也就是说一个大于128个block数据块的读写，在mmc驱动中使用若干个request请求进行读写操作完成。</p>
<ol start="2">
<li>写测试增加conv&#x3D;fsync参数</li>
</ol>
<p>该参数可通过dd -h查看，作用将写的数据完全写入到sd完成返回，但是使用后根据写操作所得到的时间计算的写速度将降低<br>主要原因是，使用fsync后文件系统会将写的数据块根据bs的大小进行分割，也就是将其分割成count个bs。如果bs为512时，一次request请求的block count为512，加大了request请求次数，同时将增加sd驱动中的中断次数和读及等状态的次数，继而增大了写操作的时间，最后计算的写速度将降低。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>读写速率和以下情况有关：</p>
<ol>
<li>外部通信时钟；</li>
<li>DDR时钟，</li>
<li>代码运行速率，和CPU时钟、L2CACHE时钟有关</li>
<li>当前系统负荷</li>
<li>内部的总线时钟，比如MMC控制器所在的APB总线等</li>
<li>MMC控制器的DMA工作时钟</li>
<li>读写代码的流程</li>
<li>MSC的通信数据线的位数</li>
<li>读写的位置是否连续。</li>
</ol>
<p>其中瓶颈是在（1）SD的通信速率（7）代码的流程（8）SD卡通信所占用的数据线（9）读写的位置是否连续</p>
]]></content>
      <categories>
        <category>设备驱动</category>
        <category>mmc</category>
      </categories>
      <tags>
        <tag>mmc</tag>
        <tag>sd</tag>
        <tag>dd</tag>
      </tags>
  </entry>
  <entry>
    <title>SD卡的硬件电路及相关属性</title>
    <url>/post/47964.html</url>
    <content><![CDATA[<h2 id="class"><a href="#class" class="headerlink" title="class"></a>class</h2><h2 id="电路连接"><a href="#电路连接" class="headerlink" title="电路连接"></a>电路连接</h2><h2 id="相关属性"><a href="#相关属性" class="headerlink" title="相关属性"></a>相关属性</h2><h2 id="总线信号的变化"><a href="#总线信号的变化" class="headerlink" title="总线信号的变化"></a>总线信号的变化</h2><h2 id="CMD线的数据传输"><a href="#CMD线的数据传输" class="headerlink" title="CMD线的数据传输"></a>CMD线的数据传输</h2>]]></content>
      <categories>
        <category>设备驱动</category>
        <category>sd</category>
      </categories>
      <tags>
        <tag>电路</tag>
        <tag>sd</tag>
      </tags>
  </entry>
  <entry>
    <title>DDR相关参数</title>
    <url>/post/df3d18b7.html</url>
    <content><![CDATA[<p>记录DDR使用中的相关参数，比如位宽、带宽等</p>
<span id="more"></span>

<h2 id="DDR-x2F-DDR2-x2F-DDR3的区别"><a href="#DDR-x2F-DDR2-x2F-DDR3的区别" class="headerlink" title="DDR&#x2F;DDR2&#x2F;DDR3的区别"></a>DDR&#x2F;DDR2&#x2F;DDR3的区别</h2><ul>
<li><code>DDR</code>采用时钟脉冲上升、下降沿各传一次数据，1个时钟信号可以传输2倍于SDRAM的数据，所以又称为双倍速率SDRAM。它的倍增系数就是2。</li>
<li><code>DDR2</code>仍然采用时钟脉冲上升、下降支各传一次数据的技术（不是传2次），但是一次预读4bit数据，是DDR一次预读2bit的2倍，因此，它的倍增系数是2X2&#x3D;4。</li>
<li><code>DDR3</code>作为DDR2的升级版，最重要的改变是一次预读8bit，是DDR2的2倍，DDR的4倍，所以，它的倍增系数是2X2X2&#x3D;8。</li>
</ul>
<h2 id="内存的频率指标"><a href="#内存的频率指标" class="headerlink" title="内存的频率指标"></a>内存的频率指标</h2><ul>
<li>核心频率：即为内存Cell阵列(Memory Cell Array)的工作频率，它是内存的真实运行频率；</li>
<li>时钟频率：即I&#x2F;O Buffer（输入&#x2F;输出缓存）的传输频率；</li>
<li>有效数据：传输频率则是指数据传送的频率。</li>
</ul>
<h2 id="位宽"><a href="#位宽" class="headerlink" title="位宽"></a>位宽</h2><p>DDR中的位宽分为：<code>DDR的数据位宽</code>和<code>应用端位宽</code></p>
<h3 id="DDR的数据位宽"><a href="#DDR的数据位宽" class="headerlink" title="DDR的数据位宽"></a>DDR的数据位宽</h3><p>数据位宽：指的是内存中以多长为单位进行存储</p>
<p>比如，16bit，即是说内存中是以16bit为单位访问内存的，也就是说，你给内存一个地址，内存会给你一个16bit的数据到数据线。<br>在DDR芯片名称中也包含了位宽信息，比如<code>MT41J256M16RH</code>，这里的<code>16</code>是代表芯片的数据位宽是<code>16位</code>（也就是16根数据线），总容量大小是256×16&#x2F;8&#x3D;<code>512MB</code></p>
<p>用两个16bit的DDR3内存拼成了一个32bit的DDR3</p>
<h3 id="应用端位宽"><a href="#应用端位宽" class="headerlink" title="应用端位宽"></a>应用端位宽</h3><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8xMTMxODc3MDc=">DDR4实战教学（一）：DDR4寻址原理<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>设备驱动</category>
        <category>内存</category>
      </categories>
      <tags>
        <tag>ddr</tag>
      </tags>
  </entry>
  <entry>
    <title>ALSA驱动——DAPM</title>
    <url>/post/1e1fc3f4.html</url>
    <content><![CDATA[<p>DAPM(Dynamic Audio Power Management):动态音频电源管理旨在允许便携式Linux设备始终使用音频子系统内的最低电量。它独立于其他内核PM，因此可以轻松与其他PM系统共存。</p>
<p>DAPM对所有用户空间应用程序也是完全透明的，因为所有电源切换都在ASoC内核内完成。用户空间应用程序不需要更改代码或重新编译。 DAPM根据设备内的任何音频流（录音&#x2F;播放）活动和混音器设置做出电源切换决策。</p>
<p>DAPM跨越整个机器。它涵盖了整个音频子系统内的电源控制，包括内部编解码器电源块和机器级电源系统。</p>
<span id="more"></span>

<p>DAPM中有<code>4</code>个电源域：</p>
<ul>
<li>Codec domain: VREF、VMID（核心编解码器和音频功率）。通常在编解码器探测&#x2F;删除和暂停&#x2F;恢复时进行控制，但如果侧音等不需要电源，则可以在流时间设置。</li>
<li>Platform&#x2F;Machine domain: 物理连接的输入和输出。特定于平台&#x2F;机器和用户操作，由机器驱动程序配置并响应异步事件。例如，当插入 HP 时</li>
<li>Path domain: 音频子系统信号路径。当用户更改混频器和复用器设置时自动设置。例如混合器，混合器</li>
<li>Stream domain: DAC和ADC。分别在开始和停止流播放&#x2F;捕获时启用和禁用。例如aplay，记录。</li>
</ul>
<p>DAPM框架会根据音频路径，完美地对各种部件的电源进行控制，而且精确地按某种顺序进行，防止上下电过程中产生不必要的pop-pop声。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWxzYS1wcm9qZWN0Lm9yZy9tYWluL2luZGV4LnBocC9EQVBN">DAPM<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20veGluZ2h1bzEyMy9wLzEzMTkxNTEwLmh0bWw=">linux-alsa详解14之DAPM详解7上下电过程分析<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>设备驱动</category>
        <category>音频</category>
      </categories>
      <tags>
        <tag>alsa</tag>
        <tag>dapm</tag>
        <tag>音频</tag>
      </tags>
  </entry>
  <entry>
    <title>ASOC之DAPM</title>
    <url>/post/53bf4a8e.html</url>
    <content><![CDATA[<p>动态音频电源管理 (DAPM-Dynamic Audio Power Management) 旨在让便携式Linux设备始终使用音频子系统内的最低电量。 它独立于其他内核PM，因此可以轻松地与其他PM系统共存。</p>
<blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cua2VybmVsLm9yZy9kb2MvaHRtbC9sYXRlc3Qvc291bmQvc29jL2RhcG0uaHRtbA==">Dynamic Audio Power Management for Portable Devices<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<span id="more"></span>

<p>DAPM对所有用户空间应用程序也是完全透明的，因为所有电源切换都在 ASoC 内核内完成。 用户空间应用程序不需要更改代码或重新编译。 DAPM 根据设备内的任何音频流（捕获&#x2F;播放）活动和混音器设置做出电源切换决策。</p>
<p>DAPM横跨整台机器。 它涵盖了整个音频子系统内的电源控制，其中包括内部编解码器电源模块和机器级电源系统。</p>
<p>DAPM中有4个电源域:</p>
<ul>
<li><p>Codec bias domain</p>
<ul>
<li>VREF、VMID（核心编解码器和音频功率）</li>
<li>通常在编解码器探测&#x2F;删除和挂起&#x2F;恢复时控制，但如果侧音不需要电源等，可以在流时设置。</li>
</ul>
</li>
<li><p>Platform&#x2F;Machine domain</p>
<ul>
<li>物理连接的输入和输出</li>
<li>特定于平台&#x2F;机器和用户操作，由机器驱动程序配置并响应异步事件，例如插入 HP 时</li>
</ul>
</li>
<li><p>Path domain</p>
<ul>
<li>音频子系统信号路径</li>
<li>当用户更改混音器和复用器设置时自动设置。例如alsamixer，混合器。</li>
</ul>
</li>
<li><p>Stream domain</p>
<ul>
<li>DAC 和 ADC。</li>
<li>分别在流播放&#x2F;捕获开始和停止时启用和禁用。例如播放，录音。</li>
</ul>
</li>
</ul>
<p>所有DAPM电源切换决策都是通过查阅整台机器的<code>音频路由图</code>自动做出的。此映射特定于每台机器，由每个音频组件（包括内部编解码器组件）之间的互连组成。所有影响电源的音频组件在下文中都称为小部件。</p>
<p>dapm最核心的部分大概就是<code>widgets</code>、<code>paths</code>和<code>routes</code>，其中widgets是DAPM的基本单元，paths是widget之间的连接器，routes表示widget的连接关系，在一个声卡中由三者构成了一个<code>音频路由图</code></p>
<blockquote>
<p>widgets是dapm所控制的最小单元，如果把n个widgets比作是n个村庄，那么在这n个村庄之间修铁路就是route所需要做的工作，相同等级的村庄之间也没必要修铁路，修铁路的目的当然是为了能从起始地(source)到目的地(sink)，而到底走哪条路，也不是随机的，这个可以理解成kcontrol所干的活</p>
</blockquote>
<h2 id="DAPM-Widgets"><a href="#DAPM-Widgets" class="headerlink" title="DAPM Widgets"></a>DAPM Widgets</h2><p>在DAPM框架中，widget用结构体<code>snd_soc_dapm_widget</code>来描述。 头文件<code>include/sound/soc-dapm.h</code></p>
<p>将codec中的各个组件以widget来描述，比如</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* ASRC */</span></span><br><span class="line">SND_SOC_DAPM_SUPPLY_S(<span class="string">&quot;I2S1 ASRC&quot;</span>, <span class="number">1</span>, RT5651_PLL_MODE_2,</span><br><span class="line">              <span class="number">15</span>, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="number">0</span>),</span><br><span class="line">SND_SOC_DAPM_SUPPLY_S(<span class="string">&quot;I2S2 ASRC&quot;</span>, <span class="number">1</span>, RT5651_PLL_MODE_2,</span><br><span class="line">              <span class="number">14</span>, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="number">0</span>),</span><br><span class="line">SND_SOC_DAPM_SUPPLY_S(<span class="string">&quot;STO1 DAC ASRC&quot;</span>, <span class="number">1</span>, RT5651_PLL_MODE_2,</span><br><span class="line">              <span class="number">13</span>, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="number">0</span>),</span><br><span class="line">SND_SOC_DAPM_SUPPLY_S(<span class="string">&quot;STO2 DAC ASRC&quot;</span>, <span class="number">1</span>, RT5651_PLL_MODE_2,</span><br><span class="line">              <span class="number">12</span>, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="number">0</span>),</span><br><span class="line">SND_SOC_DAPM_SUPPLY_S(<span class="string">&quot;ADC ASRC&quot;</span>, <span class="number">1</span>, RT5651_PLL_MODE_2,</span><br><span class="line">              <span class="number">11</span>, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="number">0</span>),</span><br><span class="line"></span><br><span class="line"><span class="comment">/* micbias */</span></span><br><span class="line">SND_SOC_DAPM_SUPPLY(<span class="string">&quot;LDO&quot;</span>, RT5651_PWR_ANLG1,</span><br><span class="line">        RT5651_PWR_LDO_BIT, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="number">0</span>),</span><br><span class="line">SND_SOC_DAPM_SUPPLY(<span class="string">&quot;micbias1&quot;</span>, RT5651_PWR_ANLG2,</span><br><span class="line">        RT5651_PWR_MB1_BIT, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="number">0</span>),</span><br><span class="line"><span class="comment">/* Input Lines */</span></span><br><span class="line">SND_SOC_DAPM_INPUT(<span class="string">&quot;MIC1&quot;</span>),</span><br><span class="line">SND_SOC_DAPM_INPUT(<span class="string">&quot;MIC2&quot;</span>),</span><br><span class="line">SND_SOC_DAPM_INPUT(<span class="string">&quot;MIC3&quot;</span>),</span><br><span class="line"></span><br><span class="line">SND_SOC_DAPM_INPUT(<span class="string">&quot;IN1P&quot;</span>),</span><br><span class="line">SND_SOC_DAPM_INPUT(<span class="string">&quot;IN2P&quot;</span>),</span><br><span class="line">SND_SOC_DAPM_INPUT(<span class="string">&quot;IN2N&quot;</span>),</span><br><span class="line">SND_SOC_DAPM_INPUT(<span class="string">&quot;IN3P&quot;</span>),</span><br><span class="line">SND_SOC_DAPM_INPUT(<span class="string">&quot;DMIC L1&quot;</span>),</span><br><span class="line">SND_SOC_DAPM_INPUT(<span class="string">&quot;DMIC R1&quot;</span>),</span><br><span class="line">SND_SOC_DAPM_SUPPLY(<span class="string">&quot;DMIC CLK&quot;</span>, RT5651_DMIC, RT5651_DMIC_1_EN_SFT,</span><br><span class="line">            <span class="number">0</span>, set_dmic_clk, SND_SOC_DAPM_PRE_PMU),</span><br></pre></td></tr></table></figure>

<h2 id="DAPM-routes"><a href="#DAPM-routes" class="headerlink" title="DAPM routes"></a>DAPM routes</h2><p>在DAPM框架中，route用结构体snd_soc_dapm_route来描述. include&#x2F;sound&#x2F;soc-dapm.h</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">&quot;IN1P&quot;</span>, <span class="literal">NULL</span>, <span class="string">&quot;MIC1&quot;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;IN2P&quot;</span>, <span class="literal">NULL</span>, <span class="string">&quot;MIC2&quot;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;IN2N&quot;</span>, <span class="literal">NULL</span>, <span class="string">&quot;MIC2&quot;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;IN3P&quot;</span>, <span class="literal">NULL</span>, <span class="string">&quot;MIC3&quot;</span>&#125;,</span><br><span class="line"></span><br><span class="line">&#123;<span class="string">&quot;BST1&quot;</span>, <span class="literal">NULL</span>, <span class="string">&quot;IN1P&quot;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;BST2&quot;</span>, <span class="literal">NULL</span>, <span class="string">&quot;IN2P&quot;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;BST2&quot;</span>, <span class="literal">NULL</span>, <span class="string">&quot;IN2N&quot;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;BST3&quot;</span>, <span class="literal">NULL</span>, <span class="string">&quot;IN3P&quot;</span>&#125;,</span><br><span class="line"></span><br><span class="line">&#123;<span class="string">&quot;INL1 VOL&quot;</span>, <span class="literal">NULL</span>, <span class="string">&quot;IN2P&quot;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;INR1 VOL&quot;</span>, <span class="literal">NULL</span>, <span class="string">&quot;IN2N&quot;</span>&#125;,</span><br><span class="line"></span><br><span class="line">&#123;<span class="string">&quot;RECMIXL&quot;</span>, <span class="string">&quot;INL1 Switch&quot;</span>, <span class="string">&quot;INL1 VOL&quot;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;RECMIXL&quot;</span>, <span class="string">&quot;BST3 Switch&quot;</span>, <span class="string">&quot;BST3&quot;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;RECMIXL&quot;</span>, <span class="string">&quot;BST2 Switch&quot;</span>, <span class="string">&quot;BST2&quot;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;RECMIXL&quot;</span>, <span class="string">&quot;BST1 Switch&quot;</span>, <span class="string">&quot;BST1&quot;</span>&#125;,</span><br><span class="line"></span><br><span class="line">&#123;<span class="string">&quot;RECMIXR&quot;</span>, <span class="string">&quot;INR1 Switch&quot;</span>, <span class="string">&quot;INR1 VOL&quot;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;RECMIXR&quot;</span>, <span class="string">&quot;BST3 Switch&quot;</span>, <span class="string">&quot;BST3&quot;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;RECMIXR&quot;</span>, <span class="string">&quot;BST2 Switch&quot;</span>, <span class="string">&quot;BST2&quot;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;RECMIXR&quot;</span>, <span class="string">&quot;BST1 Switch&quot;</span>, <span class="string">&quot;BST1&quot;</span>&#125;,</span><br></pre></td></tr></table></figure>

<p>组成部分：<code>&#123;source name, control name, sink name&#125;</code></p>
<h2 id="DAPM-paths"><a href="#DAPM-paths" class="headerlink" title="DAPM paths"></a>DAPM paths</h2><p>所有定义好的route，最后都要注册到dapm系统中，dapm会根据这些名字找出相应的widget，并动态地生成所需要的snd_soc_dapm_path结构</p>
<h2 id="音频通路设置"><a href="#音频通路设置" class="headerlink" title="音频通路设置"></a>音频通路设置</h2><p>音频通路主要是路由设置的是<code>sink</code>、<code>source</code>和<code>control</code>，三者关系如下：</p>
<p><img data-src="/images/2022/02/asoc_dapm_route.png" alt="asoc_dapm_route"></p>
<blockquote>
<p><code>sink</code>:输出，<code>source</code>:数据源头，<code>control</code>: 输出是打到哪个通路的开关</p>
</blockquote>
<h2 id="Endpoint-Widgets"><a href="#Endpoint-Widgets" class="headerlink" title="Endpoint Widgets"></a>Endpoint Widgets</h2><p><code>Endpoint</code>是机器内的音频信号的起始或终点（窗口小部件），并包括编解码器。例如</p>
<ul>
<li>Headphone Jack</li>
<li>Internal Speaker</li>
<li>Internal Mic</li>
<li>Mic Jack</li>
<li>Codec Pins</li>
</ul>
<p>为设备树<code>simple-audio-card</code>定义的<code>Endpoint</code>名字</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static const struct snd_soc_dapm_widget simple_widgets[] = &#123;</span><br><span class="line">    SND_SOC_DAPM_MIC(&quot;Microphone&quot;, NULL),</span><br><span class="line">    SND_SOC_DAPM_LINE(&quot;Line&quot;, NULL),</span><br><span class="line">    SND_SOC_DAPM_HP(&quot;Headphone&quot;, NULL),</span><br><span class="line">    SND_SOC_DAPM_SPK(&quot;Speaker&quot;, NULL),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>sound&#x2F;soc&#x2F;soc-core.c</p>
</blockquote>
<h2 id="DAPM-Widget-Events"><a href="#DAPM-Widget-Events" class="headerlink" title="DAPM Widget Events"></a>DAPM Widget Events</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">snd_soc_dapm_new_dai</span><br><span class="line">  \-&gt; struct snd_soc_dapm_widget template</span><br><span class="line">  \-&gt; template.event = snd_soc_dai_link_event</span><br></pre></td></tr></table></figure>


<h2 id="Event-types"><a href="#Event-types" class="headerlink" title="Event types"></a>Event types</h2><p>事件widget支持以下事件类型。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* dapm event types */</span><br><span class="line">#define SND_SOC_DAPM_PRE_PMU  0x1     /* before widget power up */</span><br><span class="line">#define SND_SOC_DAPM_POST_PMU 0x2             /* after widget power up */</span><br><span class="line">#define SND_SOC_DAPM_PRE_PMD  0x4     /* before widget power down */</span><br><span class="line">#define SND_SOC_DAPM_POST_PMD 0x8             /* after widget power down */</span><br><span class="line">#define SND_SOC_DAPM_PRE_REG  0x10    /* before audio path setup */</span><br><span class="line">#define SND_SOC_DAPM_POST_REG 0x20    /* after audio path setup */</span><br></pre></td></tr></table></figure>

<h2 id="dapm中的path是否被打开"><a href="#dapm中的path是否被打开" class="headerlink" title="dapm中的path是否被打开"></a>dapm中的path是否被打开</h2><p>在<code>snd_soc_dapm_new_widgets</code>接口中判断是否打开</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">snd_soc_dapm_new_widgets</span><span class="params">(<span class="keyword">struct</span> snd_soc_card *card)</span></span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span> (w-&gt;reg &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    soc_dapm_read(w-&gt;dapm, w-&gt;reg, &amp;val);</span><br><span class="line">    val = val &gt;&gt; w-&gt;shift;</span><br><span class="line">    val &amp;= w-&gt;mask;</span><br><span class="line">    <span class="keyword">if</span> (val == w-&gt;on_val)</span><br><span class="line">        w-&gt;power = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cua2VybmVsLm9yZy9kb2MvaHRtbC9sYXRlc3Qvc291bmQvc29jL2RhcG0uaHRtbA==">Dynamic Audio Power Management for Portable Devices<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vLWdsYi9wLzE0NDExMzAxLmh0bWw=">DAPM_widget_route_path简介<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vUGgtb25lL3AvNjI5NzM4Mi5odG1s">ALSA声卡驱动中的DAPM详解之二：widget-具备路径和电源管理信息的kcontrol<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9jbG91ZC50ZW5jZW50LmNvbS9kZXZlbG9wZXIvYXJ0aWNsZS8xMDc4MDAy">ALSA声卡驱动的DAPM（一）-DPAM详解<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>设备驱动</category>
        <category>音频</category>
      </categories>
      <tags>
        <tag>alsa</tag>
        <tag>dapm</tag>
        <tag>audio</tag>
      </tags>
  </entry>
  <entry>
    <title>回声消除</title>
    <url>/post/5add31c4.html</url>
    <content><![CDATA[<span id="more"></span>


<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><span class="exturl" data-url="aHR0cDovL2Jsb2cuc2luYS5jb20uY24vcy9ibG9nXzZkOGRmN2QwMDEwMTRpczUuaHRtbA==">VoIP声学回声消除算法研究<i class="fa fa-external-link-alt"></i></span></li>
</ol>
]]></content>
      <categories>
        <category>设备驱动</category>
        <category>音频</category>
      </categories>
      <tags>
        <tag>驱动</tag>
        <tag>alsa</tag>
        <tag>audio</tag>
      </tags>
  </entry>
  <entry>
    <title>ALSA-DAPM</title>
    <url>/post/69425dfa.html</url>
    <content><![CDATA[<blockquote>
<p>所谓widget，其实可以理解为是kcontrol的进一步升级和封装，她同样是指音频系统中的某个部件，比如mixer，mux，输入输出引脚，电源供应器等等，甚至，我们可以定义虚拟的widget，例如playback stream widget。widget把kcontrol和动态电源管理进行了有机的结合，同时还具备音频路径的连结功能，一个widget可以与它相邻的widget有某种动态的连结关系。在DAPM框架中，widget用结构体snd_soc_dapm_widget来描述：</p>
</blockquote>
<span id="more"></span>

<h2 id="amixer工作流程"><a href="#amixer工作流程" class="headerlink" title="amixer工作流程"></a>amixer工作流程</h2><blockquote>
<p>参考tinymix的使用流程</p>
</blockquote>
<h2 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define SNDRV_CTL_IOCTL_CARD_INFO _IOR(&#x27;U&#x27;, 0x01, struct snd_ctl_card_info)</span><br><span class="line">#define SNDRV_CTL_IOCTL_ELEM_LIST _IOWR(&#x27;U&#x27;, 0x10, struct snd_ctl_elem_list)</span><br><span class="line">#define SNDRV_CTL_IOCTL_ELEM_INFO _IOWR(&#x27;U&#x27;, 0x11, struct snd_ctl_elem_info)</span><br></pre></td></tr></table></figure>

<h2 id="驱动的注册"><a href="#驱动的注册" class="headerlink" title="驱动的注册"></a>驱动的注册</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">snd_ctl_create  //创建控件管理结构</span><br><span class="line">    |-&gt; snd_device_new [SNDRV_DEV_CONTROL]</span><br><span class="line">        |</span><br><span class="line">        |-&gt; struct file_operations</span><br></pre></td></tr></table></figure>


<h2 id="控件-元素-的添加"><a href="#控件-元素-的添加" class="headerlink" title="控件(元素)的添加"></a>控件(元素)的添加</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">snd_soc_add_codec_controls</span><br><span class="line">    |-&gt; snd_soc_add_controls</span><br><span class="line">        |-&gt; snd_ctl_add   &lt;---- snd_soc_cnew</span><br><span class="line">            |-&gt; list_add_tail</span><br></pre></td></tr></table></figure>

<h2 id="kcontrol"><a href="#kcontrol" class="headerlink" title="kcontrol"></a>kcontrol</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">snd_kcontrol_new</span> &#123;</span></span><br><span class="line">    <span class="type">snd_ctl_elem_iface_t</span> iface; <span class="comment">/* interface identifier */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> device;        <span class="comment">/* device/client number */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> subdevice;     <span class="comment">/* subdevice (substream) number */</span></span><br><span class="line">    <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *name;  <span class="comment">/* ASCII name of item */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> index;     <span class="comment">/* index of item */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> access;        <span class="comment">/* access rights */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> count;     <span class="comment">/* count of same elements */</span></span><br><span class="line">    <span class="type">snd_kcontrol_info_t</span> *info;</span><br><span class="line">    <span class="type">snd_kcontrol_get_t</span> *get;</span><br><span class="line">    <span class="type">snd_kcontrol_put_t</span> *put;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="type">snd_kcontrol_tlv_rw_t</span> *c;</span><br><span class="line">        <span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> *p;</span><br><span class="line">    &#125; tlv;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> private_value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="kcontrol的命名"><a href="#kcontrol的命名" class="headerlink" title="kcontrol的命名"></a>kcontrol的命名</h3><blockquote>
<p>kcontrol的作用由名称来区分，对于名称相同的kcontrol，则使用index区分。name定义的标准是“SOURCE DIRECTION FUNCTION”即“源 方向 功能”，SOURCE定义了kcontrol的源，如“Master”、“PCM”等；DIRECTION 则为“Playback”、“Capture”等，如果DIRECTION忽略，意味着Playback和capture双向；FUNCTION则可以是“Switch”、“Volume”和“Route”等。</p>
</blockquote>
<p>内核说明文档:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">This document describes standard names of mixer controls.</span><br><span class="line"></span><br><span class="line">Syntax: SOURCE [DIRECTION] FUNCTION</span><br><span class="line"></span><br><span class="line">DIRECTION:</span><br><span class="line">  &lt;nothing&gt;	(both directions)</span><br><span class="line">  Playback</span><br><span class="line">  Capture</span><br><span class="line">  Bypass Playback</span><br><span class="line">  Bypass Capture</span><br><span class="line"></span><br><span class="line">FUNCTION:</span><br><span class="line">  Switch	(on/off switch)</span><br><span class="line">  Volume</span><br><span class="line">  Route		(route control, hardware specific)</span><br><span class="line"></span><br><span class="line">SOURCE:</span><br><span class="line">  Master</span><br><span class="line">  Master Mono</span><br><span class="line">  Hardware Master</span><br><span class="line">  Speaker	(internal speaker)</span><br><span class="line">  Headphone</span><br><span class="line">  Beep		(beep generator)</span><br><span class="line">  Phone</span><br><span class="line">  Phone Input</span><br><span class="line">  Phone Output</span><br><span class="line">  Synth</span><br><span class="line">  FM</span><br><span class="line">  Mic</span><br><span class="line">  Line</span><br><span class="line">  CD</span><br><span class="line">  Video</span><br><span class="line">  Zoom Video</span><br><span class="line">  Aux</span><br><span class="line">  PCM</span><br><span class="line">  PCM Front</span><br><span class="line">  PCM Rear</span><br><span class="line">  PCM Pan</span><br><span class="line">  Loopback</span><br><span class="line">  Analog Loopback	(D/A -&gt; A/D loopback)</span><br><span class="line">  Digital Loopback	(playback -&gt; capture loopback - without analog path)</span><br><span class="line">  Mono</span><br><span class="line">  Mono Output</span><br><span class="line">  Multi</span><br><span class="line">  ADC</span><br><span class="line">  Wave</span><br><span class="line">  Music</span><br><span class="line">  I2S</span><br><span class="line">  IEC958</span><br><span class="line"></span><br><span class="line">Exceptions:</span><br><span class="line">  [Digital] Capture Source</span><br><span class="line">  [Digital] Capture Switch	(aka input gain switch)</span><br><span class="line">  [Digital] Capture Volume	(aka input gain volume)</span><br><span class="line">  [Digital] Playback Switch	(aka output gain switch)</span><br><span class="line">  [Digital] Playback Volume	(aka output gain volume)</span><br><span class="line">  Tone Control - Switch</span><br><span class="line">  Tone Control - Bass</span><br><span class="line">  Tone Control - Treble</span><br><span class="line">  3D Control - Switch</span><br><span class="line">  3D Control - Center</span><br><span class="line">  3D Control - Depth</span><br><span class="line">  3D Control - Wide</span><br><span class="line">  3D Control - Space</span><br><span class="line">  3D Control - Level</span><br><span class="line">  Mic Boost [(?dB)]</span><br><span class="line"></span><br><span class="line">PCM interface:</span><br><span class="line"></span><br><span class="line">  Sample Clock Source	&#123; &quot;Word&quot;, &quot;Internal&quot;, &quot;AutoSync&quot; &#125;</span><br><span class="line">  Clock Sync Status	&#123; &quot;Lock&quot;, &quot;Sync&quot;, &quot;No Lock&quot; &#125;</span><br><span class="line">  External Rate		/* external capture rate */</span><br><span class="line">  Capture Rate		/* capture rate taken from external source */</span><br><span class="line"></span><br><span class="line">IEC958 (S/PDIF) interface:</span><br><span class="line"></span><br><span class="line">  IEC958 [...] [Playback|Capture] Switch	/* turn on/off the IEC958 interface */</span><br><span class="line">  IEC958 [...] [Playback|Capture] Volume	/* digital volume control */</span><br><span class="line">  IEC958 [...] [Playback|Capture] Default	/* default or global value - read/write */</span><br><span class="line">  IEC958 [...] [Playback|Capture] Mask		/* consumer and professional mask */</span><br><span class="line">  IEC958 [...] [Playback|Capture] Con Mask	/* consumer mask */</span><br><span class="line">  IEC958 [...] [Playback|Capture] Pro Mask	/* professional mask */</span><br><span class="line">  IEC958 [...] [Playback|Capture] PCM Stream	/* the settings assigned to a PCM stream */</span><br><span class="line">  IEC958 Q-subcode [Playback|Capture] Default	/* Q-subcode bits */</span><br><span class="line">  IEC958 Preamble [Playback|Capture] Default	/* burst preamble words (4*16bits) */</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Documentation&#x2F;sound&#x2F;alsa&#x2F;ControlNames.txt</p>
</blockquote>
<h2 id="widget"><a href="#widget" class="headerlink" title="widget"></a>widget</h2><ol>
<li>codec域</li>
</ol>
<p>比如VREF和VMID等提供参考电压的widget，这些widget通常在codec的probe&#x2F;remove回调中进行控制，当然，在工作中如果没有音频流时，也可以适当地进行控制它们的开启与关闭。</p>
<ol start="2">
<li>platform域</li>
</ol>
<p>位于该域上的widget通常是针对平台或板子的一些需要物理连接的输入&#x2F;输出接口，例如耳机、扬声器、麦克风，因为这些接口在每块板子上都可能不一样，所以通常它们是在machine驱动中进行定义和控制，并且也可以由用户空间的应用程序通过某种方式来控制它们的打开和关闭。</p>
<ol start="3">
<li>音频路径域</li>
</ol>
<p>一般是指codec内部的mixer、mux等控制音频路径的widget，这些widget可以根据用户空间的设定连接关系，自动设定他们的电源状态。</p>
<ol start="4">
<li>音频数据流域</li>
</ol>
<p>是指那些需要处理音频数据流的widget，例如ADC、DAC等等。</p>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="snd-soc-dapm-type"><a href="#snd-soc-dapm-type" class="headerlink" title="snd_soc_dapm_type"></a>snd_soc_dapm_type</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* dapm widget types */</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">snd_soc_dapm_type</span> &#123;</span></span><br><span class="line">    snd_soc_dapm_input = <span class="number">0</span>,     <span class="comment">/* input pin */</span></span><br><span class="line">    snd_soc_dapm_output,        <span class="comment">/* output pin */</span></span><br><span class="line">    snd_soc_dapm_mux,           <span class="comment">/* selects 1 analog signal from many inputs */</span></span><br><span class="line">    snd_soc_dapm_virt_mux,          <span class="comment">/* virtual version of snd_soc_dapm_mux */</span></span><br><span class="line">    snd_soc_dapm_value_mux,         <span class="comment">/* selects 1 analog signal from many inputs */</span></span><br><span class="line">    snd_soc_dapm_mixer,         <span class="comment">/* mixes several analog signals together */</span></span><br><span class="line">    snd_soc_dapm_mixer_named_ctl,       <span class="comment">/* mixer with named controls */</span></span><br><span class="line">    snd_soc_dapm_pga,           <span class="comment">/* programmable gain/attenuation (volume) */</span></span><br><span class="line">    snd_soc_dapm_out_drv,           <span class="comment">/* output driver */</span></span><br><span class="line">    snd_soc_dapm_adc,           <span class="comment">/* analog to digital converter */</span></span><br><span class="line">    snd_soc_dapm_dac,           <span class="comment">/* digital to analog converter */</span></span><br><span class="line">    snd_soc_dapm_micbias,       <span class="comment">/* microphone bias (power) */</span></span><br><span class="line">    snd_soc_dapm_mic,           <span class="comment">/* microphone */</span></span><br><span class="line">    snd_soc_dapm_hp,            <span class="comment">/* headphones */</span></span><br><span class="line">    snd_soc_dapm_spk,           <span class="comment">/* speaker */</span></span><br><span class="line">    snd_soc_dapm_line,          <span class="comment">/* line input/output */</span></span><br><span class="line">    snd_soc_dapm_switch,        <span class="comment">/* analog switch */</span></span><br><span class="line">    snd_soc_dapm_vmid,          <span class="comment">/* codec bias/vmid - to minimise pops */</span></span><br><span class="line">    snd_soc_dapm_pre,           <span class="comment">/* machine specific pre widget - exec first */</span></span><br><span class="line">    snd_soc_dapm_post,          <span class="comment">/* machine specific post widget - exec last */</span></span><br><span class="line">    snd_soc_dapm_supply,        <span class="comment">/* power/clock supply */</span></span><br><span class="line">    snd_soc_dapm_regulator_supply,  <span class="comment">/* external regulator */</span></span><br><span class="line">    snd_soc_dapm_clock_supply,  <span class="comment">/* external clock */</span></span><br><span class="line">    snd_soc_dapm_aif_in,        <span class="comment">/* audio interface input */</span></span><br><span class="line">    snd_soc_dapm_aif_out,       <span class="comment">/* audio interface output */</span></span><br><span class="line">    snd_soc_dapm_siggen,        <span class="comment">/* signal generator */</span></span><br><span class="line">    snd_soc_dapm_dai_in,        <span class="comment">/* link to DAI structure */</span></span><br><span class="line">    snd_soc_dapm_dai_out,</span><br><span class="line">    snd_soc_dapm_dai_link,      <span class="comment">/* link between two DAI structures */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="snd-soc-dapm-widget"><a href="#snd-soc-dapm-widget" class="headerlink" title="snd_soc_dapm_widget"></a>snd_soc_dapm_widget</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* dapm widget */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dapm_widget</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">snd_soc_dapm_type</span> <span class="title">id</span>;</span>   <span class="comment">//该widget的类型值，比如snd_soc_dapm_output，snd_soc_dapm_mixer等等。</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *name;       <span class="comment">/* widget name */</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *sname;  <span class="comment">/* stream name */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_codec</span> *<span class="title">codec</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_platform</span> *<span class="title">platform</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span>		<span class="comment">//所有注册到系统中的widget都会通过该list，链接到代表声卡的snd_soc_card结构的widgets链表头字段中</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dapm_context</span> *<span class="title">dapm</span>;</span>	<span class="comment">//snd_soc_dapm_context结构指针，ASoc把系统划分为多个dapm域，每个widget属于某个dapm域，同一个域代表着同样的偏置电压供电策略，</span></span><br><span class="line">										<span class="comment">//比如，同一个codec中的widget通常位于同一个dapm域，而平台上的widget可能又会位于另外一个platform域中。</span></span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> *priv;             <span class="comment">/* widget specific data */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">regulator</span> *<span class="title">regulator</span>;</span>        <span class="comment">/* attached regulator */</span>	<span class="comment">// 对于snd_soc_dapm_regulator_supply类型的widget，该字段指向与之相关的regulator结构指针。</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_pcm_stream</span> *<span class="title">params</span>;</span> <span class="comment">/* params for dai links */</span> <span class="comment">//目前对于snd_soc_dapm_dai_link类型的widget，指向该dai的配置信息的snd_soc_pcm_stream结构</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* dapm control */</span></span><br><span class="line">    <span class="type">int</span> reg;                <span class="comment">/* negative reg = no direct dapm */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> shift;            <span class="comment">/* bits to shift */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> value;             <span class="comment">/* widget current value */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> mask;          <span class="comment">/* non-shifted mask */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> on_val;            <span class="comment">/* on state value */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> off_val;           <span class="comment">/* off state value */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> power:<span class="number">1</span>;          <span class="comment">/* block power status */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> invert:<span class="number">1</span>;         <span class="comment">/* invert the power bit */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> active:<span class="number">1</span>;         <span class="comment">/* active stream on DAC, ADC&#x27;s */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> connected:<span class="number">1</span>;      <span class="comment">/* connected codec pin */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> new:<span class="number">1</span>;            <span class="comment">/* cnew complete */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> ext:<span class="number">1</span>;            <span class="comment">/* has external widgets */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> force:<span class="number">1</span>;          <span class="comment">/* force state */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> ignore_suspend:<span class="number">1</span>;         <span class="comment">/* kept enabled over suspend */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> new_power:<span class="number">1</span>;      <span class="comment">/* power from this run */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> power_checked:<span class="number">1</span>;      <span class="comment">/* power checked this run */</span></span><br><span class="line">    <span class="type">int</span> subseq;             <span class="comment">/* sort within widget type */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> (*power_check)(<span class="keyword">struct</span> snd_soc_dapm_widget *w);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* external events */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> event_flags;     <span class="comment">/* flags to specify event types */</span></span><br><span class="line">    <span class="type">int</span> (*event)(<span class="keyword">struct</span> snd_soc_dapm_widget*, <span class="keyword">struct</span> snd_kcontrol *, <span class="type">int</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* kcontrols that relate to this widget */</span></span><br><span class="line">    <span class="type">int</span> num_kcontrols;</span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">snd_kcontrol_new</span> *<span class="title">kcontrol_news</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">snd_kcontrol</span> **<span class="title">kcontrols</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* widget input and outputs */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">sources</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">sinks</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* used during DAPM updates */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">power_list</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">dirty</span>;</span></span><br><span class="line">    <span class="type">int</span> inputs;			<span class="comment">//该widget的所有有效路径中，连接到输入端的路径数量。</span></span><br><span class="line">    <span class="type">int</span> outputs;		<span class="comment">//该widget的所有有效路径中，连接到输出端的路径数量。</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">clk</span> *<span class="title">clk</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="dapm"><a href="#dapm" class="headerlink" title="dapm"></a>dapm</h2><p>先注册widget,而后逐一进行初始化处理</p>
<h3 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int snd_soc_register_component(struct device *dev,</span><br><span class="line">                   const struct snd_soc_component_driver *cmpnt_drv,</span><br><span class="line">                   struct snd_soc_dai_driver *dai_drv,</span><br><span class="line">                   int num_dai)</span><br></pre></td></tr></table></figure>

<p>数据结构:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct snd_soc_component_driver &#123;</span><br><span class="line">    const char *name;</span><br><span class="line"></span><br><span class="line">    /* Default control and setup, added after probe() is run */</span><br><span class="line">    const struct snd_kcontrol_new *controls;</span><br><span class="line">    unsigned int num_controls;</span><br><span class="line">    const struct snd_soc_dapm_widget *dapm_widgets;</span><br><span class="line">    unsigned int num_dapm_widgets;</span><br><span class="line">    const struct snd_soc_dapm_route *dapm_routes;</span><br><span class="line">    unsigned int num_dapm_routes;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注册流程:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">snd_soc_register_component</span><br><span class="line">    |-&gt; snd_soc_component_initialize</span><br><span class="line">        |-&gt;</span><br><span class="line">            &#123;   component-&gt;controls = driver-&gt;controls;</span><br><span class="line">                component-&gt;num_controls = driver-&gt;num_controls;</span><br><span class="line">                component-&gt;dapm_widgets = driver-&gt;dapm_widgets;</span><br><span class="line">                component-&gt;num_dapm_widgets = driver-&gt;num_dapm_widgets;</span><br><span class="line">                component-&gt;dapm_routes = driver-&gt;dapm_routes;</span><br><span class="line">                component-&gt;num_dapm_routes = driver-&gt;num_dapm_routes;</span><br><span class="line"></span><br><span class="line">                INIT_LIST_HEAD(&amp;component-&gt;dai_list);</span><br><span class="line">            &#125;</span><br><span class="line">   |-&gt; snd_soc_register_dais</span><br><span class="line">        |-&gt; list_add(&amp;dai-&gt;list, &amp;component-&gt;dai_list);</span><br><span class="line">   |-&gt; snd_soc_component_add</span><br><span class="line">        |-&gt; snd_soc_component_add_unlocked</span><br><span class="line">            |-&gt; list_add(&amp;component-&gt;list, &amp;component_list);</span><br></pre></td></tr></table></figure>

<p>初始化流程:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">snd_soc_register_card</span><br><span class="line">    |-&gt; snd_soc_instantiate_card</span><br><span class="line">        |-&gt; soc_probe_link_components</span><br><span class="line">            |-&gt; soc_probe_component</span><br><span class="line">                |-&gt; snd_soc_dapm_new_dai_widgets</span><br><span class="line">                    |-&gt; snd_soc_dapm_new_control_unlocked</span><br><span class="line">                        |-&gt; dapm_cnew_widget</span><br></pre></td></tr></table></figure>


<p>连接:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">snd_soc_register_card</span><br><span class="line">    |-&gt; snd_soc_instantiate_card</span><br><span class="line">        |-&gt; soc_probe_link_dais</span><br><span class="line">            |-&gt; soc_link_dai_widgets</span><br><span class="line">                |-&gt; snd_soc_dapm_new_pcm</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>更新寄存器:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dapm_power_widgets</span><br><span class="line">    |-&gt; dapm_widget_update</span><br><span class="line">        |-&gt; soc_dapm_update_bits(struct snd_soc_dapm_context *dapm,int reg,</span><br><span class="line">                                unsigned int mask, unsigned int value)</span><br></pre></td></tr></table></figure>


<h3 id="Add-Controls"><a href="#Add-Controls" class="headerlink" title="Add Controls"></a>Add Controls</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">snd_soc_add_codec_controls</span><br><span class="line">    |-&gt; snd_soc_add_controls</span><br><span class="line">        |</span><br><span class="line">        |-&gt; for &#123; snd_ctl_add(card, snd_soc_cnew(control, data,control-&gt;name, prefix)); &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>sound&#x2F;soc&#x2F;soc-core.c</p>
</blockquote>
<p>作用:</p>
<h3 id="Add-Widgets"><a href="#Add-Widgets" class="headerlink" title="Add Widgets"></a>Add Widgets</h3><h3 id="Add-Route"><a href="#Add-Route" class="headerlink" title="Add Route"></a>Add Route</h3><h2 id="相关术语"><a href="#相关术语" class="headerlink" title="相关术语"></a>相关术语</h2><h3 id="MIXER"><a href="#MIXER" class="headerlink" title="MIXER"></a>MIXER</h3><blockquote>
<p>Mixer      - Mixes several analog signals into a single analog signal.</p>
</blockquote>
<blockquote>
<p>Mixer可以混合多个输入到输出</p>
</blockquote>
<h3 id="MUX"><a href="#MUX" class="headerlink" title="MUX"></a>MUX</h3><blockquote>
<p>Mux        - An analog switch that outputs only one of many inputs.</p>
</blockquote>
<blockquote>
<p>Mux只能从多个输入里选择一个作为输出</p>
</blockquote>
<h2 id="dapm-widget链表更新"><a href="#dapm-widget链表更新" class="headerlink" title="dapm widget链表更新"></a>dapm widget链表更新</h2><ol>
<li>初始化的时候，snd_soc_instantiate_card里调用snd_soc_dapm_new_widgets，最终会调用dapm_power_widgets</li>
<li>在用户空间通过tinymix设置路径，在SOC_DAPM_ENUM中的put或者get函数最终会调用dapm_power_widgets</li>
<li>在用户空间通过tinyplay播放或者录音是的soc_pcm_prepare和soc_pcm_close，最终会调用dapm_power_widgets</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><span class="exturl" data-url="aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZHJvaWRwaG9uZS9hcnRpY2xlL2RldGFpbHMvMTI5MDYxMzk=">ALSA声卡驱动中的DAPM详解之二：widget-具备路径和电源管理信息的kcontrol<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGlhb2pzajExMS9hcnRpY2xlL2RldGFpbHMvMjU2MDE3Nzc="> linux alsa 音频路径切换<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRHJvaWRQaG9uZS9hcnRpY2xlL2RldGFpbHMvMTI5NzgyODc=">ALSA声卡驱动中的DAPM详解之三：如何定义各种widget<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL3d3dy5zdW5ueXFpLmNvbS91cExvYWQvcHJvZHVjdC9tb250aF8xMzA2L1dNODk2MC5wZGY=">codec–wm8960<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYXpsb29uZy9hcnRpY2xlL2RldGFpbHMvNjMyNDkwMQ==">snd_kcontrol_new名称中的SOURCE字段<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbHVja3l3YW5nMTEwMy9hcnRpY2xlL2RldGFpbHMvNTAxNTE2NDk=">Asoc dapm(三) - dapm widgets &amp; dapm kcontrol &amp; dapm route<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZHJvaWRwaG9uZS9hcnRpY2xlL2RldGFpbHMvMTQxNDYzMTk=">ALSA声卡驱动中的DAPM详解之六：精髓所在，牵一发而动全身<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWxzYS1wcm9qZWN0Lm9yZy9tYWluL2luZGV4LnBocC9EQVBN">DAPM<i class="fa fa-external-link-alt"></i></span></li>
</ol>
]]></content>
      <categories>
        <category>设备驱动</category>
        <category>音频</category>
      </categories>
      <tags>
        <tag>驱动</tag>
        <tag>alsa</tag>
        <tag>audio</tag>
      </tags>
  </entry>
  <entry>
    <title>ALSA-DMA</title>
    <url>/post/8df01b06.html</url>
    <content><![CDATA[<blockquote>
<p>dma数据传输块的组织和应用</p>
</blockquote>
<!-- more --->

<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * info for buffer allocation</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">snd_dma_buffer</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">snd_dma_device</span> <span class="title">dev</span>;</span>  <span class="comment">/* device type */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *area;    <span class="comment">/* virtual pointer */</span></span><br><span class="line">    <span class="type">dma_addr_t</span> addr;    <span class="comment">/* physical address */</span></span><br><span class="line">    <span class="type">size_t</span> bytes;       <span class="comment">/* buffer size in bytes */</span></span><br><span class="line">    <span class="type">void</span> *private_data; <span class="comment">/* private for allocator; don&#x27;t touch */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="申请"><a href="#申请" class="headerlink" title="申请"></a>申请</h2><p>在通过machine将每一条声卡链路建立完成后.将通过<code>pcm_new</code>申请dma_buffer</p>
<h3 id="申请当前的stream支持的最大的DMA-buffer内存空间"><a href="#申请当前的stream支持的最大的DMA-buffer内存空间" class="headerlink" title="申请当前的stream支持的最大的DMA buffer内存空间."></a>申请当前的stream支持的最大的DMA buffer内存空间.</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">snd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV,</span><br><span class="line">    card-&gt;dev, buffer_size, buffer_bytes_max);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>dma buffer获得后，即是获得了dma操作的源地址，那么目的地址在哪里？</p>
</blockquote>
<h3 id="实际使用的DMA-buffer空间大小-跟实际的采样率-位宽-通道有关"><a href="#实际使用的DMA-buffer空间大小-跟实际的采样率-位宽-通道有关" class="headerlink" title="实际使用的DMA buffer空间大小,跟实际的采样率,位宽,通道有关."></a>实际使用的DMA buffer空间大小,跟实际的采样率,位宽,通道有关.</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">snd_pcm_lib_malloc_pages(substream, params_buffer_bytes(params));</span><br></pre></td></tr></table></figure>

<h2 id="DMA-buffer的管理"><a href="#DMA-buffer的管理" class="headerlink" title="DMA buffer的管理"></a>DMA buffer的管理</h2><p>环形缓冲区正好适合用于这种情景的buffer管理，理想情况下，大小为Count的缓冲区具备一个读指针和写指针，我们期望他们都可以闭合地做环形移动，但是实际的情况确实：缓冲区通常都是一段连续的地址，他是有开始和结束两个边界，每次移动之前都必须进行一次判断，当指针移动到末尾时就必须人为地让他回到起始位置。在实际应用中，我们通常都会把这个大小为Count的缓冲区虚拟成一个大小为n*Count的逻辑缓冲区，相当于理想状态下的圆形绕了n圈之后，然后把这段总的距离拉平为一段直线，每一圈对应直线中的一段，因为n比较大，所以大多数情况下不会出现读写指针的换位的情况（如果不对buffer进行扩展，指针到达末端后，回到起始端时，两个指针的前后相对位置会发生互换）。扩展后的逻辑缓冲区在计算剩余空间可条件判断是相对方便。alsa driver也使用了该方法对dma buffer进行管理：</p>
<p><img data-src="/" alt="rang buffer"></p>
<ol>
<li><p>Period size：周期，每次硬件中断处理音频数据的帧数，对于音频设备的数据读写，以此为单位。</p>
</li>
<li><p>Buffer size：数据缓冲区大小，这里特指runtime的buffer size，而不是snd_pcm_hardware定义的buffer_bytes_max。<br>一般来说Buffer size &#x3D; period_size * period_count(periods)，<strong>period_count相当于处理完一个buffer数据所需的硬件中断次数(在DMA传输中,相当于DMA描述符的个数)。</strong></p>
</li>
</ol>
<p>大小:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">runtime-&gt;period_size = params_period_size(params);</span><br><span class="line">runtime-&gt;periods = params_periods(params);</span><br><span class="line">runtime-&gt;buffer_size = params_buffer_size(params);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>period_size的大小确认为,sample_rate &#x2F; channel &#x2F; frame Byte<br>frame &#x3D; channel*bit&#x2F;8 Byte</p>
</blockquote>
<p><code>snd_pcm_runtime</code>结构中，使用了四个相关的字段来完成这个逻辑缓冲区的管理：</p>
<ul>
<li><code>snd_pcm_runtime.hw_ptr_base</code>  环形缓冲区每一圈的基地址，当读写指针越过一圈后，它按buffer size进行移动；</li>
<li><code>snd_pcm_runtime.status-&gt;hw_ptr</code>  硬件逻辑位置，播放时相当于读指针，录音时相当于写指针；</li>
<li><code>snd_pcm_runtime.control-&gt;appl_ptr</code>  应用逻辑位置，播放时相当于写指针，录音时相当于读指针；</li>
<li><code>snd_pcm_runtime.boundary</code>  扩展后的逻辑缓冲区大小，通常是(2^n)*size；</li>
</ul>
<h3 id="播放"><a href="#播放" class="headerlink" title="播放"></a>播放</h3><p>以播放(playback)为例，至少有3个途径可以完成对dma buffer的写入：</p>
<ol>
<li>应用程序调用alsa-lib的snd_pcm_writei、snd_pcm_writen函数；</li>
<li>应用程序使用ioctl：SNDRV_PCM_IOCTL_WRITEI_FRAMES或SNDRV_PCM_IOCTL_WRITEN_FRAMES；</li>
<li>应用程序使用alsa-lib的snd_pcm_mmap_begin&#x2F;snd_pcm_mmap_commit;</li>
</ol>
<p>以上几种方式最终把数据写入dma buffer中，然后修改runtime-&gt;control-&gt;appl_ptr的值。</p>
<p>播放过程中，通常会配置成每一个period size生成一个dma中断，中断处理函数最重要的任务就是：更新dma的硬件的当前位置，该数值通常保存在runtime-&gt;private_data中；<br>调用<code>snd_pcm_period_elapsed</code>函数，该函数会进一步调用<code>snd_pcm_update_hw_ptr0</code>函数更新上述所说的4个缓冲区管理字段，然后<strong>唤醒相应的等待进程</strong>；</p>
<p>三个指针</p>
<h2 id="snd-psnd-pcm-period-elapsed"><a href="#snd-psnd-pcm-period-elapsed" class="headerlink" title="snd_psnd_pcm_period_elapsed"></a>snd_psnd_pcm_period_elapsed</h2><h2 id="驱动控制器层的数据关系"><a href="#驱动控制器层的数据关系" class="headerlink" title="驱动控制器层的数据关系"></a>驱动控制器层的数据关系</h2><ul>
<li>buffer大小: snd_pcm_lib_buffer_bytes(substream) &#x3D; 32768 &#x3D; 32KB</li>
<li>period : snd_pcm_lib_period_bytes(substream) &#x3D; 8192 &#x3D; 8KB</li>
<li>DMA描述符的个数: snd_pcm_lib_buffer_bytes(substream) &#x2F; snd_pcm_lib_period_bytes(substream) &#x3D; 4</li>
</ul>
<h2 id="设置运行时的硬件参数"><a href="#设置运行时的硬件参数" class="headerlink" title="设置运行时的硬件参数"></a>设置运行时的硬件参数</h2><blockquote>
<p>snd_soc_set_runtime_hwparams</p>
</blockquote>
<h2 id="DMA-buffer-大小"><a href="#DMA-buffer-大小" class="headerlink" title="DMA buffer 大小"></a>DMA buffer 大小</h2><p><strong>DMA buffer的大小必须时frame和dma burst的倍数,也就是二者大最小公倍数的倍数</strong></p>
<p>限制buffer的大小关系,当然最特定的播放条件可以通过手动设置buffer最大值和周期的大小进行设置.</p>
<p>根本性的解决</p>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct snd_interval &#123;</span><br><span class="line">    unsigned int min, max;  //最小,最大值</span><br><span class="line">    unsigned int openmin:1, //最小值的开区间,使能,默认闭区间</span><br><span class="line">             openmax:1,</span><br><span class="line">             integer:1,     //使能后取范围内的整数</span><br><span class="line">             empty:1;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int xxx_open()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"> ret = snd_pcm_hw_constraint_integer(runtime, SNDRV_PCM_HW_PARAM_PERIOD_BYTES);</span><br><span class="line"> if (ret &lt; 0)</span><br><span class="line">     return ret;</span><br><span class="line"></span><br><span class="line"> if (as_dma-&gt;dma_fth_quirk) &#123;</span><br><span class="line">     snd_pcm_hw_rule_add(substream-&gt;runtime, 0,</span><br><span class="line">             SNDRV_PCM_HW_PARAM_PERIOD_BYTES,</span><br><span class="line">             ingenic_as_dma_period_bytes_quirk,</span><br><span class="line">             NULL,</span><br><span class="line">             SNDRV_PCM_HW_PARAM_FRAME_BITS,</span><br><span class="line">             SNDRV_PCM_HW_PARAM_PERIOD_BYTES,</span><br><span class="line">             -1);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static int ingenic_as_dma_period_bytes_quirk(struct snd_pcm_hw_params *params,</span><br><span class="line">        struct snd_pcm_hw_rule *rule)</span><br><span class="line">&#123;</span><br><span class="line">    struct snd_interval *iperiod_bytes = hw_param_interval(params,</span><br><span class="line">            SNDRV_PCM_HW_PARAM_PERIOD_BYTES);</span><br><span class="line">    struct snd_interval *iframe_bits = hw_param_interval(params,</span><br><span class="line">            SNDRV_PCM_HW_PARAM_FRAME_BITS);</span><br><span class="line">    int align_bytes = DCM_TSZ_MAX_WORD &lt;&lt; 2; //32 world</span><br><span class="line">    int min_frame_bytes = iframe_bits-&gt;min &gt;&gt; 3;</span><br><span class="line">    int max_frame_bytes = iframe_bits-&gt;max &gt;&gt; 3;</span><br><span class="line">    int min_period_bytes = iperiod_bytes-&gt;min;</span><br><span class="line">    int max_period_bytes = iperiod_bytes-&gt;max;</span><br><span class="line">    int min_align_bytes, max_align_bytes;</span><br><span class="line">    struct snd_interval nperiod_bytes;</span><br><span class="line"></span><br><span class="line">    snd_interval_any(&amp;nperiod_bytes);</span><br><span class="line">    min_align_bytes = lcm(align_bytes, min_frame_bytes);</span><br><span class="line">    min_period_bytes = (min_period_bytes + min_align_bytes - 1) / min_align_bytes;</span><br><span class="line">    nperiod_bytes.min = min_period_bytes * min_align_bytes;</span><br><span class="line"></span><br><span class="line">    max_align_bytes = lcm(align_bytes, max_frame_bytes);</span><br><span class="line">    max_period_bytes = max_period_bytes / max_align_bytes;</span><br><span class="line">    nperiod_bytes.max = max_period_bytes * max_align_bytes;</span><br><span class="line"></span><br><span class="line">    DMA_DEBUG_MSG(&quot;==&gt; %s %d : align_bytes = %d \n\</span><br><span class="line">            frame_bytes.min (%d)\t\tframe_bytes.max (%d) \n\</span><br><span class="line">            period_bytes.min  [%d]\tperiod_bytes.max  [%d] \n\</span><br><span class="line">            nperiod_bytes.min [%d]\tnperiod_bytes.max [%d]\n&quot;,</span><br><span class="line">            __func__, __LINE__, align_bytes,</span><br><span class="line">            min_frame_bytes, max_frame_bytes, iperiod_bytes-&gt;min,</span><br><span class="line">            iperiod_bytes-&gt;max, nperiod_bytes.min, nperiod_bytes.max);</span><br><span class="line">    return snd_interval_refine(iperiod_bytes, &amp;nperiod_bytes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="调用过程"><a href="#调用过程" class="headerlink" title="调用过程"></a>调用过程</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int snd_pcm_hw_refine(struct snd_pcm_substream *substream,</span><br><span class="line">              struct snd_pcm_hw_params *params)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    changed = r-&gt;func(params, r);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>sound&#x2F;core&#x2F;pcm_native.c</p>
</blockquote>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><span class="exturl" data-url="aHR0cDovL2t1YWZ1ODAuYmxvZy4xNjMuY29tL2Jsb2cvc3RhdGljLzEyMjY0NzE4MDIwMTQ4NTExNDU4NzI5Lw==">内核Alsa之pcm<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL3d3dy5jbmJsb2dzLmNvbS9mZWxsb3cxOTg4L3AvNjE5NTIzMy5odG1s">ALSA lib基本概念<i class="fa fa-external-link-alt"></i></span></li>
</ol>
]]></content>
      <categories>
        <category>设备驱动</category>
        <category>音频</category>
      </categories>
      <tags>
        <tag>驱动</tag>
        <tag>alsa</tag>
        <tag>audio</tag>
      </tags>
  </entry>
  <entry>
    <title>ASOC之DPCM</title>
    <url>/post/14697.html</url>
    <content><![CDATA[<span id="more"></span>
]]></content>
      <categories>
        <category>设备驱动</category>
        <category>音频</category>
      </categories>
      <tags>
        <tag>alsa</tag>
        <tag>audio</tag>
        <tag>dpcm</tag>
      </tags>
  </entry>
  <entry>
    <title>音频接口</title>
    <url>/post/25782.html</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th align="center">接口</th>
<th align="left">应用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">I2S</td>
<td align="left">传输双声道数据，比如喇叭</td>
</tr>
<tr>
<td align="center">PCM</td>
<td align="left">传输单声道数据，比如麦克风</td>
</tr>
<tr>
<td align="center">TDM</td>
<td align="left">传输两个以上声道数据，同时区别于IIS特定格式</td>
</tr>
</tbody></table>
<!---more--->

<h2 id="I2S"><a href="#I2S" class="headerlink" title="I2S"></a>I2S</h2><blockquote>
<p>传输双声道数据(立体声)</p>
</blockquote>
<p>I2S(Inter—IC Sound)总线, 又称 集成电路内置音频总线，是飞利浦公司为数字音频设备之间的音频数据传输而制定的一种总线标准，该总线专责于音频设备之间的数据传输，广泛应用于各种多媒体系统。它采用了沿独立的导线传输时钟与数据信号的设计，通过将数据和时钟信号分离，避免了因时差诱发的失真，为用户节省了购买抵抗音频抖动的专业设备的费用。</p>
<h3 id="硬件接口"><a href="#硬件接口" class="headerlink" title="硬件接口"></a>硬件接口</h3><p>三个主要的信号线<br><img data-src="/images/audio/i2s-sycle.png" alt="i2s-sycle"></p>
<h4 id="BCLK"><a href="#BCLK" class="headerlink" title="BCLK"></a>BCLK</h4><blockquote>
<p>时钟是方波的形式</p>
</blockquote>
<p>串行时钟SCLK，也叫位时钟（BCLK），即对应数字音频的每一位数据，SCLK都有1个脉冲。<code>SCLK的频率=2×采样频率×采样位数</code>。</p>
<p>如采样频率&#x3D;44.1Khz  采样位数&#x3D;24bit</p>
<p>SCLK &#x3D; 2 * 44.1kHz * 24 &#x3D; 2.1168MHz</p>
<h4 id="LRCLK"><a href="#LRCLK" class="headerlink" title="LRCLK"></a>LRCLK</h4><p>帧时钟LRCK，(也称WS)，用于切换左右声道的数据。LRCK为“1”表示正在传输的是<code>右声道</code>的数据，为“0”则表示正在传输的是<code>左声道</code>的数据。<code>LRCK的频率 = 采样频率</code>。<br>在目前的测试中主要为SYNC_CLK</p>
<p>LRCLK&#x3D;44.1kHz</p>
<h4 id="SDATA"><a href="#SDATA" class="headerlink" title="SDATA"></a>SDATA</h4><p>串行数据SDATA，就是用二进制补码表示的音频数据。</p>
<h3 id="操作模式"><a href="#操作模式" class="headerlink" title="操作模式"></a>操作模式</h3><h4 id="I2S-1"><a href="#I2S-1" class="headerlink" title="I2S"></a>I2S</h4><p><img data-src="/images/audio/I2S.png" alt="I2S"></p>
<h4 id="LJ-Left-Justified"><a href="#LJ-Left-Justified" class="headerlink" title="LJ (Left Justified)"></a>LJ (Left Justified)</h4><p><img data-src="/images/audio/I2S-LJ.png" alt="I2S-LJ"></p>
<h4 id="RJ-Left-Justified"><a href="#RJ-Left-Justified" class="headerlink" title="RJ (Left Justified)"></a>RJ (Left Justified)</h4><p><img data-src="/images/audio/I2S-RJ.png" alt="I2S-RJ"></p>
<h3 id="I2S–八声道"><a href="#I2S–八声道" class="headerlink" title="I2S–八声道"></a>I2S–八声道</h3><p><img data-src="/images/2019/02/i2s_channel_8.png" alt="i2s_channel_8"></p>
<blockquote>
<p>i2s normal mode</p>
</blockquote>
<h2 id="PCM"><a href="#PCM" class="headerlink" title="PCM"></a>PCM</h2><blockquote>
<p>传输单声道数据，比如麦克风</p>
</blockquote>
<p><img data-src="/images/2022/08/audio_pcm_mode_a.png" alt="audio pcm mode a"></p>
<h2 id="TDM"><a href="#TDM" class="headerlink" title="TDM"></a>TDM</h2><blockquote>
<p>传输两个以上声道数据，同时区别于IIS特定格式。</p>
</blockquote>
<h3 id="硬件接口信号"><a href="#硬件接口信号" class="headerlink" title="硬件接口信号"></a>硬件接口信号</h3><p>PCM接口与I2S相似，电路信号包括：</p>
<ul>
<li>PCM_CLK   数据时钟信号</li>
<li>PCM_SYNC  帧同步时钟信号</li>
<li>PCM_IN    接收数据信号</li>
<li>PCM_OUT   发送数据信号</li>
</ul>
<table>
<thead>
<tr>
<th align="center">PCM接口</th>
<th align="center">I2S接口</th>
</tr>
</thead>
<tbody><tr>
<td align="center">PCM_OUT</td>
<td align="center">SD_OUT</td>
</tr>
<tr>
<td align="center">PCM_IN</td>
<td align="center">SD_IN</td>
</tr>
<tr>
<td align="center">PCM_SYNC</td>
<td align="center">WS(LRCLK)</td>
</tr>
<tr>
<td align="center">PCM_CLK</td>
<td align="center">sCK(BCLK)</td>
</tr>
</tbody></table>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><span class="exturl" data-url="aHR0cDovL3d3dy50LWZpcmVmbHkuY29tL2Rvd25sb2FkL2ZpcmVmbHktcmszMjg4L2RvY3MvVFJNL3JrMzI4OC1jaGFwdGVyLTE2LWkycy1wY20tY29udHJvbGxlci0oOC1jaGFubmVsKS5wZGY=">16I2S&#x2F;PCM Controller (8 channel)<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>设备驱动</category>
        <category>音频</category>
      </categories>
      <tags>
        <tag>alsa</tag>
        <tag>audio</tag>
        <tag>i2s</tag>
      </tags>
  </entry>
  <entry>
    <title>音频混音</title>
    <url>/post/5658a503.html</url>
    <content><![CDATA[<h2 id="混音原理"><a href="#混音原理" class="headerlink" title="混音原理"></a>混音原理</h2><p>将两个音源进行混合输出(如果多个音源的混音,个人理解将第一次混音数据个下一个音源再次混音)</p>
<span id="more"></span>

<h2 id="混音算法"><a href="#混音算法" class="headerlink" title="混音算法"></a>混音算法</h2><h3 id="线性叠加后求平均"><a href="#线性叠加后求平均" class="headerlink" title="线性叠加后求平均"></a>线性叠加后求平均</h3><blockquote>
<p>优点：不会产生溢出，噪音较小；<br>缺点：衰减过大，影响通话质量；</p>
</blockquote>
<p>实现: <strong>(A + B) &#x2F; 2</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">short  remix(short buffer1,short buffer2)</span><br><span class="line">&#123;</span><br><span class="line">    int value = buffer1 + buffer2;</span><br><span class="line">    return (short)(value/2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="归一化混音-自适应加权混音算法"><a href="#归一化混音-自适应加权混音算法" class="headerlink" title="归一化混音(自适应加权混音算法)"></a>归一化混音(自适应加权混音算法)</h3><blockquote>
<p>思路：使用更多的位数(32 bit)来表示音频数据的一个样本，混完音后在想办法降低其振幅，使其仍旧分布在16 bit所能表示的范围之内，这种方法叫做归一法；</p>
</blockquote>
<p>方法：为避免发生溢出，使用一个可变的衰减因子对语音进行衰减。这个衰减因子也就代表语音的权重，衰减因子随着音频数据的变化而变化，所以称为自适应加权混音。当溢出时，衰减因子较小，使得溢出的数据在衰减后能够处于临界值以内，而在没有溢出时，又让衰减因子慢慢增大，使数据较为平缓的变化。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IN_FILE1 <span class="string">&quot;1.wav&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IN_FILE2 <span class="string">&quot;2.wav&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OUT_FILE <span class="string">&quot;remix.pcm&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIZE_AUDIO_FRAME (2)</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Mix</span><span class="params">(<span class="type">char</span> sourseFile[<span class="number">10</span>][SIZE_AUDIO_FRAME],<span class="type">int</span> number,<span class="type">char</span> *objectFile)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//归一化混音</span></span><br><span class="line">	<span class="type">int</span> <span class="type">const</span> MAX=<span class="number">32767</span>;</span><br><span class="line">	<span class="type">int</span> <span class="type">const</span> MIN=<span class="number">-32768</span>;</span><br><span class="line"></span><br><span class="line">	<span class="type">double</span> f=<span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> output;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>,j = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;SIZE_AUDIO_FRAME/<span class="number">2</span>;i++) &#123;</span><br><span class="line">		<span class="type">int</span> temp=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (j=<span class="number">0</span>;j&lt;number;j++)</span><br><span class="line">			temp+=*(<span class="type">short</span>*)(sourseFile[j]+i*<span class="number">2</span>);</span><br><span class="line">		output=(<span class="type">int</span>)(temp*f);</span><br><span class="line">		<span class="keyword">if</span> (output&gt;MAX) &#123;</span><br><span class="line">			f=(<span class="type">double</span>)MAX/(<span class="type">double</span>)(output);</span><br><span class="line">			output=MAX;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (output&lt;MIN) &#123;</span><br><span class="line">			f=(<span class="type">double</span>)MIN/(<span class="type">double</span>)(output);</span><br><span class="line">			output=MIN;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (f&lt;<span class="number">1</span>)</span><br><span class="line">			f+=((<span class="type">double</span>)<span class="number">1</span>-f)/(<span class="type">double</span>)<span class="number">32</span>;</span><br><span class="line"></span><br><span class="line">		*(<span class="type">short</span>*)(objectFile+i*<span class="number">2</span>)=(<span class="type">short</span>)output;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	FILE * fp1,*fp2,*fpm;</span><br><span class="line">	fp1 = fopen(IN_FILE1,<span class="string">&quot;rb&quot;</span>);</span><br><span class="line">	fp2 = fopen(IN_FILE2,<span class="string">&quot;rb&quot;</span>);</span><br><span class="line">	fpm = fopen(OUT_FILE,<span class="string">&quot;wb&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="type">short</span> data1,data2,date_mix;</span><br><span class="line">	<span class="type">int</span> ret1,ret2;</span><br><span class="line">	<span class="type">char</span> sourseFile[<span class="number">10</span>][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">		ret1 = fread(&amp;data1,<span class="number">2</span>,<span class="number">1</span>,fp1);</span><br><span class="line">		ret2 = fread(&amp;data2,<span class="number">2</span>,<span class="number">1</span>,fp2);</span><br><span class="line">		*(<span class="type">short</span>*) sourseFile[<span class="number">0</span>] = data1;</span><br><span class="line">		*(<span class="type">short</span>*) sourseFile[<span class="number">1</span>] = data2;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(ret1&gt;<span class="number">0</span> &amp;&amp; ret2&gt;<span class="number">0</span>) &#123;</span><br><span class="line">			Mix(sourseFile,<span class="number">2</span>,(<span class="type">char</span> *)&amp;date_mix);</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			   if( data1 &lt; 0 &amp;&amp; data2 &lt; 0)</span></span><br><span class="line"><span class="comment">			   date_mix = data1+data2 - (data1 * data2 / -(pow(2,16-1)-1));</span></span><br><span class="line"><span class="comment">			   else</span></span><br><span class="line"><span class="comment">			   date_mix = data1+data2 - (data1 * data2 / (pow(2,16-1)-1));</span></span><br><span class="line"><span class="comment">			   */</span></span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span>(date_mix &gt; <span class="built_in">pow</span>(<span class="number">2</span>,<span class="number">16</span><span class="number">-1</span>) || date_mix &lt; -<span class="built_in">pow</span>(<span class="number">2</span>,<span class="number">16</span><span class="number">-1</span>))</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;mix error\n&quot;</span>);</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span>( (ret1 &gt; <span class="number">0</span>) &amp;&amp; (ret2==<span class="number">0</span>))</span><br><span class="line">			date_mix = data1;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>( (ret2 &gt; <span class="number">0</span>) &amp;&amp; (ret1==<span class="number">0</span>))</span><br><span class="line">			date_mix = data2;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>( (ret1 == <span class="number">0</span>) &amp;&amp; (ret2 == <span class="number">0</span>))</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		fwrite(&amp;date_mix,<span class="number">2</span>,<span class="number">1</span>,fpm);</span><br><span class="line">	&#125;</span><br><span class="line">	fclose(fp1);</span><br><span class="line">	fclose(fp2);</span><br><span class="line">	fclose(fpm);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Done!\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="切割时间片，重采样算法"><a href="#切割时间片，重采样算法" class="headerlink" title="切割时间片，重采样算法"></a>切割时间片，重采样算法</h3><blockquote>
<p>可以把各个通道的声音叠到一起，让声音的采样率按倍增加，如果提高声音的播放频率，声音可以正常的播放，声音实现了叠加；如果不想修改声音的播放输出频率，可以通过声音的重采样后输出自己想要的输出频率；</p>
</blockquote>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><span class="exturl" data-url="aHR0cDovL3d3dy5qaWFuc2h1LmNvbS9wLzY0OTJmMmExODljZg==">Android音视频处理之音频混音<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL3d3dy5jcHBibG9nLmNvbS9qaW5xMDEyMy9hcmNoaXZlLzIwMDcvMTAvMzEvYXVkaW9taXhpbmdzdHVkeS5odG1s">混音算法的学习与研究<i class="fa fa-external-link-alt"></i></span></li>
</ol>
]]></content>
      <categories>
        <category>设备驱动</category>
        <category>音频</category>
      </categories>
      <tags>
        <tag>驱动</tag>
        <tag>alsa</tag>
        <tag>audio</tag>
      </tags>
  </entry>
  <entry>
    <title>ALSA-DMA</title>
    <url>/post/8df01b06.html</url>
    <content><![CDATA[<blockquote>
<p>S&#x2F;PDIF，全名为Sony&#x2F;Philips Digital Interconnect Format，是Sony和Philips这两大巨头在80年代为一般家用器材所定制出来的一种数字讯号传输接口，基本上是以AES&#x2F;EBU(也称为AES3)专业用数字接口为参考然后做了一些小变动而成的家用版本，可以使用成本比较低的硬件来实现数字讯号传输。为了定制一个统一的接口规格，在现今以IEC 60958标准规范来囊括取代AES&#x2F;EBU与S&#x2F;PDIF规范，而IEC 60958定义了三种主要型态：</p>
</blockquote>
<span id="more"></span>

<ul>
<li>IEC 60958 TYPE 1 Balanced ─ 三线式传输，使用110 Ohm阻抗的线材以及XLR接头，使用于专业场合。</li>
<li>IEC 60958 TYPE 2 Unbalanced ─ 使用75 Ohm阻抗的铜轴线以及RCA接头，使用于一般家用场合。</li>
<li>IEC 60958 TYPE 2 Optical ─ 使用光纤传输以及F05光纤接头，也是使用于一般家用场合</li>
</ul>
<p>事实上，IEC 60958有时会简称为IEC958，而IEC 60958 TYPE 1即为AES&#x2F;EBU(或著称为AES3)界面，而IEC 60958 TYPE 2即为S&#x2F;PDIF接口，而虽然在IEC 60958 TYPE 2的接头规范里是使用RCA或着光纤接头，不过近年来一些使用S&#x2F;PDIF的专业器材改用BNC接头搭配上75 Ohm的同轴线以得到比较好的传输质量，下表为AES&#x2F;EBU与S&#x2F;PDIF的比较表。</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">AES&#x2F;EBU</th>
<th align="center">S&#x2F;PDIF</th>
</tr>
</thead>
<tbody><tr>
<td align="center">线材</td>
<td align="center">110 Ohm屏蔽绞线</td>
<td align="center">75 Ohm同轴线或是光纤线</td>
</tr>
<tr>
<td align="center">接头</td>
<td align="center">XLR 3 Pin接头</td>
<td align="center">RCA或BNC接头</td>
</tr>
<tr>
<td align="center">最大位数</td>
<td align="center">24 Bits</td>
<td align="center">标准为20 Bits(可支持到24 Bits)</td>
</tr>
<tr>
<td align="center">讯号电平</td>
<td align="center">3 ~ 10V</td>
<td align="center">0.5 ~ 1V</td>
</tr>
<tr>
<td align="center">编码</td>
<td align="center">双相符号编码(Biphase Mark Code)</td>
<td align="center">双相符号编码(Biphase Mark Code)</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>设备驱动</category>
        <category>音频</category>
      </categories>
      <tags>
        <tag>驱动</tag>
        <tag>alsa</tag>
        <tag>audio</tag>
      </tags>
  </entry>
  <entry>
    <title>Audio ALSA数据传输</title>
    <url>/post/6516.html</url>
    <content><![CDATA[<p>在ALSA数据传输中，主要出现错误<code>underrun</code>和<code>overrun</code></p>
<blockquote>
<p>DDR —&gt; buffer —&gt; digital singal</p>
</blockquote>
<span id="more"></span>

<h2 id="overrun"><a href="#overrun" class="headerlink" title="overrun"></a>overrun</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MIC --&gt; DMIC(控制器) --&gt; DDR(RAM) --&gt; Flash</span><br></pre></td></tr></table></figure>
<p>在<code>录音</code>时由于录音数据过快会产生<code>overrun</code>现象</p>
<h2 id="underrun"><a href="#underrun" class="headerlink" title="underrun"></a>underrun</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Flash --&gt; DDR --&gt; I2S --&gt; Codec --&gt; spk</span><br></pre></td></tr></table></figure>
<p>在<code>放音</code>时由于用户层的音频数据到DDR中的速度比控制器到codec放出的速度慢,出现<code>underrun</code></p>
<h3 id="断音"><a href="#断音" class="headerlink" title="断音"></a>断音</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+------+        +----+</span><br><span class="line">|      |        |    |       +---------+    +-----+</span><br><span class="line">|      |        |    | DMA   |         |    |     |</span><br><span class="line">| flash+--------&gt; DDR+-------&gt; buffer  +----&gt;codec|</span><br><span class="line">|      |        |    |       +---------+    +-----+</span><br><span class="line">+------+        +----+</span><br></pre></td></tr></table></figure>
<blockquote>
<p>从flash到DDR的速度，比数据从DDR通过DMA到buffer的速度慢，导致出现断音<code>underrun</code></p>
</blockquote>
<ol>
<li>DMA没有及时的从DDR中将数据搬到FIFO</li>
<li>DDR中申请的buffer不够大</li>
<li>DDR中的buffer没有数据</li>
</ol>
<p>假如播放的是音乐格式是采样率为192KHz，采样宽度为24bit，声道为2，驱动中的buffer大小为1M bytes（256 pages），FIFO深度为64 entry，DDR为150MHz（假如cpu和DDR间的数据拷贝仅仅为200M bytes&#x2F;s）</p>
<ul>
<li>DDR</li>
</ul>
<p>那么1s播放出去的声音数据为192000 * 24 * 2&#x2F;8(bytes)&#x3D;1152000 bytes，而拷贝到buffer的数据为200Mbytes，即每10ms播放1152bytes,进入buffer的数据为2M bytes,而buffer仅仅有1M空间，所以播放完1 * 1024 * 1024 &#x2F; 1152 &#x3D;910次，即910 * 10ms&#x3D;9s中内需要将程序调度回来，显然这是没有太大问题，因为我们的系统中不可能跑910个线程的。也就是说驱动中的buffer为1M byte的空间是没有问题的。</p>
<ul>
<li>FIFO</li>
</ul>
<p>fifo为64个entry，那么存放的音频数据仅仅是64 * 24&#x3D;1536 bits&#x3D;192bytes，播放完这些数据需要的时间是192&#x2F;115.2 (ms)&#x3D;1.67ms, 也就是说需要播放完fifo中的数据后的2ms内就要把数据添加到fifo中，如果这段时间没有做到这一点，那么就断音了</p>
<h2 id="xrun"><a href="#xrun" class="headerlink" title="xrun"></a>xrun</h2>]]></content>
      <categories>
        <category>设备驱动</category>
        <category>音频</category>
      </categories>
      <tags>
        <tag>驱动</tag>
        <tag>alsa</tag>
        <tag>audio</tag>
      </tags>
  </entry>
  <entry>
    <title>ALSA-xrun</title>
    <url>/post/bf06e0bf.html</url>
    <content><![CDATA[<p><code>overrun</code>和<code>underrun</code>通过snd_pcm_period_elapsed()接口进行控制</p>
<p>流程: stop-&gt;start-&gt;stop-&gt;start-&gt;</p>
<span id="more"></span>

<h3 id="overrun"><a href="#overrun" class="headerlink" title="overrun"></a>overrun</h3><p>在录音时由于录音数据过快会产生overrun现象</p>
<h3 id="underrun"><a href="#underrun" class="headerlink" title="underrun"></a>underrun</h3><p>在放音时由于用户层的音频数据到DDR中的速度比控制放的速度满,出现underrun</p>
<h2 id="snd-pcm-period-elapsed正常更新位置"><a href="#snd-pcm-period-elapsed正常更新位置" class="headerlink" title="snd_pcm_period_elapsed正常更新位置"></a>snd_pcm_period_elapsed正常更新位置</h2><p>正常录音: 应用层使用poll的调用关系</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">snd_pcm_period_elapsed</span><br><span class="line">    |</span><br><span class="line">    |-&gt; snd_pcm_update_hw_ptr0</span><br><span class="line">        |</span><br><span class="line">        |-&gt; pos = substream-&gt;ops-&gt;pointer(substream); <span class="comment">// 回调pladform中的.pointer接口</span></span><br><span class="line">        |</span><br><span class="line">        |-&gt; snd_pcm_update_state</span><br><span class="line">            |-&gt; snd_pcm_capture_avail</span><br><span class="line">            |-&gt; wake_up(&amp;runtime-&gt;sleep);</span><br></pre></td></tr></table></figure>

<h2 id="read进程"><a href="#read进程" class="headerlink" title="read进程"></a>read进程</h2><p><strong>overrun以后不能通过wakeup唤醒, 正常要通过wake_up(&amp;runtime-&gt;sleep)唤醒什么?</strong></p>
<p>通过wake_up(&amp;runtime-&gt;sleep)唤醒核心层core中的<code>read</code>进程</p>
<h3 id="read进程的由来"><a href="#read进程的由来" class="headerlink" title="read进程的由来"></a>read进程的由来</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">用户空间      arecord -f cd <span class="number">1.</span>wav  --- 产生read进程</span><br><span class="line"></span><br><span class="line">           ioctl - SNDRV_PCM_IOCTL_READI_FRAMES</span><br><span class="line">                        |</span><br><span class="line">-------------------------------------------------</span><br><span class="line">                        |</span><br><span class="line">内核空间        snd_pcm_capture_ioctl</span><br></pre></td></tr></table></figure>


<h3 id="内核空间的数据处理"><a href="#内核空间的数据处理" class="headerlink" title="内核空间的数据处理"></a>内核空间的数据处理</h3><p>数据的调用关系:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">snd_pcm_capture_ioctl</span><br><span class="line">    |-&gt; snd_pcm_capture_ioctl1</span><br><span class="line">        |-&gt; snd_pcm_lib_read (SNDRV_PCM_IOCTL_READI_FRAMES)</span><br><span class="line">            |-&gt; snd_pcm_lib_read1</span><br><span class="line">                |-&gt; snd_pcm_capture_avail</span><br><span class="line">                |------&gt; wait_for_avail</span><br><span class="line">                |-&gt; transfer(substream, appl_ofs, data, offset, frames)</span><br></pre></td></tr></table></figure>

<p>wait_for_avail的实现逻辑:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">wait_for_avail</span><br><span class="line">    |-&gt; init_waitqueue_entry(&amp;wait, current);</span><br><span class="line">    |-&gt; set_current_state(TASK_INTERRUPTIBLE);</span><br><span class="line">    |-&gt; add_wait_queue(&amp;runtime-&gt;tsleep, &amp;wait);</span><br><span class="line">    |</span><br><span class="line">    |-&gt; <span class="keyword">for</span>(;;)</span><br><span class="line">        |-&gt; signal_pending(current)</span><br><span class="line">        |<span class="comment">//wait_time等待时间和具体的采样率相关</span></span><br><span class="line">        |-&gt; tout = schedule_timeout(wait_time);    <span class="comment">//等待数据处理</span></span><br><span class="line">        |-&gt; 上报用户空间当前stream流的状态</span><br></pre></td></tr></table></figure>

<h3 id="sleep队列的工作"><a href="#sleep队列的工作" class="headerlink" title="sleep队列的工作"></a>sleep队列的工作</h3><p>通过打印调试信息可以判断在使用<code>snd_pcm_period_elapsed</code>更新位置信息后,是通过<code>wake_up(&amp;runtime-&gt;sleep)</code>将当前进程唤醒</p>
<blockquote>
<p>什么时候对sleep队列进行的初始化,什么时候将当前进程加入的sleep队列</p>
</blockquote>
<ol>
<li>初始化</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">snd_pcm_capture_open</span><br><span class="line">    |-&gt; snd_pcm_open</span><br><span class="line">        |-&gt; snd_pcm_open_file</span><br><span class="line">            |-&gt; snd_pcm_open_substream</span><br><span class="line">                |-&gt; snd_pcm_attach_substream</span><br><span class="line">                    |-&gt; init_waitqueue_head(&amp;runtime-&gt;sleep);</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>将当前进程加入sleep队列</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">.poll =         snd_pcm_capture_poll</span><br><span class="line">    |-&gt;  poll_wait(file, &amp;runtime-&gt;sleep, wait); <span class="comment">//将进程添加到sleep队列</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>poll()该接口用户空间arecord应用有调用</p>
</blockquote>
<ol start="3">
<li>poll的作用;</li>
</ol>
<ul>
<li><strong>判断该文件是否可读</strong></li>
<li><strong>将该进程挂到等待队列中</strong></li>
</ul>
<h3 id="read进程的控制机制"><a href="#read进程的控制机制" class="headerlink" title="read进程的控制机制"></a>read进程的控制机制</h3><p>通过源码中的wakeup可以判断对read进程的唤醒存在两种方式</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (runtime-&gt;twake) &#123;</span><br><span class="line">    <span class="keyword">if</span> (avail &gt;= runtime-&gt;twake)</span><br><span class="line">        wake_up(&amp;runtime-&gt;tsleep); <span class="comment">//核心层自己维护</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (avail &gt;= runtime-&gt;control-&gt;avail_min)</span><br><span class="line">    wake_up(&amp;runtime-&gt;sleep);    <span class="comment">//通过poll机制实现</span></span><br></pre></td></tr></table></figure>

<p>通过核心层core中自己控制(唤醒)read进程,必须<code>runtime-&gt;twake=1</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> snd_pcm_lib_read1</span><br><span class="line">    |-&gt; runtime-&gt;twake = runtime-&gt;control-&gt;avail_min ? : <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> snd_pcm_hw_params</span><br><span class="line">    |-&gt; runtime-&gt;period_size = params_period_size(params);</span><br><span class="line">    |-&gt; runtime-&gt;control-&gt;avail_min = runtime-&gt;period_size;</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> params_period_size(params)</span><br><span class="line">    |-&gt; 解析用户空间参数SNDRV_PCM_HW_PARAM_PERIOD_SIZE</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span> arecord参数选项:</span><br><span class="line">    --period-size=<span class="meta">#     distance between interrupts is # frames</span></span><br></pre></td></tr></table></figure>

<h2 id="stop"><a href="#stop" class="headerlink" title="stop"></a>stop</h2><blockquote>
<p>出现overrun或underrun后,alsa什么时候在那进行stop</p>
</blockquote>
<h3 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h3><p>在对每个DMA描述符进行处理时,也就是DMA描述符中断的callback中.</p>
<h3 id="位置"><a href="#位置" class="headerlink" title="位置"></a>位置</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">snd_pcm_period_elapsed()</span><br></pre></td></tr></table></figure>
<blockquote>
<p>sound&#x2F;core&#x2F;pcm_lib.c</p>
</blockquote>
<blockquote>
<p>Description:<br>This function is called from the interrupt handler when the PCM has processed the period size. It will update the current pointer, set up the tick, wake up sleepers, etc.<br>Even if more than one periods have elapsed since the last call, you have to call this only once.</p>
</blockquote>
<p>作用: 通知缓冲区空闲（对应回放）或者有效（对应录音）</p>
<h3 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h3><p>实现逻辑: 主要以<code>overrun</code>为例</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">snd_pcm_period_elapsed</span><br><span class="line">    |</span><br><span class="line">    |-&gt; snd_pcm_update_hw_ptr0</span><br><span class="line">        |</span><br><span class="line">        |-&gt; pos = substream-&gt;ops-&gt;pointer(substream); <span class="comment">// 回调pladform中的.pointer接口</span></span><br><span class="line">            <span class="keyword">if</span> (pos == SNDRV_PCM_POS_XRUN) &#123;   <span class="comment">// SNDRV_PCM_POS_XRUN = -1</span></span><br><span class="line">                xrun(substream);</span><br><span class="line">                <span class="keyword">return</span> -EPIPE;  <span class="comment">// EPIPE --  Broken pipe</span></span><br><span class="line">            &#125;</span><br><span class="line">        |-&gt; 更新指针(hw_ptr_base,hw_ptr_interrupt, status-&gt;hw_ptr), (hw_ptr_jiffies)</span><br><span class="line">        |-&gt; snd_pcm_update_state</span><br><span class="line">            |</span><br><span class="line">            |-&gt; snd_pcm_playback_avail(/snd_pcm_capture_avail) <span class="comment">//得到录放有效数据大小</span></span><br><span class="line">            |--&gt; snd_pcm_drain_done() <span class="comment">// state == SNDRV_PCM_STATE_DRAINING</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>当<code>pos == SNDRV_PCM_POS_XRUN</code>时,出现overrun</p>
</blockquote>
<h3 id="出现overrun后的处理"><a href="#出现overrun后的处理" class="headerlink" title="出现overrun后的处理"></a>出现overrun后的处理</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">xrun</span><br><span class="line">  |-&gt; snd_pcm_stop(substream, SNDRV_PCM_STATE_XRUN);</span><br></pre></td></tr></table></figure>


<h2 id="start"><a href="#start" class="headerlink" title="start"></a>start</h2><blockquote>
<p>出现overrun或underrun, 并且数据准备完成后,alsa什么时候在那进行start</p>
</blockquote>
<h3 id="时间-1"><a href="#时间-1" class="headerlink" title="时间"></a>时间</h3><h3 id="位置-1"><a href="#位置-1" class="headerlink" title="位置"></a>位置</h3>]]></content>
      <categories>
        <category>设备驱动</category>
        <category>音频</category>
      </categories>
      <tags>
        <tag>驱动</tag>
        <tag>alsa</tag>
        <tag>audio</tag>
      </tags>
  </entry>
  <entry>
    <title>Audio驱动——设备树</title>
    <url>/post/a482f327.html</url>
    <content><![CDATA[<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sound &#123;</span><br><span class="line">    compatible = &quot;simple-audio-card&quot;;</span><br><span class="line">    ...</span><br><span class="line">    simple-audio-card,widgets =</span><br><span class="line">        &quot;Headphone&quot;, &quot;Headphone Jack&quot;;</span><br><span class="line">    simple-audio-card,routing =</span><br><span class="line">        &quot;Headphone Jack&quot;, &quot;HPLEFT&quot;,</span><br><span class="line">        &quot;Headphone Jack&quot;, &quot;HPRIGHT&quot;,</span><br><span class="line">        &quot;LEFTIN&quot;, &quot;HPL&quot;,</span><br><span class="line">        &quot;RIGHTIN&quot;, &quot;HPR&quot;;</span><br><span class="line">    simple-audio-card,aux-devs = &lt;&amp;amp&gt;;</span><br><span class="line">    simple-audio-card,cpu &#123;</span><br><span class="line">        sound-dai = &lt;&amp;ssi2&gt;;</span><br><span class="line">    &#125;;</span><br><span class="line">    simple-audio-card,codec &#123;</span><br><span class="line">        sound-dai = &lt;&amp;codec&gt;;</span><br><span class="line">        clocks = ...</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>From： Documentation&#x2F;devicetree&#x2F;bindings&#x2F;sound&#x2F;simple-card.txt</p>
</blockquote>
<span id="more"></span>

<h2 id="simple-audio-card"><a href="#simple-audio-card" class="headerlink" title="simple-audio-card"></a>simple-audio-card</h2><p>简单通用的<code>machine driver</code>, 是一个为了简化音频框架，在alsa上面的一个封装。如果simple-audio-card框架足够满足需求, 建议优先使用simple-audio-card框架。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">status: 声卡目前的状态，目前是未激活；</span><br><span class="line">compatible: 设备文件中的的名字，系统靠这个去匹配驱动代码中的simple-audio-card层的驱动程序；</span><br><span class="line">simple-audio-card,name: 声卡在系统中的名字；</span><br><span class="line">simple-audio-card,format： CPU/CODEC 通用音频格式&quot;i2s&quot;, &quot;right_j&quot;, &quot;left_j&quot;等</span><br><span class="line">simple-audio-card,mclk-fs： 流速率和编解码器mclk之间的乘法因子。 定义时，在 dai-link 子节点中定义的 mclk-fs 属性将被忽略</span><br><span class="line">simple-audio-card,hp-det-gpio： 对连接耳机时发出信号的GPIO检测，检查耳机接入的GPIO配置端口</span><br><span class="line">simple-audio-card,mic-det-gpio： 对连接麦克风时发出信号的GPIO检测</span><br><span class="line">simple-audio-card,widgets：主要指定音频非编解码器 DAPM 小部件。</span><br><span class="line">                每个条目都是DT中的一对字符串：&quot;template-wname&quot;, &quot;user-supplied-wname&quot;。</span><br><span class="line">                “template-wname”是模板小部件名称，目前包括：&quot;Microphone&quot;, &quot;Line&quot;,&quot;Headphone&quot; and &quot;Speaker&quot;。</span><br><span class="line">                “user-supplied-wname”是用户指定的小部件名称。</span><br><span class="line">simple-audio-card,routing： 音频组件之间的连接列表。每个条目都是一对字符串，第一个是连接的接收器，第二个是连接的源。</span><br><span class="line">simple-audio-card,cpu &#123;</span><br><span class="line">      sound-dai: soc端的dai配置，i2s接口的配置；</span><br><span class="line">&#125;</span><br><span class="line">simple-audio-card,codec &#123;</span><br><span class="line">      sound-dai:codec端的dai配置，就是soc外界codec的接口的配置，这里是虚拟声卡；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>设备驱动</category>
        <category>音频</category>
      </categories>
      <tags>
        <tag>驱动</tag>
        <tag>alsa</tag>
        <tag>audio</tag>
        <tag>设备树</tag>
      </tags>
  </entry>
  <entry>
    <title>pop音与耳机插拔杂音处理</title>
    <url>/post/9744d14a.html</url>
    <content><![CDATA[<p>在音频调试过程中，经常会遇到pop音与耳机相关问题（比如声音大小，插拔杂音等）。</p>
<span id="more"></span>


<h2 id="pop音"><a href="#pop音" class="headerlink" title="pop音"></a>pop音</h2><h3 id="POP音基本原理"><a href="#POP音基本原理" class="headerlink" title="POP音基本原理"></a>POP音基本原理</h3><p>POP音的产生主要是因为codec开始工作时，耳机等输出或mic输入声道上的直流电平跳变产生的；手机或一般的手持设备上不会有负电压，音源信号必须在一个直流电平上（如1&#x2F;2VDD上）输出，这样一个从0电平到1&#x2F;2VDD的直流跳变，通过隔直电容后到耳机上必然会产生POP音，同样地对于喇叭输出也类似；codec内部操作某些寄存器也会产生pop，有的时间比较长，需要增加延时。</p>
<p>一般出现在音频开始工作、结束工作或者动态切换通路时，出现这种问题的原因有很多，需要具体情况具体分析。</p>
<p>大部分情况下在PA之后加延时都能解决，当然，加了PA延时可能也不起作用，即使加了一秒的延时，还会惊喜的发现pop会在一秒之后出现。这就要分析下具体是啥原因造成的了。</p>
<p>还有就是，如果左右声道都是采用全差分方式输出的话，那是不需要隔直电容，但是耳机就不能够用标准四线耳机插孔，这种全差分的方式，耳机一般都是用的专用输出插头（与调试接口共用）。</p>
<h3 id="POP音常见原因"><a href="#POP音常见原因" class="headerlink" title="POP音常见原因"></a>POP音常见原因</h3><p>引起POP原因可能有多种，可排查以下几点：</p>
<ol>
<li>音源与PA（Power Amplifier，功率放大器）开启关断时序不合理（可通过抓取音频输出波形与PA使能引脚波形来判定）<br>因为有的功放PA使能之后要一定时间才能稳定工作，在这个时间内，codec有任何变化都会被放大出来。</li>
</ol>
<p><img data-src="/images/2022/06/%E9%9F%B3%E9%A2%91%E5%8A%9F%E6%94%BE%E5%BC%80%E5%85%B3.png" alt="音频功放开关"></p>
<ul>
<li>正常时序理应如下：<ul>
<li>上电时序：<ul>
<li>1.打开codec输出。</li>
<li>2.PA拉高使能。</li>
<li>3.延时一小段后送入相应音源。</li>
</ul>
</li>
<li>下电时序：<ul>
<li>1.关闭相应音源。</li>
<li>2.PA 拉低。</li>
<li>3.延时一小段以后关闭codec输出。</li>
</ul>
</li>
</ul>
</li>
</ul>
<ol start="2">
<li><p>输入电容，电阻失配引起；</p>
</li>
<li><p>原理图错误：AB类差分输入应用；例如板子是差分输出，但是配置了单端输出。</p>
</li>
<li><p>音源本身问题； 如果音频经过AU软件修改，文件尾部被附带了一段软件信息。</p>
</li>
<li><p>控制音频PA使能引脚的GPIO口下拉能力弱，或其他地方有上拉，导致长时间未关断；有的方案PA是常开的。</p>
</li>
<li><p>部分PA芯片的使能会存在Pa音，单独操作PA使能开关查看是否POP音是本身产生的</p>
</li>
</ol>
<h3 id="通用解决方法"><a href="#通用解决方法" class="headerlink" title="通用解决方法"></a>通用解决方法</h3><ol>
<li><p>一般来说， IC 上、下电时的 POP 音是由于偏置电压的瞬间跳变引起的。所以要减小 POP 音就必须抑制 IC 的偏置电压bias的瞬变。Layout上的体现方法就是增大bias的滤波电容。偏置电容变得过大会导致 IC 的建立时间变长，另外电容过大还会导致 THD+N 变差。</p>
</li>
<li><p>通过改变上下电时序，是在噪声出来之前关掉末端输出，通过软件修改PA mute和spk mute的时序，即为在codec驱动代码中定义的dapm的通路上调准顺序，在回调中增加delay时间，是内部产生的杂音不走到下一级输出，使其提前关闭。</p>
</li>
<li><p>预充电的方法，再加上上拉和下拉电阻将电容的直流电压稳定住，可能效果会比较好。当然首先要确认这个直流偏置1&#x2F;2VDD到底是多高（有些是可以设置的，有些固定），才好设计上下拉电阻的大小，这样调整后，感觉效果还可以，pop noise几乎感觉不到。</p>
</li>
<li><p>有些CODEC在软件上有一个寄存器可以设置这个直流电平的上升时间，让它在一定时间内跳变到1&#x2F;2VDD，而不是很陡的一个上升沿，这样可以在一定程度改善这个POP音。</p>
</li>
</ol>
<p>开关机的POP 音问题目前是整个音频功放的瓶颈问题，目前最好的一个解决方法是方法二。</p>
<p>对于正常工作时切换内部音频通路产生POP，切换之前可以将输出(HP，LineOut)Mute，切换完成后再unMute。</p>
<p>解决POP音小诀窍：从末端各个环节进行切分，然后细分codec内部数字和模拟模块的各个部件的上下电顺序，以及保持时间大小。</p>
<h3 id="特殊情况的杂音"><a href="#特殊情况的杂音" class="headerlink" title="特殊情况的杂音"></a>特殊情况的杂音</h3><p>在正常放音的过程中，将其关机后重新开机（开关断电上电）时，出现部分杂音，可能原因是codec没有断过电一直处于正常工作状态。</p>
<p>检测方法：测量codec供电电压是否存在，有时候电压很低也可以正常工作，比如codec正常工作电压可以是1.8V，但是在0.9V时同样可以正常工作，而0.2V时无法工作</p>
<p>原因：关机后CPU等模块已经断电，但是codec由于与串口Rx&#x2F;Tx共用电压，导致codec关机后一直处于正常工作状态，而重新开机时，由于CPU复位启动初期所有时钟源为晶振时钟24M，与上一次正常工作时时钟源不同导致codec出现杂音，杂音会持续到spl阶段重新初始化时钟模块后结束。</p>
<p>解决方法：不使用串口进行测试正常，将串口输入部分与codec供电部分进行隔离</p>
<h2 id="耳机"><a href="#耳机" class="headerlink" title="耳机"></a>耳机</h2><p>耳机常见问题：</p>
<table>
<thead>
<tr>
<th align="center">问题</th>
<th align="left">可能原因</th>
<th align="left">方法</th>
</tr>
</thead>
<tbody><tr>
<td align="center">部分耳机识别异常</td>
<td align="left">（1）美标和国标问题 （2）耳机座子设计连接问题而不支持</td>
<td align="left">优先查看原理图区分耳机标准问题</td>
</tr>
<tr>
<td align="center">四节耳机无法录音</td>
<td align="left">（1）美标和国标问题，以及硬件本身不支持耳机录音 （2）audioroute设置问题 （3）录音时codec bias电压是否正常</td>
<td align="left">（1）优先查看原理图区分耳机标准问题，并测试bias电压是否正常 （2）根据codec spec的Mixer Path并通过tinymix工具检查mixer的设置</td>
</tr>
<tr>
<td align="center">耳机输出串音</td>
<td align="left">主要和硬件pcb layout设计有关</td>
<td align="left">（1）左右声道用GND隔离，降低干扰 （2）加大PCB layout的耳机的GND面积</td>
</tr>
<tr>
<td align="center">耳机插拔状态相反</td>
<td align="left">硬件耳机座子连接相反</td>
<td align="left">修改检测电平代码</td>
</tr>
<tr>
<td align="center">音频信号削波</td>
<td align="left">（1）DAC增益过大 （2）PA功放设置增益过大</td>
<td align="left">（1）降低增益，DAC音量默认不要给到大于0db的情况 （2）修改硬件电路PA增益设置</td>
</tr>
<tr>
<td align="center">音量过小</td>
<td align="left">（1）模拟部分音量设置增益过小 （2）audioroute设置问题 （3）末端功放功率不达标 （4）单喇叭输出前有混音，针对0dB的音量来说，output mixer前端会有-6dB的操作，防止叠加后削顶失真，只有单边声道数据的话，音量会减小很多 （5）装机喇叭方向贴反 （6）喇叭紧贴屏幕，会有掉磁</td>
<td align="left">（1）调节模拟输出增益 （2）查看mixer的设置 （3）开启DRC功能 （4）外壳喇叭开孔处有音腔设计，有增大音量的效果</td>
</tr>
<tr>
<td align="center">耳机插拔杂音</td>
<td align="left">可能存在bias电压，导致插拔时电压波动，从mic输入，又在左右声道输出产生杂音</td>
<td align="left">默认关闭bias电压，只在进行录音时将其开启</td>
</tr>
</tbody></table>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2R5cm9uL2FydGljbGUvZGV0YWlscy84MTYxODc1">杂音 &amp; pop 音的解决方法<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2d1ZXRfa2l0ZS9hcnRpY2xlL2RldGFpbHMvMTEwODE5NjM0">ALSA子系统（六）——POP音排查<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0d1ZXRfS2l0ZS9hcnRpY2xlL2RldGFpbHMvMTEwODIxODU3">ALSA子系统（九）——常见耳机问题<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>设备驱动</category>
        <category>音频</category>
      </categories>
      <tags>
        <tag>alsa</tag>
        <tag>pop</tag>
        <tag>耳机</tag>
      </tags>
  </entry>
  <entry>
    <title>音频codec——耳机电路</title>
    <url>/post/86a98cff.html</url>
    <content><![CDATA[<p><img data-src="/images/2021/11/%E8%80%B3%E6%9C%BA%E6%8E%A5%E5%A4%B4.png" alt="耳机接头"></p>
<span id="more"></span>

<h2 id="耳机接口原理图"><a href="#耳机接口原理图" class="headerlink" title="耳机接口原理图"></a>耳机接口原理图</h2><p><img data-src="/images/2021/11/%E8%80%B3%E6%9C%BA%E6%8E%A5%E5%8F%A3%E5%8E%9F%E7%90%86%E5%9B%BE.png" alt="耳机接口原理图"></p>
<blockquote>
<p>该原理图为<code>国标</code>耳机插座</p>
<p>四段式耳机插头: <code>第1节——1pin</code>：接地，<code>第2节——2、5pin</code>：接MIC，<code>第3节——3、6pin</code>：接右声道，<code>第4节——4、7pin</code>：接左声道</p>
</blockquote>
<ul>
<li><code>MIC_IN1P</code>： Single-end input for microphone 1（麦克风单端输入 1）</li>
<li><code>MICBIAS1</code>： Bias voltage output for microphone（麦克风偏置电压输出）</li>
<li>耳机插座说明，原理图中带箭头的表示开关，默认耳机没有插入时处理连接状态（比如pin2和pin5），但是一旦耳机插入后会将其断开。</li>
</ul>
<h2 id="Single-ended输入模式"><a href="#Single-ended输入模式" class="headerlink" title="Single-ended输入模式"></a>Single-ended输入模式</h2><p>对于每一个信号源，都有一根线，连接到你所用到的数据采集接口上。</p>
<h2 id="耳机的类型"><a href="#耳机的类型" class="headerlink" title="耳机的类型"></a>耳机的类型</h2><p>从主观来看，耳机分三段耳机和四段耳机，而四段耳机又分为欧标和美标两种。具体的区别如下图：<br><img data-src="/images/2021/11/%E8%80%B3%E6%9C%BA%E7%B1%BB%E5%9E%8B.png" alt="耳机类型"></p>
<ul>
<li><code>三段耳机</code>：线序分别为，L、R、G，没有MIC端，所以三段耳机无法使用mic，只能接受声音，另外，三段耳机L,R线序长度正常，G端比较长</li>
<li><code>四段-美标(CTIA)耳机</code>：线序分别为L,R,G,M，第三阶为GND</li>
<li><code>四段-欧标（OMTP）耳机</code>：线序分别为L,R,M,G，第四段为GND</li>
</ul>
<blockquote>
<p>由于<code>CTIA</code>和<code>OMTP</code>在MIC和GND是相反的，所以会出现有些耳机插入手机上声音很小，按住HOOK将恢复正常，说明耳机和手机不匹配造成。<br><code>国内大部分厂商都使用欧标，所以也有把OMTP叫做国标</code></p>
</blockquote>
<h3 id="如何区分欧标和美标耳机"><a href="#如何区分欧标和美标耳机" class="headerlink" title="如何区分欧标和美标耳机"></a>如何区分欧标和美标耳机</h3><p>区分美标或者欧标，可以简单的用万能表来测量耳机电阻，确定线序中的GND是在第三段或者第四段</p>
<h2 id="Jack结构"><a href="#Jack结构" class="headerlink" title="Jack结构"></a>Jack结构</h2><p>一般常见的Jack都是由5PIN or 6PIN组成，其中PIN脚分别作为<code>HP_OUTL</code>(左声道输出)、<code>HP_OUTR</code>(右声道输出)、<code>HP_DET</code>#(耳机检测)、<code>GROUND</code>(地) &amp; <code>MIC</code>(麦克风)使用</p>
<h3 id="声卡驱动中耳机检测流程"><a href="#声卡驱动中耳机检测流程" class="headerlink" title="声卡驱动中耳机检测流程"></a>声卡驱动中耳机检测流程</h3><ul>
<li><p><code>插入（PLUG IN）</code>： HP_DET#信号由<code>High-&gt;Low</code>，触发IRQ到SOC，进入中断处理函数（即耳机类型检测）；当检测到耳机为4环耳机时，直接上报给系统，并Enable butten press功能；若检测到为3环耳机时，继续检测，直到检测为4环耳机或则检测次数已满，然后将当前耳机状态上报给系统。</p>
</li>
<li><p><code>拔出（PLUG OUT）</code>： HP_DET#信号由<code>Low-&gt;High</code>，触发IRQ到SOC，将当前耳机状态上报系统，并Disable那些和耳机相关的工作；</p>
</li>
</ul>
<h3 id="耳机线控按键"><a href="#耳机线控按键" class="headerlink" title="耳机线控按键"></a>耳机线控按键</h3><p>通常耳机上的线控按钮会有一个或者三个，分别是<code>HOOK</code>，<code>音量+</code>，<code>音量-</code></p>
<p><code>HOOK</code>的作用是由上层负责，底层只需要确保上报了对应的<code>HOOK event</code>事件给上层应用</p>
<h2 id="ALSA中耳机检测-——-ASoC-jack-detection"><a href="#ALSA中耳机检测-——-ASoC-jack-detection" class="headerlink" title="ALSA中耳机检测 —— ASoC jack detection"></a>ALSA中耳机检测 —— ASoC jack detection</h2><p><span class="exturl" data-url="aHR0cHM6Ly93d3cua2VybmVsLm9yZy9kb2MvaHRtbC92NC4xNi9zb3VuZC9zb2MvamFjay5odG1s">https://www.kernel.org/doc/html/v4.16/sound/soc/jack.html<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><span class="exturl" data-url="aHR0cDovL3d3dy5lbGVjZmFucy5jb20vYmFpa2Uvd2FpamllcGVpamlhbi9lcmppLzIwMTkwNTIyOTQwMDA0Lmh0bWw=">手机耳机接线图的工作原理，各种耳机插头接线图<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N1bmZsb3dlcmZzdy9hcnRpY2xlL2RldGFpbHMvNTA0NDIzOTY=">单端（Single-Ended）模式与差分（Differential）模式的区别<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1YW5nXzE2NS9hcnRpY2xlL2RldGFpbHMvODUzMjE5NDU=">rk3399调试alc5651(audio模块)之操作方法<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL3d3dy5hcm1kZXNpZ25lci5jb20vZG93bmxvYWQvQUxDNTY1MV9EYXRhU2hlZXRfVjAuOTIucGRm">ALC5651_DataSheet_V0.92<i class="fa fa-external-link-alt"></i></span> —— codec</li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NpbmF0XzM0NjA2MDY0L2FydGljbGUvZGV0YWlscy83NzkzMjgxNg==">【audio】耳机插拔&#x2F;线控按键识别流程<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vUGV0ZXItQ2hlbi9wLzM5OTkyMTIuaHRtbA==">耳机jack构造及在应用时可能出现的问题<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>设备驱动</category>
        <category>音频</category>
      </categories>
      <tags>
        <tag>音频</tag>
        <tag>i2s</tag>
        <tag>codec</tag>
      </tags>
  </entry>
  <entry>
    <title>音频编码格式</title>
    <url>/post/2711c03c.html</url>
    <content><![CDATA[<p>音频编码，主要是指对声音文件的数模转换的过程，由此需要一定的文件格式保存音频文件和音频文件中的数据格式（音频编码格式）</p>
<span id="more"></span>

<h2 id="音频编码"><a href="#音频编码" class="headerlink" title="音频编码"></a>音频编码</h2><p>音频编码的主要作用是将音频采样数据（PCM等）压缩成为音频码流，从而降低音频的数据量,偏于存储和传输。</p>
<h3 id="PCM"><a href="#PCM" class="headerlink" title="PCM"></a>PCM</h3><p>PCM(脉冲编码调制 Pulse Code Modulation)是一种音频的<code>裸数据格式</code>。</p>
<p>PCM音频数据是未经压缩的音频采样数据裸流，它是由模拟信号经过采样、量化、编码转换成的标准的数字音频数据。PCM约定俗成了无损编码，能做到最大程度的无限接近绝对保真。被广泛用于素材保存及音乐欣赏，CD、DVD以及我们常见的WAV文件中均有应用，优点是音质好，缺点是体积大。</p>
<h3 id="RAW"><a href="#RAW" class="headerlink" title="RAW"></a>RAW</h3><p>在一些外国品牌的播放机中名为 BitSream，我们通常称为“源码”。意义是把光盘上的音频格式不加处理地、“原汁原味”地从同轴和光纤输出。这就要求用户的功放具备这种音频格式的解码功能</p>
<h2 id="音频编码格式"><a href="#音频编码格式" class="headerlink" title="音频编码格式"></a>音频编码格式</h2><table>
<thead>
<tr>
<th align="center">编码格式</th>
<th align="left">描述</th>
<th align="left">特点</th>
<th align="left">应用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">WAV</td>
<td align="left">WAV为微软公司（Microsoft）开发的一种声音文件格式,直接给PCM码流数据增加了一个WAV头</td>
<td align="left">无损编码，音质好，体积大</td>
<td align="left">多媒体开发、保存音乐和音效素材</td>
</tr>
<tr>
<td align="center">PM3</td>
<td align="left">MPEG-1 or MPEG-2 Audio Layer III是一种音频压缩技术，（Moving Picture Experts Group Audio Layer III），简称为MP3，是目前最流行的音频编码格式。</td>
<td align="left">有损压缩编码</td>
<td align="left">适合用于比较高要求的音乐欣赏</td>
</tr>
<tr>
<td align="center">AAC</td>
<td align="left">AAC是高级音频编码（Advanced Audio Coding）的缩写，出现于1997年，最初是基于MPEG-2的音频编码技术。目的是取代MP3格式</td>
<td align="left">有损压缩技术</td>
<td align="left">128Kbit&#x2F;s以下的音频编码，多用于视频中音频轨的编码</td>
</tr>
<tr>
<td align="center">OPUS</td>
<td align="left">Opus是一个有损声音编码的格式，由Xiph.Org基金会开发，之后由IETF（互联网工程任务组）进行标准化</td>
<td align="left">低比特率低延时，适用于网络上低延迟的即时声音传输</td>
<td align="left">IP语音、视频会议、游戏内聊天、流音乐、甚至远程现场音乐表演</td>
</tr>
<tr>
<td align="center">WMA</td>
<td align="left">Windows Media Audio编码格式</td>
<td align="left">有损压缩，低码率下的音质表现难有对手</td>
<td align="left">在线试听、低要求下的音乐欣赏</td>
</tr>
<tr>
<td align="center">OGG</td>
<td align="left">OGG是一个自由且开放标准的容器格式</td>
<td align="left">有损压缩，可以用比mp3更小的码率实现比mp3更好的音质，高中低码率下均具有良好的表现</td>
<td align="left">用更小的存储空间获得更好的音质（相对MP3）</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>设备驱动</category>
        <category>音频</category>
      </categories>
      <tags>
        <tag>audio</tag>
        <tag>pcm</tag>
      </tags>
  </entry>
  <entry>
    <title>块设备驱动</title>
    <url>/post/51792.html</url>
    <content><![CDATA[<p>块设备传输数据的固定长度为一个sector,因此，输入、输出调度器和块设备的驱动必须管理扇区的数据。<strong>虚拟文件系统-&gt;磁盘设备的中间映射层</strong>，它使用一种逻辑单元来管理磁盘数据，这种逻辑单元被称之为“Block”,一个块相当于一个文件系统里面的最小磁盘存储单元。</p>
<h2 id="块设备"><a href="#块设备" class="headerlink" title="块设备"></a>块设备</h2><ul>
<li><p>块设备（blockdevice）</p>
<p>是一种具有一定结构的随机存取设备，对这种设备的读写是按块进行的，他使用缓冲区来存放暂时的数据，待条件成熟后，从缓存一次性写入设备或者从设备一次性读到缓冲区。</p>
</li>
</ul>
<!---more--->

<ul>
<li><p>字符设备（Character device）</p>
<p>是一个顺序的数据流设备，对这种设备的读写是按字符进行的，而且这些字符是连续地形成一个数据流。他不具备缓冲区，所以对这种设备的读写是实时的。</p>
</li>
</ul>
<h2 id="块设备的驱动框架"><a href="#块设备的驱动框架" class="headerlink" title="块设备的驱动框架"></a>块设备的驱动框架</h2><p><img data-src="/images/block.png" alt="块设备驱动框架"></p>
<blockquote>
<p>块设备的应用在Linux中是一个完整的子系统。</p>
</blockquote>
<p>在Linux中，驱动对块设备的输入或输出(I&#x2F;O)操作，都会向块设备发出一个请求，在驱动中用request结构体描述。但对于一些磁盘设备而言请求的速度很慢，这时候内核就提供一种队列的机制把这些I&#x2F;O请求添加到队列中（即：请求队列），在驱动中用request_queue结构体描述。在向块设备提交这些请求前内核会先执行请求的合并和排序预操作，以提高访问的效率，然后再由内核中的I&#x2F;O调度程序子系统来负责提交  I&#x2F;O 请求，  调度程序将磁盘资源分配给系统中所有挂起的块 I&#x2F;O  请求，其工作是管理块设备的请求队列，决定队列中的请求的排列顺序以及什么时候派发请求到设备。</p>
<p>由通用块层(Generic Block Layer)负责维持一个I&#x2F;O请求在上层文件系统与底层物理磁盘之间的关系。在通用块层中，通常用一个bio结构体来对应一个I&#x2F;O请求。</p>
<p>Linux提供了一个gendisk数据结构体，用来表示一个独立的磁盘设备或分区，用于对底层物理磁盘进行访问。在gendisk中有一个类似字符设备中file_operations的硬件操作结构指针，是block_device_operations结构体。</p>
<p>当多个请求提交给块设备时，执行效率依赖于请求的顺序。如果所有的请求是同一个方向（如：写数据），执行效率是最大的。内核在调用块设备驱动程序例程处理请求之前，先收集I&#x2F;O请求并将请求排序，然后，将连续扇区操作的多个请求进行合并以提高执行效率（内核算法会自己做，不用你管），对I&#x2F;O请求排序的算法称为电梯算法（elevator algorithm）。电梯算法在I&#x2F;O调度层完成。内核提供了不同类型的电梯算法.</p>
<h3 id="电梯算法"><a href="#电梯算法" class="headerlink" title="电梯算法"></a>电梯算法</h3><p>1 noop（实现简单的FIFO，基本的直接合并与排序）,<br>2 anticipatory（延迟I&#x2F;O请求，进行临界区的优化排序），<br>3 Deadline（针对anticipatory缺点进行改善，降低延迟时间）,<br>4 Cfq（均匀分配I&#x2F;O带宽，公平机制）<br>PS：其实IO调度层（包括请求合并排序算法）是不需要用户管的，内核已经做好</p>
<h3 id="相关数据结构"><a href="#相关数据结构" class="headerlink" title="相关数据结构"></a>相关数据结构</h3><p>block_device:      描述一个分区或整个磁盘对内核的一个块设备实例<br>gendisk:               描述一个通用硬盘（generic hard disk）对象。<br>hd_struct:             描述分区应有的分区信息<br>bio:                        描述块数据传送时怎样完成填充或读取块给driver<br>request:                描述向内核请求一个列表准备做队列处理。<br>request_queue:  描述内核申请request资源建立请求链表并填写BIO形成队列。</p>
<h2 id="驱动的实现"><a href="#驱动的实现" class="headerlink" title="驱动的实现"></a>驱动的实现</h2>]]></content>
      <categories>
        <category>设备驱动</category>
        <category>驱动</category>
      </categories>
      <tags>
        <tag>驱动</tag>
        <tag>块设备</tag>
      </tags>
  </entry>
  <entry>
    <title>MMC子系统</title>
    <url>/post/24681.html</url>
    <content><![CDATA[<h2 id="MMC子系统"><a href="#MMC子系统" class="headerlink" title="MMC子系统"></a>MMC子系统</h2><p>系统框架：</p>
<p><img data-src="/images/mmc_framework.png" alt="mmc子系统"></p>
<!---more--->

<p>Linux MMC子系统主要分成三个部分：</p>
<ul>
<li>MMC核心层：完成不同协议和规范的实现，为host层和设备驱动层提供接口函数。MMC核心层由三个部分组成：MMC，SD和SDIO，分别为三类设备驱动提供接口函数；</li>
<li>Host 驱动层：针对不同主机端的SDHC、MMC控制器的驱动；</li>
<li>Client 驱动层：针对不同客户端的设备驱动程序。如SD卡、T-flash卡、SDIO接口的GPS和wi-fi等设备驱动。</li>
</ul>
<h2 id="代码结构"><a href="#代码结构" class="headerlink" title="代码结构"></a>代码结构</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── card</span><br><span class="line">├── core</span><br><span class="line">└── host</span><br></pre></td></tr></table></figure>
<p>MMC子系统代码主要在drivers&#x2F;mmc目录下，共有三个目录：</p>
<ul>
<li>Card：与块设备调用相关驱动，如MMC&#x2F;SD卡设备驱动，SDIOUART；</li>
<li>Core：整个MMC的核心层，这部分完成不同协议和规范的实现，为host层和设备驱动层提供接口函数。</li>
<li>Host：针对不同主机端的SDHC、MMC控制器的驱动，这部分需要由驱动工程师来完成；</li>
</ul>
<h2 id="注册流程"><a href="#注册流程" class="headerlink" title="注册流程"></a>注册流程</h2><p>在linux系统中，系统启动时将加载相关配置的驱动模块，而各模块的加载将通过各自之间相应的结构关系进行先后顺序进行<a href="/posts/linux_kernel_initcall.md">设备注册</a>，下面是mmc子系统的注册流程</p>
<blockquote>
<p>core —&gt; host —&gt; card</p>
</blockquote>
<ol>
<li>core层的注册主要创建两条虚拟总线mmc_bus和sdio_bus，为host层</li>
<li>host注册主要为相关控制器的初始化及配置参数</li>
<li>card层主要用于与block设备进行绑定，为数据读写准备</li>
</ol>
<h2 id="MMC控制器驱动的软件框架"><a href="#MMC控制器驱动的软件框架" class="headerlink" title="MMC控制器驱动的软件框架"></a>MMC控制器驱动的软件框架</h2><p>在这里主要以符合sdhci标准的mmc控制器为例，结合sdhci驱动说明mmc的工作流程。</p>
<p>驱动的总体框架：</p>
<p><img data-src="/images/mmc_software_struct.png" alt="mmc驱动软件框架"></p>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>mmc子系统是将msc（mobile storage controller）控制器及其该控制器适配的相关外设中的细节屏蔽掉而抽象出来的一种框架。<br>主要将控制器和卡抽象成为不同的结构mmc_host和mmc_card.</p>
<h3 id="mmc-host"><a href="#mmc-host" class="headerlink" title="mmc_host"></a>mmc_host</h3><p>  该结构体主要为msc控制器所抽象化的一个对象，用于对当前控制器的描述。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mmc_host</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span>		*<span class="title">parent</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span>		<span class="title">class_dev</span>;</span></span><br><span class="line"><span class="type">int</span>			index;</span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">mmc_host_ops</span> *<span class="title">ops</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mmc_ios</span>		<span class="title">ios</span>;</span>		<span class="comment">/* current io bus settings */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mmc_card</span>		*<span class="title">card</span>;</span>		<span class="comment">/* device attached to this host */</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">mmc_bus_ops</span> *<span class="title">bus_ops</span>;</span>	<span class="comment">/* current bus driver */</span></span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span>		private[<span class="number">0</span>] ____cacheline_aligned;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>以上为该结构体的主要成员（由于成员变量过多省略部分）</p>
<ol>
<li>struct mmc_host_ops *ops</li>
</ol>
<p>该接口主要为控制器的操作函数，用于控制器各种行为的控制，由于不同的控制器的设计和使用流程不同，mmc子系统将控制器的实际操作抽象出来，为驱动开发人员，根据实际要求进行功能实现。<br>主要功能：<br>  1）request<br>    为mmc子系统中的request请求进行数据处理，其中包含对cmd命令的发送和data数据的传输（PIO，DMA）<br>  2）set_ios<br>    主要设置控制器的各种参数，包括时钟，电压，总线宽度及驱动类型（驱动类型跟卡自身的属性相关）等。<br>  3）get_sd<br>    主要由于对卡的探测，实现热插拔功能（一般可能过gpio中断实现）</p>
<ol start="2">
<li>struct mmc_bus_ops</li>
</ol>
<p>主要为mmc子系统中的一条虚拟总线的操作接口函数，该接口的实现由mmc子系统自己完成。</p>
<ol start="3">
<li>struct mmc_ios		ios</li>
</ol>
<p>主要为当前总线的设置参数，该总线指控制器和卡实际相接的数据线（cmd，lck，data），主要参数包含set_ios所设置的时钟，电压，总线宽度及驱动类型（驱动类型跟卡自身的属性相关）等参数。</p>
<h3 id="mmc-card"><a href="#mmc-card" class="headerlink" title="mmc_card"></a>mmc_card</h3><p>  主要是与msc控制相连的相关卡的抽象对象，其中主要描述了卡自身的一些属性</p>
<h2 id="初始化控制器"><a href="#初始化控制器" class="headerlink" title="初始化控制器"></a>初始化控制器</h2><h2 id="数据读写"><a href="#数据读写" class="headerlink" title="数据读写"></a>数据读写</h2><p>在mmc驱动的核心是数据的读写，根据sd协议数据的读写流程基本一致。</p>
<blockquote>
<p>cmd + data<br>cmd_line   先发送读写命令<br>data_line  进行数据传输</p>
</blockquote>
<h3 id="读流程"><a href="#读流程" class="headerlink" title="读流程"></a>读流程</h3><p>数据读命令:CMD17和CMD18（single block和multiple block）<br><img data-src="/images/mmc_single_read.png" alt="数据读"><br><strong>注</strong>:多个block和多根数据线读，流程基本一致，主要是在数据传输时，将读的数据分配给了4根数据线。</p>
<h3 id="写流程"><a href="#写流程" class="headerlink" title="写流程"></a>写流程</h3><p>数据读命令:CMD24和CMD25（single block和multiple block）<br><img data-src="/images/mmc_single_write.png" alt="数据写"></p>
<p>注：</p>
<ul>
<li>S: start 起始位[0]</li>
<li>E: end   结束位[1]</li>
</ul>
<table>
<thead>
<tr>
<th>status</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>“010”</td>
<td>数据被接受写入卡中</td>
</tr>
<tr>
<td>“101”</td>
<td>由于CRC错误，数据不被卡接受</td>
</tr>
<tr>
<td>“110”</td>
<td>由于写错误，数据不被卡接受</td>
</tr>
</tbody></table>
<blockquote>
<p>在写的过程中由于控制器需要等到卡将数据全部写完，才视一次传输完成。而在卡写的过程中，<br>只有数据完全写入后，标志数据传输完成的busy位才会返回。同时返回的还有此次写数据后的状态status(CRC校验值)。<br>如果CRC的校验值大于”010”,将代表数据传输失败（如果status为“101”， 表示写数据出现CRC错误）</p>
</blockquote>
<h2 id="mmc中的request处理"><a href="#mmc中的request处理" class="headerlink" title="mmc中的request处理"></a>mmc中的request处理</h2><p>在mmc子系统中将msc控制器和卡初始化完成后，进入数据传输阶段。在此阶段主要维护一个属于当前控制器的一个线程kthread_run(mmc_queue_thread, mq, “mmcqd&#x2F;%d%s”,host-&gt;index, subname ? subname : “”)，mmc_queue_thread线程在一个while(1)循环中现实对block层的request请求队列的数据处理。</p>
<h3 id="维护mmc-queue-thread线程状态"><a href="#维护mmc-queue-thread线程状态" class="headerlink" title="维护mmc_queue_thread线程状态"></a>维护mmc_queue_thread线程状态</h3><ol>
<li>进入该线程将其设置为set_current_state(TASK_INTERRUPTIBLE)</li>
<li>处理request请求数据，set_current_state(TASK_RUNNING)</li>
<li>数据处理完毕后，如果没有需要处理的数据，调用schedule()</li>
</ol>
<h3 id="Block层的request请求队列"><a href="#Block层的request请求队列" class="headerlink" title="Block层的request请求队列"></a>Block层的request请求队列</h3><p>请求队列的组成方式：<br><img data-src="/images/block_request_queue.png" alt="request请求队列"><br>具体的实现方式在block设备驱动继续。</p>
<h3 id="request请求队列的处理"><a href="#request请求队列的处理" class="headerlink" title="request请求队列的处理"></a>request请求队列的处理</h3><ol>
<li>通过blk_fetch_request(q)从request请求队列中取出一个request请求。</li>
<li>如果request请求队列中有需要处理的数据，调用issue_fn(mq, req)的回调函数进行数据处理。</li>
</ol>
<h3 id="一个request请求的处理流程"><a href="#一个request请求的处理流程" class="headerlink" title="一个request请求的处理流程"></a>一个request请求的处理流程</h3><p>这里以multiple block的读写为例进行说明：</p>
<h4 id="写数据的处理"><a href="#写数据的处理" class="headerlink" title="写数据的处理"></a>写数据的处理</h4><p>在一个写操作中的request基本可以分为三类:</p>
<ul>
<li>a. 使用写命令CMD25写1024block的数据写操作</li>
<li>b. 先进行数据同步操作，接着使用cmd13获取卡的状态,判断没有错误后,再使用CMD25写1024block数据</li>
<li>c. 先进行数据同步操作，再单独发送cmd13命令检测卡的状态</li>
</ul>
<blockquote>
<p>注: 一次request请求所传输的数据量有block层设置.在注册card层初始化mmc_queue时,根据block的设置进行配置.<br>mmc_blk_probe-&gt;mmc_blk_alloc-&gt;mmc_blk_alloc_req-&gt;mmc_init_queue-&gt;blk_queue_max_hw_sectors-&gt;blk_limits_max_hw_sectors-&gt;BLK_DEF_MAX_SECTORS&#x3D;1024</p>
</blockquote>
<h4 id="读数据的处理"><a href="#读数据的处理" class="headerlink" title="读数据的处理"></a>读数据的处理</h4><p>在进行读操作时的request,分为两类:</p>
<ul>
<li>a. 携带数据和读命令的request， 及CMD18 + data（512block）</li>
<li>b. 进行数据同步的request</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h2 id="附：相关简写"><a href="#附：相关简写" class="headerlink" title="附：相关简写"></a>附：相关简写</h2><ol>
<li>mmc<br>  mmc（Multi-Media Card）主要指mmc子系统</li>
<li>sd<br>  sd（Secure Digital）拥有两层含义：一种指sd卡，另一种指sd卡协议</li>
<li>emmc<br>  emmc（Embedded Multi Media Card)）同样一种指emmc卡，另一种指emmc协议，该卡的主要存储介质为nand flash，因此也称e-nand<br>3.sdio<br>  sdio（Secure Digital Input and Output Card）一种在sd标准上定义的外设接口。不过其有自己的特有协议标准。主要由于sdio接口的wifi，蓝牙等</li>
</ol>
]]></content>
      <categories>
        <category>设备驱动</category>
        <category>驱动</category>
      </categories>
      <tags>
        <tag>驱动</tag>
        <tag>emmc</tag>
        <tag>mmc</tag>
        <tag>sd</tag>
      </tags>
  </entry>
  <entry>
    <title>vmware文件共享</title>
    <url>/post/36698.html</url>
    <content><![CDATA[<ul>
<li>看这破网速实在是蛋疼，200多兆的更新文件，下载了半个小时。闲来无事就随便写写，这次不知道咋了。一个VMware tool安装完居然找不到共享文件夹。网上找半天解决办法，照着来一遍吧，最简单可是设置成功后，只要系统一挂起或是重启，好像共享有关闭了。写到这突然觉得是不是，重启后VMware共享服务给关了，没有办法自动重启服务。现在想试试可已经重新安装了一遍VMware tool，将open-vm-dkms工具更新后，看能不能重新挂载hgfs文件。<!---more--->
呵呵，这就是现在蛋疼的地方，第一次使用apt-get upgarde 软件名 更新软件，以为是只更新单独软件，谁知道更新了423个软件包。这就是我们小白的痛苦吧，也不敢中断怕软件更新不完整，开个玩笑，呵呵。软件更新是先下载，在进行更新软件操作，我现在正在下载。这个月流量刚开始这点流量不是事。只是希望更新完后，共享文件可以顺利挂载mount -t vmhgfs .host:&#x2F; &#x2F;mnt&#x2F;hgfs 一个回车OK。vmhgfs表示文件系统类型，VMware虚拟操作系统与宿主机之间共享的特定文件类型。根据monut命令的格式，.host:&#x2F; 应该表示需要挂载的文件，没加共享文件名，表示VMware共享的所有宿主机的文件。在虚拟操作系统ubuntu 12.10 下可以使用vmware-hgfsclient命令查看宿主机共享文件名。</li>
<li>终于快下载完了，边写边搜边想，感觉还是不能显示共享文件夹，安装完了试试在说吧。</li>
<li>文件共享终于成功了，还是网络的力量大啊呵呵呵。</li>
</ul>
]]></content>
      <categories>
        <category>软件使用</category>
        <category>vmware</category>
      </categories>
      <tags>
        <tag>vmware</tag>
      </tags>
  </entry>
  <entry>
    <title>redhat更新yum源进行软件在线安装</title>
    <url>/post/44387.html</url>
    <content><![CDATA[<h3 id="yum安装"><a href="#yum安装" class="headerlink" title="yum安装"></a>yum安装</h3><ul>
<li><p>YUM是Redhat Linux在线安装更新及软件的工具，但是这是RHEL5的收费功能，如果没有购买Redhat的服务时不能使用RHEL5的更新源的，会提示注册。由于CentOS是从Redhat演化而来的免费Linux版本，因此可以利用CentOS的yum更新源来实现RHEL5的YUM功能。</p>
</li>
<li><p>配置方法如下：检查yum是否安装，默认情况下都是安装好的，总共4各包</p>
<pre><code>  [root@localhost /]# rpm -qa |grep yum
  yum-3.2.22-20.el5
  yum-security-1.1.16-13.el5
  yum-metadata-parser-1.1.2-3.el5
  yum-updatesd-0.9-2.el5
  yum-rhn-plugin-0.5.4-13.el5
</code></pre>
</li>
</ul>
<!---more--->
<h3 id="更新yum源"><a href="#更新yum源" class="headerlink" title="更新yum源"></a>更新yum源</h3><ul>
<li><p>修改&#x2F;etc&#x2F;yum.conf文件，用下面代码全部覆盖。定义yum更新源，这里使用的是上海交大的CentOS更新源</p>
<pre><code>  [main]

  cachedir=/var/cache/yum

  keepcache=1

  debuglevel=2

  logfile=/var/log/yum.log

  pkgpolicy=newest

  distroverpkg=redhat-release

  tolerant=1

  exactarch=1

  obsoletes=1

  gpgcheck=1

  plugins=1

  [base]
  name=CentOS-5-Base
  #mirrorlist=http://mirrorlist.centos.org/?release=$releasever5&amp;arch=$basearch&amp;repo=os
  #baseurl=http://mirror.centos.org/centos/$releasever/os/$basearch/
  baseurl=http://ftp.sjtu.edu.cn/centos/5/os/$basearch/
  gpgcheck=0
  gpgkey=http://mirror.centos.org/centos/RPM-GPG-KEY-centos5
  #released updates
  [update]
  name=CentOS-5-Updates
  #mirrorlist=http://mirrorlist.centos.org/?release=4&amp;arch=$basearch&amp;repo=updates
  baseurl=http://ftp.sjtu.edu.cn/centos/5/updates/$basearch/
  gpgcheck=0
  gpgkey=http://mirror.centos.org/centos/RPM-GPG-KEY-centos5
  #packages used/produced in the build but not released
  [addons]
  name=CentOS-5-Addons
  #mirrorlist=http://mirrorlist.centos.org/?release=4&amp;arch=$basearch&amp;repo=addons
  baseurl=http://ftp.sjtu.edu.cn/centos/5/addons/$basearch/
  gpgcheck=0
  gpgkey=http://mirror.centos.org/centos/RPM-GPG-KEY-centos5
  #additional packages that may be useful
  [extras]
  name=CentOS-5-Extras
  #mirrorlist=http://mirrorlist.centos.org/?release=4&amp;arch=$basearch&amp;repo=extras
  baseurl=http://ftp.sjtu.edu.cn/centos/5/extras/$basearch/
  gpgcheck=0
  gpgkey=http://mirror.centos.org/centos/RPM-GPG-KEY-centos5
  #additional packages that extend functionality of existing packages
  [centosplus]
  name=CentOS-5-Plus
  #mirrorlist=http://mirrorlist.centos.org/?release=4&amp;arch=$basearch&amp;repo=centosplus
  baseurl=http://ftp.sjtu.edu.cn/centos/5/centosplus/$basearch/
  gpgcheck=0
  enabled=0
  gpgkey=http://mirror.centos.org/centos/RPM-GPG-KEY-centos5
  #contrib - packages by Centos Users
  [contrib]
  name=CentOS-5-Contrib
  #mirrorlist=http://mirrorlist.centos.org/?release=4&amp;arch=$basearch&amp;repo=contrib
  baseurl=http://ftp.sjtu.edu.cn/centos/5/contrib/$basearch/
  gpgcheck=0
  enabled=0
  gpgkey=http://mirror.centos.org/centos/RPM-GPG-KEY-centos5
  # vi dag.repo
  [dag]
  name=Dag RPM Repository for RHEL5
  baseurl=http://ftp.riken.jp/Linux/dag/redhat/el5/en/$basearch/dag/
  enabled=1
  gpgcheck=0
  gpgkey=http://ftp.riken.jp/Linux/dag/packages/RPM-GPG-KEY.dag.txt]
</code></pre>
</li>
<li><p>修改yum.conf配置文件中[main]部分的参数详细说明如下：</p>
<pre><code>  [main] //main开头的块用于对客户端进行配置，在main后也可以指定yum源（不推荐这样做），与/etc/yum.repo.d中指定yum源相同

  cachedir=/var/cache/yum
  #cachedir：yum更新软件时的缓存目录，默认设置为/var/cache/yum
  keepcache=[1 or 0]

  #设置 keepcache=1，yum 在成功安装软件包之后保留缓存的头文件 (headers) 和软件包。默认值为 keepcache=0 不保存

  debuglevel=2
  #debuglevel：Debug信息输出等级，范围为0-10，缺省为2
  logfile=/var/log/yum.log
  #logfile：存放系统更新软件的日志的目录。用户可以到/var/log/yum.log文件去查询自己在过去的日子里都做了哪些更新。
  pkgpolicy=newest
  #包的策略。一共有两个选项，newest和last，这个作用是如果你设置了多个repository，而同一软件在不同的repository中同时存在，yum应该安装哪一个，如果是newest，则yum会安装最新的那个版本。如果是last，则yum会将服务器id以字母表排序，并选择最后的那个服务器上的软件安装。一般都是选newest。
  distroverpkg=redhat-release
  #指定一个软件包，yum会根据这个包判断你的发行版本，默认是redhat-release，也可以是安装的任何针对自己发行版的rpm包。
  tolerant=1
  #如果值为1，则yum会忽略任何的有关包的错误。举例来说，当执行yum来安装baz时，如果baz包已经安装在系统中了，则yum会继续重复安装baz，而不会报错。默认值为1。
  exactarch=1
  #设置为1，则yum只会安装和系统架构匹配的软件包，例如，yum不会将i686的软件包安装在适合i386的系统中。默认为1
  retries=20
  #网络连接发生错误后的重试次数，如果设为0，则会无限重试。默认值为6
  obsoletes=1
  #此选项在进行发行版跨版本升级的时候会用到。
  gpgcheck=1
  #有1和0两个选择，分别代表是否是否进行gpg校验。这个选项如果设置在[main]部分，则对每个repository都有效。默认值为0.
  plugins = 1 //是否启用插件，默认1为允许，0表示不允许
</code></pre>
</li>
<li><p>修改完yum.conf文件，使用下列命令进行配置。</p>
<pre><code>  yum clean all    清楚缓存
  yum makecache    更新生成缓存
</code></pre>
</li>
</ul>
<h3 id="使用yum安装软件"><a href="#使用yum安装软件" class="headerlink" title="使用yum安装软件"></a>使用yum安装软件</h3><h3 id="1-用YUM安装删除软件"><a href="#1-用YUM安装删除软件" class="headerlink" title="1. 用YUM安装删除软件"></a>1. 用YUM安装删除软件</h3><ul>
<li><p>注：Yum（ Yellow dog Updater, Modified）是一个在Fedora和RedHat以及SUSE中的Shell前端软件包管理器。基于RPM包管理，能够从指定的服务器自动下载RPM包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软体包，无须繁琐地一次次下载、安装。</p>
</li>
<li><p>在系统中添加删除软件是常事，yum同样可以胜任这一任务，只要软件是rpm安装的。安装的命令是，yum install xxx，yum会查询数据库，有无这一软件包，如果有，则检查其依赖冲突关系，如果没有依赖冲突，那么最好，下载安装;如果有，则会给出提示，询问是否要同时安装依赖，或删除冲突的包，你可以自己作出判断。删除的命令是，yum remove xxx，同安装一样，yum也会查询数据库，给出解决依赖关系的提示。</p>
</li>
</ul>
<ul>
<li><p>用YUM安装软件包命令：</p>
<pre><code>  yum install xxx
</code></pre>
</li>
<li><p>用YUM删除软件包命令：</p>
<p>  yum remove xxx</p>
</li>
</ul>
<h3 id="2-用YUM查询软件信息"><a href="#2-用YUM查询软件信息" class="headerlink" title="2. 用YUM查询软件信息"></a>2. 用YUM查询软件信息</h3><ul>
<li>我们常会碰到这样的情况，想要安装一个软件，只知道它和某方面有关，但又不能确切知道它的名字。这时yum的查询功能就起作用了。<br>你可以用 yum  search keyword这样的命令来进行搜索，比如我们要则安装一个Instant Messenger,但又不知到底有哪些，这时不妨用yum search messenger这样的指令进行搜索，yum会搜索所有可用rpm的描述，列出所有描述中和messeger有关的rpm包，于是我们可能得到gaim,kopete等等，并从中选择。有时我们还会碰到安装了一个包，但又不知道其用途，我们可以用yum info packagename这个指令来获取信息。</li>
</ul>
<p>　　使用YUM查找软件包命令：</p>
<pre><code>    yum search
</code></pre>
<p>　　列出所有可安装的软件包命令：</p>
<pre><code>    yum list
</code></pre>
<p>　　列出所有可更新的软件包命令：</p>
<pre><code>    yum list updates
</code></pre>
<p>　　列出所有已安装的软件包命令：</p>
<pre><code>    yum list installed
</code></pre>
<p>　　列出所有已安装但不在 Yum Repository 内的软件包命令：</p>
<pre><code>    yum list extras
</code></pre>
<p>　　列出所指定的软件包命令：</p>
<pre><code>    yum list
</code></pre>
<h3 id="Ubuntu中的高级包管理方法apt-get"><a href="#Ubuntu中的高级包管理方法apt-get" class="headerlink" title="Ubuntu中的高级包管理方法apt-get"></a>Ubuntu中的高级包管理方法apt-get</h3><ul>
<li>apt-get的一大好处是极大地减小了所谓依赖关系恶梦的发生几率(dependency hell)，即使是陷入了dependency hell,apt-get也提供了很好的援助手段。通常 apt-get 都和网上的压缩包一起出没，从互联网上下载或是安装。</li>
</ul>
<h3 id="apt方式安装："><a href="#apt方式安装：" class="headerlink" title="apt方式安装："></a>apt方式安装：</h3><ol>
<li>打开一个终端，su -成root用户；</li>
<li>apt-cache search soft 注：soft是您要找的软件的名称或相关信息</li>
<li>假如2中找到了软件soft.version，则用apt-get install soft.version命令安装软件 注：只要您能够上网，只需要用apt-cache search查找软件，用apt-get install软件</li>
</ol>
<ul>
<li><p>常用的APT命令参数</p>
<pre><code>  apt-cache search package 搜索包
  apt-cache show package 获取包的相关信息，如说明、大小、版本等
  sudo apt-get install package 安装包
  sudo apt-get install package - - reinstall 重新安装包
  sudo apt-get -f install 修复安装&quot;-f = --fix-missing&quot;
  sudo apt-get remove package 删除包
  sudo apt-get remove package - - purge 删除包，包括删除配置文件等
  sudo apt-get update 更新源sudo apt-get upgrade 更新已安装的包
  sudo apt-get dist-upgrade 升级系统
  sudo apt-get dselect-upgrade 使用 dselect 升级
  apt-cache depends package 了解使用依赖
  apt-cache rdepends package 是查看该包被哪些包依赖
  sudo apt-get build-dep package 安装相关的编译环境
  apt-get source package 下载该包的源代码
  sudo apt-get clean &amp;&amp; sudo apt-get autoclean 清理无用的包
  sudo apt-get check 检查是否有损坏的依赖
</code></pre>
</li>
</ul>
<h2 id="其他软件安装技巧"><a href="#其他软件安装技巧" class="headerlink" title="其他软件安装技巧"></a>其他软件安装技巧</h2><h3 id="1-linux下安装软件，如何知道软件安装位置"><a href="#1-linux下安装软件，如何知道软件安装位置" class="headerlink" title="1. linux下安装软件，如何知道软件安装位置"></a>1. linux下安装软件，如何知道软件安装位置</h3><blockquote>
<p>注：一般的软件的默认安装目录在&#x2F;usr&#x2F;local或者&#x2F;opt里，可以到那里去找找.</p>
</blockquote>
<ul>
<li><p>指令名称：whereis</p>
</li>
<li><p>功能介绍：在特定目录中查找符合条件的文件。这些文件的烈性应属于原始代码，二进制文件，或是帮助文件。</p>
</li>
<li><p>语法格式：whereis [-bfmsu][-B &lt;目录&gt;…][-M &lt;目录&gt;…][-S &lt;目录&gt;…][文件…]</p>
</li>
<li><p>常用参数说明：</p>
</li>
</ul>
<p>　-b 　只查找二进制文件。<br>　-B &lt;目录&gt; 　只在设置的目录下查找二进制文件。<br>　-f 　不显示文件名前的路径名称。<br>　-m 　只查找说明文件。<br>　-M &lt;目录&gt; 　只在设置的目录下查找说明文件。<br>　-s 　只查找原始代码文件。<br>　-S &lt;目录&gt; 　只在设置的目录下查找原始代码文件。<br>　-u 　查找不包含指定类型的文件。</p>
<ul>
<li>应用：#whereis  软件名   –&gt;查看软件安装路径</li>
<li>#which  软件名     –&gt;软件软件的运行路径</li>
</ul>
<h3 id="2-通过rpm包管理器安装的软件："><a href="#2-通过rpm包管理器安装的软件：" class="headerlink" title="2. 通过rpm包管理器安装的软件："></a>2. 通过rpm包管理器安装的软件：</h3><ul>
<li>rpm包</li>
</ul>
<ul>
<li><p>可以用命令：</p>
<pre><code>  #rpm –ql 包名           如 rpm -ql gcc 来查看gcc的文件都安装到哪里去了
  #rpm -qa | grep 包名   来查看有没有安装这个包 ，
  #rpm -qa              查看全部已经安装的包名
</code></pre>
</li>
</ul>
<ul>
<li>deb包</li>
</ul>
<ul>
<li><p>可以用命令：</p>
<pre><code>  #dpkg -L 包名 查看如 dpkg -L gcc 来查看gcc的文件。
  #dpkg -l | grep 包名  来查看有没有安装某个包 ，
  # dpkg -l            是查看全部包的
</code></pre>
</li>
</ul>
<h2 id="其他更多软件安装方法技巧"><a href="#其他更多软件安装方法技巧" class="headerlink" title="其他更多软件安装方法技巧"></a>其他更多软件安装方法技巧</h2><blockquote>
<p>参考[<span class="exturl" data-url="aHR0cDovL2Jsb2cuY2hpbmF1bml4Lm5ldC91aWQtMjg3NjkyMDktaWQtNDI1NzQ1MS5odG1sXTpodHRwOi8vYmxvZy5jaGluYXVuaXgubmV0L3VpZC0yODc2OTIwOS1pZC00MjU3NDUxLmh0bWw=">http://blog.chinaunix.net/uid-28769209-id-4257451.html]:http://blog.chinaunix.net/uid-28769209-id-4257451.html<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
]]></content>
      <categories>
        <category>软件使用</category>
        <category>yum</category>
      </categories>
      <tags>
        <tag>yum</tag>
        <tag>redhat</tag>
      </tags>
  </entry>
  <entry>
    <title>Cgroup</title>
    <url>/post/10807.html</url>
    <content><![CDATA[<p>CGroup 是 Control Groups 的缩写，是 Linux 内核提供的一种可以限制、记录、隔离进程组 (process groups) 所使用的物力资源 (如 cpu memory i&#x2F;o 等等) 的机制。</p>
<p>CGroup 是将任意进程进行分组化管理的 Linux 内核功能。CGroup 本身是提供将进程进行分组化管理的功能和接口的基础结构，I&#x2F;O 或内存的分配控制等具体的资源管理功能是通过这个功能来实现的。这些具体的资源管理功能称为 CGroup 子系统或控制器。CGroup 子系统有控制内存的 Memory 控制器、控制进程调度的 CPU 控制器等。运行中的内核可以使用的 Cgroup 子系统由<code>/proc/cgroup</code> 来确认，根据系统对资源的需求，这个根进程组将被进一步细分为子进程组，子进程组内的进程是根进程组内进程的子集。而这些子进程组很有可能继续被进一步细分，最终，系统内所有的进程组形成一颗具有层次等级（hierarchy）关系的进程组树。</p>
<p><img data-src="/images/cgroup/cgroup_tree.jpeg" alt="cgroup tree"></p>
<span id="more"></span>
<h2 id="Cgroup虚拟文件系统"><a href="#Cgroup虚拟文件系统" class="headerlink" title="Cgroup虚拟文件系统"></a>Cgroup虚拟文件系统</h2><blockquote>
<p>CGroup 提供了一个 CGroup 虚拟文件系统，作为进行分组管理和各子系统设置的用户接口。要使用 CGroup，必须挂载 CGroup 文件系统。这时通过挂载选项指定使用哪个子系统。</p>
</blockquote>
<p><img data-src="/images/cgroup/cgroup_struct.jpeg" alt="cgroup stru"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@buildroot /]# mount -t cgroup cgroup /mnt/</span><br><span class="line">[root@buildroot /]# ls /mnt/</span><br><span class="line">blkio.reset_stats                cpuset.mem_exclusive</span><br><span class="line">cgroup.clone_children            cpuset.mem_hardwall</span><br><span class="line">cgroup.event_control             cpuset.memory_migrate</span><br><span class="line">cgroup.procs                     cpuset.memory_pressure</span><br><span class="line">cgroup.sane_behavior             cpuset.memory_pressure_enabled</span><br><span class="line">cpu.cfs_period_us                cpuset.memory_spread_page</span><br><span class="line">cpu.cfs_quota_us                 cpuset.memory_spread_slab</span><br><span class="line">cpu.rt_period_us                 cpuset.mems</span><br><span class="line">cpu.rt_runtime_us                cpuset.sched_load_balance</span><br><span class="line">cpu.shares                       cpuset.sched_relax_domain_level</span><br><span class="line">cpu.stat                         devices.allow</span><br><span class="line">cpuacct.stat                     devices.deny</span><br><span class="line">cpuacct.usage                    devices.list</span><br><span class="line">cpuacct.usage_percpu             notify_on_release</span><br><span class="line">cpuset.cpu_exclusive             release_agent</span><br><span class="line">cpuset.cpus                      tasks</span><br></pre></td></tr></table></figure>
<p>各个子系统的挂载：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mount -t cgroup -o cpu cgroup /mnt/</span><br><span class="line">mount -t cgroup -o cpu,cpuset cgroup /mnt/</span><br><span class="line">mount -t cgroup -o cpu,cpuset,devices cgroup /mnt/</span><br></pre></td></tr></table></figure>

<p>CGroup 支持的文件种类:</p>
<table>
<thead>
<tr>
<th align="center">文件</th>
<th align="center">R&#x2F;W</th>
<th align="center">用途</th>
</tr>
</thead>
<tbody><tr>
<td align="center">release_agent</td>
<td align="center">RW</td>
<td align="center">删除分组时执行的命令，这个文件只存在于根分组</td>
</tr>
<tr>
<td align="center">notify_on_release</td>
<td align="center">RW</td>
<td align="center">设置是否执行 release_agent。为 1 时执行</td>
</tr>
<tr>
<td align="center">tasks</td>
<td align="center">RW</td>
<td align="center">属于分组的线程 TID 列表(进程ID)</td>
</tr>
<tr>
<td align="center">cgroup.procs</td>
<td align="center">R</td>
<td align="center">属于分组的进程 PID 列表。仅包括多线程进程的线程 leader 的 TID，这点与 tasks 不同</td>
</tr>
<tr>
<td align="center">cgroup.event_control</td>
<td align="center">RW</td>
<td align="center">监视状态变化和分组删除事件的配置文件</td>
</tr>
</tbody></table>
<h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><ul>
<li>子系统（subsystem）<br>一个子系统就是一个资源控制器，比如 cpu 子系统就是控制 cpu 时间分配的一个控制器。子系统必须附加（attach）到一个层级上才能起作用，一个子系统附加到某个层级以后，这个层级上的所有控制族群都受到这个子系统的控制。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@buildroot ~]# cat /proc/cgroups</span><br><span class="line">#subsys_name      hierarchy       num_cgroups     enabled</span><br><span class="line">cpuset    1       1       1</span><br><span class="line">cpu       1       1       1</span><br><span class="line">cpuacct   1       1       1</span><br><span class="line">devices   1       1       1</span><br><span class="line">freezer   1       1       1</span><br><span class="line">blkio     1       1       1</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Version: Linux-3.10.14</p>
</blockquote>
</li>
</ul>
<p>1.<code>cpuset</code>: 为cgroup中的任务分配独立CPU（SMP多核）和内存节点<br>2.<code>cpu</code>： 提供调度程序对CPU的cgroup任务访问<br>3.<code>cpuacct</code>： 自动生成cgroup中任务所使用的CPU报告<br>4.<code>devices</code>: 允许或拒绝cgroup中的任务访问设备<br>5.<code>freezer</code>：挂起或者恢复cgroup中的任务<br>6.<code>blkio</code>： 块设备输入输出的限制<br>7.<code>perf_event</code>：  增加了对每group的监测跟踪的能力，即可以监测属于某个特定的group的所有线程以及运行在特定CPU上的线程，此功能对于监测整个group非常有用，<span class="exturl" data-url="aHR0cHM6Ly9sd24ubmV0L0FydGljbGVzLzQyMTU3NC8=">https://lwn.net/Articles/421574/<i class="fa fa-external-link-alt"></i></span></p>
<ul>
<li><p>层级（hierarchy）<br>控制族群可以组织成 hierarchical 的形式，既一颗控制族群树。控制族群树上的子节点控制族群是父节点控制族群的孩子，继承父控制族群的特定的属性；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@buildroot ~]# cat /proc/cgroups</span><br><span class="line">#subsys_name      hierarchy       num_cgroups     enabled</span><br><span class="line">cpuset    0       1       1</span><br><span class="line">cpu       0       1       1</span><br><span class="line">cpuacct   0       1       1</span><br><span class="line">devices   0       1       1</span><br><span class="line">freezer   0       1       1</span><br><span class="line">blkio     0       1       1</span><br><span class="line">[root@buildroot ~]# mount -t cgroup -o cpu cgroup /mnt/cpu/</span><br><span class="line">[root@buildroot ~]# mount -t cgroup -o cpuset cgroup /mnt/cpuset/</span><br><span class="line">[root@buildroot ~]# mount -t cgroup -o devices cgroup /mnt/blkio/</span><br><span class="line">[root@buildroot ~]# mount -t cgroup -o blkio cgroup /mnt/blkio/</span><br><span class="line">[root@buildroot ~]# cat /proc/cgroups</span><br><span class="line">#subsys_name      hierarchy       num_cgroups     enabled</span><br><span class="line">cpuset    0       1       1</span><br><span class="line">cpu       4       1       1</span><br><span class="line">cpuacct   0       1       1</span><br><span class="line">devices   0       1       1</span><br><span class="line">freezer   0       1       1</span><br><span class="line">blkio     0       1       1</span><br></pre></td></tr></table></figure>
<blockquote>
<p>一个子系统最多只能附加到一个层级</p>
</blockquote>
</li>
<li><p>控制族群（control group）</p>
</li>
</ul>
<p>控制族群就是一组按照某种标准划分的进程。Cgroups 中的资源控制都是以控制族群为单位实现。一个进程可以加入到某个控制族群，也从一个进程组迁移到另一个控制族群。一个进程组的进程可以使用 cgroups 以控制族群为单位分配的资源，同时受到 cgroups 以控制族群为单位设定的限制.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@buildroot cpu]# mkdir aaa</span><br><span class="line">[root@buildroot cpu]# mkdir bbb</span><br><span class="line">[root@buildroot cpu]# ls</span><br><span class="line">aaa/                   cgroup.sane_behavior   cpu.shares</span><br><span class="line">bbb/                   cpu.cfs_period_us      cpu.stat</span><br><span class="line">cgroup.clone_children  cpu.cfs_quota_us       notify_on_release</span><br><span class="line">cgroup.event_control   cpu.rt_period_us       release_agent</span><br><span class="line">cgroup.procs           cpu.rt_runtime_us      tasks</span><br><span class="line">[root@buildroot cpu]# ls aaa/ bbb/</span><br><span class="line">aaa/:</span><br><span class="line">cgroup.clone_children  cpu.cfs_quota_us       cpu.stat</span><br><span class="line">cgroup.event_control   cpu.rt_period_us       notify_on_release</span><br><span class="line">cgroup.procs           cpu.rt_runtime_us      tasks</span><br><span class="line">cpu.cfs_period_us      cpu.shares</span><br><span class="line"></span><br><span class="line">bbb/:</span><br><span class="line">cgroup.clone_children  cpu.cfs_quota_us       cpu.stat</span><br><span class="line">cgroup.event_control   cpu.rt_period_us       notify_on_release</span><br><span class="line">cgroup.procs           cpu.rt_runtime_us      tasks</span><br><span class="line">cpu.cfs_period_us      cpu.shares</span><br></pre></td></tr></table></figure>

<ul>
<li>任务（task）<br>在 cgroups 中，任务就是系统的一个进程<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@buildroot cpu]# cat tasks</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h3><ul>
<li>每次在系统中创建新层级时，该系统中的所有任务都是那个层级的默认 cgroup（我们称之为 <code>root cgroup</code>，此cgroup在创建层级时自动创建，后面在该层级中创建的cgroup都是此cgroup的后代）的初始成员;</li>
</ul>
<p><code>root cgroup:</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@buildroot mnt]# cat tasks</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p><code>subsys cgroup:</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@buildroot mnt]# mkdir aaa</span><br><span class="line">[root@buildroot mnt]# cd aaa/</span><br><span class="line">[root@buildroot aaa]# cat tasks</span><br></pre></td></tr></table></figure>
<ul>
<li>一子系统最多只能附加到一个层级;</li>
<li>一个层级可以附加多个子系统;</li>
<li>一个任务可以是多个cgroup的成员，但是这些cgroup必须在不同的层级;</li>
<li>系统中的进程（任务）创建子进程（任务）时，该子任务自动成为其父进程所在 cgroup的成员。然后可根据需要将该子任务移动到不同的 cgroup 中，但开始时它总是继承其父任务的cgroup。</li>
</ul>
<h2 id="限制cpu的资源"><a href="#限制cpu的资源" class="headerlink" title="限制cpu的资源"></a>限制cpu的资源</h2><p>CPU资源的控制，主要是对CPU计算的控制，可以最大化的利用CPU资源。而<code>进程</code>是对CPU资源的利用实体。</p>
<h3 id="实时进程控制-–-系统整体"><a href="#实时进程控制-–-系统整体" class="headerlink" title="实时进程控制 – 系统整体"></a>实时进程控制 – 系统整体</h3><blockquote>
<p>控制实时进程的CPU资源占用</p>
</blockquote>
<ul>
<li>获取当前系统的设置<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">sysctl -n kernel.sched_rt_period_us   <span class="comment"># 实时进程调度的单位CPU时间 1 秒</span></span></span><br><span class="line">1000000</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">sysctl -n kernel.sched_rt_runtime_us  <span class="comment"># 实时进程在 1 秒中实际占用的CPU时间, 0.95秒</span></span></span><br><span class="line">950000</span><br></pre></td></tr></table></figure></li>
<li>设置实时进程占用CPU时间<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">sysctl -w kernel.sched_rt_runtime_us=970000 <span class="comment"># 设置实时进程每1秒中只占0.97秒的CPU时间</span></span></span><br><span class="line">kernel.sched_rt_runtime_us = 970000</span><br></pre></td></tr></table></figure>
<blockquote>
<p>sysctl -w : 临时修改指定参数的值</p>
</blockquote>
</li>
</ul>
<h3 id="实时进程控制-–-系统部分"><a href="#实时进程控制-–-系统部分" class="headerlink" title="实时进程控制 – 系统部分"></a>实时进程控制 – 系统部分</h3><blockquote>
<p>通过cgroup对一组进程中的实时进程的CPU资源进行控制.</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">mount -t cgroup cgroup -o cpu /mnt/</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">ls</span></span></span><br><span class="line">cgroup.clone_children  cpu.cfs_quota_us       notify_on_release</span><br><span class="line">cgroup.event_control   cpu.rt_period_us       release_agent</span><br><span class="line">cgroup.procs           cpu.rt_runtime_us      tasks</span><br><span class="line">cgroup.sane_behavior   cpu.shares</span><br><span class="line">cpu.cfs_period_us      cpu.stat</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">cat</span> cpu.rt_period_us cpu.rt_runtime_us</span></span><br><span class="line">1000000</span><br><span class="line">950000</span><br></pre></td></tr></table></figure>

<p>通过虚拟文件系统mount出CPU子系统，为CPU子系统的根节点，其可以控制整个系统的进程<code>tasks</code>,因此如果想对部分实时进程进行控制，需要创建子cgroup，并将需要控制的进程搬到新的cgroup中。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">mkdir</span> rt_ctl</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">cd</span> rt_ctl/</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">echo</span> PID &gt; tasks</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">echo</span> 1000000 &gt; cpu.rt_period_us</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">echo</span> 920000 &gt; cpu.rt_runtime_us</span></span><br></pre></td></tr></table></figure>
<p>通过配置<code>cpu.rt_period_us</code>和<code>cpu.rt_runtime_us</code>就可以对<code> rt_ctl cgroup</code> 中的进程组中的实时进程进行CPU使用时间的控制.</p>
<p>在子cgroup中，对相关子系统进行修改时，该子系统的相关属性小于父cgroup属性的相应值。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">echo</span> 960000 &gt; cpu.rt_runtime_us</span></span><br><span class="line">sh: write error: Invalid arguments</span><br></pre></td></tr></table></figure>

<h2 id="限制进程的内存资源"><a href="#限制进程的内存资源" class="headerlink" title="限制进程的内存资源"></a>限制进程的内存资源</h2><p>内核配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Location:</span><br><span class="line">  -&gt; General setup</span><br><span class="line">    -&gt; Control Group support (CGROUPS [=y])</span><br><span class="line">      -&gt; Resource counters (RESOURCE_COUNTERS [=y])</span><br><span class="line">        -&gt; Memory Resource Controller for Control Groups (MEMCG [=y])</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">mount -t cgroup -o memory cgroup /mnt/</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># cd /mnt/</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">ls</span></span></span><br><span class="line">cgroup.clone_children               memory.kmem.usage_in_bytes</span><br><span class="line">cgroup.event_control                memory.limit_in_bytes</span><br><span class="line">cgroup.procs                        memory.max_usage_in_bytes</span><br><span class="line">cgroup.sane_behavior                memory.move_charge_at_immigrate</span><br><span class="line">memory.failcnt                      memory.oom_control</span><br><span class="line">memory.force_empty                  memory.pressure_level</span><br><span class="line">memory.kmem.failcnt                 memory.soft_limit_in_bytes</span><br><span class="line">memory.kmem.limit_in_bytes          memory.stat</span><br><span class="line">memory.kmem.max_usage_in_bytes      memory.swappiness</span><br><span class="line">memory.kmem.slabinfo                memory.usage_in_bytes</span><br><span class="line">memory.kmem.tcp.failcnt             memory.use_hierarchy</span><br><span class="line">memory.kmem.tcp.limit_in_bytes      notify_on_release</span><br><span class="line">memory.kmem.tcp.max_usage_in_bytes  release_agent</span><br><span class="line">memory.kmem.tcp.usage_in_bytes      tasks</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>memsw</code>:表示虚拟内存，不带<code>memsw</code>的仅包括物理内存</p>
</blockquote>
<ul>
<li><p><code>limit_in_bytes</code> 是用来限制内存使用 ,memory.memsw.limit_in_bytes 必须大于或等于 memory.limit_in_byte。要解除内存限制，对应的值设为 -1</p>
<blockquote>
<p>这种方式限制进程内存占用会有个风险。当进程试图占用的内存超过限制时，会触发 oom ，导致进程直接被杀，从而造成可用性问题。即使关闭控制组的 oom killer，在内存不足时，进程虽然不会被杀，但是会长时间进入 D 状态（等待系统调用的不可中断休眠），并被放到 OOM-waitqueue 等待队列中， 仍然导致服务不可用。因此，用 memory.limit_in_bytes 或 memory.memsw.limit_in_bytes 限制进程内存占用仅应当作为一个保险，避免在进程异常时耗尽系统资源</p>
</blockquote>
</li>
<li><p><code>memory.oom_control</code>：内存超限之后的OOM行为控制</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">cat</span> memory.oom_control</span></span><br><span class="line">oom_kill_disable 0</span><br><span class="line">under_oom 0</span><br></pre></td></tr></table></figure>
<blockquote>
<p>关闭oom killer： <code>oom_kill_disable为1</code></p>
</blockquote>
</li>
<li><p><code>memory.soft_limit_in_bytes</code>: memory.limit_in_bytes 的不同是，这个限制并不会阻止进程使用超过限额的内存，只是在系统内存足够时，会优先回收超过限额的内存，使之向限定值靠拢。</p>
</li>
<li><p><code>memory.usage_in_bytes</code>: 当前使用量</p>
</li>
<li><p><code>memory.max_usage_in_bytes</code>: 最高使用量</p>
</li>
<li><p><code>memory.failcnt</code>: 发生的缺页次数（申请内存失败的次数)</p>
</li>
<li><p><code>memory.stat</code>: 就是内存使用情况报告了。包括当前资源总量、使用量、换页次数、活动页数量等等</p>
</li>
</ul>
<h2 id="进程迁移"><a href="#进程迁移" class="headerlink" title="进程迁移"></a>进程迁移</h2><p>在多核处理器时，如果想将一个进程指定到特定的CPU上进行执行，可通过<code>cpuset</code>子系统实现。</p>
<blockquote>
<p><code>cpuset</code>:针对 CPU 核心进行隔离，其实就是把要运行的进程绑定到指定的核心上运行，通过让不同的进程占用不同的核心，以达到运算资源隔离的目的。为cgroup中的任务分配独立<code>CPU（在多核系统）</code>和<code>内存节点</code>。</p>
</blockquote>
<ol>
<li>挂载 cgroup 文件系统, 并指定 -o cpuset</li>
<li>指定 A 的物理CPU为 0 (双核CPU的每个核编号分别是 CPU0, CPU1)</li>
<li>指定 B 的物理CPU也为 1</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">mount -t cgroup -o cpuset cgroup /mnt/</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">cat</span> cpuset.cpus cpuset.mems</span></span><br><span class="line">0-1</span><br><span class="line">0</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">cd</span> /mnt/</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">mkdir</span> A B <span class="comment"># 创建子cgroup A 和 B</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">cat</span> A/cpuset.cpus</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">cat</span> B/cpuset.cpus</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">echo</span> 0 &gt; A/cpuset.cpus <span class="comment"># 设置A组绑定到CPU0</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">echo</span> 1 &gt; B/cpuset.cpus <span class="comment"># 设置B组绑定到CPU1</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">echo</span> 0 &gt; A/cpuset.mems <span class="comment"># 设置A组绑定内存</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">echo</span> 0 &gt; B/cpuset.mems <span class="comment"># 设置A组绑定内存</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">echo</span> pid1 &gt; A/tasks <span class="comment">#将B组进程迁入A组</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">echo</span> pid2 &gt; B/tasks <span class="comment">#将A组进程迁入B组</span></span></span><br></pre></td></tr></table></figure>
<blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash"><span class="comment"># echo $$ &gt; tasks</span></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">sh: write error: No space left on devices</span></span><br></pre></td></tr></table></figure>
<p><strong>原因</strong>：没有配置<code>cpuset.mems</code></p>
</blockquote>
<h3 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h3><blockquote>
<p>ltp-full-20140115&#x2F;testcases&#x2F;kernel&#x2F;controllers&#x2F;cpuctl&#x2F;cpuctl_test02.c</p>
</blockquote>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuaWJtLmNvbS9kZXZlbG9wZXJ3b3Jrcy9jbi9saW51eC8xNTA2X2Nncm91cC8=">CGroup 介绍、应用实例及原理描述<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9hY2Nlc3MucmVkaGF0LmNvbS9kb2N1bWVudGF0aW9uL3poLWNuL3JlZF9oYXRfZW50ZXJwcmlzZV9saW51eC82L2h0bWwvcmVzb3VyY2VfbWFuYWdlbWVudF9ndWlkZS9jaDAx">控制族群（CGROUP）<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGp5MTk4ODEyMy9hcnRpY2xlL2RldGFpbHMvNDgwMzI1Nzc=">Linux内核工程导论——CGroup子系统<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYXJub2xkbHUvYXJ0aWNsZS9kZXRhaWxzLzUyOTQ1MjUy">Linux资源控制-使用cgroup控制CPU和内存<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC9kYzMxNDA2OTllNzk=">cgroup实践-资源控制<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vYWNvb2wvcC82ODUyMjUwLmh0bWw=">cgroup原理简析:vfs文件系统<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL3d3dy5pbmZvcS5jb20vY24vYXJ0aWNsZXMvZG9ja2VyLWtlcm5lbC1rbm93bGVkZ2UtY2dyb3Vwcy1yZXNvdXJjZS1pc29sYXRpb24=">Docker背后的内核知识——cgroups资源限制<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prMTk4MzEwL2FydGljbGUvZGV0YWlscy85Mjg4ODc3">Linux cgroup机制分析之框架分析<i class="fa fa-external-link-alt"></i></span></li>
</ol>
]]></content>
      <categories>
        <category>进程</category>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>cgroup</tag>
      </tags>
  </entry>
  <entry>
    <title>Namespace</title>
    <url>/post/31401.html</url>
    <content><![CDATA[<p>容器，cgroup，namespace之间的关系：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">       +-------------------------------------+</span><br><span class="line">       |                                     |</span><br><span class="line">       |            容器                     |   用户空间</span><br><span class="line">       +-------------------------------------+</span><br><span class="line">+-------------------------------------------------------+</span><br><span class="line">       +--------------+  +-------------------+</span><br><span class="line">       |  cgroup fs   |  |  syscall（clone） |</span><br><span class="line">       +------+-------+  +---------+---------+</span><br><span class="line">              ^                    ^</span><br><span class="line">       +------+------+   +---------+---------+</span><br><span class="line">       |  cgroup     |   |    namespace      |   内核空间</span><br><span class="line">       +-------------+   +-------------------+</span><br><span class="line">       +-------------+   +-------------------+</span><br><span class="line">       |             |   |                   |</span><br><span class="line">       |     CPU     |   |    PID，IPC，     |</span><br><span class="line">       |    内存资源 |   |    网络等资源     |</span><br><span class="line">       |             |   |                   |</span><br><span class="line">       |             |   |                   |</span><br><span class="line">       +-------------+   +-------------------+</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<span id="more"></span>

<h2 id="Cgroup"><a href="#Cgroup" class="headerlink" title="Cgroup"></a>Cgroup</h2><h2 id="Namespace"><a href="#Namespace" class="headerlink" title="Namespace"></a>Namespace</h2><p>Namespace又称为命名空间，它主要做访问隔离。其原理是针对一类资源进行抽象，并将其封装在一起提供给一个容器使用，对于这类资源，因为每个容器都有自己的抽象，而他们彼此之间是不可见的，所以就可以做到访问隔离。可以让每一个进程具有独立的<code>PID</code>，<code>IPC</code>和<code>网络空间</code>。</p>
<blockquote>
<p>通过执行clone系统调用可以划分命名空间，主要是根据clone的第3个参数flags标志进行设置</p>
</blockquote>
<h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><ul>
<li><code>clone()</code>: 实现线程的系统调用，用来创建一个新的进程，并可以通过设计上述参数达到隔离。</li>
<li><code>unshare()</code>: 使某进程脱离某个namespace</li>
<li><code>setns()</code>: 把某进程加入到某个namespace</li>
</ul>
<h3 id="资源划分"><a href="#资源划分" class="headerlink" title="资源划分"></a>资源划分</h3><table>
<thead>
<tr>
<th align="center">名 称</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">CLONE_NEWIPC</td>
<td align="center">划分IPC（进程间通信）命名空间，信号量，共享内存，消息队列，等进程间通信的资源</td>
</tr>
<tr>
<td align="center">CLONE_NEWNET</td>
<td align="center">划分网络命令空间，分配网络接口</td>
</tr>
<tr>
<td align="center">CLONE_NEWNS</td>
<td align="center">划分挂载命名空间。与chroot同样分配新的根文件系统</td>
</tr>
<tr>
<td align="center">CLONE_NEWPID</td>
<td align="center">划分PID命名空间。分配新的进程ID空间</td>
</tr>
<tr>
<td align="center">CLONE_NEWUTS</td>
<td align="center">划分UTS(主机名)命名空间。分配新的UTS空间</td>
</tr>
</tbody></table>
<h4 id="clone"><a href="#clone" class="headerlink" title="clone"></a>clone</h4><p>创建一个子进程，后续的命名空间的划分在此基础上操作。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STACK_SIZE (1024*1024)</span></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> child_stack[STACK_SIZE];</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *<span class="type">const</span> child_args[] = &#123;</span><br><span class="line">    <span class="string">&quot;/bin/bash&quot;</span>,</span><br><span class="line">    <span class="literal">NULL</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">child_main</span><span class="params">(<span class="type">void</span> *args)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;in child process \n&quot;</span>);</span><br><span class="line">    execv(child_args[<span class="number">0</span>], child_args);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;process start: \n&quot;</span>);</span><br><span class="line">    <span class="type">int</span> child_pid = clone(child_main, child_stack + STACK_SIZE, SIGCHLD, <span class="literal">NULL</span>);</span><br><span class="line">    waitpid(child_pid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;end \n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="UTS命名空间（CLONE-NEWUTS）"><a href="#UTS命名空间（CLONE-NEWUTS）" class="headerlink" title="UTS命名空间（CLONE_NEWUTS）"></a>UTS命名空间（CLONE_NEWUTS）</h4><p>UTS命名空间，提供了主机名和域名的隔离。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STACK_SIZE (1024*1024)</span></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> child_stack[STACK_SIZE];</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *<span class="type">const</span> child_args[] = &#123;</span><br><span class="line">	<span class="string">&quot;/bin/bash&quot;</span>,</span><br><span class="line">	<span class="literal">NULL</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">child_main</span><span class="params">(<span class="type">void</span> *args)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;in child process \n&quot;</span>);</span><br><span class="line">	sethostname(<span class="string">&quot;NewNameSpace&quot;</span>, <span class="number">20</span>); <span class="comment">//设置新的主机名</span></span><br><span class="line">	execv(child_args[<span class="number">0</span>], child_args);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;process start: \n&quot;</span>);</span><br><span class="line">	<span class="type">int</span> child_pid = clone(child_main, child_stack + STACK_SIZE, CLONE_NEWUTS|SIGCHLD, <span class="literal">NULL</span>);</span><br><span class="line">	waitpid(child_pid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;end \n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;user@ingenic-xxx:~/namespace$ sudo ./a.out</span><br><span class="line">&gt;process start:</span><br><span class="line">&gt;in child process</span><br><span class="line">&gt;root@NewNameSpace:~/namespace# echo $HOSTNAME</span><br><span class="line">&gt;NewNameSpace</span><br><span class="line">&gt;root@NewNameSpace:~/namespace# exit</span><br><span class="line">&gt;exit</span><br><span class="line">&gt;end</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="IPC命名空间（CLONE-NEWIPC）"><a href="#IPC命名空间（CLONE-NEWIPC）" class="headerlink" title="IPC命名空间（CLONE_NEWIPC）"></a>IPC命名空间（CLONE_NEWIPC）</h4><p>IPC Namespace 是用来隔离 System V IPC 和POSIX message queues.每一个IPC Namespace都有他们自己的System V IPC 和POSIX message queue。</p>
<p>验证：消息队列</p>
<ul>
<li>ipcs查看队列<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ipcs -q</span><br></pre></td></tr></table></figure></li>
<li>ipcmk创建队列<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ipcmk -Q</span><br></pre></td></tr></table></figure></li>
<li>ipcrm删除队列<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ipcrm -q 0</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="PID命名空间（CLONE-NEWPID）"><a href="#PID命名空间（CLONE-NEWPID）" class="headerlink" title="PID命名空间（CLONE_NEWPID）"></a>PID命名空间（CLONE_NEWPID）</h4><p>PID namespace是用来隔离进程 id。同样的一个进程在不同的 PID Namespace 里面可以拥有不同的 PID。空间内的PID 是独立分配的，意思就是命名空间内的虚拟 PID 可能会与命名空间外的 PID 相冲突，于是命名空间内的 PID 映射到命名空间外时会使用另外一个 PID。比如说，命名空间内第一个 PID 为1，而在命名空间外就是该 PID 已被 init 进程所使用。</p>
<p>验证： <code>echo $$</code></p>
<blockquote>
<p>在子进程的shell里输入ps,top等命令，我们还是可以看得到所有进程。说明并没有完全隔离。这是因为，像ps, top这些命令会去读&#x2F;proc文件系统，所以，因为&#x2F;proc文件系统在父进程和子进程都是一样的，所以这些命令显示的东西都是一样的。</p>
</blockquote>
<h4 id="mount命名空间（CLONE-NEWNS）"><a href="#mount命名空间（CLONE-NEWNS）" class="headerlink" title="mount命名空间（CLONE_NEWNS）"></a>mount命名空间（CLONE_NEWNS）</h4><p>进程运行时可以将挂载点与系统分离，使用这个功能时，我们可以达到 chroot 的功能进程运行时可以将挂载点与系统分离，使用这个功能时，可以达到 chroot 的功能</p>
<blockquote>
<p>在通过<code>CLONE_NEWNS</code>创建mount namespace后，父进程会把自己的文件结构复制给子进程中。而子进程中新的namespace中的所有mount操作都只影响自身的文件系统，而不对外界产生任何影响。这样可以做到比较严格地隔离。</p>
</blockquote>
<h3 id="小应用"><a href="#小应用" class="headerlink" title="小应用"></a>小应用</h3><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vbGluaGFpZmVuZy9wLzY2NTcxMTkuaHRtbA==">网络虚拟化基础一：linux名称空间Namespaces<i class="fa fa-external-link-alt"></i></span></li>
</ol>
]]></content>
      <categories>
        <category>进程</category>
        <category>namespace</category>
      </categories>
      <tags>
        <tag>进程</tag>
        <tag>namespace</tag>
      </tags>
  </entry>
  <entry>
    <title>进程状态-Z:僵尸进程产生的原因</title>
    <url>/post/5718.html</url>
    <content><![CDATA[<p><code>Z (zombie)</code>:僵死状态是一个比较特殊的状态。进程在退出的过程中，处于<code>TASK_DEAD</code>状态。</p>
<blockquote>
<p>在这个退出过程中，进程占有的所有资源将被回收，除了task_struct结构（以及少数资源）以外。于是进程就只剩下task_struct这么个空壳，故称为僵尸。</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ps</span></span><br><span class="line">  PID USER       VSZ STAT COMMAND</span><br><span class="line">    1 root      3100 S    init</span><br><span class="line">    2 root         0 SW   [kthreadd]</span><br><span class="line">    3 root         0 SW   [ksoftirqd/0]</span><br><span class="line">    4 root         0 SW   [kworker/0:0]</span><br><span class="line">    5 root         0 SW&lt;  [kworker/0:0H]</span><br><span class="line">    6 root         0 SW   [kworker/u8:0]</span><br><span class="line">    ...</span><br><span class="line">    1380 root      0 Z    [view]     #僵尸进程</span><br><span class="line">    ...</span><br><span class="line">    1392 root   3104 S    -/bin/sh</span><br><span class="line">    1404 root      0 SW&lt;  [kworker/2:1H]</span><br><span class="line">    1429 root      0 SW&lt;  [kworker/0:1H]</span><br><span class="line">    1444 root      0 SW&lt;  [kworker/1:1H]</span><br></pre></td></tr></table></figure>
<ul>
<li>僵尸进程产生的原因???</li>
<li>如何确定根本原因???</li>
<li>如何避免???</li>
</ul>
<span id="more"></span>

<h2 id="僵尸进程产生的原因"><a href="#僵尸进程产生的原因" class="headerlink" title="僵尸进程产生的原因"></a>僵尸进程产生的原因</h2><blockquote>
<p><strong>僵尸进程</strong>: 是当子进程比父进程先结束，而父进程又没有回收子进程，释放子进程占用的资源（也就是子进程先于父进程结束），此时子进程将成为一个僵尸进程。如果父进程先退出 ，子进程被init接管，子进程退出后init会回收其占用的相关资源</p>
</blockquote>
<p>原因:</p>
<ol>
<li>子进程被直接杀死</li>
<li>子进程无法正常关闭</li>
</ol>
<p>场景:主进程创建的线程在进行数据搬运时,搬运数据的大小超过了放置数据buffer的大小,导致部分数据被污染,最终导致子线程在运行过程中出现段错误,将其直接杀死,没有等到父进程回收,而产生了僵尸进程.</p>
<h2 id="为什么子进程结束时，不直接退出"><a href="#为什么子进程结束时，不直接退出" class="headerlink" title="为什么子进程结束时，不直接退出"></a>为什么子进程结束时，不直接退出</h2><p>因为父进程有时候需要获取到子进程的退出状态，如果是正常退出，可以直接将其释放，如果是异常退出，又可以根据异常信息进行进一步的相关操作。</p>
<h2 id="调试-amp-amp-Debug"><a href="#调试-amp-amp-Debug" class="headerlink" title="调试&amp;&amp;Debug"></a>调试&amp;&amp;Debug</h2><ul>
<li>查找子进程被杀死的原因,如,段错误可以重新定义段错误信号的处理打印部分信息.</li>
<li>排查显示fork和隐式fork,对子进程的操作.</li>
<li>子进程退出信号<code>signal(SIGCHLD,sig_child)</code>的自定义处理</li>
</ul>
<h2 id="设计时的预防"><a href="#设计时的预防" class="headerlink" title="设计时的预防"></a>设计时的预防</h2><ul>
<li><p>父进程通过wait和waitpid等函数等待子进程结束，这会导致父进程挂起。</p>
<ul>
<li>执行wait（）或waitpid（）系统调用，则子进程在终止后会立即把它在进程表中的数据返回给父进程，此时系统会立即删除该进入点。在这种情形下就不会产生defunct进程。</li>
</ul>
</li>
<li><p>如果父进程很忙，那么可以用signal函数为SIGCHLD安装handler。在子进程结束后，父进程会收到该信号，可以在handler中调用wait回收。</p>
</li>
<li><p>如果父进程不关心子进程什么时候结束，那么可以用<code>signal(SIGCLD, SIG_IGN)</code>或<code>signal(SIGCHLD, SIG_IGN)</code>通知内核，自己对子进程的结束不感兴趣，那么子进程结束后，内核会回收，并不再给父进程发送信号</p>
<ul>
<li>signal(SIGCHLD, SIG_IGN): 通过信号回收子进程的SIGCHLD. 子进程要终止了，发个SIGCHLD信号告诉父进程, 设置<code>SIG_IGN</code>忽略信号，则表示父进程不关心子进程退出，子进程退出后内核把资源回收即可。</li>
<li>signal(SIGCLD, SIG_IGN): 子进程状态改变后产生此信号，该信号的配置为SIG_IGN, 子进程状态信息会被丢弃，也就是自动回收了，则调用进程的子进程将不产生僵死进程</li>
</ul>
</li>
<li><p>fork两次，父进程fork一个子进程，然后继续工作，子进程fork一个孙进程后退出，那么孙进程被init接管，孙进程结束后，init会回收。不过子进程的回收还要自己做</p>
</li>
</ul>
<h2 id="父进程退出时通知子进程退出"><a href="#父进程退出时通知子进程退出" class="headerlink" title="父进程退出时通知子进程退出"></a>父进程退出时通知子进程退出</h2><ul>
<li>方法1：在子进程和父进程之间建立通信管道(<code>socketpair(PF_LOCAL, SOCK_STREAM, 0, fd)</code>)，一旦通信异常，则认为父进程退出，子进程自己也回收资源退出。</li>
<li>方法2：借助<code>prctl</code>函数中的<code>PR_GET_PDEATHSIG</code>参数, 在子进程中添加<code>prctl(PR_SET_PDEATHSIG,SIGKILL);</code>，这样父进程退出时，子进程将会收到SIGKILL信号，而进程收到该信号的默认动作则是退出。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PR_SET_PDEATHSIG (since Linux 2.1.57)</span><br><span class="line">       Set the parent-death signal of the calling process to arg2 (either a signal value in the range 1..maxsig, or 0 to clear).  This is the signal that the calling process will get when its parent dies.</span><br><span class="line"></span><br><span class="line">       Warning:  the  &quot;parent&quot;  in this case is considered to be the thread that created this process.  In other words, the signal will be sent when that thread terminates (via, for example, pthread_exit(3)), rather than</span><br><span class="line">       after all of the threads in the parent process terminate.</span><br><span class="line"></span><br><span class="line">       The parent-death signal is sent upon subsequent termination of the parent thread and also upon termination of each subreaper process (see the description of PR_SET_CHILD_SUBREAPER above) to  which  the  caller  is</span><br><span class="line">       subsequently reparented.  If the parent thread and all ancestor subreapers have already terminated by the time of the PR_SET_PDEATHSIG operation, then no parent-death signal is sent to the caller.</span><br><span class="line"></span><br><span class="line">       The  parent-death  signal is process-directed (see signal(7)) and, if the child installs a handler using the sigaction(2) SA_SIGINFO flag, the si_pid field of the siginfo_t argument of the handler contains the PID</span><br><span class="line">       of the terminating parent process.</span><br><span class="line"></span><br><span class="line">       The parent-death signal setting is cleared for the child of a fork(2).  It is also (since Linux 2.4.36 / 2.6.23) cleared when executing a set-user-ID or set-group-ID binary, or a binary that has  associated  capa‐</span><br><span class="line">       bilities (see capabilities(7)); otherwise, this value is preserved across execve(2).</span><br></pre></td></tr></table></figure>

<h2 id="子进程状态变为Zl"><a href="#子进程状态变为Zl" class="headerlink" title="子进程状态变为Zl"></a>子进程状态变为<code>Zl</code></h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ps aux | grep enc-test</span></span><br><span class="line">vx        132525  0.0  0.0      0     0 pts/0    Zl   02:14   0:00 [enc-test-16] &lt;defunct&gt;</span><br><span class="line">vx        132586  0.0  0.0      0     0 pts/0    Zl   02:14   0:00 [enc-test-56] &lt;defunct&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ps -A -ostat,ppid,pid,cmd | grep -e <span class="string">&#x27;^[Zz]&#x27;</span></span></span><br><span class="line">Zl         1  132525 [enc-test-16] &lt;defunct&gt;</span><br><span class="line">Zl         1  132586 [enc-test-56] &lt;defunct&gt;</span><br></pre></td></tr></table></figure>

<p>当前系统无法使用gdb和strace，但是系统配置均正常，是否为僵尸进程就无法被attach。</p>
<p>出现错误信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">strace: Could not attach to process. If your uid matches the uid of the target process, check the setting of /proc/sys/kernel/yama/ptrace_scope, or try again as the root user. For more details, see /etc/sysctl.d/10-ptrace.conf: Operation not permitted</span><br><span class="line">strace: attach: ptrace(PTRACE_SEIZE, 132525): Operation not permitted</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注：系统已经正确配置将<code>/etc/sysctl.d/10-ptrace.conf</code>文件中修改<code>kernel.yama.ptrace_scope = 0</code>并且系统进行了重启，重启后<code>/proc/sys/kernel/yama/ptrace_scope</code>为<code>0</code>,但是还是无法使用。<br>(strace系统中的其他正常进程是正常的)</p>
</blockquote>
<h3 id="栈信息"><a href="#栈信息" class="headerlink" title="栈信息"></a>栈信息</h3><p>通过proc文件系统查看进程当前栈信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo cat /proc/132525/stack</span><br><span class="line">$</span><br></pre></td></tr></table></figure>
<p>没有输出如何栈信息，也就是说当前出问题的进程没有运行，正是僵尸进程的表现。</p>
<h3 id="该僵尸进程如何产生"><a href="#该僵尸进程如何产生" class="headerlink" title="该僵尸进程如何产生"></a>该僵尸进程如何产生</h3><p>一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为<code>僵死进程</code>。</p>
<p>其实就是子进程退出的时候父进程不知道，因此解决方法就是在子进程退出时，告诉父进程一下（参考：设计时的预防）。</p>
<p>而该测试中的僵尸进程是由于测试进程在循环测试中，Ctrl+C终止测试时，偶尔会产生僵尸进程，应该是在测试程序运行过程中，子进程和父进程先后收到了Ctrl+c信号（可能信号处理的时序问题）导致部分子进程退出时，父进程已经退出没有来的即调用wait接口，无人回收资源变为僵尸进程。</p>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>在进程中忽略INT信号（也就是Ctrl+c），如果实际业务流程需要，可以自己实现INT信号的处理函数。</p>
]]></content>
      <categories>
        <category>进程</category>
        <category>进程状态</category>
      </categories>
      <tags>
        <tag>进程</tag>
      </tags>
  </entry>
  <entry>
    <title>阻塞，非阻塞</title>
    <url>/post/63673.html</url>
    <content><![CDATA[<p>在mmc子系统自带的测试中数据的读写有<code>阻塞</code>和<code>非阻塞</code>两种，这里主要将这两种IO的操作进一步做简单的总结，来加深自己的理解。同时，也将在学习过程中又接触到的<code>同步</code>和<code>异步</code>记录在此。</p>
<h2 id="阻塞IO-block-IO"><a href="#阻塞IO-block-IO" class="headerlink" title="阻塞IO(block IO)"></a>阻塞IO(block IO)</h2><blockquote>
<p>阻塞操作是指在执行设备操作时，若不能获取资源，则挂起进程直到满足可操作的条件后再进行操作。</p>
</blockquote>
<p>在进行阻塞的IO操作时，如果没有可用的资源，当前进程将进入睡眠模式，它将CPU资源让给其他进程，但是由于会进入睡眠状态，因此在我们得到资源可以利用时（设备驱动中一般中断的方式得到该状态，因为在硬件资源发生变化是一般都会产生中断），必须将休眠的进程再次唤醒进行后续的操作。</p>
<h2 id="非阻塞IO-unblock-IO"><a href="#非阻塞IO-unblock-IO" class="headerlink" title="非阻塞IO(unblock IO)"></a>非阻塞IO(unblock IO)</h2><blockquote>
<p>非阻塞操作进程在不能进行设备操作时，并不挂起，它要么放弃，要么不停的查询，直到可以进行操作为止</p>
</blockquote>
<p>这种方式是不断的查询当前资源的状态，不断的尝试，将消耗大量的CPU资源。</p>
]]></content>
      <categories>
        <category>进程</category>
        <category>阻塞io</category>
      </categories>
      <tags>
        <tag>阻塞io</tag>
      </tags>
  </entry>
  <entry>
    <title>Cortex-A8平台实验</title>
    <url>/post/36419.html</url>
    <content><![CDATA[<p>毕业的时候有把A8板子拿了过来，之前由于没有源程序（光盘丢失找不到资料）对它的开发和实验都一直没有做过，它上面的资源很多不想让它就静静的放着浪费。虽然已经很久没有接触ARM平台了，但是它与MIPS的上层基本原理相似，所以最近想倒腾它，希望可以把linux系统跑起来，也不枉失去它在我手中的价值嘿嘿嘿。在这里简单记录实验的过程和中间的少许思考吧。</p>
<!---more--->

<h1 id="开篇——flag"><a href="#开篇——flag" class="headerlink" title="开篇——flag"></a>开篇——flag</h1><h2 id="实验环境："><a href="#实验环境：" class="headerlink" title="实验环境："></a>实验环境：</h2><ul>
<li>开发板：Cortex-A8</li>
<li>开发系统：Linux machine 4.2.0-27-generic #32~14.04.1-Ubuntu SMP</li>
<li><del>uboot：u-boot-2016-07</del></li>
<li>uboot：u-boot-v2014.07-rc4</li>
<li>linux：linux-4.0.9</li>
<li>文件系统：buildroot<blockquote>
<p>在实际的操作中可能会有所变动，不断更新 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0VtRGVwVGVhbQ==">DebugCode<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
</li>
</ul>
<h2 id="交叉编译工具"><a href="#交叉编译工具" class="headerlink" title="交叉编译工具"></a>交叉编译工具</h2><p>作为嵌入式开发交叉编译工具链是必不可少的，主要是为了在宿主机（PC）上，开发目标机（arm开发板）中可以运行的程序。</p>
<h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p>这里选择<span class="exturl" data-url="aHR0cHM6Ly9sYXVuY2hwYWRsaWJyYXJpYW4ubmV0LzI2ODMzMDUwMy9nY2MtYXJtLW5vbmUtZWFiaS01XzQtMjAxNnEyLTIwMTYwNjIyLWxpbnV4LnRhci5iejI=">gcc-arm-none-eabi-5_4-2016q2-20160622-linux.tar.bz2<i class="fa fa-external-link-alt"></i></span></p>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>由于PC中从在多个交叉编译工具链，这里采用脚本envsetup.sh设置，每进入一个终端需要运行其脚本进行配置，方可使用该编译工具链。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">MY_PWD=`pwd`</span><br><span class="line"></span><br><span class="line">PATH=$PATH:$MY_PWD/gcc-arm-none-eabi-5_4-2016q2/bin</span><br><span class="line">CROSS_COMPILE=arm-none-eabi-</span><br><span class="line"></span><br><span class="line">export PATH CROSS_COMPILE</span><br><span class="line"></span><br><span class="line">echo $PATH</span><br><span class="line">echo $CROSS_COMPILE</span><br></pre></td></tr></table></figure>
<p>设置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">source envsetup.sh</span><br></pre></td></tr></table></figure>
<h2 id="uboot移植"><a href="#uboot移植" class="headerlink" title="uboot移植"></a>uboot移植</h2><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><ol>
<li>查找Cortex-A8相关的README，进行参考，全局搜索</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grep &quot;Cortex-A8&quot; . -rn</span><br></pre></td></tr></table></figure>
<p>.&#x2F;doc&#x2F;README.s5pc1xx中有Cortex-A8的相关说明，结合该文档进行最初的编译。</p>
<p><del>2. 根据README.s5pc1xx的步骤配置编译</del></p>
<p>将出现以下错误：</p>
<blockquote>
<p>lib&#x2F;asm-offsets.c:1:0: error: bad value (armv5) for -march&#x3D; switch</p>
</blockquote>
<p>出现这个错误的原因是我们没有为uboot指定交叉编译工具链，它依然用自己默认的gcc进行编译，有怎么会找到armv5呢。</p>
<p><del>3. 指定交叉编译工具链</del></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">CROSS_COMPILE=arm-none-eabi-</span><br><span class="line">export CROSS_COMPILE</span><br></pre></td></tr></table></figure>
<p>为了以后方便使用可将以上两句命令添加到envsetup.sh脚本中。<br>参考：.&#x2F;README — 4963 Building the Software:</p>
<h4 id="改变uboot版本"><a href="#改变uboot版本" class="headerlink" title="改变uboot版本"></a>改变uboot版本</h4><blockquote>
<p>最新的uboot采用图形界面的配置方式及增加了设备树的配置，由于对这两方面都不太了解尤其设备树，根据自己比较熟悉的使用方式，选择u-boot-v2014.07-rc4。设备树等uboot可以正常启动后在深入学习添加。</p>
</blockquote>
<h4 id="选择默认配置编译"><a href="#选择默认配置编译" class="headerlink" title="选择默认配置编译"></a>选择默认配置编译</h4><ol>
<li>选择配置</li>
</ol>
<p>根据README在boards.cfg选择smdkc100，后续在此基础上进行移植<br>2. 指定编译器</p>
<p>根据上文（3. 指定交叉编译工具链）即可<br>3. 编译</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">make smdkc100_config</span><br><span class="line">make</span><br></pre></td></tr></table></figure>
<p>顺利编译通过，接下来将添加spl和uboot</p>
<h4 id="添加自己配置"><a href="#添加自己配置" class="headerlink" title="添加自己配置"></a>添加自己配置</h4><ol>
<li><p>添加配置文件s5pv210.h<br> cp include&#x2F;configs&#x2F;smdkc100.h include&#x2F;configs&#x2F;s5pv210.h</p>
</li>
<li><p>添加编译配置boards.cfg<br> Active  arm         armv7          s5pc1xx     samsung   smdkc100   s5pv210      Winddoing <span class="exturl" data-url="bWFpbHRvOiYjeDc3OyYjMTA1OyYjeDZlOyYjMTAwOyYjMTAwOyYjeDZmOyYjeDY5OyYjeDZlOyYjMTAzOyYjeDQwOyYjeDczOyYjMTA1OyYjeDZlOyYjeDYxOyYjeDJlOyYjOTk7JiN4NmU7">&#x77;&#105;&#x6e;&#100;&#100;&#x6f;&#x69;&#x6e;&#103;&#x40;&#x73;&#105;&#x6e;&#x61;&#x2e;&#99;&#x6e;<i class="fa fa-external-link-alt"></i></span></p>
</li>
</ol>
<h3 id="添加SPL阶段"><a href="#添加SPL阶段" class="headerlink" title="添加SPL阶段"></a>添加SPL阶段</h3><p>在uboot中SPL阶段的控制是通过spl&#x2F;Makefile中的CONFIG_SPL_BUILD宏控制</p>
<h2 id="使用最新的uboot"><a href="#使用最新的uboot" class="headerlink" title="使用最新的uboot"></a>使用最新的uboot</h2><h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><ol>
<li>指定编译工具链<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export CROSS_COMPILE</span><br></pre></td></tr></table></figure></li>
<li>使用相关配置测试工具链<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$make s5pc210_universal_defconfig</span><br><span class="line">$make -j12</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="添加自定义配置"><a href="#添加自定义配置" class="headerlink" title="添加自定义配置"></a>添加自定义配置</h3><p>在<code>s5pc210_universal_defconfig</code>配置基础上修改。</p>
<h4 id="添加配置文件"><a href="#添加配置文件" class="headerlink" title="添加配置文件"></a>添加配置文件</h4><ol>
<li>拷贝现有相关配置<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$cp include/configs/s5pc210_universal.h include/configs/s5pc210_a8.h</span><br><span class="line">$cp configs/s5pc210_universal_defconfig configs/s5pc210_a8_defconfig</span><br></pre></td></tr></table></figure>
2.添加板级<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">board/samsung/cortex-a8/</span><br><span class="line">configs/s5pc210_a8_defconfig</span><br><span class="line">include/configs/s5pc210_a8.h</span><br></pre></td></tr></table></figure>
<h4 id="添加SPL"><a href="#添加SPL" class="headerlink" title="添加SPL"></a>添加SPL</h4></li>
</ol>
<h3 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./tools/mkexynosspl  spl/u-boot-spl.bin spl/qt210-spl.bin</span><br><span class="line">make[1]: ./tools/mkexynosspl: Command not found</span><br><span class="line">scripts/Makefile.spl:283: recipe for target &#x27;spl/qt210-spl.bin&#x27; failed</span><br><span class="line">make[1]: *** [spl/qt210-spl.bin] Error 127</span><br><span class="line">Makefile:1508: recipe for target &#x27;spl/u-boot-spl&#x27; failed</span><br><span class="line">make: *** [spl/u-boot-spl] Error 2</span><br></pre></td></tr></table></figure>

<p>这是个可执行文件是在make时自动增加头信息用的</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dqaWFudzIxNy9hcnRpY2xlL2RldGFpbHMvNzk5Mzk4ODk=">【u-boot-2016到s5pv210】1.1 自定义板卡ok210<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2tleXVlMTIzL2FydGljbGUvZGV0YWlscy81MzA3MjE2NA==">u-boot-2016.09移植(3)-u-boot-spl.bin<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NvbmZpZ19pbml0L2FydGljbGUvZGV0YWlscy81MzM3MzQyMw==">u-boot-2016.11移植uboot-spl.bin<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTY1NTc2NS9hcnRpY2xlL2RldGFpbHMvODAwNTg2NDQ=">u-boot v2018.01 启动流程分析<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<h2 id="参考-1"><a href="#参考-1" class="headerlink" title="参考"></a>参考</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0plcnJ5R291L2FydGljbGUvZGV0YWlscy83OTAyNzQ3OQ==">S5PV210开发版配置<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<h1 id="再续前缘——2022-1-21"><a href="#再续前缘——2022-1-21" class="headerlink" title="再续前缘——2022.1.21"></a>再续前缘——2022.1.21</h1><p>今天已经是在家隔离的第28天了，接着上次在家办公时把uboot基本移植成功后，这两天也把kerel和文件系统都给安排上了，算是完成了这个久违的flag。以上这部分，记录了刚毕业那会对手里拿着的cortex-a8开发版所立的一个flag，想着既然有一个就将最新的uboot和kernel全部跑起来，也是一个锻炼过程，同时如果需要调试内核新的功能也方便，出于这个目的就进行了uboot的移植（记录在上），记得当时spl都没有弄完就不了了之了。这次乘着疫情在家时间比较充足就将其重新进行移植。</p>
<p>在移植之前给这个工程与开发板起了一个新的名字<code>wdg</code>，其实就是winddoing的简写，主要是为了容易辩识。</p>
<p>当前状态：</p>
<ul>
<li>uboot移植<ul>
<li>实现uart，时钟，DDR初始化等，最基本功能</li>
<li>移植LAN9220网卡</li>
<li>实现tftp加载kernel，及挂载NFS文件系统</li>
</ul>
</li>
<li>kernel移植<ul>
<li>实现正常启动并进入文件系统</li>
<li>移植LAN9220网卡驱动</li>
</ul>
</li>
<li>buildroot<ul>
<li>构建完成可用的最小文件系统</li>
</ul>
</li>
</ul>
<p>这里主要记录整个调试流程和需要注意的地方，其实也就是我出现错误和比较容易忽略的地方。</p>
<h2 id="wdg工程环境"><a href="#wdg工程环境" class="headerlink" title="wdg工程环境"></a>wdg工程环境</h2><ul>
<li>硬件环境：<ul>
<li>s5pv210开发板（Cortex-A8）</li>
</ul>
</li>
<li>软件环境：<ul>
<li>开发机：<code>Ubuntu 20.04.3 LTS</code></li>
<li>交叉编译工具：<code>arm-none-eabi-gcc</code>, sudo apt install gcc-arm-none-eabi</li>
<li>uboot：<code>v2021.10-rc5</code></li>
<li>kernel：<code>5.16.0</code></li>
<li>buildroot: <code>2021.11</code><blockquote>
<p>uboot、kernel、buildroot均为当时下载<code>master</code>分支代码进行移植操作，目的是为了后续方便更新代码</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h2 id="基础环境"><a href="#基础环境" class="headerlink" title="基础环境"></a>基础环境</h2><h3 id="编译工具"><a href="#编译工具" class="headerlink" title="编译工具"></a>编译工具</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install gcc-arm-none-eabi</span><br></pre></td></tr></table></figure>
<blockquote>
<p>编译应用：arm-none-eabi-gcc –specs&#x3D;nosys.specs $(OTHER_LINK_OPTIONS)</p>
<p>如：arm-none-eabi-gcc –specs&#x3D;nosys.specs  a.c</p>
</blockquote>
<h3 id="硬件电路——调试"><a href="#硬件电路——调试" class="headerlink" title="硬件电路——调试"></a>硬件电路——调试</h3><h4 id="串口"><a href="#串口" class="headerlink" title="串口"></a>串口</h4><p>默认使用最边上的串口，为COM1，j7</p>
<p><img data-src="/images/2022/01/s5pv210_wdg_uart_debug.png" alt="s5pv210_wdg_uart_debug"></p>
<h4 id="LED"><a href="#LED" class="headerlink" title="LED"></a>LED</h4><p>在开发板上有四个led灯，为了方便调试uboot与spl的启动，将其作为指示灯用</p>
<p><img data-src="/images/2022/01/s5pv210_wdg_led_debug.png" alt="s5pv210_wdg_led_debug"></p>
<p>uboot中接口函数<code>wdg_led_status()</code>,可以直接设置状态值<code>1~15</code></p>
<h2 id="裸板测试"><a href="#裸板测试" class="headerlink" title="裸板测试"></a>裸板测试</h2><p>裸板测试主要调试uart和led，为spl启动流程调试做准备。</p>
<p><img data-src="/images/2022/01/s5pv210_boot_diagram.png" alt="s5pv210_boot_diagram"></p>
<p><code>BL1</code>区域最大大小为16KByte，因此启动阶段BL1代码大小不能超过16KByte，也就是裸板测试程序不能超过16KByte，（uboot spl阶段大小也不能超过16KByte）</p>
<p>BL1区域数据格式：<code>Header</code>+<code>Data</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   ----+------------------------+-----------&gt;+------------------------------+</span><br><span class="line">    ^  |                        |            |BL1 size unit:byte(User Write)|</span><br><span class="line">    |  |   BL1 Header(16byte)   |            +------------------------------+</span><br><span class="line">    |  |                        |            |Reserved(should be 0)         |</span><br><span class="line">    |  +------------------------+-----+      +------------------------------+</span><br><span class="line">    |  |                        | ^   |      |CheckSum(User write)          |</span><br><span class="line">    |  |                        | |   |      +------------------------------+</span><br><span class="line">    |  |                        | |   |      |Reserved(should be 0)         |</span><br><span class="line">    |  |                        | |   +-----&gt;+------------------------------+</span><br><span class="line">    |  |                        | |</span><br><span class="line">    |  |                        | |</span><br><span class="line">    |  |      BL1 binary        | |</span><br><span class="line">BL1 size                        | |</span><br><span class="line">    |  |                        | |</span><br><span class="line">    |  |                        |CheckSum</span><br><span class="line">    |  |                        | |</span><br><span class="line">    |  |                        | |</span><br><span class="line">    |  |                        | |</span><br><span class="line">    |  |                        | |</span><br><span class="line">    |  |                        | |</span><br><span class="line">    |  |                        | |</span><br><span class="line">    |  |                        | |</span><br><span class="line">    |  |                        | |</span><br><span class="line">    |  |                        | |</span><br><span class="line">    v  |                        | v</span><br><span class="line">   ----+------------------------+----</span><br></pre></td></tr></table></figure>

<p>裸板测试程序编译生成后，需要根据以上格式进行处理生成新的bin文件，这个bin文件写入SD卡启动时才会被识别运行，否则会触发蜂鸣器报警。</p>
<p>BL1阶段bin格式处理流程：</p>
<ol>
<li>添加<code>16Byte</code>的头部信息</li>
<li>计算BL1阶段程序bin文件的实际大小，并填入头部第一个word</li>
<li>计算BL1阶段程序bin文件的校验和，它通过对所有字节求和来计算，并填入头部第三个word</li>
<li>生成新的BL1阶段执行程序BIN</li>
</ol>
<p>将最终生成的BIN写入SD卡的第1个扇区，启动测试。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo dd if=BIN of=/dev/sdb bs=512 seek=1</span><br></pre></td></tr></table></figure>

<h2 id="uboot移植-1"><a href="#uboot移植-1" class="headerlink" title="uboot移植"></a>uboot移植</h2><h3 id="添加wdg板级"><a href="#添加wdg板级" class="headerlink" title="添加wdg板级"></a>添加wdg板级</h3><p>为了后续添加各种配置并不影响后续代码的更新，需要添加一份自定义板级，这里主要参考uboot源码中的<code>goni</code>，以其为模板进行拷贝。</p>
<ul>
<li><p>添加设备树</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cp arch/arm/dts/s5pc1xx-goni.dts arch/arm/dts/s5pc1xx-wdg.dts</span><br></pre></td></tr></table></figure></li>
<li><p>添加配置文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cp configs/s5p_goni_defconfig  configs/s5p_wdg_defconfig</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cp include/configs/s5p_goni.h  include/configs/s5p_wdg.h</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加板级目录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cp board/samsung/goni board/samsung/wdg</span><br></pre></td></tr></table></figure>
<blockquote>
<p>拷贝完板级目录后，修改相应的文件名及makefile文件，并且将设备树和配置文件中的可能无用的模块进行<code>删减</code>，后续如果需要可以不断添加</p>
</blockquote>
</li>
</ul>
<p>注：根据自定义板级名，修改相应的Makefile及Kconfig文件中的相关配置</p>
<h3 id="添加SPL阶段-1"><a href="#添加SPL阶段-1" class="headerlink" title="添加SPL阶段"></a>添加SPL阶段</h3><p>在s5pv210的启动流程中由于BL1阶段可利用的SRAM空间有限（最大只有16KB），这样就无法直接使用uboot进行启动，这样uboot将分为两部分启动，一部分SPL，主要为初始化DDR（以小的SRAM空间，换大的内存空间）；第二部分uboot，一般意义上的uboot，初始化各种外设，并加载引导kernel启动。</p>
<blockquote>
<p>SPL阶段，其实就是BL1阶段，主要的目的就是初始化DDR，将uboot拷贝到DDR中并进入下一阶段。</p>
</blockquote>
<p>使能SPL，使uboot编译后生成两部分。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">diff --git a/arch/arm/mach-s5pc1xx/Kconfig b/arch/arm/mach-s5pc1xx/Kconfig</span><br><span class="line">index b9e620e885..2b973d0633 100644</span><br><span class="line">--- a/arch/arm/mach-s5pc1xx/Kconfig</span><br><span class="line">+++ b/arch/arm/mach-s5pc1xx/Kconfig</span><br><span class="line">@@ -15,6 +15,7 @@ config TARGET_S5P_WDG</span><br><span class="line">        select OF_CONTROL</span><br><span class="line">        select BLK</span><br><span class="line">        select DM_MMC</span><br><span class="line">+       select SUPPORT_SPL</span><br></pre></td></tr></table></figure>

<p>在配置完成后，直接编译测试，正常情况下可以生成u-boot-spl.bin,但是该bin文件无法直接启动测试，跟裸板程序一样需要进一步处理，也就是加头部信息。</p>
<p>这部分处理工作在uboot存在有成的工具，但是无法直接使用，需要针对s5pv210进行调整</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">diff --git a/tools/Makefile b/tools/Makefile</span><br><span class="line">index 4a86321f64..b2f1a75138 100644</span><br><span class="line">--- a/tools/Makefile</span><br><span class="line">+++ b/tools/Makefile</span><br><span class="line">@@ -193,6 +193,7 @@ HOSTLDLIBS_fit_check_sign := $(HOSTLDLIBS_mkimage)</span><br><span class="line"></span><br><span class="line"> hostprogs-$(CONFIG_EXYNOS5250) += mkexynosspl</span><br><span class="line"> hostprogs-$(CONFIG_EXYNOS5420) += mkexynosspl</span><br><span class="line">+hostprogs-$(CONFIG_S5PC110) += mkexynosspl</span><br><span class="line"> HOSTCFLAGS_mkexynosspl.o := -pedantic</span><br><span class="line"></span><br><span class="line"> ifdtool-objs := $(LIBFDT_OBJS) ifdtool.o</span><br><span class="line">diff --git a/tools/mkexynosspl.c b/tools/mkexynosspl.c</span><br><span class="line">index 53122b8614..a9be388e19 100644</span><br><span class="line">--- a/tools/mkexynosspl.c</span><br><span class="line">+++ b/tools/mkexynosspl.c</span><br><span class="line">@@ -11,6 +11,7 @@</span><br><span class="line"> #include &lt;string.h&gt;</span><br><span class="line"> #include &lt;sys/stat.h&gt;</span><br><span class="line"> #include &lt;compiler.h&gt;</span><br><span class="line">+#include &lt;generated/autoconf.h&gt;</span><br><span class="line"></span><br><span class="line"> #define CHECKSUM_OFFSET                (14*1024-4)</span><br><span class="line"> #define FILE_PERM              (S_IRUSR | S_IWUSR | S_IRGRP \</span><br><span class="line">@@ -28,11 +29,21 @@</span><br><span class="line">  * blob [i.e size - sizeof(struct var_size_header) bytes], calculates the</span><br><span class="line">  * checksum and compares it with value read from the header.</span><br><span class="line">  */</span><br><span class="line">+#ifdef CONFIG_ARCH_S5PC1XX</span><br><span class="line">+//BL1 Header (16byte) for s5pv210</span><br><span class="line">+struct var_size_header &#123;</span><br><span class="line">+       uint32_t spl_size;</span><br><span class="line">+       uint32_t reserved;</span><br><span class="line">+       uint32_t spl_checksum;</span><br><span class="line">+       uint32_t reserved1;</span><br><span class="line">+&#125;;</span><br><span class="line">+#else</span><br><span class="line"> struct var_size_header &#123;</span><br><span class="line">        uint32_t spl_size;</span><br><span class="line">        uint32_t spl_checksum;</span><br><span class="line">        uint32_t reserved[2];</span><br><span class="line"> &#125;;</span><br><span class="line">+#endif</span><br></pre></td></tr></table></figure>
<p>这样处理后将生成wdg-spl.bin，这个是可以烧录到SD卡进行测试的，这样虽然可以启动，并且蜂鸣器也没有报警，但是不幸的是串口也不会有任何输入打印（可能有些板级完全相同的，这样处理后在<code>spl阶段</code>输出少量打印的吧）。因为时钟与串口可能都没有正常初始化，无法通过输出打印确定spl运行的流程以及卡死的位置。</p>
<p>在进入这一步后，就需要引入新的调试手段，这里有两种，一种串口输出，直接通过汇编指令往串口的TX地址写数据，使其串口输出；另一种是点亮LED指示灯，同样使用汇编指令点亮LED灯。</p>
<p>这两种方式在裸板测试阶段，均以测试完成。这里我选择使用点亮LED灯，更直观方便。在uboot中将点亮LED灯，封装成一个接口函数<code>wdg_led_status</code>，入参为<code>1~15</code>数值，LED灯会根据相应的值被一次点亮。</p>
<p>下一步就是追踪<code>Crotex-a8</code>在SPL中的启动流程，在可能卡住或不确定的地方添加<code>wdg_led_status</code>，判断实际流程是否执行到此处，进行相关代码的调试。</p>
<p>这里简单记录一下，调试流程，细节东西可以直接看代码。</p>
<h3 id="uart与ddr初始化"><a href="#uart与ddr初始化" class="headerlink" title="uart与ddr初始化"></a>uart与ddr初始化</h3><p>在spl阶段uart和ddr的初始化是最关键的，这部分调试消耗的时间最长，主要是ddr老初始化不成功。最后直接将uplooking提供的uboot中ddr初始化部分全部移植过来，才完成ddr初始化。当时在这个阶段感觉又进行不下去了，主要是DDR这块不熟悉也没有相关的文档。</p>
<h3 id="移植LAN9220网卡驱动"><a href="#移植LAN9220网卡驱动" class="headerlink" title="移植LAN9220网卡驱动"></a>移植LAN9220网卡驱动</h3><p>网卡移植比较简单在设备中添加，lan9220网卡设备并配置相关参数，由于该网卡是内部集成PHY，因此相对更简单不需要考虑相关PHY的操作。</p>
<p>注意点：<code>总线位宽</code>、<code>时钟</code></p>
<ul>
<li>总线位宽：lan9220是16bit地址宽度，因此需要配置成16bit，默认好像是32bit。</li>
<li>时钟：lan9220接在SROM bank3上，因此需要配置相关时钟，这部分也是从旧uboot中移植。</li>
</ul>
<h3 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h3><p>命令行参数这部分主要是针对kernel而已，目前为了使用方便主要配置tftp boot与NFS文件系统</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define CONFIG_BOOTCOMMAND  &quot;run tftpboot&quot;</span><br><span class="line"></span><br><span class="line">#define CONFIG_RAMDISK_BOOT &quot;root=/dev/ram0 rw $&#123;console&#125;&quot;</span><br><span class="line"></span><br><span class="line">#define CONFIG_COMMON_BOOT  &quot;$&#123;console&#125;&quot;</span><br><span class="line"></span><br><span class="line">#define CONFIG_MISC_COMMON</span><br><span class="line"></span><br><span class="line">#define CONFIG_EXTRA_ENV_SETTINGS                   \</span><br><span class="line">    &quot;tftpboot=&quot; \</span><br><span class="line">        &quot;setenv bootargs root=/dev/nfs rw &quot; \</span><br><span class="line">        &quot;nfsroot=192.168.2.2:/home/wqshao/nfs/rootfs,tcp,nfsvers=3,nolock &quot; \</span><br><span class="line">        &quot;ip=192.168.2.3:192.168.2.2:192.168.2.1:255.255.255.0 ::eth0:off &quot; \</span><br><span class="line">        CONFIG_COMMON_BOOT \</span><br><span class="line">        &quot;;tftp 40000000 s5pv210-wdg.dtb; tftpboot 20008000 zImage; &quot;\</span><br><span class="line">        &quot;fdt addr 40000000; bootz 20008000 - 40000000\0&quot; \</span><br><span class="line">    &quot;ramboot=&quot; \</span><br><span class="line">        &quot;set bootargs &quot; CONFIG_RAMDISK_BOOT \</span><br><span class="line">        &quot;initrd=0x33000000,8M ramdisk=8192 &quot; \</span><br><span class="line">        &quot;;tftp 40000000 s5pv210-wdg.dtb; tftpboot 20008000 zImage; &quot;\</span><br><span class="line">        &quot;fdt addr 40000000; bootz 20008000 - 40000000\0&quot; \</span><br><span class="line">    &quot;mmcboot=&quot; \</span><br><span class="line">        &quot;set bootargs root=/dev/mmcblk$&#123;mmcdev&#125;p$&#123;mmcrootpart&#125; &quot; \</span><br><span class="line">        &quot;rootfstype=$&#123;rootfstype&#125; $&#123;opts&#125; $&#123;lcdinfo&#125; &quot; \</span><br><span class="line">        CONFIG_COMMON_BOOT &quot;; run bootk\0&quot; \</span><br><span class="line">    &quot;boottrace=setenv opts initcall_debug; run bootcmd\0&quot; \</span><br><span class="line">    &quot;bootchart=set opts init=/sbin/bootchartd; run bootcmd\0&quot; \</span><br><span class="line">    &quot;verify=n\0&quot; \</span><br><span class="line">    &quot;rootfstype=ext4\0&quot; \</span><br><span class="line">    &quot;console=console=ttySAC0,115200n8 earlyprintk\0&quot; \</span><br><span class="line">    &quot;loaduimage=ext4load mmc $&#123;mmcdev&#125;:$&#123;mmcbootpart&#125; 0x30007FC0 uImage\0&quot; \</span><br><span class="line">    &quot;mmcdev=0\0&quot; \</span><br><span class="line">    &quot;mmcbootpart=2\0&quot; \</span><br><span class="line">    &quot;mmcrootpart=5\0&quot; \</span><br><span class="line">    &quot;partitions=&quot; PARTS_DEFAULT \</span><br><span class="line">    &quot;opts=always_resume=1\0&quot; \</span><br><span class="line">    &quot;dfu_alt_info=&quot; CONFIG_DFU_ALT &quot;\0&quot;</span><br></pre></td></tr></table></figure>

<p><strong>注意点</strong>:</p>
<ul>
<li>串口打印输出，在进入内核后打印内核调试信息，必须在<code>console</code>项添加<code>earlyprintk</code>，否则严重影响内核调试，在内核卡死的时候不输出任何信息无法定位</li>
<li>tftpboot需要适应zimage和dtb，在bootz参数后需要添加kernel和dtb加载到内存中的地址</li>
<li>nfs文件系统，在挂载nfs文件系统时，出现卡住无法挂载的情况，根本原因是uboot中默认支持的nfs协议版本为<code>2</code>,但是开发机中搭建的NFS server支持的nfs协议版本为<code>3</code>和<code>4</code>。由于协议版本不匹配导致无法正常挂载文件系统，因此需要在<code>nfsroot</code>参数后添加<code>nfsvers=3</code></li>
</ul>
<h3 id="uboot与kernel的机器码匹配"><a href="#uboot与kernel的机器码匹配" class="headerlink" title="uboot与kernel的机器码匹配"></a>uboot与kernel的机器码匹配</h3><p>在kernel启动中出现以下错误：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Error: invalid dtb and unrecognized/unsupported machine ID</span><br><span class="line">  r1=0x00000b2e, r2=0x20000100</span><br><span class="line">  r2[]=05 00 00 00 01 00 41 54 00 00 00 00 00 00 00 00</span><br><span class="line">Available machine support:</span><br><span class="line"></span><br><span class="line">ID (hex)        NAME</span><br><span class="line">ffffffff        Generic DT based system</span><br><span class="line">ffffffff        Samsung S5PC110/S5PV210-based board</span><br><span class="line"></span><br><span class="line">Please check your kernel config and/or bootloader.</span><br></pre></td></tr></table></figure>
<blockquote>
<p>该错误就是uboot传入的与内核中的machine ID不一致无法启动的。</p>
</blockquote>
<p>uboot中传递的ID是<code>r1=0x00000b2e</code>，由<code>bi_arch_number</code>字段配置，但是内核不支持，而内核支持的ID是<code>ffffffff</code>, 因此解决方法有两种，一种是修改内核ID为uboot传递的，另一种是修改uboot传递的ID为全f</p>
<p>这里选择后者，在uboot板级文件中修改<code>bi_arch_number = 0xffffffff</code></p>
<p>bi_arch_number配置值在uboot中可以通过<code>bdinfo</code>获取</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wdg # bdinfo</span><br><span class="line">bd address  = 0x3fe93fa0</span><br><span class="line">boot_params = 0x20000100</span><br><span class="line">   ...</span><br><span class="line">arch_number = 0x00000b2e    &lt;ID&gt;</span><br><span class="line">TLB addr    = 0x3fff0000</span><br><span class="line">irq_sp      = 0x3fe930f0</span><br><span class="line">sp start    = 0x3fe930e0</span><br><span class="line">Early malloc usage: 100 / 400</span><br></pre></td></tr></table></figure>
<h2 id="kernel移植"><a href="#kernel移植" class="headerlink" title="kernel移植"></a>kernel移植</h2><h3 id="添加wdg配置文件"><a href="#添加wdg配置文件" class="headerlink" title="添加wdg配置文件"></a>添加wdg配置文件</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cp arch/arm/configs/s5pv210_defconfig arch/arm/configs/s5pv210_wdg_defconfig</span><br></pre></td></tr></table></figure>

<h3 id="添加wdg设备树"><a href="#添加wdg设备树" class="headerlink" title="添加wdg设备树"></a>添加wdg设备树</h3><p>内核中同样选择<code>smdkv210</code>的设备树配置文件为模板进行配置。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cp arch/arm/boot/dts/s5pv210-smdkv210.dts  arch/arm/boot/dts/s5pv210-wdg.dts</span><br></pre></td></tr></table></figure>
<p>将<code>s5pv210-wdg.dts</code>中可能多余的配置项删减，并修改相应的Makefile和Kconfig。</p>
<h3 id="内核配置——默认调试输出串口"><a href="#内核配置——默认调试输出串口" class="headerlink" title="内核配置——默认调试输出串口"></a>内核配置——默认调试输出串口</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Kernel hacking  ---&gt;</span><br><span class="line">    arm Debugging  ---&gt;</span><br><span class="line">        [*] Kernel low-level debugging functions (read help!)</span><br><span class="line">              Kernel low-level debugging port (Use Samsung S3C UART 0 for low-level debug)  ---&gt;</span><br><span class="line">        [*] Early printk</span><br></pre></td></tr></table></figure>


<h3 id="调整时钟"><a href="#调整时钟" class="headerlink" title="调整时钟"></a>调整时钟</h3><p>经过以上步骤编译完成的zImage，在启动时会卡死出错，如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[    0.000000] S5PV210 clocks: mout_apll = 0, mout_mpll = 0</span><br><span class="line">[    0.000000]  mout_epll = 0, mout_vpll = 0</span><br><span class="line">[    0.000000] Division by zero in kernel.</span><br><span class="line">[    0.000000] CPU: 0 PID: 0 Comm: swapper Not tainted 5.16.0-11061-g6c325cf02a71 #15</span><br><span class="line">[    0.000000] Hardware name: Samsung S5PC110/S5PV210-based board</span><br><span class="line">[    0.000000]  unwind_backtrace from show_stack+0x10/0x14</span><br><span class="line">[    0.000000]  show_stack from Ldiv0+0x8/0x10</span><br><span class="line">[    0.000000]  Ldiv0 from clockevents_config.part.0+0x18/0x74</span><br><span class="line">[    0.000000]  clockevents_config.part.0 from clockevents_config_and_register+0x20/0x2c</span><br><span class="line">[    0.000000]  clockevents_config_and_register from _samsung_pwm_clocksource_init+0x150/0x2a0</span><br><span class="line">[    0.000000]  _samsung_pwm_clocksource_init from samsung_pwm_alloc+0x144/0x190</span><br><span class="line">[    0.000000]  samsung_pwm_alloc from timer_probe+0x74/0xec</span><br><span class="line">[    0.000000]  timer_probe from start_kernel+0x4b4/0x620</span><br><span class="line">[    0.000000]  start_kernel from 0x0</span><br><span class="line">[    0.000000] ------------[ cut here ]------------</span><br><span class="line">[    0.000000] WARNING: CPU: 0 PID: 0 at kernel/time/clockevents.c:38 cev_delta2ns+0x148/0x170</span><br><span class="line">[    0.000000] Modules linked in:</span><br><span class="line">[    0.000000] CPU: 0 PID: 0 Comm: swapper Not tainted 5.16.0-11061-g6c325cf02a71 #15</span><br><span class="line">[    0.000000] Hardware name: Samsung S5PC110/S5PV210-based board</span><br><span class="line">[    0.000000]  unwind_backtrace from show_stack+0x10/0x14</span><br><span class="line">[    0.000000]  show_stack from __warn+0xd4/0xec</span><br><span class="line">[    0.000000]  __warn from warn_slowpath_fmt+0x64/0xc8</span><br><span class="line">[    0.000000]  warn_slowpath_fmt from cev_delta2ns+0x148/0x170</span><br><span class="line">[    0.000000]  cev_delta2ns from clockevents_config.part.0+0x54/0x74</span><br><span class="line">[    0.000000]  clockevents_config.part.0 from clockevents_config_and_register+0x20/0x2c</span><br><span class="line">[    0.000000]  clockevents_config_and_register from _samsung_pwm_clocksource_init+0x150/0x2a0</span><br><span class="line">[    0.000000]  _samsung_pwm_clocksource_init from samsung_pwm_alloc+0x144/0x190</span><br><span class="line">[    0.000000]  samsung_pwm_alloc from timer_probe+0x74/0xec</span><br><span class="line">[    0.000000]  timer_probe from start_kernel+0x4b4/0x620</span><br><span class="line">[    0.000000]  start_kernel from 0x0</span><br></pre></td></tr></table></figure>

<p>这个错误主要是<code>xxti</code>时钟没有配置，因此需要在设备树中添加<code>xxti</code>的时钟配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+++ b/arch/arm/boot/dts/s5pv210-wdg.dts</span><br><span class="line">@@ -58,6 +58,10 @@ backlight &#123;</span><br><span class="line">        &#125;;</span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line">+&amp;xxti &#123;</span><br><span class="line">+       clock-frequency = &lt;24000000&gt;;</span><br><span class="line">+&#125;;</span><br><span class="line">+</span><br><span class="line"> &amp;xusbxti &#123;</span><br><span class="line">        clock-frequency = &lt;24000000&gt;;</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>

<h3 id="使用Ramdisk文件系统"><a href="#使用Ramdisk文件系统" class="headerlink" title="使用Ramdisk文件系统"></a>使用Ramdisk文件系统</h3><p>到这一步内核基本完成需要挂载文件系统，这里使用最方便的文件系统ramdisk，文件系统格式<code>cpio</code></p>
<p>内核配置ramdisk文件系统路径：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">General setup  ---&gt;</span><br><span class="line">    [*] Initial RAM filesystem and RAM disk (initramfs/initrd) support</span><br><span class="line">    (/home/xxx/rootfs.cpio) Initramfs source file(s)</span><br></pre></td></tr></table></figure>

<p>这样在uboot中选择<code>ramboot</code>进行启动，系统就可以正常启动进入文件系统</p>
<p><code>ramboot</code>启动操作方式：重启系统回车进入uboot命令行中，执行<code>run ramboot</code></p>
<h3 id="调试LAN9220网卡驱动"><a href="#调试LAN9220网卡驱动" class="headerlink" title="调试LAN9220网卡驱动"></a>调试LAN9220网卡驱动</h3><p>由于ramdisk文件系统的使用没有NFS文件系统方便，因此添加网卡驱动为后续挂载NFS文件系统做准备。</p>
<p>在设备树中添加lan9220设备，参考<code>Documentation/devicetree/bindings/net/smsc,lan9115.yaml</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ethernet@a8000000 &#123;</span><br><span class="line">    compatible = &quot;smsc,lan9115&quot;;</span><br><span class="line">    reg = &lt;0xA8000000 0x10000&gt;;</span><br><span class="line">    phy-mode = &quot;mii&quot;;</span><br><span class="line">    interrupt-parent = &lt;&amp;gph1&gt;;</span><br><span class="line">    interrupts = &lt;1 IRQ_TYPE_LEVEL_LOW&gt;;</span><br><span class="line">    clocks = &lt;&amp;clocks CLK_SROMC&gt;;</span><br><span class="line">    local-mac-address = [00 00 de ad be ef];</span><br><span class="line">    reg-io-width = &lt;2&gt;;</span><br><span class="line">    smsc,force-internal-phy;</span><br><span class="line">    smsc,irq-push-pull;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>注意点与uboot中一样，<code>总线位宽</code>与<code>时钟</code>,在内核中时钟可以直接通过添加<code>clocks = &lt;&amp;clocks CLK_SROMC&gt;;</code>开启，如果不添加时钟，网卡驱动进行loop测试时会失败。</p>
<h3 id="添加NFS文件系统"><a href="#添加NFS文件系统" class="headerlink" title="添加NFS文件系统"></a>添加NFS文件系统</h3><p>NFS文件系统，在内核中需要开启NFS client，启动参考uboot命令行中的tftpboot</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">File systems  ---&gt;</span><br><span class="line">    [*] Network File Systems  ---&gt;</span><br><span class="line">        &lt;*&gt;   NFS client support</span><br><span class="line">        &lt;*&gt;     NFS client support for NFS version 2</span><br><span class="line">        &lt;*&gt;     NFS client support for NFS version 3</span><br><span class="line">        [ ]       NFS client support for the NFSv3 ACL protocol extension</span><br><span class="line">        &lt; &gt;     NFS client support for NFS version 4</span><br><span class="line">        [ ]     Provide swap over NFS support</span><br><span class="line">        [*]   Root file system on NFS</span><br><span class="line">        [*]   NFS: Disable NFS UDP protocol support</span><br></pre></td></tr></table></figure>

<h2 id="文件系统构建"><a href="#文件系统构建" class="headerlink" title="文件系统构建"></a>文件系统构建</h2><p>通过buildroot构建最小的文件系统，后续根据实际需求逐步添加。</p>
<h3 id="添加wdg配置"><a href="#添加wdg配置" class="headerlink" title="添加wdg配置"></a>添加wdg配置</h3><p>在<code>configs</code>目录下搜索存在<code>cortex_a8</code>的配置文件，随便选择一个.&#x2F;mx51evk_defconfig为例，拷贝一份添加自己的配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cp configs/mx51evk_defconfig configs/s5pv210_wdg_defconfig</span><br></pre></td></tr></table></figure>

<h3 id="调整配置——只编译文件系统"><a href="#调整配置——只编译文件系统" class="headerlink" title="调整配置——只编译文件系统"></a>调整配置——只编译文件系统</h3><ol>
<li>关闭uboot和kernel的编译配置</li>
<li>指定包的下载目录为<code>BR2_DL_DIR=&quot;$(TOPDIR)/../downloads&quot;</code>，方便使用单独的库进行保存</li>
<li>删除多余无用配置项</li>
<li>配置串口设备名<code>BR2_TARGET_GENERIC_GETTY_PORT=&quot;ttySAC0&quot;</code></li>
<li>配置ramdisk文件系统格式<code>ROOTFS_CPIO</code></li>
<li><del>配置shell为bash</del>，后续根据实际需求确定是否修改，改为bash，文件系统比之前大1.2M将近一倍</li>
</ol>
<h2 id="参考-2"><a href="#参考-2" class="headerlink" title="参考"></a>参考</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly93aW5kZG9pbmcuY29kaW5nLm5ldC9wL3M1cHYyMTAvZC9kb2NzL2dpdC9yYXcvbWFzdGVyL2RhdGFzaGVldC9TNVBWMjEwX2lST01fQXBwbGljYXRpb25Ob3RlX1ByZWxpbWluYXJ5XzIwMDkxMTI2LnBkZg==">S5PV210_iROM_ApplicationNote_Preliminary_20091126.pdf<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpdWppYTIxMDAvYXJ0aWNsZS9kZXRhaWxzLzg2ODg2NTc=">linux-3.4.2 smsc911x 网卡移植<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW9qaWFvaHVhemkvYXJ0aWNsZS9kZXRhaWxzLzgyODUwNTQ/c3BtPTEwMDEuMjAxNC4zMDAxLjU1MDI=">s5pv210 uboot-2012-10移植(五) 之支持LAN9220网卡<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hhbnhpYW9odWFhL2FydGljbGUvZGV0YWlscy8xMDU0MjA2Njk=">S5PV210 Linux内核移植 - 天嵌E8<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>Cortex-A8</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>arm</tag>
        <tag>uboot</tag>
        <tag>cortex-a8</tag>
        <tag>bulidroot</tag>
        <tag>s5pv210</tag>
      </tags>
  </entry>
  <entry>
    <title>Cgroup框架的实现</title>
    <url>/post/3438.html</url>
    <content><![CDATA[<p>CGoup核心主要创建一系列sysfs文件，用户空间可以通过这些节点控制CGroup各子系统行为，以及各子系统模块根据参数。在执行过程中或调度进程到不同CPU上，或控制CPU占用时间，或控制IO带宽等等。另外，在每个系统的proc文件系统中都有一个cgroup，显示该进程对应的CGroup各子系统信息。</p>
<p><img data-src="/images/cgroup/cgroup_struct.png" alt="cgroup strutc"></p>
<span id="more"></span>

<h2 id="内核配置"><a href="#内核配置" class="headerlink" title="内核配置"></a>内核配置</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Symbol: CGROUPS [=y]</span><br><span class="line">Type  : boolean</span><br><span class="line">Prompt: Control Group support</span><br><span class="line">  Location:</span><br><span class="line">      -&gt; General setup</span><br><span class="line"></span><br><span class="line">Symbol: CGROUP_SCHED [=y]</span><br><span class="line">Type  : boolean</span><br><span class="line">Prompt: Group CPU scheduler</span><br><span class="line">  Location:</span><br><span class="line">      -&gt; General setup</span><br><span class="line">	        -&gt; Control Group support (CGROUPS [=y])</span><br></pre></td></tr></table></figure>

<p>通过<code>CONFIG_CGROUPS</code>配置cgroup框架的实现,<code>CONFIG_CGROUP_SCHED</code>控制CPU子系统。</p>
<h2 id="基本应用"><a href="#基本应用" class="headerlink" title="基本应用"></a>基本应用</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">mount -t cgroup -o cpu cgroup /mnt/</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">mkdir</span> tst_cgroup</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">rmdir</span> tst_cgroup</span></span><br></pre></td></tr></table></figure>
<p>在文件系统中cgroup的挂载目录,也就是cgroup虚拟文件系统的根目录用数据结构<code>struct cgroupfs_root</code>表示.而cgroup用<code>struct cgroup</code>表示.</p>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>主要用于对进程不同资源的管理和配置，以及进程和cgroup之间的关系。</p>
<h3 id="task-struct"><a href="#task-struct" class="headerlink" title="task_struct"></a>task_struct</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_CGROUPS</span></span><br><span class="line">	<span class="comment">/* Control Group info protected by css_set_lock */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">css_set</span> __<span class="title">rcu</span> *<span class="title">cgroups</span>;</span></span><br><span class="line">	<span class="comment">/* cg_list protected by css_set_lock and tsk-&gt;alloc_lock */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">cg_list</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>struct task_struct</code>中并没有一个直接的成员指向cgroup,而是指向了<code>struct css_set</code>的结构, css_set存储路与进程相关的cgroup信息。</p>
<p><code>cg_list</code>: 是一个链表结构，用于将连到同一个css_set的进程组织成一个链表。</p>
<h3 id="css-set"><a href="#css-set" class="headerlink" title="css_set"></a>css_set</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * A css_set is a structure holding pointers to a set of</span></span><br><span class="line"><span class="comment"> * cgroup_subsys_state objects. This saves space in the task struct</span></span><br><span class="line"><span class="comment"> * object and speeds up fork()/exit(), since a single inc/dec and a</span></span><br><span class="line"><span class="comment"> * list_add()/del() can bump the reference count on the entire cgroup</span></span><br><span class="line"><span class="comment"> * set for a task.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">css_set</span> &#123;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Reference count */</span></span><br><span class="line">	<span class="type">atomic_t</span> refcount;  <span class="comment">//引用计数，因为一个css_set可以被多个进程共用，这些进程的cgroup信息相同</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * List running through all cgroup groups in the same hash</span></span><br><span class="line"><span class="comment">	 * slot. Protected by css_set_lock</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> <span class="title">hlist</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * List running through all tasks using this cgroup</span></span><br><span class="line"><span class="comment">	 * group. Protected by css_set_lock</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">tasks</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * List of cg_cgroup_link objects on link chains from</span></span><br><span class="line"><span class="comment">	 * cgroups referenced from this css_set. Protected by</span></span><br><span class="line"><span class="comment">	 * css_set_lock</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">     <span class="comment">//由cg_cgroup_link组成的链表，链表上每一项cg_cgroup_link都指向和css_set关联的cgroup.</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">cg_links</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Set of subsystem states, one for each subsystem. This array</span></span><br><span class="line"><span class="comment">	 * is immutable after creation apart from the init_css_set</span></span><br><span class="line"><span class="comment">	 * during subsystem registration (at boot time) and modular subsystem</span></span><br><span class="line"><span class="comment">	 * loading/unloading.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">     <span class="comment">/*</span></span><br><span class="line"><span class="comment">     *css_set关联的css.每一个subsystem对应数组中相应id的项。</span></span><br><span class="line"><span class="comment">     *subsys应当包括所有子系统的css.如果此css_set没有制定某个subsystem的css或者subsystem没有mount，则默认初始化为根css.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cgroup_subsys_state</span> *<span class="title">subsys</span>[<span class="title">CGROUP_SUBSYS_COUNT</span>];</span> <span class="comment">//是进程与一个特定子系统相关的信息</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* For RCU-protected deletion */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">rcu_head</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>file: include&#x2F;linux&#x2F;cgroup.h</p>
</blockquote>
<p>主要用来描述一个个子系统，通过<code>cgroup_subsys_state</code>定义不同子系统的相关控制信息，<code>hlist</code>将同一个子系统下的所有css_set组织成一个hash表，方便内核查找特定的css_set.<br><code>tasks</code>指向所有连到此css_set的进程连成的链表。</p>
<p>那从<code>struct css_set</code>怎么转换到cgroup呢? 再来看一个辅助的数据结构<code>struct cg_cgroup_link</code></p>
<h3 id="cgroup-subsys-state"><a href="#cgroup-subsys-state" class="headerlink" title="cgroup_subsys_state"></a>cgroup_subsys_state</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Per-subsystem/per-cgroup state maintained by the system. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cgroup_subsys_state</span> &#123;</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * The cgroup that this subsystem is attached to. Useful</span></span><br><span class="line"><span class="comment">     * for subsystems that want to know about the cgroup</span></span><br><span class="line"><span class="comment">     * hierarchy structure</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cgroup</span> *<span class="title">cgroup</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * State maintained by the cgroup system to allow subsystems</span></span><br><span class="line"><span class="comment">     * to be &quot;busy&quot;. Should be accessed via css_get(),</span></span><br><span class="line"><span class="comment">     * css_tryget() and css_put().</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">atomic_t</span> refcnt;</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line">    <span class="comment">/* ID for this css, if possible */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">css_id</span> __<span class="title">rcu</span> *<span class="title">id</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Used to put @cgroup-&gt;dentry on the last css_put() */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">dput_work</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>file: include&#x2F;linux&#x2F;cgroup.h</p>
</blockquote>
<p>cgroup指针指向了一个cgroup结构，也就是进程属于的cgroup.</p>
<p>进程受到子系统的控制，实际上是通过加入到特定的cgroup实现的，因为cgroup在特定的层级上，而子系统又是附加到曾经上的 。通过以上三个结构，进程就可以和cgroup关联起来了 ：</p>
<blockquote>
<p>task_struct-&gt;css_set-&gt;cgroup_subsys_state-&gt;cgroup。</p>
</blockquote>
<p><img data-src="/images/cgroup/task_cgroup_relation.png" alt="task cgroup"></p>
<h3 id="cgroup"><a href="#cgroup" class="headerlink" title="cgroup"></a>cgroup</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cgroup</span> &#123;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> flags;		<span class="comment">/* &quot;unsigned long&quot; so bitops work */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * count users of this cgroup. &gt;0 means busy, but doesn&#x27;t</span></span><br><span class="line"><span class="comment">	 * necessarily indicate the number of tasks in the cgroup</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">atomic_t</span> count;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> id;				<span class="comment">/* ida allocated in-hierarchy ID */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * We link our &#x27;sibling&#x27; struct into our parent&#x27;s &#x27;children&#x27;.</span></span><br><span class="line"><span class="comment">	 * Our children link their &#x27;sibling&#x27; into our &#x27;children&#x27;.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">sibling</span>;</span>	<span class="comment">/* my parent&#x27;s children */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">children</span>;</span>	<span class="comment">/* my children */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">files</span>;</span>		<span class="comment">/* my files */</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cgroup</span> *<span class="title">parent</span>;</span>		<span class="comment">/* my parent */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">dentry</span>;</span>		<span class="comment">/* cgroup fs entry, RCU protected */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * This is a copy of dentry-&gt;d_name, and it&#x27;s needed because</span></span><br><span class="line"><span class="comment">	 * we can&#x27;t use dentry-&gt;d_name in cgroup_path().</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * You must acquire rcu_read_lock() to access cgrp-&gt;name, and</span></span><br><span class="line"><span class="comment">	 * the only place that can change it is rename(), which is</span></span><br><span class="line"><span class="comment">	 * protected by parent dir&#x27;s i_mutex.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Normally you should use cgroup_name() wrapper rather than</span></span><br><span class="line"><span class="comment">	 * access it directly.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cgroup_name</span> __<span class="title">rcu</span> *<span class="title">name</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Private pointers for each registered subsystem */</span></span><br><span class="line">    <span class="comment">//此cgroup关联subsystem的css结构，每个subsystem的css在数组中对应subsys[subsystem-&gt;subsys_id].</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cgroup_subsys_state</span> *<span class="title">subsys</span>[<span class="title">CGROUP_SUBSYS_COUNT</span>];</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cgroupfs_root</span> *<span class="title">root</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * List of cg_cgroup_links pointing at css_sets with</span></span><br><span class="line"><span class="comment">	 * tasks in this cgroup. Protected by css_set_lock</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">css_sets</span>;</span> <span class="comment">//通过cs_cgroup_link指向此cgroup关联的css_set</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">allcg_node</span>;</span>	<span class="comment">/* cgroupfs_root-&gt;allcg_list */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">cft_q_node</span>;</span>	<span class="comment">/* used during cftype add/rm */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Linked list running through all cgroups that can</span></span><br><span class="line"><span class="comment">	 * potentially be reaped by the release agent. Protected by</span></span><br><span class="line"><span class="comment">	 * release_list_lock</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">release_list</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * list of pidlists, up to two for each namespace (one for procs, one</span></span><br><span class="line"><span class="comment">	 * for tasks); created on demand.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">pidlists</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">pidlist_mutex</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* For RCU-protected deletion */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">rcu_head</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">free_work</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* List of events which userspace want to receive */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">event_list</span>;</span></span><br><span class="line">	<span class="type">spinlock_t</span> event_list_lock;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* directory xattrs */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">simple_xattrs</span> <span class="title">xattrs</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>sibling</code>,<code>children</code>和<code>parent</code>三个list_head负责将同一层级的cgroup连接成一颗cgroup树。</li>
<li><code>subsys</code>是一个指针数组，存储一组指向cgroup_subsys_state的指针。这组指针指向了此cgroup跟各个子系统相关的信息</li>
<li><code>root</code>指向了一个cgroupfs_root的结构，就是cgroup所在的层级对应的结构体</li>
</ul>
<p>cgroup和css_set是多对多的关系，既：一个css_set可以对应多个cgroup,同时一个cgroup也可以被多个css_set所包含。<br>这种多对多的映射关系，是通过cg_cgroup_link这个中间结构来关联的。</p>
<h3 id="cg-cgroup-link"><a href="#cg-cgroup-link" class="headerlink" title="cg_cgroup_link"></a>cg_cgroup_link</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Link structure for associating css_set objects with cgroups */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cg_cgroup_link</span> &#123;</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * List running through cg_cgroup_links associated with a</span></span><br><span class="line"><span class="comment">     * cgroup, anchored on cgroup-&gt;css_sets</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">cgrp_link_list</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cgroup</span> *<span class="title">cgrp</span>;</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * List running through cg_cgroup_links pointing at a</span></span><br><span class="line"><span class="comment">     * single css_set object, anchored on css_set-&gt;cg_links</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">cg_link_list</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">css_set</span> *<span class="title">cg</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>一个cg_cgroup_link需要包含两类信息，即关联的cgroup和css_set信息，一个cg_cgroup_link可以让一个cgroup和一个css_set相关联。但是正如我们前面所说，css_set和cgroup是多对多的对应关系，所以，一个css_set需要保存多个cg_cgroup_link，一个cgroup也需要保存多个cg_cgroup_link信息。具体来说，css_set中的cg_links维护了一个链表，链表中的元素为cg_cgroup_link中的cg_link_list.cgroup中的css_set也维护了一个cg_cgroup_link链表，链表中元素为cgrp_link_list.</p>
<p><code>cgrp_link_list</code>连入到<code>cgroup-&gt;css_set</code>指向的链表，cgrp则指向此<code>cg_cgroup_link</code>相关的cgroup。</p>
<p><code>cg_link_list</code>则连入到<code>css_set-&gt;cg_links</code>指向的链表,cg则指向此<code>cg_cgroup_link</code>相关的css_set。</p>
<h3 id="cgroupfs-root"><a href="#cgroupfs-root" class="headerlink" title="cgroupfs_root"></a>cgroupfs_root</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * A cgroupfs_root represents the root of a cgroup hierarchy, and may be</span></span><br><span class="line"><span class="comment"> * associated with a superblock to form an active hierarchy.  This is</span></span><br><span class="line"><span class="comment"> * internal to cgroup core.  Don&#x27;t access directly from controllers.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cgroupfs_root</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> *<span class="title">sb</span>;</span>  <span class="comment">//cgroup文件系统的超级块</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * The bitmask of subsystems intended to be attached to this</span></span><br><span class="line"><span class="comment">	 * hierarchy</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> subsys_mask; <span class="comment">//hierarchy相关联的subsys 位图</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Unique id for this hierarchy. */</span></span><br><span class="line">	<span class="type">int</span> hierarchy_id;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* The bitmask of subsystems currently attached to this hierarchy */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> actual_subsys_mask;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* A list running through the attached subsystems */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">subsys_list</span>;</span> <span class="comment">//hierarchy中的subsys链表</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* The root cgroup for this hierarchy */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cgroup</span> <span class="title">top_cgroup</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Tracks how many cgroups are currently defined in hierarchy.*/</span></span><br><span class="line">	<span class="type">int</span> number_of_cgroups;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* A list running through the active hierarchies */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">root_list</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* All cgroups on this root, cgroup_mutex protected */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">allcg_list</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Hierarchy-specific flags */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* IDs for cgroups in this hierarchy */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ida</span> <span class="title">cgroup_ida</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* The path to use for release notifications. */</span></span><br><span class="line">	<span class="type">char</span> release_agent_path[PATH_MAX];</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* The name for this hierarchy - may be empty */</span></span><br><span class="line">	<span class="type">char</span> name[MAX_CGROUP_ROOT_NAMELEN];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>top_cgroup</code>指向了所在层级的根cgroup，也就是创建层级时自动创建的那个cgroup。</p>
<h3 id="cgroup-subsys"><a href="#cgroup-subsys" class="headerlink" title="cgroup_subsys"></a>cgroup_subsys</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Control Group subsystem type.</span></span><br><span class="line"><span class="comment"> * See Documentation/cgroups/cgroups.txt for details</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cgroup_subsys</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cgroup_subsys_state</span> *(*<span class="title">css_alloc</span>)(<span class="keyword">struct</span> <span class="title">cgroup</span> *<span class="title">cgrp</span>);</span></span><br><span class="line">    <span class="type">int</span> (*css_online)(<span class="keyword">struct</span> cgroup *cgrp);</span><br><span class="line">    <span class="type">void</span> (*css_offline)(<span class="keyword">struct</span> cgroup *cgrp);</span><br><span class="line">    <span class="type">void</span> (*css_free)(<span class="keyword">struct</span> cgroup *cgrp);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> (*allow_attach)(<span class="keyword">struct</span> cgroup *cgrp, <span class="keyword">struct</span> cgroup_taskset *tset);</span><br><span class="line">    <span class="type">int</span> (*can_attach)(<span class="keyword">struct</span> cgroup *cgrp, <span class="keyword">struct</span> cgroup_taskset *tset);</span><br><span class="line">    <span class="type">void</span> (*cancel_attach)(<span class="keyword">struct</span> cgroup *cgrp, <span class="keyword">struct</span> cgroup_taskset *tset);</span><br><span class="line">    <span class="type">void</span> (*attach)(<span class="keyword">struct</span> cgroup *cgrp, <span class="keyword">struct</span> cgroup_taskset *tset);</span><br><span class="line">    <span class="type">void</span> (*fork)(<span class="keyword">struct</span> task_struct *task);</span><br><span class="line">    <span class="type">void</span> (*<span class="built_in">exit</span>)(<span class="keyword">struct</span> cgroup *cgrp, <span class="keyword">struct</span> cgroup *old_cgrp,</span><br><span class="line">             <span class="keyword">struct</span> task_struct *task);</span><br><span class="line">    <span class="type">void</span> (*bind)(<span class="keyword">struct</span> cgroup *root);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> subsys_id;</span><br><span class="line">    <span class="type">int</span> disabled;</span><br><span class="line">    <span class="type">int</span> early_init;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * True if this subsys uses ID. ID is not available before cgroup_init()</span></span><br><span class="line"><span class="comment">     * (not available in early_init time.)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">bool</span> use_id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * If %false, this subsystem is properly hierarchical -</span></span><br><span class="line"><span class="comment">     * configuration, resource accounting and restriction on a parent</span></span><br><span class="line"><span class="comment">     * cgroup cover those of its children.  If %true, hierarchy support</span></span><br><span class="line"><span class="comment">     * is broken in some ways - some subsystems ignore hierarchy</span></span><br><span class="line"><span class="comment">     * completely while others are only implemented half-way.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * It&#x27;s now disallowed to create nested cgroups if the subsystem is</span></span><br><span class="line"><span class="comment">     * broken and cgroup core will emit a warning message on such</span></span><br><span class="line"><span class="comment">     * cases.  Eventually, all subsystems will be made properly</span></span><br><span class="line"><span class="comment">     * hierarchical and this will go away.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">     <span class="type">bool</span> broken_hierarchy;</span><br><span class="line">     <span class="type">bool</span> warned_broken_hierarchy;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_CGROUP_TYPE_NAMELEN 32</span></span><br><span class="line">     <span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/*</span></span><br><span class="line"><span class="comment">      * Link to parent, and list entry in parent&#x27;s children.</span></span><br><span class="line"><span class="comment">      * Protected by cgroup_lock()</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">cgroupfs_root</span> *<span class="title">root</span>;</span></span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">sibling</span>;</span></span><br><span class="line">     <span class="comment">/* used when use_id == true */</span></span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">idr</span> <span class="title">idr</span>;</span></span><br><span class="line">     <span class="type">spinlock_t</span> id_lock;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/* list of cftype_sets */</span></span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">cftsets</span>;</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">/* base cftypes, automatically [de]registered with subsys itself */</span></span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">cftype</span> *<span class="title">base_cftypes</span>;</span></span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">cftype_set</span> <span class="title">base_cftset</span>;</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">/* should be defined only by modular subsystems */</span></span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">module</span>;</span></span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>
<p>Cgroup_subsys定义了一组操作，让各个子系统根据各自的需要去实现。这个相当于C++中抽象基类，然后各个特定的子系统对应cgroup_subsys则是实现了相应操作的子类。类似的思想还被用在了cgroup_subsys_state中，cgroup_subsys_state并未定义控制信息，而只是定义了各个子系统都需要的共同信息，比如该cgroup_subsys_state从属的cgroup。然后各个子系统再根据各自的需要去定义自己的进程控制信息结构体，最后在各自的结构体中将cgroup_subsys_state包含进去，这样通过Linux内核的container_of等宏就可以通过cgroup_subsys_state来获取相应的结构体。</p>
<h3 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h3><p><img data-src="/images/cgroup/cgroup_data_struct.jpeg" alt="cgroup data struct"></p>
<p>|	数据结构	|	划分	|<br>|	:——:	|	:—:	|<br>|	cgroupfs_root	|	层级（hierarchy）	|<br>|	css_set	|	子系统（subsystem）	|<br>|	cgroup	|	进程控制组	|</p>
<h2 id="cgroup初始化"><a href="#cgroup初始化" class="headerlink" title="cgroup初始化"></a>cgroup初始化</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">start_kernel</span><br><span class="line">	\-&gt;cgroup_init_early();</span><br><span class="line">		\-&gt;init_cgroup_root</span><br><span class="line">		\-&gt;cgroup_init_subsys</span><br><span class="line">	\-&gt;cgroup_init();</span><br><span class="line">		\-&gt;cgroup_init_subsys</span><br><span class="line">		\-&gt;kobject_create_and_add</span><br><span class="line">		\-&gt;register_filesystem</span><br></pre></td></tr></table></figure>

<h3 id="cgroup-init-early"><a href="#cgroup-init-early" class="headerlink" title="cgroup_init_early"></a>cgroup_init_early</h3><p>第一阶段：主要进行数据结构的初始化和链表之间关系的绑定</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __init <span class="title function_">cgroup_init_early</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">atomic_set</span>(&amp;init_css_set.refcount, <span class="number">1</span>);</span><br><span class="line">    INIT_LIST_HEAD(&amp;init_css_set.cg_links); <span class="comment">//初始化全局结构体struct css_set init</span></span><br><span class="line">    INIT_LIST_HEAD(&amp;init_css_set.tasks);</span><br><span class="line">    INIT_HLIST_NODE(&amp;init_css_set.hlist);</span><br><span class="line">    css_set_count = <span class="number">1</span>;  <span class="comment">//系统中struct css_set计数</span></span><br><span class="line">    init_cgroup_root(&amp;rootnode); <span class="comment">//初始化全局结构体struct cgroupfs_root</span></span><br><span class="line">    root_count = <span class="number">1</span>;		<span class="comment">//系统中的层级计数</span></span><br><span class="line">    init_task.cgroups = &amp;init_css_set; <span class="comment">//使系统的初始化进程cgroup指向init_css_set</span></span><br><span class="line"></span><br><span class="line">    init_css_set_link.cg = &amp;init_css_set;</span><br><span class="line">	<span class="comment">/* dummytop is a shorthand for the dummy hierarchy&#x27;s top cgroup */</span></span><br><span class="line">    init_css_set_link.cgrp = dummytop;</span><br><span class="line"></span><br><span class="line">    list_add(&amp;init_css_set_link.cgrp_link_list,</span><br><span class="line">         &amp;rootnode.top_cgroup.css_sets);</span><br><span class="line">    list_add(&amp;init_css_set_link.cg_link_list,</span><br><span class="line">         &amp;init_css_set.cg_links);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//对一些需要在系统启动时初始化的subsys进行初始化</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; CGROUP_SUBSYS_COUNT; i++) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">cgroup_subsys</span> *<span class="title">ss</span> =</span> subsys[i];</span><br><span class="line"></span><br><span class="line">		...</span><br><span class="line">        <span class="keyword">if</span> (ss-&gt;early_init)</span><br><span class="line">            cgroup_init_subsys(ss);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="cgroup-init"><a href="#cgroup-init" class="headerlink" title="cgroup_init"></a>cgroup_init</h3><p>第二阶段： 主要生成cgroup虚拟文件系统</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * cgroup_init - cgroup initialization</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Register cgroup filesystem and /proc file, and initialize</span></span><br><span class="line"><span class="comment"> * any subsystems that didn&#x27;t request early init.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> __init <span class="title function_">cgroup_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">    err = bdi_init(&amp;cgroup_backing_dev_info);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; CGROUP_SUBSYS_COUNT; i++) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">cgroup_subsys</span> *<span class="title">ss</span> =</span> subsys[i];</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* at bootup time, we don&#x27;t worry about modular subsystems */</span></span><br><span class="line">        <span class="keyword">if</span> (!ss || ss-&gt;module)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (!ss-&gt;early_init)</span><br><span class="line">            cgroup_init_subsys(ss);</span><br><span class="line">        <span class="keyword">if</span> (ss-&gt;use_id)</span><br><span class="line">            cgroup_init_idr(ss, init_css_set.subsys[ss-&gt;subsys_id]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Add init_css_set to the hash table */</span></span><br><span class="line">    key = css_set_hash(init_css_set.subsys);</span><br><span class="line">    hash_add(css_set_table, &amp;init_css_set.hlist, key);</span><br><span class="line">    BUG_ON(!init_root_id(&amp;rootnode));</span><br><span class="line">	...</span><br><span class="line">    cgroup_kobj = kobject_create_and_add(<span class="string">&quot;cgroup&quot;</span>, fs_kobj);</span><br><span class="line"></span><br><span class="line">    err = register_filesystem(&amp;cgroup_fs_type);</span><br><span class="line"></span><br><span class="line">    proc_create(<span class="string">&quot;cgroups&quot;</span>, <span class="number">0</span>, <span class="literal">NULL</span>, &amp;proc_cgroupstats_operations);</span><br><span class="line">	...</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1.bdi_init用于初始化后备存储器的一些字段，这些字段包括回写链表、回写锁等，关系到读写策略，和挂载关系并不大</p>
<h3 id="subsys"><a href="#subsys" class="headerlink" title="subsys"></a>subsys</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SUBSYS(_x) [_x ## _subsys_id] = &amp;_x ## _subsys,</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IS_SUBSYS_ENABLED(option) IS_BUILTIN(option)</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">cgroup_subsys</span> *<span class="title">subsys</span>[<span class="title">CGROUP_SUBSYS_COUNT</span>] =</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cgroup_subsys.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> IS_SUBSYS_ENABLED(CONFIG_CGROUP_DEBUG)</span></span><br><span class="line">SUBSYS(debug)</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>file: kernel&#x2F;cgroup.c</p>
</blockquote>
<h2 id="cgroup文件系统的挂载"><a href="#cgroup文件系统的挂载" class="headerlink" title="cgroup文件系统的挂载"></a>cgroup文件系统的挂载</h2><blockquote>
<p>mount -t cgroup -o cpu cgroup &#x2F;mnt&#x2F;</p>
</blockquote>
<h3 id="注册："><a href="#注册：" class="headerlink" title="注册："></a>注册：</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_system_type</span> <span class="title">cgroup_fs_type</span> =</span> &#123;</span><br><span class="line">	.name = <span class="string">&quot;cgroup&quot;</span>,</span><br><span class="line">	.mount = cgroup_mount,</span><br><span class="line">	.kill_sb = cgroup_kill_sb,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="调用关系："><a href="#调用关系：" class="headerlink" title="调用关系："></a>调用关系：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SyS_mount</span><br><span class="line">	\-&gt;do_mount</span><br><span class="line">		\-&gt;vfs_kern_mount</span><br><span class="line">			\-&gt;mount_fs</span><br><span class="line">				\-&gt;cgroup_mount</span><br><span class="line">					\-&gt;cgroup_populate_dir  //生成基础的文件属性</span><br></pre></td></tr></table></figure>
<p>cgoup基础的文件：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*for hysterical raisins, we can&#x27;t put this on the older files*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CGROUP_FILE_GENERIC_PREFIX <span class="string">&quot;cgroup.&quot;</span></span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">cftype</span> <span class="title">files</span>[] =</span> &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        .name = <span class="string">&quot;tasks&quot;</span>,</span><br><span class="line">        .open = cgroup_tasks_open,</span><br><span class="line">        .write_u64 = cgroup_tasks_write,</span><br><span class="line">        .release = cgroup_pidlist_release,</span><br><span class="line">        .mode = S_IRUGO | S_IWUSR,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        .name = CGROUP_FILE_GENERIC_PREFIX <span class="string">&quot;procs&quot;</span>,</span><br><span class="line">        .open = cgroup_procs_open,</span><br><span class="line">        .write_u64 = cgroup_procs_write,</span><br><span class="line">        .release = cgroup_pidlist_release,</span><br><span class="line">        .mode = S_IRUGO | S_IWUSR,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        .name = <span class="string">&quot;notify_on_release&quot;</span>,</span><br><span class="line">        .read_u64 = cgroup_read_notify_on_release,</span><br><span class="line">        .write_u64 = cgroup_write_notify_on_release,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        .name = CGROUP_FILE_GENERIC_PREFIX <span class="string">&quot;event_control&quot;</span>,</span><br><span class="line">        .write_string = cgroup_write_event_control,</span><br><span class="line">        .mode = S_IWUGO,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        .name = <span class="string">&quot;cgroup.clone_children&quot;</span>,</span><br><span class="line">        .flags = CFTYPE_INSANE,</span><br><span class="line">        .read_u64 = cgroup_clone_children_read,</span><br><span class="line">        .write_u64 = cgroup_clone_children_write,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        .name = <span class="string">&quot;cgroup.sane_behavior&quot;</span>,</span><br><span class="line">        .flags = CFTYPE_ONLY_ON_ROOT,</span><br><span class="line">        .read_seq_string = cgroup_sane_behavior_show,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        .name = <span class="string">&quot;release_agent&quot;</span>,</span><br><span class="line">        .flags = CFTYPE_ONLY_ON_ROOT,</span><br><span class="line">        .read_seq_string = cgroup_release_agent_show,</span><br><span class="line">        .write_string = cgroup_release_agent_write,</span><br><span class="line">        .max_write_len = PATH_MAX,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123; &#125; <span class="comment">/* terminate */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h2 id="创建子cgroup"><a href="#创建子cgroup" class="headerlink" title="创建子cgroup"></a>创建子cgroup</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SyS_mkdirat</span><br><span class="line">	\-&gt;cgroup_mkdir</span><br><span class="line">		\-&gt;cgroup_create</span><br></pre></td></tr></table></figure>

<h2 id="task"><a href="#task" class="headerlink" title="task"></a>task</h2><blockquote>
<p>echo $$ &gt; task</p>
</blockquote>
<p>将当前进程迁移到一个cgroup中：</p>
<p>Open:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">do_sys_open</span><br><span class="line"> |-&gt;do_filp_open</span><br><span class="line">   |-&gt; path_openat.isra.13</span><br><span class="line">     |-&gt;do_last.isra.12</span><br><span class="line">       |-&gt;finish_open</span><br><span class="line">         |-&gt;do_dentry_open.isra.2</span><br><span class="line">		   |-&gt;cgroup_pidlist_open</span><br></pre></td></tr></table></figure>

<p>Write:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SyS_write</span><br><span class="line">  |-&gt;vfs_write</span><br><span class="line">    |-&gt;cgroup_file_write</span><br><span class="line">      |-&gt;cgroup_tasks_write</span><br><span class="line">        |-&gt;attach_task_by_pid</span><br></pre></td></tr></table></figure>


<h2 id="DEBUG子系统实现"><a href="#DEBUG子系统实现" class="headerlink" title="DEBUG子系统实现"></a>DEBUG子系统实现</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cgroup_subsys</span> <span class="title">debug_subsys</span> =</span> &#123;</span><br><span class="line">    .name = <span class="string">&quot;debug&quot;</span>,</span><br><span class="line">    .css_alloc = debug_css_alloc,</span><br><span class="line">    .css_free = debug_css_free,</span><br><span class="line">    .subsys_id = debug_subsys_id,</span><br><span class="line">    .base_cftypes = debug_files,</span><br><span class="line">&#125;;                                           SS</span><br></pre></td></tr></table></figure>


<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><span class="exturl" data-url="aHR0cHM6Ly9maWxlcy5jbmJsb2dzLmNvbS9maWxlcy9saXNwZXJsL2Nncm91cHMlRTQlQkIlOEIlRTclQkIlOEQucGRm">Linux Cgroups 详解<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3poYW5neWlmZWkyMTYvYXJ0aWNsZS9kZXRhaWxzLzQ5NDkxNTQ5">Cgroup框架分析<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL3d3dy54dWVidXl1YW4uY29tLzYyNDI0OS5odG1s">Linux cgroup机制分析之框架分析<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL3d3dy5jbmJsb2dzLmNvbS9hcm5vbGRsdS9wLzYyMDg0NDMuaHRtbA==">Android&#x2F;Linux下CGroup框架分析及其使用<i class="fa fa-external-link-alt"></i></span></li>
</ol>
]]></content>
      <categories>
        <category>Linux内核</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>cgroup</tag>
      </tags>
  </entry>
  <entry>
    <title>LInux内核——CMA</title>
    <url>/post/38033c5c.html</url>
    <content><![CDATA[<p><code>CMA</code>，Contiguous Memory Allocator，是内存管理子系统中的一个模块，<strong>预留内存的配置解析和管理内存配置</strong>。一般系统会在启动过程中，从整个memory中配置一段连续内存用于CMA，然后内核其他的模块可以通过CMA的接口API进行连续内存的分配。CMA的核心并不是设计精巧的算法来管理地址连续的内存块，实际上它的底层还是依赖内核伙伴系统这样的内存管理机制，或者说CMA是处于需要连续内存块的其他内核模块（例如DMA mapping framework）和内存管理模块之间的一个中间层模块，主要功能包括：</p>
<ul>
<li>解析DTS或者命令行中的参数，确定CMA内存的区域，这样的区域我们定义为CMA area。</li>
<li>提供cma_alloc和cma_release两个接口函数用于分配和释放CMA pages</li>
<li>记录和跟踪CMA area中各个pages的状态</li>
<li>调用伙伴系统接口，进行真正的内存分配。</li>
</ul>
<span id="more"></span>

<h2 id="CMA最初的目的"><a href="#CMA最初的目的" class="headerlink" title="CMA最初的目的"></a>CMA最初的目的</h2><blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9sd24ubmV0L0FydGljbGVzLzM5NjY1Ny8=">https://lwn.net/Articles/396657/<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<p>连续内存分配器(CMA)是一个框架，它允许为物理连续内存管理设置特定于计算机的配置。然后根据该配置为设备分配内存。<br>该框架的主要作用<strong>不是分配内存，而是解析和管理内存配置，以及充当设备驱动程序和可插入分配器之间的中介</strong>。因此，它不依赖于任何内存分配方法或策略。</p>
<h2 id="CMA使用"><a href="#CMA使用" class="headerlink" title="CMA使用"></a>CMA使用</h2><p>cma区域可以通过<code>设备树</code>、<code>cmdline</code>和<code>menuconfig</code>指定，并且可以通过设备树的phandle机制和单独的设备绑定，具体的实现和原理说明如下:</p>
<h3 id="设备树指定"><a href="#设备树指定" class="headerlink" title="设备树指定"></a>设备树指定</h3><p>在设备树中添加<code>reserved-memory</code>节点，并且compatible属性指定为shared-dma-pool，并在设备节点中通过memory-region引用该节点，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">reserved-memory &#123;</span><br><span class="line">    #address-cells = &lt;2&gt;;</span><br><span class="line">    #size-cells = &lt;2&gt;;</span><br><span class="line">    ranges;</span><br><span class="line"></span><br><span class="line">    /* Chipselect 2,00000000 is physically at 0x18000000 */</span><br><span class="line">    vram: vram@18000000 &#123;</span><br><span class="line">        /* 8 MB of designated video RAM */</span><br><span class="line">        compatible = &quot;shared-dma-pool&quot;;</span><br><span class="line">        reg = &lt;0x00000000 0x18000000 0 0x00800000&gt;;</span><br><span class="line">        no-map;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>节点配置属性：</p>
<ul>
<li>compatible (optional) ——standard definition<ul>
<li><code>shared-dma-pool</code>： 表示一个内存区域，用于一组设备的DMA缓冲区共享池。操作系统可以使用它在必要时实例化必要的池管理子系统。</li>
<li>vendor specific, 特定于供应商的字符串，形式为，<vendor>,[<device>-]<usage></li>
</ul>
</li>
<li>no-map (optional) —— empty property<ul>
<li>指示操作系统不能创建该区域的虚拟映射作为其系统内存的标准映射的一部分，也不允许在使用该区域的设备驱动程序控制之外的任何情况下对其进行投机性访问。</li>
</ul>
</li>
<li>reusable (optional) ——  empty property<ul>
<li>操作系统可以使用该区域的内存，但该区域的设备驱动程序需要能够回收它。通常，这意味着操作系统可以使用该区域存储易失性数据或缓存数据，这些数据可以重新生成或迁移到其他地方。</li>
</ul>
</li>
</ul>
<p>详细参考文档：<code>Documentation/devicetree/bindings/reserved-memory/reserved-memory.txt</code></p>
<h3 id="cmdline指定"><a href="#cmdline指定" class="headerlink" title="cmdline指定"></a>cmdline指定</h3><p>在uboot的<code>bootargs</code>可以添加cma属性指定cma区域</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cma=nn[MG]@[start[MG][-end[MG]]]</span><br><span class="line">        [ARM,X86,KNL]</span><br><span class="line">        Sets the size of kernel global memory area for</span><br><span class="line">        contiguous memory allocations and optionally the</span><br><span class="line">        placement constraint by the physical address range of</span><br><span class="line">        memory allocations. A value of 0 disables CMA</span><br><span class="line">        altogether. For more information, see</span><br><span class="line">        include/linux/dma-contiguous.h</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Documentation&#x2F;admin-guide&#x2F;kernel-parameters.txt</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cma=256M</span><br><span class="line">或</span><br><span class="line">cma=64M@0x0-0xb0000000</span><br></pre></td></tr></table></figure>

<h3 id="menuconfig指定"><a href="#menuconfig指定" class="headerlink" title="menuconfig指定"></a>menuconfig指定</h3><p>CMA相关的menuconfig分别在<code>memory management options</code>和<code>library routines</code>里面</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Memory Management options  ---&gt;</span><br><span class="line">  [*] Contiguous Memory Allocator</span><br><span class="line">  [ ]   CMA debug messages (DEVELOPMENT)</span><br><span class="line">  [*]   CMA debugfs interface</span><br><span class="line">  (7)   Maximum count of the CMA areas</span><br><span class="line"></span><br><span class="line">Library routines  ---&gt;</span><br><span class="line">  [*] DMA Contiguous Memory Allocator</span><br><span class="line">        *** Default contiguous memory area size: ***</span><br><span class="line">  (1280) Size in Mega Bytes</span><br><span class="line">        Selected region size (Use mega bytes value only)  ---&gt;</span><br><span class="line">  (8)   Maximum PAGE_SIZE order of alignment for contiguous buffers</span><br></pre></td></tr></table></figure>


<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>CMA通过在启动阶段预先保留内存。这些内存叫做CMA区域，稍后返回给伙伴系统从而可以被用作正常申请。如果要保留内存，则需要恰好在底层<code>MEMBLOCK</code>分配器初始化之后，及大量内存被占用之前调用，并在伙伴系统建立之前调用。</p>
<ul>
<li>页迁移：</li>
</ul>
<p>当从伙伴系统申请内存的时候，需要提供一个gfp_mask参数。不管其他事情，这个参数指定了要申请内存的迁移类型。迁移类型是MIGRATE_MOVABLE，它背后的意思是在可移动页面上的数据可以被迁移（或者移动，因此而命名），这对于磁盘缓存或者进程页面来说很有效。为了使相同迁移类型的页面在一起，伙伴系统把页面组成 “页面块 (pageblock)”，每组都有一个指定的迁移类型。分配器根据请求的类型在不同的页面块上分配页。如果尝试失败，分配器会在其它页面块上分配并甚至修改页面块的迁移类型。这意味着一个不可移动的页可能分配自一个MIGRATE_MOVABLE页面块，并导致该页面块的迁移类型改变。这不是CMA想要的，所以它引入了一个MIGRATE_CMA类型，该类型又一个重要的属性: <strong>只有可移动页可以从MIGRATE_CMA页面块种分配</strong>。那么，在启动期间，当dma_congiguous_reserve()和dma_declare_contiguous()方法被调用的时候，CMA在memblock中预留一部分RAM，并在随后将其返还给伙伴系统，仅将其页面块的迁移类型置为MIGRATE_CMA. 最终的结果是所有预留的页都在伙伴系统里，所以它们都可以用于可移动页的分配。</p>
<ul>
<li>CMA分配与释放<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int alloc_contig_range(unsigned long start, unsigned long end, unsigned migratetype, gfp_t gfp_mask)</span><br><span class="line">void free_contig_range(unsigned long pfn, unsigned nr_pages);</span><br></pre></td></tr></table></figure>
CMA分配，<code>dma_alloc_from_contiguous()</code>选择一个页范围，start和end参数指定了目标内存的页框个数（或PFN范围)。参数migratetype指定了潜在的迁移类型; 在CMA的情况下，这个参数就是MIGRATE_CMA。这个函数所做的第一件事是将包含 (start, end) 范围内的页面块标记为 MIGRATE_ISOLATE。伙伴系统不会去触动这种类型的页面块。改变迁移类型不会魔 法般地释放页面，因此接下来需要调用 __alloc_conting_migrate_range()。它扫 描PFN范围并寻找可以迁移的页面。迁移是将页面复制到系统其它内存部分并更新相 关引用的过程。迁移部份很直接，后面的部分需要内存管理子系统来完成。当数据迁 移完成，旧的页面被释放并回归伙伴系统。这就是为什么之前那些需要包含的页面块 一定要标记为 MIGRATE_ISOLATE 的原因。如果指定了其它的迁移类型，伙伴系统会 毫不犹豫地将它们用于其它类型的申请。</li>
</ul>
<p>现在所有 alloc_contig_range 关心的页都是空闲的了。该方法将从伙伴系统中取 出它们，并将这些页面块的类型改为 MIGRATE_CMA。然后将这些页返回给调用者。</p>
<p>CMA释放：调用free_contig_range函数迭代所有的页面并将其返还给伙伴系统。</p>
<blockquote>
<ul>
<li>当设备驱动不用时，内存管理系统将该区域用于分配和管理可移动类型页面；</li>
<li>当设备驱动使用时，此时已经分配的页面需要进行迁移，又用于连续内存分配；</li>
</ul>
</blockquote>
<h2 id="主要数据结构"><a href="#主要数据结构" class="headerlink" title="主要数据结构"></a>主要数据结构</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cma</span> &#123;</span></span><br><span class="line">    <span class="comment">//起始物理地址对应的页帧号，相当于起始地址</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>   base_pfn;</span><br><span class="line">    <span class="comment">//当前CMA区域页的个数，也就内存总容量，页的默认大小4K</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>   count;</span><br><span class="line">    <span class="comment">//使用bitmap机制维护当前CMA区域内存的物理页，每个bit代表一定数量的物理页，至于代表多少物理页与order_per_bit有关</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>   *bitmap;</span><br><span class="line">    <span class="comment">//指明该CMA区域的bitmap中，每个bit代表的页数量为2^order值</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> order_per_bit; <span class="comment">/* Order of pages represented by one bit */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span>    <span class="title">lock</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_CMA_DEBUGFS</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hlist_head</span> <span class="title">mem_head</span>;</span></span><br><span class="line">    <span class="type">spinlock_t</span> mem_head_lock;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">//当前CMA区域的描述名</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//存放各个CMA区域的cma信息的数组</span></span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">cma</span> <span class="title">cma_areas</span>[<span class="title">MAX_CMA_AREAS</span>];</span></span><br><span class="line"><span class="comment">//统计当前系统初始化的最大可用的cma区域数量</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">unsigned</span> cma_area_count;</span><br></pre></td></tr></table></figure>

<h2 id="系统CMA调试信息"><a href="#系统CMA调试信息" class="headerlink" title="系统CMA调试信息"></a>系统CMA调试信息</h2><ul>
<li>CMA区域内存统计<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># cat /proc/meminfo | grep cma -i</span><br><span class="line">CmaTotal:        1310720 kB</span><br><span class="line">CmaFree:         1309472 kB</span><br></pre></td></tr></table></figure></li>
<li>各个CMA区域详细信息<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># ls /sys/kernel/debug/cma/cma-reserved/</span><br><span class="line">alloc          bitmap         free           order_per_bit</span><br><span class="line">base_pfn       count          maxchunk       used</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># cat /sys/kernel/debug/cma/cma-reserved/count</span><br><span class="line">327680</span><br><span class="line"></span><br><span class="line"># cat /sys/kernel/debug/cma/cma-reserved/bitmap</span><br><span class="line">4294967295 4294967295 4294967295 4294967295 16777215 0 0 0 4294967295 4294967295 65535 0 4294967295 4294967295 65535 0 0 0 0 0 0 0</span><br><span class="line"></span><br><span class="line"># cat /sys/kernel/debug/cma/cma-reserved/order_per_bit</span><br><span class="line">0</span><br></pre></td></tr></table></figure></li>
<li><code>order_per_bit</code>,为0,表示bitmap中的每一位bit代表一个1（2^0）个物理页。</li>
<li><code>bitmap</code>： 其中的每一项占32bit，而每一bit代表的一个物理页的状态，<code>0</code>表示free，<code>1</code>表示已经分配。（bitmap的总数为count&#x2F;32, 327680&#x2F;32&#x3D;10240）</li>
</ul>
<blockquote>
<p>查看bitmap中的特殊数字</p>
<ul>
<li>4294967295 -&gt; 0xFFFFFFFF: 32位全1</li>
<li>16777215 -&gt; 0xFFFFFF: 24位全1</li>
<li>65535 -&gt; 0xFFFF: 16为全1</li>
</ul>
</blockquote>
<h2 id="应用——memuconfig指定"><a href="#应用——memuconfig指定" class="headerlink" title="应用——memuconfig指定"></a>应用——memuconfig指定</h2><p>内核版本： <code>5.4.217</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># dmesg | grep cma</span><br><span class="line">[    0.000000] cma: Reserved 1280 MiB at 0x0000000020000000</span><br><span class="line">[    0.000000] Memory: 553676K/1966080K available (9982K kernel code, 1174K rwdata, 3328K rodata, 896K init, 497K bss, 101684K reserved, 1310720K cma-reserved)</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>当前系统内存2G，而cma预留了1280MB，这1280MB内存预留有谁决定？？</li>
<li>除去CMA预留的1280MB，内存剩余768MB，如果系统占用内存超过768MB事，如何处理？？？</li>
<li>2G系统内存，预留1280MB，为啥free看到的可用内存依然是1866MB，是不是CMA预留内存也可以被系统应用所使用？？？</li>
<li>如果CMA预留内存也可以被系统使用，那么后期内存碎片化严重时，在CMA中无法分配大内存区域时怎么办？？？</li>
</ul>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0.000000] Call trace:</span><br><span class="line">[    0.000000]  dump_backtrace+0x0/0x19c</span><br><span class="line">[    0.000000]  show_stack+0x28/0x34</span><br><span class="line">[    0.000000]  dump_stack+0xa4/0xe4</span><br><span class="line">[    0.000000]  cma_declare_contiguous+0x2f4/0x330</span><br><span class="line">[    0.000000]  dma_contiguous_reserve_area+0x5c/0x8c</span><br><span class="line">[    0.000000]  dma_contiguous_reserve+0xe4/0x110</span><br><span class="line">[    0.000000]  arm64_memblock_init+0x200/0x270</span><br><span class="line">[    0.000000]  setup_arch+0x240/0x5c0</span><br><span class="line">[    0.000000]  start_kernel+0x90/0x468</span><br><span class="line">[    0.000000] cma: Reserved 1280 MiB at 0x0000000020000000</span><br></pre></td></tr></table></figure>

<p>函数调用栈：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">start_kernel</span><br><span class="line">  \-&gt; setup_arch</span><br><span class="line">    \-&gt; arm64_memblock_init</span><br><span class="line">      \-&gt; dma_contiguous_reserve</span><br><span class="line">        \-&gt; dma_contiguous_reserve_area</span><br><span class="line">          \-&gt; cma_declare_contiguous</span><br></pre></td></tr></table></figure>

<p>物理内存范围：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">                               总大小1920 MB</span><br><span class="line">    +-----------------------------------------------------------------------------+</span><br><span class="line">    |                                                                             |</span><br><span class="line">    |                                                                             |</span><br><span class="line">    +-----------------------------------------------------------------------------+</span><br><span class="line">0x7800 0000                                                                       0</span><br></pre></td></tr></table></figure>

<h3 id="CMA预留大小"><a href="#CMA预留大小" class="headerlink" title="CMA预留大小"></a>CMA预留大小</h3><p>首先，确定<code>Reserved 1280 MiB</code>日志输出的位置，再找到其调用关系及cma预留大小的定义。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __init <span class="title function_">cma_declare_contiguous</span><span class="params">(<span class="type">phys_addr_t</span> base,</span></span><br><span class="line"><span class="params">            <span class="type">phys_addr_t</span> size, <span class="type">phys_addr_t</span> limit,</span></span><br><span class="line"><span class="params">            <span class="type">phys_addr_t</span> alignment, <span class="type">unsigned</span> <span class="type">int</span> order_per_bit,</span></span><br><span class="line"><span class="params">            <span class="type">bool</span> fixed, <span class="type">const</span> <span class="type">char</span> *name, <span class="keyword">struct</span> cma **res_cma)</span></span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  pr_info(<span class="string">&quot;Reserved %ld MiB at %pa\n&quot;</span>, (<span class="type">unsigned</span> <span class="type">long</span>)size / SZ_1M,</span><br><span class="line">    &amp;base);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>mm&#x2F;cma.c</p>
</blockquote>
<p>在<code>dma_contiguous_reserve</code>接口中指定需要预留的内存大小</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> __init <span class="title function_">dma_contiguous_reserve</span><span class="params">(<span class="type">phys_addr_t</span> limit)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_CMA_SIZE_SEL_MBYTES</span></span><br><span class="line">        selected_size = size_bytes;</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined(CONFIG_CMA_SIZE_SEL_PERCENTAGE)</span></span><br><span class="line">        selected_size = cma_early_percent_memory();</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined(CONFIG_CMA_SIZE_SEL_MIN)</span></span><br><span class="line">        selected_size = min(size_bytes, cma_early_percent_memory());</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined(CONFIG_CMA_SIZE_SEL_MAX)</span></span><br><span class="line">        selected_size = max(size_bytes, cma_early_percent_memory());</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (selected_size &amp;&amp; !dma_contiguous_default_area) &#123;</span><br><span class="line">        pr_debug(<span class="string">&quot;%s: reserving %ld MiB for global area\n&quot;</span>, __func__,</span><br><span class="line">             (<span class="type">unsigned</span> <span class="type">long</span>)selected_size / SZ_1M);</span><br><span class="line"></span><br><span class="line">        dma_contiguous_reserve_area(selected_size, selected_base,</span><br><span class="line">                        selected_limit,</span><br><span class="line">                        &amp;dma_contiguous_default_area,</span><br><span class="line">                        fixed);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>menuconfig中指定了<code>CONFIG_CMA_SIZE_SEL_MBYTES</code>，因此CMA预留内存大小为<code>size_bytes</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_CMA_SIZE_MBYTES</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CMA_SIZE_MBYTES CONFIG_CMA_SIZE_MBYTES</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CMA_SIZE_MBYTES 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Default global CMA area size can be defined in kernel&#x27;s .config.</span></span><br><span class="line"><span class="comment"> * This is useful mainly for distro maintainers to create a kernel</span></span><br><span class="line"><span class="comment"> * that works correctly for most supported systems.</span></span><br><span class="line"><span class="comment"> * The size can be set in bytes or as a percentage of the total memory</span></span><br><span class="line"><span class="comment"> * in the system.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Users, who want to set the size of global CMA area for their system</span></span><br><span class="line"><span class="comment"> * should use cma= kernel parameter.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">phys_addr_t</span> size_bytes = (<span class="type">phys_addr_t</span>)CMA_SIZE_MBYTES * SZ_1M;</span><br></pre></td></tr></table></figure>

<p>实际预留大小在menuconfig中进行配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#</span><br><span class="line"># Default contiguous memory area size:</span><br><span class="line">#</span><br><span class="line">CONFIG_CMA_SIZE_MBYTES=1280</span><br><span class="line">CONFIG_CMA_SIZE_SEL_MBYTES=y</span><br><span class="line"># CONFIG_CMA_SIZE_SEL_PERCENTAGE is not set</span><br><span class="line"># CONFIG_CMA_SIZE_SEL_MIN is not set</span><br><span class="line"># CONFIG_CMA_SIZE_SEL_MAX is not set</span><br><span class="line">CONFIG_CMA_ALIGNMENT=8</span><br></pre></td></tr></table></figure>

<p>在<code>cma_declare_contiguous</code>函数中的memblock_phys_alloc_range接口申请了CMA内存区域。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">         + &lt;--------------------------+ 物理内存总大小1920MB +-------------------------&gt; +</span><br><span class="line">         |        + &lt;----------+ CMA区域大小1280MB +---------&gt; +                        |</span><br><span class="line">         |        |                                           |                        |</span><br><span class="line">         +-----------------------------------------------------------------------------+</span><br><span class="line">         |        |                CMA area                   |                        |</span><br><span class="line">         +--------+-------------------------------------------+------------------------+</span><br><span class="line">0x7800 0000    0x7000 0000                                0x2000 0000                  0</span><br><span class="line">                                                           cma base</span><br></pre></td></tr></table></figure>

<p>CMA base地址如何确定：随机还是指定？</p>
<ul>
<li>cmdline方式中可以指定CMA区域的base地址和大小</li>
<li>menuconfig方式中指定指定CMA区域的大小，base地址随机指定符合要求的区域。</li>
</ul>
<p>在<code>cma_declare_contiguous</code>函数中，通过<code>memblock_phys_alloc_range</code>接口申请完了CMA区域的内存后，紧接着使用<code>cma_init_reserved_mem</code>接口将其进行初始化。</p>
<p>初始化的目的指定CMA相应区域的参数，比如基址、大小等</p>
<p>CMA区域的个数可以进行配置，内核默认最多<code>8</code>个，因为<code>CONFIG_CMA_AREAS</code>默认值为7</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cma</span> <span class="title">cma_areas</span>[<span class="title">MAX_CMA_AREAS</span>];</span></span><br><span class="line"><span class="type">unsigned</span> cma_area_count;</span><br><span class="line"></span><br><span class="line"><span class="comment">//MAX_CMA_AREAS定义：</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * There is always at least global CMA area and a few optional</span></span><br><span class="line"><span class="comment"> * areas configured in kernel .config.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_CMA_AREAS</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_CMA_AREAS   (1 + CONFIG_CMA_AREAS)</span></span><br></pre></td></tr></table></figure>

<p>每个CMA区域将一定大小的内存申请后将通过<code>cma_init_reserved_mem</code>进行初始化，并将参数信息保存到<code>cma_areas</code>数组中。</p>
<p>使用memconfig进行CMA预留区域的指定，只会使用一个<code>cma_areas</code>数组项，而设计多个的目的是在设备树中可以指定多个不同的CMA预留区域。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * cma_init_reserved_mem() - create custom contiguous area from reserved memory</span></span><br><span class="line"><span class="comment"> * @base: Base address of the reserved area</span></span><br><span class="line"><span class="comment"> * @size: Size of the reserved area (in bytes),</span></span><br><span class="line"><span class="comment"> * @order_per_bit: Order of pages represented by one bit on bitmap.</span></span><br><span class="line"><span class="comment"> * @name: The name of the area. If this parameter is NULL, the name of</span></span><br><span class="line"><span class="comment"> *        the area will be set to &quot;cmaN&quot;, where N is a running counter of</span></span><br><span class="line"><span class="comment"> *        used areas.</span></span><br><span class="line"><span class="comment"> * @res_cma: Pointer to store the created cma region.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function creates custom contiguous area from already reserved memory.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> __init <span class="title function_">cma_init_reserved_mem</span><span class="params">(<span class="type">phys_addr_t</span> base, <span class="type">phys_addr_t</span> size,</span></span><br><span class="line"><span class="params">                 <span class="type">unsigned</span> <span class="type">int</span> order_per_bit,</span></span><br><span class="line"><span class="params">                 <span class="type">const</span> <span class="type">char</span> *name,</span></span><br><span class="line"><span class="params">                 <span class="keyword">struct</span> cma **res_cma)</span></span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  cma = &amp;cma_areas[cma_area_count];</span><br><span class="line">  <span class="keyword">if</span> (name) &#123;</span><br><span class="line">      cma-&gt;name = name;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      cma-&gt;name = kasprintf(GFP_KERNEL, <span class="string">&quot;cma%d\n&quot;</span>, cma_area_count);</span><br><span class="line">      <span class="keyword">if</span> (!cma-&gt;name)</span><br><span class="line">          <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">  &#125;</span><br><span class="line">  cma-&gt;base_pfn = PFN_DOWN(base);</span><br><span class="line">  cma-&gt;count = size &gt;&gt; PAGE_SHIFT;</span><br><span class="line">  cma-&gt;order_per_bit = order_per_bit;</span><br><span class="line">  *res_cma = cma;</span><br><span class="line">  cma_area_count++;</span><br><span class="line">  totalcma_pages += (size / PAGE_SIZE);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>各个CMA预留区域的内存页初始化：</p>
<p>系统启动初期根据各种参数，预留CMA区域的物理内存，将其基地址和大小进行确认，并检查其合法性；系统启动过程中，调用<code>cma_init_reserved_areas</code>接口对个CMA区域内存进行初始化后， CMA就可用供其他模块、设备和子系统使用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">core_initcall(cma_init_reserved_areas)</span><br><span class="line">  cma_init_reserved_areas</span><br><span class="line">    \-&gt; 遍历cma_areas数组进行初始化</span><br><span class="line">    |-&gt; cma_activate_area</span><br><span class="line">      \-&gt; cma-&gt;bitmap = bitmap_zalloc(cma_bitmap_maxno(cma), GFP_KERNEL)</span><br><span class="line">      |-&gt; init_cma_reserved_pageblock</span><br><span class="line">        \-&gt; set_pageblock_migratetype(page, MIGRATE_CMA);</span><br><span class="line">        |-&gt; __free_pages</span><br><span class="line">        |-&gt; adjust_managed_page_count</span><br></pre></td></tr></table></figure>
<p><code>init_cma_reserved_pageblock</code>接口将释放整个页面块并将其迁移类型设置为<code>MIGRATE_CMA</code>。</p>
<p>内核初始化过程中，通过core_initcall()函数将该 section 内的初始化 函数遍历执行，其中包括 CMA 的激活入口 cma_init_reserved_areas() 函数， 该函数遍历 CMA 分配的所有 CMA 分区并激活每一个 CMA 分区。在该函数中， 函数首先调用kzalloc()函数为CMA分区的bitmap所需的内存，然后调用<code>init_cma_reserved_pageblock()</code>函数，在该函数中，内核将CMA区块内的<strong>所有物理页都清除RESERVED标志，引用计数设置为0</strong>，接着按pageblock的方式设置区域内的页组迁移类型都是<code>MIGRATE_CMA</code>。函数继续调用set_page_refcounted()函数将引用计数设置为1以及调用<code>__free_pages()</code>函数将所有的页从CMA分配器中释放并归还给buddy管理器。最后调用<code>adjust_managed_page_count()</code>更新系统可用物理页总数。至此系统的其他部分可以开始使用CMA分配器分配的连续物理内存。</p>
<h3 id="系统free是否统计CMA内存"><a href="#系统free是否统计CMA内存" class="headerlink" title="系统free是否统计CMA内存"></a>系统free是否统计CMA内存</h3><blockquote>
<p>结论：free会统计CMA区域内存。</p>
</blockquote>
<p>因为CMA区域中的page被设置为<code>MIGRATE_CMA</code>,然后放入<code>伙伴系统</code>中，等待用户使用（NOTE：MIGRATE_CMA是伙伴系统中页属性的概念,所以CMA区也只是伙伴系统中的一个概念，不是一个ZONE）,这样进行初始化后，free统计时也会将CMA区域的内存统计进去。</p>
<h3 id="CMA预留内存与系统内存关系"><a href="#CMA预留内存与系统内存关系" class="headerlink" title="CMA预留内存与系统内存关系"></a>CMA预留内存与系统内存关系</h3><blockquote>
<p>结论：CMA区域的内存即是预留内存（reserved），也是系统内存（memory）；也就是说CMA区域这部分内存除了设备驱动申请DMA内存使用外，在系统内存不足时可以使用，</p>
</blockquote>
<p>系统中何时使用CMA区域内存：</p>
<ul>
<li>设备驱动中主动申请DMA内存时使用，这个每个驱动实现不同由驱动工程师自主控制。</li>
<li>系统应用程序的使用，也就是申请内存时如何使用MIGRATE_CMA page？</li>
</ul>
<h2 id="问题——PFNs-busy"><a href="#问题——PFNs-busy" class="headerlink" title="问题——PFNs busy"></a>问题——PFNs busy</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[  136.103382] alloc_contig_range: [22200, 22ef4) PFNs busy</span><br><span class="line">[  136.110892] alloc_contig_range: [22400, 22ff4) PFNs busy</span><br><span class="line">[  136.118504] alloc_contig_range: [22400, 230f4) PFNs busy</span><br><span class="line">[  136.126102] alloc_contig_range: [22400, 231f4) PFNs busy</span><br><span class="line">[  136.133735] alloc_contig_range: [22400, 232f4) PFNs busy</span><br><span class="line">[  136.141229] alloc_contig_range: [22800, 233f4) PFNs busy</span><br><span class="line">[  136.148870] alloc_contig_range: [22800, 234f4) PFNs busy</span><br><span class="line">[  136.156469] alloc_contig_range: [22800, 235f4) PFNs busy</span><br><span class="line">[  136.164026] alloc_contig_range: [22800, 236f4) PFNs busy</span><br></pre></td></tr></table></figure>

<p>函数调用栈：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dma_alloc_coherent</span><br><span class="line">  \-&gt; dma_alloc_attrs</span><br><span class="line">    \-&gt; dma_direct_alloc</span><br><span class="line">      \-&gt; arch_dma_alloc</span><br><span class="line">        \-&gt; __dma_direct_alloc_pages</span><br><span class="line">          \-&gt; dma_alloc_contiguous</span><br><span class="line">            \-&gt; cma_alloc</span><br><span class="line">              \-&gt; alloc_contig_range</span><br><span class="line">                \-&gt; pr_info_ratelimited(&quot;...PFNs busy\n&quot;)</span><br></pre></td></tr></table></figure>

<p><code>alloc_contig_range</code>从伙伴系统中分配一定大小的物理页，该接口参数会指定页的起始和结束号。<br>PFN范围不必是pageblock或MAX_ORDER_NR_PAGES对齐的。PFN范围必须属于一个单独的区域。<br>这个例程做的第一件事是尝试MIGRATE_ISOLATE范围内的所有页面块。一旦隔离(isolated)，页面块不应该被其他人修改。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">alloc_contig_range</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> start, <span class="type">unsigned</span> <span class="type">long</span> end,</span></span><br><span class="line"><span class="params">               <span class="type">unsigned</span> migratetype, <span class="type">gfp_t</span> gfp_mask)</span></span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * What we do here is we mark all pageblocks in range as</span></span><br><span class="line"><span class="comment">	 * MIGRATE_ISOLATE.  Because pageblock and max order pages may</span></span><br><span class="line"><span class="comment">	 * have different sizes, and due to the way page allocator</span></span><br><span class="line"><span class="comment">	 * work, we align the range to biggest of the two pages so</span></span><br><span class="line"><span class="comment">	 * that page allocator won&#x27;t try to merge buddies from</span></span><br><span class="line"><span class="comment">	 * different pageblocks and change MIGRATE_ISOLATE to some</span></span><br><span class="line"><span class="comment">	 * other migration type.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Once the pageblocks are marked as MIGRATE_ISOLATE, we</span></span><br><span class="line"><span class="comment">	 * migrate the pages from an unaligned range (ie. pages that</span></span><br><span class="line"><span class="comment">	 * we are interested in).  This will put all the pages in</span></span><br><span class="line"><span class="comment">	 * range back to page allocator as MIGRATE_ISOLATE.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * When this is done, we take the pages in range from page</span></span><br><span class="line"><span class="comment">	 * allocator removing them from the buddy system.  This way</span></span><br><span class="line"><span class="comment">	 * page allocator will never consider using them.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * This lets us mark the pageblocks back as</span></span><br><span class="line"><span class="comment">	 * MIGRATE_CMA/MIGRATE_MOVABLE so that free pages in the</span></span><br><span class="line"><span class="comment">	 * aligned range but not in the unaligned, original range are</span></span><br><span class="line"><span class="comment">	 * put back to page allocator so that buddy can use them.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"></span><br><span class="line">	ret = start_isolate_page_range(pfn_max_align_down(start),           -----&lt;<span class="number">1</span>&gt;</span><br><span class="line">	                   pfn_max_align_up(end), migratetype, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">	    <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * In case of -EBUSY, we&#x27;d like to know which page causes problem.</span></span><br><span class="line"><span class="comment">	 * So, just fall through. test_pages_isolated() has a tracepoint</span></span><br><span class="line"><span class="comment">	 * which will report the busy page.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * It is possible that busy pages could become available before</span></span><br><span class="line"><span class="comment">	 * the call to test_pages_isolated, and the range will actually be</span></span><br><span class="line"><span class="comment">	 * allocated.  So, if we fall through be sure to clear ret so that</span></span><br><span class="line"><span class="comment">	 * -EBUSY is not accidentally used or returned to caller.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	ret = __alloc_contig_migrate_range(&amp;cc, start, end);                 -----&lt;<span class="number">2</span>&gt;</span><br><span class="line">	<span class="keyword">if</span> (ret &amp;&amp; ret != -EBUSY)</span><br><span class="line">	    <span class="keyword">goto</span> done;</span><br><span class="line">	ret =<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Pages from [start, end) are within a MAX_ORDER_NR_PAGES</span></span><br><span class="line"><span class="comment">	 * aligned blocks that are marked as MIGRATE_ISOLATE.  What&#x27;s</span></span><br><span class="line"><span class="comment">	 * more, all pages in [start, end) are free in page allocator.</span></span><br><span class="line"><span class="comment">	 * What we are going to do is to allocate all pages from</span></span><br><span class="line"><span class="comment">	 * [start, end) (that is remove them from page allocator).</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * The only problem is that pages at the beginning and at the</span></span><br><span class="line"><span class="comment">	 * end of interesting range may be not aligned with pages that</span></span><br><span class="line"><span class="comment">	 * page allocator holds, ie. they can be part of higher order</span></span><br><span class="line"><span class="comment">	 * pages.  Because of this, we reserve the bigger range and</span></span><br><span class="line"><span class="comment">	 * once this is done free the pages we are not interested in.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * We don&#x27;t have to hold zone-&gt;lock here because the pages are</span></span><br><span class="line"><span class="comment">	 * isolated thus they won&#x27;t get removed from buddy.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"></span><br><span class="line">	lru_add_drain_all();                                                -----&lt;<span class="number">3</span>&gt;</span><br><span class="line"></span><br><span class="line">	order = <span class="number">0</span>;</span><br><span class="line">	outer_start = start;</span><br><span class="line">	<span class="keyword">while</span> (!PageBuddy(pfn_to_page(outer_start))) &#123;                      -----&lt;<span class="number">4</span>&gt;</span><br><span class="line">	    <span class="keyword">if</span> (++order &gt;= MAX_ORDER) &#123;</span><br><span class="line">	        outer_start = start;</span><br><span class="line">	        <span class="keyword">break</span>;</span><br><span class="line">	    &#125;</span><br><span class="line">	    outer_start &amp;= ~<span class="number">0UL</span> &lt;&lt; order;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (outer_start != start) &#123;</span><br><span class="line">	    order = page_order(pfn_to_page(outer_start));</span><br><span class="line"></span><br><span class="line">	    <span class="comment">/*</span></span><br><span class="line"><span class="comment">	     * outer_start page could be small order buddy page and</span></span><br><span class="line"><span class="comment">	     * it doesn&#x27;t include start page. Adjust outer_start</span></span><br><span class="line"><span class="comment">	     * in this case to report failed page properly</span></span><br><span class="line"><span class="comment">	     * on tracepoint in test_pages_isolated()</span></span><br><span class="line"><span class="comment">	     */</span></span><br><span class="line">	    <span class="keyword">if</span> (outer_start + (<span class="number">1UL</span> &lt;&lt; order) &lt;= start)</span><br><span class="line">	        outer_start = start;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Make sure the range is really isolated. */</span></span><br><span class="line">	<span class="keyword">if</span> (test_pages_isolated(outer_start, end, <span class="literal">false</span>)) &#123;                 -----&lt;<span class="number">5</span>&gt;</span><br><span class="line">	    pr_info_ratelimited(<span class="string">&quot;%s: [%lx, %lx) PFNs busy\n&quot;</span>,</span><br><span class="line">	        __func__, outer_start, end);</span><br><span class="line">	    ret = -EBUSY;</span><br><span class="line">	    <span class="keyword">goto</span> done;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Grab isolated pages from freelists. */</span></span><br><span class="line">	outer_end = isolate_freepages_range(&amp;cc, outer_start, end);         -----&lt;<span class="number">6</span>&gt;</span><br><span class="line">	<span class="keyword">if</span> (!outer_end) &#123;</span><br><span class="line">	    ret = -EBUSY;</span><br><span class="line">	    <span class="keyword">goto</span> done;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Free head and tail (if any) */</span></span><br><span class="line">	<span class="keyword">if</span> (start != outer_start)</span><br><span class="line">	    free_contig_range(outer_start, start - outer_start);</span><br><span class="line">	<span class="keyword">if</span> (end != outer_end)</span><br><span class="line">	    free_contig_range(end, outer_end - end);</span><br><span class="line"></span><br><span class="line">done:</span><br><span class="line">    undo_isolate_page_range(pfn_max_align_down(start),                -----&lt;<span class="number">7</span>&gt;</span><br><span class="line">                pfn_max_align_up(end), migratetype);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>&lt;1&gt;: start_isolate_page_range将pfn范围内的页设置为隔离（MIGRATE_ISOLATE）</p>
<ul>
<li>将页面分配类型设置为<code>MIGRATE_ISOLATE</code>意味着将永远不会分配范围内的空闲页面。任何空闲页面和将来释放的页面将不会再次分配。如果指定的范围包括MOVABLE或CMA以外的迁移类型，则会使用-EBUSY失败。为了最终隔离范围内的所有页面，调用者必须释放范围内的全部页面。test_page_isolated()可以用于测试它。</li>
<li>请注意，<strong>也没有与页面分配器的强同步。当页面块标记为“已隔离”时，页面可能会被释放</strong>。在某些情况下，页面可能仍然会出现在pcp列表中，这将允许它们的分配，即使它们实际上已经被隔离。根据调用方需要的保证程度，可能需要drain_all_pages（例如__offline_pages需要在检查隔离范围后调用它，以便下次重试）。</li>
<li>一旦页面块被标记为MIGRATE_ISOLATE，我们就从未对齐的范围（即我们感兴趣的页面）迁移页面。这将把范围内的所有页面作为MIGRATE_ISOLATE放回页面分配器。</li>
<li>完成此操作后，我们从页面分配器中获取范围内的页面，并将其从伙伴系统中删除。这样，页面分配器将永远不会考虑使用它们。</li>
<li>这使我们可以将页面块标记回MIGRATE_CMA&#x2F;MIGRATE_MOVABLE，以便将对齐范围内的空闲页面（而不是未对齐的原始范围内的）放回页面分配器，以便好友可以使用它们。</li>
</ul>
</li>
<li><p>&lt;2&gt;: __alloc_contig_migrate_range申请pfn范围内的页，扫描PFN范围页并寻找可迁移的进行迁移，可能返回BUSY，因为存在页无法迁移。</p>
</li>
<li><p>&lt;3&gt;: lru_add_drain_all对所有CPU实现缓存的刷新,将每CPU中缓存的页面进行释放</p>
</li>
<li><p>&lt;4&gt;: PageBuddy判断一个页是是否在buddy系统中，如果是1，说明还没有分配出去</p>
</li>
<li><p>&lt;5&gt;: test_pages_isolated用于检查确保该pfn范围内的页面已经被隔离</p>
</li>
<li><p>&lt;6&gt;: isolate_freepages_range则是将指定范围的空闲页面隔离出来</p>
</li>
<li><p>&lt;7&gt;: undo_isolate_page_range则是将所有的标记为隔离的页面重新标记为MIGRATE_CMA，至此所需的连续内存页面已经分配到了，无需在乎其迁移属性了，便更改回去。</p>
</li>
</ul>
<blockquote>
<p>出现<code>PFNs busy</code>是由于在&lt;5&gt;test_pages_isolated中检查到申请pfn范围内的页有没有被隔离出来，才会输出警告信息<br>而没有被隔离的原因是，这些页可能被系统中的其他应用所占用着，而无法被迁移。</p>
</blockquote>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9sd24ubmV0L0FydGljbGVzLzM5NjY1Ny8=">The Contiguous Memory Allocator<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9iaXNjdWl0b3MuZ2l0aHViLmlvL2Jsb2cvQ01BLyNBMDAw">CMA<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>Linux内核</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>内存管理</tag>
      </tags>
  </entry>
  <entry>
    <title>常用的shell命令</title>
    <url>/post/1644.html</url>
    <content><![CDATA[<p>常用的shell命令： <code>find</code>, <code>cat</code></p>
<span id="more"></span>

<h2 id="根据文件inode信息查找文件"><a href="#根据文件inode信息查找文件" class="headerlink" title="根据文件inode信息查找文件"></a>根据文件inode信息查找文件</h2><ul>
<li><p>文件系统错误，有错误inode信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXT4-fs (sda7): Delayed block allocation failed for inode 23596895 at logical offset 673 with max blocks 1 with error 117</span><br></pre></td></tr></table></figure>
</li>
<li><p>查找文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find /home/ -inum 23596895  -print</span><br></pre></td></tr></table></figure>
<blockquote>
<p>sda7挂载在home目录下。</p>
</blockquote>
</li>
</ul>
<h2 id="创建一个不能登录的账户"><a href="#创建一个不能登录的账户" class="headerlink" title="创建一个不能登录的账户"></a>创建一个不能登录的账户</h2><p>创建一个git账户，不需要其登录系统</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">useradd -s /bin/false -M git</span><br></pre></td></tr></table></figure>

<ul>
<li><code>-s /bin/false</code>：禁止login选项，用户无法登录且不会有任何提示</li>
<li><code>-M</code> ：不创建用户Home目录</li>
</ul>
<h2 id="字符串转二进制"><a href="#字符串转二进制" class="headerlink" title="字符串转二进制"></a>字符串转二进制</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo 001122334455 | xxd -r -ps &gt; test            // 6 个字节</span><br></pre></td></tr></table></figure>
<ul>
<li><code>xxd</code> :用于用二进制或十六进制显示文件的内容</li>
<li><code>-r</code>  :把xxd的十六进制输出内容转换回原文件的二进制内容</li>
<li><code>-ps</code> :以postscript的连续十六进制转储输出，这也叫做纯十六进制转储</li>
</ul>
<h2 id="查看中断与CPU的绑定关系"><a href="#查看中断与CPU的绑定关系" class="headerlink" title="查看中断与CPU的绑定关系"></a>查看中断与CPU的绑定关系</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat /proc/interrupts | grep intel | cut -d: -f1 | while read i; do echo -ne irq&quot;:$i\t bind_cpu: &quot;; cat /proc/irq/$i/smp_affinity_list; done | sort -n -t&#x27; &#x27; -k3</span><br></pre></td></tr></table></figure>

<h2 id="内存读写速度测试"><a href="#内存读写速度测试" class="headerlink" title="内存读写速度测试"></a>内存读写速度测试</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">dd if=/dev/zero of=/dev/null bs=1M count=1024</span><br></pre></td></tr></table></figure>

<h2 id="查看当前CPU运行频率"><a href="#查看当前CPU运行频率" class="headerlink" title="查看当前CPU运行频率"></a>查看当前CPU运行频率</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">watch -n 0.1 &quot;cat /proc/cpuinfo | grep \&quot;^[c]pu MHz\&quot;&quot;</span><br></pre></td></tr></table></figure>

<h2 id="文件指定行数的字符大写转小写"><a href="#文件指定行数的字符大写转小写" class="headerlink" title="文件指定行数的字符大写转小写"></a>文件指定行数的字符大写转小写</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find -name &quot;*.md&quot; | xargs sed -i &#x27;4,9s/.*/\L&amp;/&#x27;</span><br></pre></td></tr></table></figure>

<h2 id="删除所有文件行尾空格"><a href="#删除所有文件行尾空格" class="headerlink" title="删除所有文件行尾空格"></a>删除所有文件行尾空格</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find source/_posts/ -name &quot;*.md&quot; | xargs sed -i &#x27;s/[ ]*$//g&#x27;</span><br></pre></td></tr></table></figure>

<h2 id="进程CPU占有率排序"><a href="#进程CPU占有率排序" class="headerlink" title="进程CPU占有率排序"></a>进程CPU占有率排序</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ps H -eo user,pid,ppid,tid,time,%cpu,cmd --sort=%cpu</span><br></pre></td></tr></table></figure>

<h2 id="判断进程在哪个CPU核运行的方法"><a href="#判断进程在哪个CPU核运行的方法" class="headerlink" title="判断进程在哪个CPU核运行的方法"></a>判断进程在哪个CPU核运行的方法</h2><h3 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ps -o pid,psr,cmd -p &lt;pid&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>PSR</code>: 进程分配的CPU id</p>
</blockquote>
<h3 id="top"><a href="#top" class="headerlink" title="top"></a>top</h3><p><code>top</code>命令也可以显示CPU被分配给哪个进程</p>
<ul>
<li>进入<code>top</code>后，按<code>f</code>键，出现Fields Management管理界面，(空格键选中)选择<code>P</code>选项(P &#x3D; Last Used Cpu (SMP))</li>
<li>top界面中目前使用的CPU将出现在”P”（或“PSR”）列下</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">top -p &lt;pid&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>查看单独一个进程的信息</p>
</blockquote>
<h2 id="杀死僵尸进程"><a href="#杀死僵尸进程" class="headerlink" title="杀死僵尸进程"></a>杀死僵尸进程</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kill -HUP &lt;PID&gt;</span><br></pre></td></tr></table></figure>

<h2 id="iptux–局域网数据传输–飞秋"><a href="#iptux–局域网数据传输–飞秋" class="headerlink" title="iptux–局域网数据传输–飞秋"></a>iptux–局域网数据传输–飞秋</h2><blockquote>
<p>Linux中的iptux与window中的飞秋可以相互进行文件传输</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install iptux</span><br></pre></td></tr></table></figure>
<ul>
<li><p>调整防火墙以允许使用TCP&#x2F;UDP<code>2425</code>端口</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo ufw allow 2425</span><br></pre></td></tr></table></figure>
</li>
<li><p>中文乱码<br>设置编码方式: <code>cp936</code>(or <code>gbk</code>)</p>
<blockquote>
<p>工具栏设置: Tools -&gt; Preferences -&gt; System -&gt; Candidate network conding: <code>cp936</code></p>
</blockquote>
</li>
<li><p>配置文件</p>
<ul>
<li>配置文件: <code>.iptux/config.json</code></li>
<li>日志: <code>.config/iptux/</code></li>
</ul>
</li>
</ul>
<h2 id="数据销毁和日志清理"><a href="#数据销毁和日志清理" class="headerlink" title="数据销毁和日志清理"></a>数据销毁和日志清理</h2><h3 id="bleachbit"><a href="#bleachbit" class="headerlink" title="bleachbit"></a>bleachbit</h3><blockquote>
<p>bleachbit 是一款开源免费的系统清理工具，功能类似 Windows 平台的 CCleaner</p>
</blockquote>
<h3 id="shred"><a href="#shred" class="headerlink" title="shred"></a>shred</h3><blockquote>
<p>shred 功能简单的说就是涂鸦，把一个文件用随机的字符码篡改的一塌糊涂。其宗旨就是更安全地帮助删除一个机密文件</p>
</blockquote>
<h3 id="wipe"><a href="#wipe" class="headerlink" title="wipe"></a>wipe</h3><blockquote>
<p>可安全地删除磁存储器中的文件，后续无法恢复已删除文件或目录的内容。</p>
</blockquote>
<h2 id="CPU信息"><a href="#CPU信息" class="headerlink" title="CPU信息"></a>CPU信息</h2><ul>
<li>lscpu</li>
<li>lshw</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">lscpu</span></span><br><span class="line">...</span><br><span class="line">Byte Order:            Little Endian</span><br><span class="line">CPU(s):                256</span><br><span class="line">On-line CPU(s) list:   0-255</span><br><span class="line">Thread(s) per core:    4</span><br><span class="line">Core(s) per socket:    32</span><br><span class="line">Socket(s):             2</span><br><span class="line">NUMA node(s):          2</span><br><span class="line">Model:                 1</span><br><span class="line">CPU max MHz:           2500.0000</span><br><span class="line">CPU min MHz:           1000.0000</span><br><span class="line">BogoMIPS:              400.00</span><br></pre></td></tr></table></figure>
<ul>
<li><code>socket</code>: 主板上插CPU槽的数量</li>
<li><code>core</code>: CPU上的核数(物理核)</li>
<li><code>thread</code>: core上的硬件线程数(逻辑核)</li>
</ul>
<h2 id="nproc"><a href="#nproc" class="headerlink" title="nproc"></a>nproc</h2><blockquote>
<p>获取可用CPU的数量</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nproc</span><br></pre></td></tr></table></figure>

<h2 id="apt-build-dep"><a href="#apt-build-dep" class="headerlink" title="apt build-dep"></a>apt build-dep</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get build-dep mesa</span><br></pre></td></tr></table></figure>
<blockquote>
<p>build-dep causes apt-get to install&#x2F;remove packages in an attempt to satisfy the build dependencies for a source package. By default the dependencies are satisfied to build the package natively. If desired a host-architecture can be specified with the <code>--host-architecture</code> option instead.</p>
</blockquote>
<p>根据源码编译时所需的关系包进行搜索并下载安装.建立要编译软件的环境.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">sudo apt build-dep mesa</span></span><br><span class="line">Reading package lists... Done</span><br><span class="line">Reading package lists... Done</span><br><span class="line">Building dependency tree</span><br><span class="line">Reading state information... Done</span><br><span class="line">The following NEW packages will be installed:</span><br><span class="line">  autopoint debhelper dh-autoreconf dh-strip-nondeterminism lib32gcc1 lib32stdc++6 libc6-i386 libclang-9-dev libclang-common-9-dev libclang1-9</span><br><span class="line">  libclc-dev libfile-stripnondeterminism-perl libglvnd-core-dev libobjc-7-dev libobjc4 libpfm4 libset-scalar-perl libva-dev libva-glx2</span><br><span class="line">  libvdpau-dev libvulkan-dev llvm-9 llvm-9-dev llvm-9-runtime llvm-9-tools po-debconf python-pygments python-yaml python3-pygments quilt</span><br><span class="line">The following packages will be upgraded:</span><br><span class="line">  cpp-7 g++-7 gcc-7 gcc-7-base gcc-8-base libasan4 libatomic1 libcc1-0 libcilkrts5 libgcc-7-dev libgcc1 libgomp1 libitm1 liblsan0 libmpx2</span><br><span class="line">  libquadmath0 libstdc++-7-dev libstdc++6 libtsan0 libubsan0</span><br><span class="line">20 upgraded, 30 newly installed, 0 to remove and 44 not upgraded.</span><br><span class="line">Need to get 101 MB of archives.</span><br><span class="line">After this operation, 477 MB of additional disk space will be used.</span><br><span class="line">Do you want to continue? [Y/n]</span><br></pre></td></tr></table></figure>

<h2 id="tasksel"><a href="#tasksel" class="headerlink" title="tasksel"></a>tasksel</h2><p><code>tasksel</code>命令是用来安装“任务”的，任务就是一些软件的组合，比如LAMP这个任务，就是由apache，php，MySQL等软件包组成，tasksel安装任务就是安装一系列的软件包而已。</p>
<blockquote>
<p>通过tasksel可以直接在server版，进行ubuntu桌面的安装</p>
</blockquote>
<h3 id="ubuntu-Desktop"><a href="#ubuntu-Desktop" class="headerlink" title="ubuntu Desktop"></a>ubuntu Desktop</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt upgrade</span><br><span class="line">sudo tasksel</span><br></pre></td></tr></table></figure>
<blockquote>
<p>tasksel选择ubuntu Desktop进行安装，等待安装完成</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo tasksel install ubuntu-desktop</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$tasksel --list-tasks</span><br><span class="line">u kubuntu-live	Kubuntu live CD</span><br><span class="line">u lubuntu-live-gtk	Lubuntu live CD (GTK part)</span><br><span class="line">u ubuntu-budgie-live	Ubuntu Budgie live CD</span><br><span class="line">u ubuntu-live	Ubuntu live CD</span><br><span class="line">u ubuntu-mate-live	Ubuntu MATE Live CD</span><br><span class="line">u ubuntustudio-dvd-live	Ubuntu Studio live DVD</span><br><span class="line">u vanilla-gnome-live	Ubuntu GNOME live CD</span><br><span class="line">u xubuntu-live	Xubuntu live CD</span><br><span class="line">u cloud-image	Ubuntu Cloud Image (instance)</span><br><span class="line">u dns-server	DNS server</span><br><span class="line">u kubuntu-desktop	Kubuntu desktop</span><br><span class="line">u kubuntu-full	Kubuntu full</span><br><span class="line">u lamp-server	LAMP server</span><br><span class="line">u lubuntu-core	Lubuntu minimal installation</span><br><span class="line">u lubuntu-desktop	Lubuntu Desktop</span><br><span class="line">u lubuntu-gtk-core	Lubuntu minimal installation (GTK part)</span><br><span class="line">u lubuntu-gtk-desktop	Lubuntu Desktop (GTK part)</span><br><span class="line">u lubuntu-qt-core	Lubuntu minimal installation (Qt part)</span><br><span class="line">u lubuntu-qt-desktop	Lubuntu Qt Desktop (Qt part)</span><br><span class="line">i mail-server	Mail server</span><br><span class="line">u postgresql-server	PostgreSQL database</span><br><span class="line">i print-server	Print server</span><br><span class="line">i samba-server	Samba file server</span><br><span class="line">u ubuntu-budgie-desktop	Ubuntu Budgie desktop</span><br><span class="line">i ubuntu-desktop	Ubuntu desktop</span><br><span class="line">u ubuntu-mate-core	Ubuntu MATE minimal</span><br><span class="line">u ubuntu-mate-desktop	Ubuntu MATE desktop</span><br><span class="line">u ubuntustudio-audio	Audio recording and editing suite</span><br><span class="line">u ubuntustudio-desktop	Ubuntu Studio desktop</span><br><span class="line">u ubuntustudio-desktop-core	Ubuntu Studio minimal DE installation</span><br><span class="line">u ubuntustudio-fonts	Large selection of font packages</span><br><span class="line">u ubuntustudio-graphics	2D/3D creation and editing suite</span><br><span class="line">u ubuntustudio-photography	Photograph touchup and editing suite</span><br><span class="line">u ubuntustudio-publishing	Publishing applications</span><br><span class="line">u ubuntustudio-video	Video creation and editing suite</span><br><span class="line">u vanilla-gnome-desktop	Vanilla GNOME desktop</span><br><span class="line">u xubuntu-core	Xubuntu minimal installation</span><br><span class="line">u xubuntu-desktop	Xubuntu desktop</span><br><span class="line">i openssh-server	OpenSSH server</span><br><span class="line">u server	Basic Ubuntu server</span><br></pre></td></tr></table></figure>


<h2 id="find"><a href="#find" class="headerlink" title="find"></a>find</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@linfeng etc]# find . -type f -name &quot;*&quot; | xargs grep &quot;root/init.sh&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>-type f</code> : 表示只找文件</li>
<li><code>-name &quot;xxx&quot;</code> :  表示查找特定文件；也可以不写，表示找所有文件</li>
</ul>
<h3 id="批量修改文件名后缀"><a href="#批量修改文件名后缀" class="headerlink" title="批量修改文件名后缀"></a>批量修改文件名后缀</h3><blockquote>
<p>mv .&#x2F;htxynl.f90 .&#x2F;htxynl.f77</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find . -name &quot;*.f90&quot; | awk -F &quot;.&quot; &#x27;&#123;print $2&#125;&#x27; | xargs -i -t mv .&#123;&#125;.f90  .&#123;&#125;.f77</span><br></pre></td></tr></table></figure>

<h2 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h2><blockquote>
<p>cat和重定向进行写文件操作</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">=====&gt;$cat &gt; test.sh &lt;&lt; EOF</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">this is <span class="built_in">test</span></span></span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>
<p>结束方式：</p>
<ul>
<li>输入<code>EOF</code>，最好使用EOF</li>
<li>使用<code>Ctrl+d</code></li>
</ul>
<p>写入方式：</p>
<ul>
<li><code>&gt;</code> : 以覆盖文件内容的方式，若此文件不存在，则创建</li>
<li><code>&gt;&gt;</code> : 以追加的方式写入文件</li>
</ul>
<h2 id="tee"><a href="#tee" class="headerlink" title="tee"></a>tee</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make USE_NINJA=false USE_CLANG_PLATFORM_BUILD=false 2&gt;&amp;1 | tee build.log</span><br></pre></td></tr></table></figure>

<h2 id="ssh"><a href="#ssh" class="headerlink" title="ssh"></a>ssh</h2><h3 id="跨服务器拷贝文件"><a href="#跨服务器拷贝文件" class="headerlink" title="跨服务器拷贝文件"></a>跨服务器拷贝文件</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xbin=&quot;u-boot-with-spl-mbr-gpt.bin&quot;</span><br><span class="line">xdst=&quot;user@192.168.10.44:/home/user/x2000_ddr_test&quot;</span><br><span class="line"></span><br><span class="line">scp $xbin fpga@192.168.4.13:/tmp/$xbin</span><br><span class="line">ssh fpga@192.168.4.13 &quot;scp /tmp/$xbin $xdst&quot;</span><br></pre></td></tr></table></figure>
<h3 id="ssh的key值"><a href="#ssh的key值" class="headerlink" title="ssh的key值"></a>ssh的key值</h3><ol>
<li>权限必须是<code>600</code><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chmod 600 ~/.ssh/authorized_keys</span><br></pre></td></tr></table></figure></li>
<li>添加key值<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh-add ~/.ssh/authorized_keys</span><br></pre></td></tr></table></figure></li>
<li>查看生效key值<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh-add -l</span><br></pre></td></tr></table></figure></li>
<li>测试key值<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure></li>
<li>免密登录<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh-copy-id ssh name@ip</span><br></pre></td></tr></table></figure></li>
<li>使用多个key值<blockquote>
<p>man ssh_config</p>
</blockquote>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cp /etc/ssh/ssh_config ~/.ssh/config</span><br></pre></td></tr></table></figure>
<p>编辑~&#x2F;.ssh&#x2F;config</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">#   StrictHostKeyChecking ask</span><br><span class="line">    IdentityFile ~/.ssh/id_rsa</span><br><span class="line">    IdentityFile ~/.ssh/xxxx</span><br><span class="line">#   IdentityFile ~/.ssh/id_dsa</span><br><span class="line">#   IdentityFile ~/.ssh/id_ecdsa</span><br><span class="line">#   IdentityFile ~/.ssh/id_ed25519</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h3 id="ssh登录到远程的特定目录"><a href="#ssh登录到远程的特定目录" class="headerlink" title="ssh登录到远程的特定目录"></a>ssh登录到远程的特定目录</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh -t xx@192.168.1.1 &quot;cd /home/xx/test; bash&quot;</span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh -t xx@192.168.1.1 &quot;cd /home/xx/test &amp;&amp; bash&quot;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>-t</code> :标志用于强制分配伪终端</li>
</ul>
<h3 id="通过root账户ssh登录"><a href="#通过root账户ssh登录" class="headerlink" title="通过root账户ssh登录"></a>通过root账户ssh登录</h3><blockquote>
<p>在ubuntu系统中默认不能使用root账户进行ssh登录</p>
</blockquote>
<p>开启root账户登录ssh，打开<code>/etc/ssh/sshd_config</code>配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PermitRootLogin yes</span><br></pre></td></tr></table></figure>
<blockquote>
<p>默认配置<code>#PermitRootLogin prohibit-password</code></p>
</blockquote>
<p>重启ssh服务</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo systemctl restart sshd.service</span><br></pre></td></tr></table></figure>

<h3 id="ssh数据的压缩传输"><a href="#ssh数据的压缩传输" class="headerlink" title="ssh数据的压缩传输"></a>ssh数据的压缩传输</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh -CX xxx@192.168.1.1</span><br></pre></td></tr></table></figure>
<ul>
<li><code>-C</code>: 压缩传输模式</li>
<li><code>-X</code>: 启用X11转发,远程打开使用图形应用</li>
</ul>
<h2 id="tftp"><a href="#tftp" class="headerlink" title="tftp"></a>tftp</h2><blockquote>
<p>开发板（busybox）</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tftp -g -r user/xxxx/system.tar 192.168.4.13</span><br></pre></td></tr></table></figure>

<p>tftp的服务器(PC):</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">/etc/default/tftpd-hpa</span></span><br><span class="line"></span><br><span class="line">TFTP_USERNAME=&quot;tftp&quot;</span><br><span class="line">TFTP_DIRECTORY=&quot;/home/&quot;</span><br><span class="line">TFTP_ADDRESS=&quot;0.0.0.0:69&quot;</span><br><span class="line">TFTP_OPTIONS=&quot;--secure&quot;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>file: &#x2F;etc&#x2F;default&#x2F;tftpd-hpa</p>
</blockquote>
<h2 id="cpio"><a href="#cpio" class="headerlink" title="cpio"></a>cpio</h2><blockquote>
<p>解压，制作 ramdisk</p>
</blockquote>
<ul>
<li><p>解压</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gunzip rootfs.cpio.gz</span><br><span class="line">mkdir tmp</span><br><span class="line">cd tmp</span><br><span class="line">cpio -i -F ../rootfs.cpio</span><br></pre></td></tr></table></figure>
<blockquote>
<p>code: <span class="exturl" data-url="aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL1dpbmRkb2luZy9NeUNvZGUvbWFzdGVyL2FuZHJvaWQvZGVidWcvdW56aXBfcmFtZGlzay5zaA==">unzip_ramdisk.sh<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
</li>
<li><p>制作</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find . | cpio -o -Hnewc |gzip -9 &gt; ../image.cpio.gz</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>-H</code>: 选项指定打包文件的具体格式，要生成init ramfs，只能用<code>newc</code>格式</p>
</blockquote>
</li>
</ul>
<h2 id="minicom"><a href="#minicom" class="headerlink" title="minicom"></a>minicom</h2><p>记录串口的输出日志：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line"></span><br><span class="line">mkdir dd</span><br><span class="line">echo &quot;while [ 1 ];do killall minicom; sleep 36000;done&quot; &gt; ./b.sh</span><br><span class="line">chmod +x ./b.sh</span><br><span class="line">./b.sh &amp;</span><br><span class="line"></span><br><span class="line">while [ 1 ]</span><br><span class="line">do</span><br><span class="line">	ff=`date +%Y%m%d%H%M`;</span><br><span class="line">	echo $ff;</span><br><span class="line">	minicom -w -C ./dd/$ff -o;</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<h3 id="ttyUSB0权限问题"><a href="#ttyUSB0权限问题" class="headerlink" title="ttyUSB0权限问题"></a>ttyUSB0权限问题</h3><p>每次使用串口工具时，需要sudo权限，为了普通用户方便可以通过以下命令解决：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo usermod -a -G dialout $&#123;USER&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>设置后需要重启电脑，使用minicom时不用sudo</p>
</blockquote>
<h3 id="串口输出增加时间戳："><a href="#串口输出增加时间戳：" class="headerlink" title="串口输出增加时间戳："></a>串口输出增加时间戳：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Ctrl + a ; n</span><br></pre></td></tr></table></figure>

<h3 id="串口打印内存信息："><a href="#串口打印内存信息：" class="headerlink" title="串口打印内存信息："></a>串口打印内存信息：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Ctrl + a; f; m</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>Ctrl + a; f</code>(send break)进行发送命令，<code>m</code>查看当前内存状态的命令<br>类似与：<code>echo m &gt; /proc/sysrq-trigger </code></p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">break signal</th>
<th align="center"></th>
</tr>
</thead>
<tbody><tr>
<td align="center">m</td>
<td align="center">查看当前内存状态的命令</td>
</tr>
</tbody></table>
<blockquote>
<p>内核提供接口<code>drivers/tty/sysrq.c</code>,通过按键的方式获取内核的调试信息</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static struct sysrq_key_op *sysrq_key_table[36] = &#123;</span><br><span class="line">	&amp;sysrq_loglevel_op,		/* 0 */</span><br><span class="line">	&amp;sysrq_loglevel_op,		/* 1 */</span><br><span class="line">	&amp;sysrq_loglevel_op,		/* 2 */</span><br><span class="line">	&amp;sysrq_loglevel_op,		/* 3 */</span><br><span class="line">	&amp;sysrq_loglevel_op,		/* 4 */</span><br><span class="line">	&amp;sysrq_loglevel_op,		/* 5 */</span><br><span class="line">	&amp;sysrq_loglevel_op,		/* 6 */</span><br><span class="line">	&amp;sysrq_loglevel_op,		/* 7 */</span><br><span class="line">	&amp;sysrq_loglevel_op,		/* 8 */</span><br><span class="line">	&amp;sysrq_loglevel_op,		/* 9 */</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * a: Don&#x27;t use for system provided sysrqs, it is handled specially on</span><br><span class="line">	 * sparc and will never arrive.</span><br><span class="line">	 */</span><br><span class="line">	NULL,				/* a */</span><br><span class="line">	&amp;sysrq_reboot_op,		/* b */</span><br><span class="line">	&amp;sysrq_crash_op,		/* c &amp; ibm_emac driver debug */</span><br><span class="line">	&amp;sysrq_showlocks_op,		/* d */</span><br><span class="line">	&amp;sysrq_term_op,			/* e */</span><br><span class="line">	&amp;sysrq_moom_op,			/* f */</span><br><span class="line">	/* g: May be registered for the kernel debugger */</span><br><span class="line">	NULL,				/* g */</span><br><span class="line">	NULL,				/* h - reserved for help */</span><br><span class="line">	&amp;sysrq_kill_op,			/* i */</span><br><span class="line">#ifdef CONFIG_BLOCK</span><br><span class="line">	&amp;sysrq_thaw_op,			/* j */</span><br><span class="line">#else</span><br><span class="line">	NULL,				/* j */</span><br><span class="line">#endif</span><br><span class="line">	&amp;sysrq_SAK_op,			/* k */</span><br><span class="line">#ifdef CONFIG_SMP</span><br><span class="line">	&amp;sysrq_showallcpus_op,		/* l */</span><br><span class="line">#else</span><br><span class="line">	NULL,				/* l */</span><br><span class="line">#endif</span><br><span class="line">	&amp;sysrq_showmem_op,		/* m */</span><br><span class="line">	&amp;sysrq_unrt_op,			/* n */</span><br><span class="line">	/* o: This will often be registered as &#x27;Off&#x27; at init time */</span><br><span class="line">	NULL,				/* o */</span><br><span class="line">	&amp;sysrq_showregs_op,		/* p */</span><br><span class="line">	&amp;sysrq_show_timers_op,		/* q */</span><br><span class="line">	&amp;sysrq_unraw_op,		/* r */</span><br><span class="line">	&amp;sysrq_sync_op,			/* s */</span><br><span class="line">	&amp;sysrq_showstate_op,		/* t */</span><br><span class="line">	&amp;sysrq_mountro_op,		/* u */</span><br><span class="line">	/* v: May be registered for frame buffer console restore */</span><br><span class="line">	NULL,				/* v */</span><br><span class="line">	&amp;sysrq_showstate_blocked_op,	/* w */</span><br><span class="line">	/* x: May be registered on ppc/powerpc for xmon */</span><br><span class="line">	/* x: May be registered on sparc64 for global PMU dump */</span><br><span class="line">	NULL,				/* x */</span><br><span class="line">	/* y: May be registered on sparc64 for global register dump */</span><br><span class="line">	NULL,				/* y */</span><br><span class="line">	&amp;sysrq_ftrace_dump_op,		/* z */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="enable-the-magic-SysRq-key"><a href="#enable-the-magic-SysRq-key" class="headerlink" title="enable the magic SysRq key"></a>enable the magic SysRq key</h4><blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cua2VybmVsLm9yZy9kb2MvaHRtbC9sYXRlc3QvYWRtaW4tZ3VpZGUvc3lzcnEuaHRtbA==">https://www.kernel.org/doc/html/latest/admin-guide/sysrq.html<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<p>配置内核时，您需要对’Magic Sysrq键（CONFIG_MAGIC_SYSRQ&#x3D;y)。在运行使用SYSRQ的内核时，<code>/proc/sys/kernel/sysrq</code>控制通过SYSRQ键调用允许的函数。该文件中的默认值由CONFIG_MAGIC_SYSRQ_DEFAULT_ENABLE设置，该值默认为1。</p>
<p><code>/proc/proc/sys/kernel/sysrq</code>中可能值的列表：</p>
<ul>
<li>0 - disable sysrq completely</li>
<li>1 - enable all functions of sysrq</li>
</ul>
<ul>
<li>参考配置</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CONFIG_MAGIC_SYSRQ=y</span><br><span class="line">CONFIG_MAGIC_SYSRQ_DEFAULT_ENABLE=0x1</span><br><span class="line">CONFIG_MAGIC_SYSRQ_SERIAL=y</span><br></pre></td></tr></table></figure>

<h3 id="kermit文件传输"><a href="#kermit文件传输" class="headerlink" title="kermit文件传输"></a>kermit文件传输</h3><ul>
<li>安装ckermit</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt install ckermit</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注：ubuntu20.04没有ckermit，可以手动下载ubuntu18.04的版本安装，自测可用。</p>
</blockquote>
<ul>
<li>配置kermit</li>
</ul>
<p>在配置文件<code>/etc/kermit/kermrc</code>中追加以下配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set line          /dev/ttyUSB0</span><br><span class="line">set speed         115200</span><br><span class="line">set carrier-watch off</span><br><span class="line">set handshake     none</span><br><span class="line">set flow-control none</span><br><span class="line">robust</span><br><span class="line">set file type     bin</span><br><span class="line">set file name     lit</span><br><span class="line">set rec pack      1000</span><br><span class="line">set send pack     1000</span><br><span class="line">set window        5</span><br></pre></td></tr></table></figure>

<ul>
<li>文件发送</li>
</ul>
<p>快捷键：<code>Ctrl + a + s</code>，选择<code>kermit</code></p>
<h2 id="sshfs"><a href="#sshfs" class="headerlink" title="sshfs"></a>sshfs</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo sshfs xxx@192.168.1.2:/home_back/xxx/work/aaa /home/user/aaa -o gid=1000,uid=1000,allow_other</span><br></pre></td></tr></table></figure>
<h2 id="md5sum-—-字符串"><a href="#md5sum-—-字符串" class="headerlink" title="md5sum — 字符串"></a>md5sum — 字符串</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash"><span class="built_in">echo</span> -n <span class="string">&#x27;123456&#x27;</span> | <span class="built_in">md5sum</span></span></span><br><span class="line">e10adc3949ba59abbe56e057f20f883e  -</span><br></pre></td></tr></table></figure>

<h2 id="查看硬盘型号和序列号"><a href="#查看硬盘型号和序列号" class="headerlink" title="查看硬盘型号和序列号"></a>查看硬盘型号和序列号</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo hdparm -i /dev/sda</span><br></pre></td></tr></table></figure>

<h2 id="获取计算机硬件信息"><a href="#获取计算机硬件信息" class="headerlink" title="获取计算机硬件信息"></a>获取计算机硬件信息</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo dmidecode</span><br></pre></td></tr></table></figure>
<blockquote>
<p>dmidecode遵循SMBIOS&#x2F;DMI标准，其输出的信息包括BIOS、系统、主板、处理器、内存、缓存等等。</p>
</blockquote>
<h2 id="格式化xml"><a href="#格式化xml" class="headerlink" title="格式化xml"></a>格式化xml</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xmllint --format run_xunit.xml</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在vim中直接敲xml,进行格式化</p>
</blockquote>
<h2 id="tldr"><a href="#tldr" class="headerlink" title="tldr"></a>tldr</h2><blockquote>
<p>Too Long Don’t Read!</p>
</blockquote>
<p>查找各种命令的常用例子</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install tldr</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">tldr ps</span></span><br><span class="line">ps</span><br><span class="line">Information about running processes.</span><br><span class="line"></span><br><span class="line"> - List all running processes:</span><br><span class="line">   ps aux</span><br><span class="line"></span><br><span class="line"> - List all running processes including the full command string:</span><br><span class="line">   ps auxww</span><br><span class="line"></span><br><span class="line"> - Search for a process that matches a string:</span><br><span class="line">   ps aux | grep &#123;&#123;string&#125;&#125;</span><br><span class="line"></span><br><span class="line"> - List all processes of the current user in extra full format:</span><br><span class="line">   ps --user $(id -u) -F</span><br><span class="line"></span><br><span class="line"> - List all processes of the current user as a tree:</span><br><span class="line">   ps --user $(id -u) f</span><br><span class="line"></span><br><span class="line"> - Get the parent pid of a process:</span><br><span class="line">   ps -o ppid= -p &#123;&#123;pid&#125;&#125;</span><br></pre></td></tr></table></figure>


<h2 id="top-1"><a href="#top-1" class="headerlink" title="top"></a>top</h2><p>命令相关参数</p>
<table>
<thead>
<tr>
<th align="center">参数</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>1</code></td>
<td align="center">显示每个CPU的运行情况</td>
</tr>
<tr>
<td align="center"><code>z</code></td>
<td align="center">进入高亮模式（终端红色字体）</td>
</tr>
<tr>
<td align="center"><code>b</code></td>
<td align="center">高亮显示正在运行的命令</td>
</tr>
<tr>
<td align="center"><code>c</code></td>
<td align="center">显示command列的所有信息，包括参数</td>
</tr>
<tr>
<td align="center"><code>t</code></td>
<td align="center">更直观的方式展示task&#x2F;cpu信息，像htop一样</td>
</tr>
<tr>
<td align="center"><code>m</code></td>
<td align="center">更直观的方式展示memory信息，像htop一样</td>
</tr>
<tr>
<td align="center"><code>M</code></td>
<td align="center">根据内存使用率进行排序，%MEM列</td>
</tr>
<tr>
<td align="center"><code>P</code></td>
<td align="center">根据CPU使用率进行排序，%CPU列</td>
</tr>
</tbody></table>
<h2 id="sed"><a href="#sed" class="headerlink" title="sed"></a>sed</h2><blockquote>
<p>参考：<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vZWR3YXJkbG9zdC9hcmNoaXZlLzIwMTAvMDkvMTcvMTgyOTE0NS5odG1s">sed命令详解<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<h3 id="将当前目录-包括子目录-文件中的特定字符串并进行替换"><a href="#将当前目录-包括子目录-文件中的特定字符串并进行替换" class="headerlink" title="将当前目录(包括子目录)文件中的特定字符串并进行替换"></a>将当前目录(包括子目录)文件中的特定字符串并进行替换</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sed -i s/jpeg_encode.h/jpeg_codec.h/g `grep jpeg_encode.h -rl --include=&quot;*.c&quot; ./`</span><br></pre></td></tr></table></figure>
<ul>
<li><code>-i</code> :表示操作的是文件</li>
<li><code>反引号</code> :表示将grep命令的的结果作为操作文件</li>
</ul>
<h3 id="当前目录文件替换"><a href="#当前目录文件替换" class="headerlink" title="当前目录文件替换"></a>当前目录文件替换</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sed -i s/xxxx/yyyy/g ./*.txt</span><br></pre></td></tr></table></figure>

<h2 id="pkg-config"><a href="#pkg-config" class="headerlink" title="pkg-config"></a>pkg-config</h2><blockquote>
<p>用于获得某一个库&#x2F;模块的所有编译相关的信息</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">pkg-config --libs --cflags gl</span></span><br><span class="line">-I/usr/include/libdrm -lGL</span><br></pre></td></tr></table></figure>

<h3 id="pkg-config默认的搜索路径"><a href="#pkg-config默认的搜索路径" class="headerlink" title="pkg-config默认的搜索路径"></a>pkg-config默认的搜索路径</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">pkg-config --variable pc_path pkg-config</span></span><br><span class="line">/usr/local/lib/x86_64-linux-gnu/pkgconfig:/usr/local/lib/pkgconfig:/usr/local/share/pkgconfig:/usr/lib/x86_64-linux-gnu/pkgconfig:/usr/lib/pkgconfig:/usr/share/pkgconfig</span><br></pre></td></tr></table></figure>
<h3 id="PKG-CONFIG-PATH"><a href="#PKG-CONFIG-PATH" class="headerlink" title="PKG_CONFIG_PATH"></a>PKG_CONFIG_PATH</h3><p>配置pkgconfig文件路径</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo $PKG_CONFIG_PATH</span><br></pre></td></tr></table></figure>

<h2 id="运行时库的连接"><a href="#运行时库的连接" class="headerlink" title="运行时库的连接"></a>运行时库的连接</h2><ul>
<li>在环境变量<code>LD_LIBRARY_PATH</code>中指明库的搜索路径。</li>
<li>在<code>/etc/ld.so.conf</code>文件中添加库的搜索路径。</li>
</ul>
<h3 id="LD-LIBRARY-PATH"><a href="#LD-LIBRARY-PATH" class="headerlink" title="LD_LIBRARY_PATH"></a>LD_LIBRARY_PATH</h3><p>配置运行时加载库的路径</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo $LD_LIBRARY_PATH</span><br></pre></td></tr></table></figure>

<h2 id="命令行直接打开浏览器进入指定网页"><a href="#命令行直接打开浏览器进入指定网页" class="headerlink" title="命令行直接打开浏览器进入指定网页"></a>命令行直接打开浏览器进入指定网页</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$firefox --new-window https://winddoing.github.io</span><br></pre></td></tr></table></figure>
<h2 id="命令行直接打开文件管理（ubuntu）"><a href="#命令行直接打开文件管理（ubuntu）" class="headerlink" title="命令行直接打开文件管理（ubuntu）"></a>命令行直接打开文件管理（ubuntu）</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$nautilus</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vbXktYmxvZy9hcmNoaXZlLzIwMDgvMTIvMTAvMTM1MTc1My5odG1s">minicom中文手册<i class="fa fa-external-link-alt"></i></span></li>
</ol>
]]></content>
      <categories>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>uboot启动流程——MIPS</title>
    <url>/post/47503.html</url>
    <content><![CDATA[<p>Bootloader 是在操作系统运行之前执行的一段小程序。通过这段小程序，我们可以初始化硬件设备、建立内存空间的映射表，从而建立适当的系统软硬件环境，为最终调用操作系统内核做好准备。</p>
<p>uboot引导系统启动, UBoot包含两个阶段的启动，一个是SPL启动，一个是正常的启动我们称为第二阶段Uboot。当然，我们也可以选择使用SPL和不使用，主要根据CPU中的SRAM（或者cache，bootram阶段需要初始化完成）的大小，如果不能放下uboot大小，则必须先使用SPL启动，进行DDR的初始化，以获取更大的可以空间。</p>
<blockquote>
<p>Version: u-boot-201307</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+----------------+-----------------------------------+</span><br><span class="line">|                |                                   |</span><br><span class="line">|  spl           |             uboot                 |</span><br><span class="line">|                |                                   |</span><br><span class="line">+----------------+-----------------------------------+</span><br></pre></td></tr></table></figure>

<p>在编译的过程中,这两个阶段通过<code>CONFIG_SPL_BUILD</code>宏将编译分离。拥有不同的配置，所以许多地方的宏是和SPL的不一样。而且链接的文件也不一致。</p>
<ul>
<li>SPL：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./arch/mips/cpu/xburst/x1000/u-boot-spl.lds</span><br></pre></td></tr></table></figure></li>
<li>uboot：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/arch/mips/cpu/u-boot.lds</span><br></pre></td></tr></table></figure></li>
</ul>
<span id="more"></span>

<h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p><img data-src="/images/uboot/uboot_stage.png" alt="uboot stage"></p>
<h2 id="流程"><a href="#流程" class="headerlink" title="流程:"></a>流程:</h2><p><img data-src="/images/uboot/uboot_boot.png" alt="uboot boot"></p>
<h2 id="SPL"><a href="#SPL" class="headerlink" title="SPL"></a>SPL</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">u-boot-spl.lds</span><br><span class="line">ENTRY: _start (start.S)</span><br><span class="line">		\-&gt;board_init_f (soc.c)</span><br><span class="line">			-&gt;board_init_r (spl.c)</span><br></pre></td></tr></table></figure>
<h3 id="u-boot-spl-lds"><a href="#u-boot-spl-lds" class="headerlink" title="u-boot-spl.lds"></a>u-boot-spl.lds</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CONFIG_SPL_TEXT_BASE        0xf4001000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONFIG_SPL_MAX_SIZE     (12 * 1024)</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MEMORY &#123; .sram : ORIGIN = CONFIG_SPL_TEXT_BASE,\</span><br><span class="line">		LENGTH = CONFIG_SPL_MAX_SIZE &#125;</span><br><span class="line"></span><br><span class="line">OUTPUT_ARCH(mips)</span><br><span class="line">ENTRY(_start)</span><br><span class="line">SECTIONS</span><br><span class="line">&#123;</span><br><span class="line">	.text      :</span><br><span class="line">	&#123;</span><br><span class="line">		__start = .;</span><br><span class="line">		*(.start_section*)</span><br><span class="line">		*(.text*)</span><br><span class="line">	&#125; &gt;.sram</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	.bss : &#123;</span><br><span class="line">		. = ALIGN(4);</span><br><span class="line">		__bss_start = .;</span><br><span class="line">		*(.sbss.*)</span><br><span class="line">		*(.bss.*)</span><br><span class="line">		*(COMMON)</span><br><span class="line">		. = ALIGN(4);</span><br><span class="line">		__bss_end = .;</span><br><span class="line">	&#125; &gt;.sram</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><a href="/downloads/uboot/u-boot-spl.lds.txt">u-boot-spl.lds</a></p>
</blockquote>
<p>在bootram将SPL搬到静态ram中后，执行SPL的代码将从<code>_start</code>开始。</p>
<h3 id="start-S"><a href="#start-S" class="headerlink" title="start.S"></a>start.S</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define RESERVED_FOR_SC(x) .space 1536, x</span><br><span class="line"></span><br><span class="line">	.set noreorder</span><br><span class="line"></span><br><span class="line">	.globl _start</span><br><span class="line">	.section .start_section</span><br><span class="line">_start:</span><br><span class="line">	/* magic value (&quot;MSPL&quot;) */</span><br><span class="line">	.word 0x4d53504c</span><br><span class="line">	.space 508, 0</span><br><span class="line">	RESERVED_FOR_SC(0)</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_SPL_VERSION</span><br><span class="line">	.word (0x00000000 | CONFIG_SPL_VERSION)</span><br><span class="line">	.space (512-20),0</span><br><span class="line">#else</span><br><span class="line">	.space (512-16),0</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">	/* Invalidate BTB */</span><br><span class="line">	mfc0	v0, CP0_CONFIG, 7</span><br><span class="line">	nop</span><br><span class="line">	ori	v0, v0, 2 /* MMU类型：BAT类型*/</span><br><span class="line">	mtc0	v0, CP0_CONFIG, 7</span><br><span class="line">	nop</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * CU0=UM=EXL=IE=0, BEV=ERL=1, IP2~7=1</span><br><span class="line">	 */</span><br><span class="line">	li	t0, 0x0040FC04</span><br><span class="line">	mtc0	t0, CP0_STATUS</span><br><span class="line"></span><br><span class="line">	/* CAUSE register */</span><br><span class="line">	/* IV=1, use the specical interrupt vector (0x200) */</span><br><span class="line">	li	t1, 0x00800000</span><br><span class="line">	mtc0	t1, CP0_CAUSE</span><br><span class="line"></span><br><span class="line">	.set push</span><br><span class="line">	.set	mips32</span><br><span class="line">init_caches:</span><br><span class="line">	li	t0, CONF_CM_CACHABLE_NONCOHERENT</span><br><span class="line">	mtc0	t0, CP0_CONFIG</span><br><span class="line">	nop</span><br><span class="line"></span><br><span class="line">	/* enable idx-store-data cache insn */</span><br><span class="line">	li      t0, 0x20000000</span><br><span class="line">	mtc0    t0, CP0_ECC</span><br><span class="line"></span><br><span class="line">	li	t1, KSEG0		/* Start address */</span><br><span class="line">#define CACHE_ALLOC_END (CONFIG_SYS_DCACHE_SIZE)</span><br><span class="line"></span><br><span class="line">	ori     t2, t1, CACHE_ALLOC_END	/* End address */</span><br><span class="line">	mtc0	zero, CP0_TAGLO, 0</span><br><span class="line">	mtc0	zero, CP0_TAGLO, 1</span><br><span class="line">cache_clear_a_line:</span><br><span class="line">	cache   INDEX_STORE_TAG_I, 0(t1)</span><br><span class="line">	cache   INDEX_STORE_TAG_D, 0(t1)</span><br><span class="line">	addiu   t1, t1, CONFIG_SYS_CACHELINE_SIZE</span><br><span class="line">	bne     t1, t2, cache_clear_a_line</span><br><span class="line">	nop</span><br><span class="line">	.set pop</span><br><span class="line"></span><br><span class="line">	/* Set up stack */</span><br><span class="line">#ifdef CONFIG_SPL_STACK</span><br><span class="line">	li	sp, CONFIG_SPL_STACK</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">	j	board_init_f</span><br><span class="line">	nop</span><br></pre></td></tr></table></figure>
<blockquote>
<p><a href="/downloads/uboot/spl_start.S">start.S</a></p>
</blockquote>
<ol>
<li>设置spl的空间布局,加载识别区域，SC填充区域等</li>
<li>选择MMU类型</li>
<li>通过SR，使能异常向量和配置中断屏蔽位</li>
<li>配置一个特殊的中断异常入口（0x200）</li>
<li>初始化cache</li>
<li>跳转<code>board_init_f</code></li>
</ol>
<h3 id="soc-c"><a href="#soc-c" class="headerlink" title="soc.c"></a>soc.c</h3><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><h5 id="bd-t"><a href="#bd-t" class="headerlink" title="bd_t"></a>bd_t</h5><blockquote>
<p>保存板子参数</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">bd_info</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>    bi_baudrate;    <span class="comment">/*serial console baudrate*/</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>   bi_arch_number; <span class="comment">/*unique id for this board*/</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>   bi_boot_params; <span class="comment">/*where this board expects params*/</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>   bi_memstart;    <span class="comment">/*start of DRAM memory*/</span></span><br><span class="line">    <span class="type">phys_size_t</span> bi_memsize; <span class="comment">/*size  of DRAM memory in bytes*/</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>   bi_flashstart;  <span class="comment">/*start of FLASH memory*/</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>   bi_flashsize;   <span class="comment">/*size  of FLASH memory*/</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>   bi_flashoffset; <span class="comment">/*reserved area for startup monitor*/</span></span><br><span class="line">&#125; <span class="type">bd_t</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>file: arch&#x2F;mips&#x2F;include&#x2F;asm&#x2F;u-boot.h</p>
</blockquote>
<h5 id="gd-t"><a href="#gd-t" class="headerlink" title="gd_t"></a>gd_t</h5><blockquote>
<p>全局的系统初始化参数</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">global_data</span> &#123;</span></span><br><span class="line">	<span class="type">bd_t</span> *bd;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> baudrate;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> cpu_clk;	<span class="comment">/* CPU clock in Hz!		*/</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> bus_clk;</span><br><span class="line">	<span class="comment">/* We cannot bracket this with CONFIG_PCI due to mpc5xxx */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> pci_clk;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> mem_clk;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_LCD) || defined(CONFIG_VIDEO)</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> fb_base;	<span class="comment">/* Base address of framebuffer mem */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	...</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_BOARD_TYPES</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> board_type;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> have_console;	<span class="comment">/* serial_init() was called */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_PRE_CONSOLE_BUFFER</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> precon_buf_idx;	<span class="comment">/* Pre-Console buffer index */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_MODEM_SUPPORT</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> do_mdm_init;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> be_quiet;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> env_addr;	<span class="comment">/* Address  of Environment struct */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> env_valid;	<span class="comment">/* Checksum of Environment valid? */</span></span><br><span class="line"></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> ram_top;	<span class="comment">/* Top address of RAM used by U-Boot */</span></span><br><span class="line"></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> relocaddr;	<span class="comment">/* Start address of U-Boot in RAM */</span></span><br><span class="line">	<span class="type">phys_size_t</span> ram_size;	<span class="comment">/* RAM size */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> mon_len;	<span class="comment">/* monitor len */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> irq_sp;		<span class="comment">/* irq stack pointer */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> start_addr_sp;	<span class="comment">/* start_addr_stackpointer */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> reloc_off;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">global_data</span> *<span class="title">new_gd</span>;</span>	<span class="comment">/* relocated global data */</span></span><br><span class="line">	<span class="type">const</span> <span class="type">void</span> *fdt_blob;	<span class="comment">/* Our device tree, NULL if none */</span></span><br><span class="line">	<span class="type">void</span> *new_fdt;		<span class="comment">/* Relocated FDT */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> fdt_size;	<span class="comment">/* Space reserved for relocated FDT */</span></span><br><span class="line">	<span class="type">void</span> **jt;		<span class="comment">/* jump table */</span></span><br><span class="line">	<span class="type">char</span> env_buf[<span class="number">32</span>];	<span class="comment">/* buffer for getenv() before reloc. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_TRACE</span></span><br><span class="line">	<span class="type">void</span>		*trace_buff;	<span class="comment">/* The trace buffer */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">arch_global_data</span> <span class="title">arch</span>;</span>	<span class="comment">/* architecture-specific data */</span></span><br><span class="line">&#125; <span class="type">gd_t</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>file: include&#x2F;asm-generic&#x2F;global_data.h</p>
</blockquote>
<h4 id="board-init-f"><a href="#board-init-f" class="headerlink" title="board_init_f"></a>board_init_f</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">board_init_f</span><span class="params">(ulong dummy)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*Set global data pointer*/</span></span><br><span class="line">	gd = &amp;gdata;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*Setup global info*/</span></span><br><span class="line">	gd-&gt;arch.gi = &amp;ginfo;</span><br><span class="line"></span><br><span class="line">	gpio_init();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*Init uart first*/</span></span><br><span class="line">	enable_uart_clk();</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SPL_SERIAL_SUPPORT</span></span><br><span class="line">	preloader_console_init();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;ERROR EPC %x\n&quot;</span>, read_c0_errorepc());</span><br><span class="line"></span><br><span class="line">	debug(<span class="string">&quot;Timer init\n&quot;</span>);</span><br><span class="line">	timer_init();</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SPL_CORE_VOLTAGE</span></span><br><span class="line">	debug(<span class="string">&quot;Set core voltage:%dmv\n&quot;</span>, CONFIG_SPL_CORE_VOLTAGE);</span><br><span class="line">	spl_regulator_set_voltage(REGULATOR_CORE, CONFIG_SPL_CORE_VOLTAGE);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SPL_MEM_VOLTAGE</span></span><br><span class="line">	debug(<span class="string">&quot;Set mem voltage:%dmv\n&quot;</span>, CONFIG_SPL_MEM_VOLTAGE);</span><br><span class="line">	spl_regulator_set_voltage(REGULATOR_MEM, CONFIG_SPL_MEM_VOLTAGE);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	debug(<span class="string">&quot;CLK stop\n&quot;</span>);</span><br><span class="line">	clk_prepare();</span><br><span class="line"></span><br><span class="line">	debug(<span class="string">&quot;PLL init\n&quot;</span>);</span><br><span class="line">	pll_init();</span><br><span class="line"></span><br><span class="line">	debug(<span class="string">&quot;CLK init\n&quot;</span>);</span><br><span class="line">	clk_init();</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_HW_WATCHDOG</span></span><br><span class="line">	debug(<span class="string">&quot;WATCHDOG init\n&quot;</span>);</span><br><span class="line">	hw_watchdog_init();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	debug(<span class="string">&quot;SDRAM init\n&quot;</span>);</span><br><span class="line">	sdram_init();</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DDR_TEST</span></span><br><span class="line">	ddr_basic_tests();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*Clear the BSS*/</span></span><br><span class="line">	<span class="built_in">memset</span>(__bss_start, <span class="number">0</span>, (<span class="type">char</span> *)&amp;__bss_end - __bss_start);</span><br><span class="line"></span><br><span class="line">	debug(<span class="string">&quot;board_init_r\n&quot;</span>);</span><br><span class="line">	board_init_r(<span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>file: arch&#x2F;mips&#x2F;cpu&#x2F;xburst&#x2F;x1000&#x2F;soc.c</p>
</blockquote>
<ol>
<li>初始化GPIO</li>
<li>使能串口时钟，初始化串口</li>
<li>初始化timer</li>
<li>初始化时钟,配置CPU，DDR和外设的时钟大小</li>
<li>初始化看门狗</li>
<li>初始化DDR</li>
<li>清除BSS段</li>
</ol>
<h5 id="ginfo"><a href="#ginfo" class="headerlink" title="ginfo"></a>ginfo</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm-generic/global_data.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DECLARE_GLOBAL_DATA_PTR     register volatile gd_t *gd asm (<span class="string">&quot;k0&quot;</span>)</span></span><br><span class="line"></span><br><span class="line">DECLARE_GLOBAL_DATA_PTR;</span><br><span class="line"><span class="type">gd_t</span> gdata __attribute__ ((section(<span class="string">&quot;.data&quot;</span>)));</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">global_info</span> <span class="title">ginfo</span> __<span class="title">attribute__</span> ((<span class="title">section</span>(&quot;.<span class="title">data</span>&quot;))) =</span> &#123;</span><br><span class="line">    .extal      = CONFIG_SYS_EXTAL,</span><br><span class="line">    .cpufreq    = CONFIG_SYS_CPU_FREQ,</span><br><span class="line">    .ddrfreq    = CONFIG_SYS_MEM_FREQ,</span><br><span class="line">    .uart_idx   = CONFIG_SYS_UART_INDEX,</span><br><span class="line">    .baud_rate  = CONFIG_BAUDRATE,</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>系统信息的结构体 (gd 是指 Global Data, bd 是指 Board info Data) 应该存放于在 DRAM 控制器未初始化之前就能使用的空间中，比如TCSM中。</p>
<h5 id="为什么要清除BSS段？"><a href="#为什么要清除BSS段？" class="headerlink" title="为什么要清除BSS段？"></a>为什么要清除BSS段？</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Clear the BSS */</span></span><br><span class="line"><span class="built_in">memset</span>(__bss_start, <span class="number">0</span>, (<span class="type">char</span> *)&amp;__bss_end - __bss_start);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>可执行程序包括BSS段、代码段、数据段。BSS（Block Started by Symbol）通常指用来存放程序中未初始化的全局变量和静态变量的一块内存区域，特点是可读可写，在程序执行之前BSS段会自动清0。所以，未初始化的全局变量在程序执行之前已经成0</p>
</blockquote>
<p>bss段起源于unix中。变量分两种，<code>全局变量</code>和<code>局部变量</code>。局部变量是保留在栈中的，根据C语言规定，如果对局部变量不进行初始化，初始值是不确定的，在栈中位置也不固定。全局变量有专门的数据段存储，且初始化值为0，且位置是固定的。综上，数据分为俩种，<code>位置固定（全局，数据段）</code>，<code>位置不固定（局部-栈里）</code>。</p>
<p>其实，数据段里的这么多<code>全局变量都初始化为0存在目标文件中是没有必要的，增大了存储空间使用</code>。所以就把数据段里边数据，也即未初始化全局变量存放到了BSS段里边. 并未占有真正的空间。<code>当有目标文件被载入的时候，清除bss段，将全局变量清0</code>, 其实也是在为bss段分配空间.</p>
<h4 id="board-init-r"><a href="#board-init-r" class="headerlink" title="board_init_r"></a>board_init_r</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">board_init_r</span><span class="params">(<span class="type">gd_t</span> *dummy1, ulong dummy2)</span></span><br><span class="line">&#123;</span><br><span class="line">	u32 boot_device;</span><br><span class="line">	<span class="type">char</span> *cmdargs = <span class="literal">NULL</span>;</span><br><span class="line">	debug(<span class="string">&quot;&gt;&gt;spl:board_init_r()\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SYS_SPL_MALLOC_START</span></span><br><span class="line">	mem_malloc_init(CONFIG_SYS_SPL_MALLOC_START,</span><br><span class="line">			CONFIG_SYS_SPL_MALLOC_SIZE);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CONFIG_PPC</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * timer_init() does not exist on PPC systems. The timer is initialized</span></span><br><span class="line"><span class="comment">	 * and enabled (decrementer) in interrupt_init() here.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	timer_init();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SPL_BOARD_INIT</span></span><br><span class="line">	spl_board_init();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	boot_device = spl_boot_device();</span><br><span class="line">	debug(<span class="string">&quot;boot device - %d\n&quot;</span>, boot_device);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_PALLADIUM</span></span><br><span class="line">	spl_board_prepare_for_linux();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="keyword">switch</span> (boot_device) &#123;</span><br><span class="line">	<span class="keyword">case</span> BOOT_DEVICE_MMC1:</span><br><span class="line">	<span class="keyword">case</span> BOOT_DEVICE_MMC2:</span><br><span class="line">	<span class="keyword">case</span> BOOT_DEVICE_MMC2_2:</span><br><span class="line">		spl_mmc_load_image();</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		debug(<span class="string">&quot;SPL: Un-supported Boot Device\n&quot;</span>);</span><br><span class="line">		hang();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (spl_image.os) &#123;</span><br><span class="line">	<span class="keyword">case</span> IH_OS_U_BOOT:</span><br><span class="line">		debug(<span class="string">&quot;Jumping to U-Boot\n&quot;</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SPL_OS_BOOT</span></span><br><span class="line">	<span class="keyword">case</span> IH_OS_LINUX:</span><br><span class="line">		debug(<span class="string">&quot;Jumping to Linux\n&quot;</span>);</span><br><span class="line">		spl_board_prepare_for_linux();</span><br><span class="line"></span><br><span class="line">		cmdargs = cmdargs ? cmdargs : CONFIG_SYS_SPL_ARGS_ADDR;</span><br><span class="line">		cmdargs = spl_board_process_bootargs(cmdargs);</span><br><span class="line"></span><br><span class="line">		debug(<span class="string">&quot;get cmdargs: %s.\n&quot;</span>, cmdargs);</span><br><span class="line">		jump_to_image_linux((<span class="type">void</span> *)cmdargs);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		debug(<span class="string">&quot;Unsupported OS image.. Jumping nevertheless..\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	jump_to_image_no_args(&amp;spl_image);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>file: common&#x2F;spl&#x2F;spl.c</p>
</blockquote>
<ol>
<li>从存储介质（sd&#x2F;emmc）读取uboot，并跳转到uboot执行</li>
<li>在SPL运行完后，已可以直接加载kernel或相应的BIN文件执行</li>
</ol>
<h3 id="执行C代码所必需的条件或者环境？"><a href="#执行C代码所必需的条件或者环境？" class="headerlink" title="执行C代码所必需的条件或者环境？"></a>执行C代码所必需的条件或者环境？</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">la  sp, STACK_TOP   <span class="comment">// sp</span></span><br><span class="line">j   main</span><br><span class="line">nop</span><br></pre></td></tr></table></figure>
<ol>
<li>禁止看门狗，防止CPU不断的重启</li>
<li>设置堆栈</li>
</ol>
<h3 id="SPL执行阶段其栈空间的位置？"><a href="#SPL执行阶段其栈空间的位置？" class="headerlink" title="SPL执行阶段其栈空间的位置？"></a>SPL执行阶段其栈空间的位置？</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   TCSM</span><br><span class="line">+-------------+ &lt;-+ 0xb2400000</span><br><span class="line">|  .data .bss |       4K</span><br><span class="line">+----------+--+ &lt;-+ 0xb2401000</span><br><span class="line">|    stack |  |       4K</span><br><span class="line">+----------v--+ &lt;-+ 0xb2402000</span><br><span class="line">|             |</span><br><span class="line">|             |</span><br><span class="line">|             |</span><br><span class="line">|   load spl  |       24KB</span><br><span class="line">|             |</span><br><span class="line">|             |</span><br><span class="line">|             |</span><br><span class="line">|             |</span><br><span class="line">+-------------+ &lt;-+ 0xb2408000</span><br></pre></td></tr></table></figure>

<p>CPU上电后，在bootrom中执行时，由于其是固化的代码段（只读）。因此在上电初期将Data段，BSS段以及栈指定到TCSM中（一个静态RAM，CPU上电即可以使用）。bootrom中一些外围设备如sd boot的SD控制器等初始化完成后，在SD卡中将SPL加载到TCSM中，bootrom的PC跳入SPL进行执行，此时<em><strong>依然使用bootrom的栈空间</strong></em>。</p>
<h2 id="uboot"><a href="#uboot" class="headerlink" title="uboot"></a>uboot</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">u-boot.lds</span><br><span class="line">__start （start.S）</span><br><span class="line">	-&gt;board_init_f (arch/mips/lib/board.c)</span><br><span class="line">		-&gt;relocate_code (start.S)</span><br><span class="line">				-&gt;board_init_r (arch/mips/lib/board.c)</span><br></pre></td></tr></table></figure>

<h3 id="u-boot-lds"><a href="#u-boot-lds" class="headerlink" title="u-boot.lds"></a>u-boot.lds</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">OUTPUT_ARCH(mips)</span><br><span class="line">ENTRY(_start)</span><br><span class="line">SECTIONS</span><br><span class="line">&#123;</span><br><span class="line">	. = 0x00000000;</span><br><span class="line"></span><br><span class="line">	. = ALIGN(4);</span><br><span class="line">	.text : &#123;</span><br><span class="line">		*(.text*)</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">	. = ALIGN(4);</span><br><span class="line">	.data : &#123;</span><br><span class="line">		*(.data*)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	. = .;</span><br><span class="line">	_gp = ALIGN(16) + 0x7ff0;  /*32KB*/</span><br><span class="line"></span><br><span class="line">	...</span><br></pre></td></tr></table></figure>
<blockquote>
<p><a href="/downloads/uboot/u-boot.lds.txt">u-boot.lds</a></p>
</blockquote>
<h3 id="start-S-1"><a href="#start-S-1" class="headerlink" title="start.S"></a>start.S</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CONFIG_SYS_SDRAM_BASE       0x80000000 <span class="comment">/* cached (KSEG0) address */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONFIG_SYS_INIT_SP_OFFSET   0x400000</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.set noreorder</span><br><span class="line"></span><br><span class="line">.globl _start</span><br><span class="line">.text</span><br><span class="line">_start:</span><br><span class="line">/* Initialize $gp */</span><br><span class="line">bal	1f</span><br><span class="line"> nop</span><br><span class="line">.word	_gp</span><br><span class="line">1:</span><br><span class="line">lw	gp, 0(ra)</span><br><span class="line"></span><br><span class="line">/* Set up temporary stack */</span><br><span class="line">li	sp, CONFIG_SYS_SDRAM_BASE + CONFIG_SYS_INIT_SP_OFFSET</span><br><span class="line"></span><br><span class="line">la	t9, board_init_f</span><br><span class="line">jr	t9</span><br><span class="line"> nop</span><br></pre></td></tr></table></figure>
<blockquote>
<p><a href="/downloads/uboot/uboot_start.S">start.S</a></p>
</blockquote>
<ol>
<li>重新设置栈指针<code>0x80400000</code>,</li>
<li>跳转<code>board_init_f</code></li>
</ol>
<blockquote>
<p><code>CONFIG_SYS_SDRAM_BASE ＝ 0x8000 0000</code> ，是 MIPS 虚拟寻址空间中<code>kseg0</code>段的起始地址（参考《 See MIPS Run 》），它经过 CPU TLB 翻译后是 DRAM 内存的起始物理地址。</p>
</blockquote>
<h4 id="为什么不直接跳转，而使用jr"><a href="#为什么不直接跳转，而使用jr" class="headerlink" title="为什么不直接跳转，而使用jr"></a>为什么不直接跳转，而使用<code>jr</code></h4><p>这样就可以知道代码的位置,而不是标号值。</p>
<h3 id="board-c"><a href="#board-c" class="headerlink" title="board.c"></a>board.c</h3><h4 id="uboot内存布局："><a href="#uboot内存布局：" class="headerlink" title="uboot内存布局："></a>uboot内存布局：</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CONFIG_SYS_SDRAM_BASE       0x80000000 <span class="comment">/* cached (KSEG0) address */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONFIG_SYS_SDRAM_MAX_TOP    0x90000000 <span class="comment">/* don&#x27;t run into IO space */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONFIG_SYS_INIT_SP_OFFSET   0x400000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONFIG_SYS_LOAD_ADDR        0x88000000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONFIG_SYS_MEMTEST_START    0x80000000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONFIG_SYS_MEMTEST_END      0x88000000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONFIG_SYS_TEXT_BASE        0x80100000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONFIG_SYS_MONITOR_BASE     CONFIG_SYS_TEXT_BASE</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+-------------------+ &lt;-+ 0x9000 0000</span><br><span class="line">|                   |</span><br><span class="line">|                   |</span><br><span class="line">|                   |</span><br><span class="line">|     LOAD_ADDR     |</span><br><span class="line">|                   |</span><br><span class="line">|                   |</span><br><span class="line">+-------------------+ &lt;-+ 0x8800 0000</span><br><span class="line">|                   |</span><br><span class="line">|                   |</span><br><span class="line">|                   |</span><br><span class="line">|                   |</span><br><span class="line">|                   |</span><br><span class="line">|                   |</span><br><span class="line">+-------------------+ &lt;-+ 0x8040 0000</span><br><span class="line">|                   |</span><br><span class="line">|      STACK        |</span><br><span class="line">|                   |</span><br><span class="line">+-------------------+ &lt;-+ 0x8010 0000</span><br><span class="line">|     TEXT BASE     |</span><br><span class="line">+-------------------+ &lt;-+ 0x8000 0000</span><br></pre></td></tr></table></figure>

<h4 id="board-init-f-1"><a href="#board-init-f-1" class="headerlink" title="board_init_f"></a>board_init_f</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">board_init_f</span><span class="params">(ulong bootflag)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">gd_t</span> gd_data, *id;</span><br><span class="line">	<span class="type">bd_t</span> *bd;</span><br><span class="line">	<span class="type">init_fnc_t</span> **init_fnc_ptr;</span><br><span class="line">	ulong addr, addr_sp, len;</span><br><span class="line">	ulong *s;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Pointer is writable since we allocated a register for it.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	gd = &amp;gd_data;</span><br><span class="line">	<span class="comment">/* compiler optimization barrier needed for GCC &gt;= 3.4 */</span></span><br><span class="line">	__asm__ __volatile__(<span class="string">&quot;&quot;</span> : : : <span class="string">&quot;memory&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">memset</span>((<span class="type">void</span> *)gd, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="type">gd_t</span>));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (init_fnc_ptr = init_sequence; *init_fnc_ptr; ++init_fnc_ptr) &#123;</span><br><span class="line">		<span class="keyword">if</span> ((*init_fnc_ptr)() != <span class="number">0</span>)</span><br><span class="line">			hang();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Now that we have DRAM mapped and working, we can</span></span><br><span class="line"><span class="comment">	 * relocate the code and continue running from DRAM.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	addr = CONFIG_SYS_SDRAM_BASE + gd-&gt;ram_size;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SYS_SDRAM_MAX_TOP</span></span><br><span class="line">	addr = MIN(addr, CONFIG_SYS_SDRAM_MAX_TOP);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* We can reserve some RAM &quot;on top&quot; here.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* round down to next 4 kB limit.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	addr &amp;= ~(<span class="number">4096</span> - <span class="number">1</span>);	<span class="comment">//addr &amp;= ~0x0FFF 这种计算是常用的地址对齐，向下 4K 字节对齐</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Top of RAM usable for U-Boot at: %08lx\n&quot;</span>, addr);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_LCD</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_FB_ADDR</span></span><br><span class="line">	gd-&gt;fb_base = CONFIG_FB_ADDR;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	<span class="comment">/* reserve memory for LCD display (always full pages) */</span></span><br><span class="line">	addr = lcd_setmem(addr);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Reserving %ldk for LCDC at: %08lx\n&quot;</span>, len &gt;&gt; <span class="number">10</span>, addr);</span><br><span class="line">	gd-&gt;fb_base = addr;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* CONFIG_FB_ADDR */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* CONFIG_LCD */</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Reserve memory for U-Boot code, data &amp; bss</span></span><br><span class="line"><span class="comment">	 * round down to next 16 kB limit</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	len = bss_end() - CONFIG_SYS_MONITOR_BASE;</span><br><span class="line">	addr -= len;</span><br><span class="line">	addr &amp;= ~(<span class="number">16</span> * <span class="number">1024</span> - <span class="number">1</span>); <span class="comment">// 向下 64K 字节对齐</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Reserving %ldk for U-Boot at: %08lx\n&quot;</span>, len &gt;&gt; <span class="number">10</span>, addr);</span><br><span class="line"></span><br><span class="line">	 <span class="comment">/* Reserve memory for malloc() arena.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	addr_sp = addr - TOTAL_MALLOC_LEN;	<span class="comment">// 划分 malloc() 使用的空间，即所谓的堆空间</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Reserving %dk for malloc() at: %08lx\n&quot;</span>,</span><br><span class="line">			TOTAL_MALLOC_LEN &gt;&gt; <span class="number">10</span>, addr_sp);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * (permanently) allocate a Board Info struct</span></span><br><span class="line"><span class="comment">	 * and a permanent copy of the &quot;global&quot; data</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	addr_sp -= <span class="keyword">sizeof</span>(<span class="type">bd_t</span>);</span><br><span class="line">	bd = (<span class="type">bd_t</span> *)addr_sp;</span><br><span class="line">	gd-&gt;bd = bd;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Reserving %zu Bytes for Board Info at: %08lx\n&quot;</span>,</span><br><span class="line">			<span class="keyword">sizeof</span>(<span class="type">bd_t</span>), addr_sp);</span><br><span class="line"></span><br><span class="line">	addr_sp -= <span class="keyword">sizeof</span>(<span class="type">gd_t</span>);</span><br><span class="line">	id = (<span class="type">gd_t</span> *)addr_sp;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Reserving %zu Bytes for Global Data at: %08lx\n&quot;</span>,</span><br><span class="line">			<span class="keyword">sizeof</span>(<span class="type">gd_t</span>), addr_sp);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Reserve memory for boot params.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	addr_sp -= CONFIG_SYS_BOOTPARAMS_LEN;</span><br><span class="line">	bd-&gt;bi_boot_params = addr_sp;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Reserving %dk for boot params() at: %08lx\n&quot;</span>,</span><br><span class="line">			CONFIG_SYS_BOOTPARAMS_LEN &gt;&gt; <span class="number">10</span>, addr_sp);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Finally, we set up a new (bigger) stack.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Leave some safety gap for SP, force alignment on 16 byte boundary</span></span><br><span class="line"><span class="comment">	 * Clear initial stack frame</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	addr_sp -= <span class="number">16</span>;</span><br><span class="line">	addr_sp &amp;= ~<span class="number">0xF</span>; <span class="comment">// 栈空间 16 字节对齐</span></span><br><span class="line">	s = (ulong *)addr_sp;</span><br><span class="line">	*s-- = <span class="number">0</span>;</span><br><span class="line">	*s-- = <span class="number">0</span>;</span><br><span class="line">	addr_sp = (ulong)s;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Stack Pointer at: %08lx\n&quot;</span>, addr_sp);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Save local variables to board info struct</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	bd-&gt;bi_memstart	= CONFIG_SYS_SDRAM_BASE;	<span class="comment">/* start of DRAM */</span></span><br><span class="line">	bd-&gt;bi_memsize	= gd-&gt;ram_size;		<span class="comment">/* size of DRAM in bytes */</span></span><br><span class="line">	bd-&gt;bi_baudrate	= gd-&gt;baudrate;		<span class="comment">/* Console Baudrate */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将在临时栈空间中的 GD 数据拷贝入 DRAM 中，至此， BD 和 GD 都已经存在于 DRAM 中了</span></span><br><span class="line">	<span class="built_in">memcpy</span>(id, (<span class="type">void</span> *)gd, <span class="keyword">sizeof</span>(<span class="type">gd_t</span>));</span><br><span class="line"></span><br><span class="line">	relocate_code(addr_sp, id, addr);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*NOTREACHED - relocate_code() does not return*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>调用init_sequence 函数队列，对板子进行一些初始化</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * initialization sequence configurable to the user.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The requirements for any new initalization function is simple: it</span></span><br><span class="line"><span class="comment"> * receives a pointer to the &quot;global data&quot; structure as it&#x27;s only</span></span><br><span class="line"><span class="comment"> * argument, and returns an integer return code, where 0 means</span></span><br><span class="line"><span class="comment"> * &quot;continue&quot; and != 0 means &quot;fatal error, hang the system&quot;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">int</span> <span class="params">(<span class="type">init_fnc_t</span>)</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">init_fnc_t</span> *init_sequence[] = &#123;</span><br><span class="line">	 board_early_init_f,</span><br><span class="line">	 timer_init,</span><br><span class="line">	 env_init,		<span class="comment">/* initialize environment */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_INCA_IP</span></span><br><span class="line">	 incaip_set_cpuclk,	<span class="comment">/* set cpu clock according to env. variable */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	 init_baudrate,		<span class="comment">/* initialize baudrate settings */</span></span><br><span class="line">	 serial_init,		<span class="comment">/* serial communications setup */</span></span><br><span class="line">	 console_init_f,</span><br><span class="line">	 display_banner,		<span class="comment">/* say that we are here */</span></span><br><span class="line">	 checkboard,</span><br><span class="line">	 init_func_ram,</span><br><span class="line">	 <span class="literal">NULL</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>为uboot在DRAM中执行准备条件</li>
</ul>
<h4 id="relocate-code"><a href="#relocate-code" class="headerlink" title="relocate_code"></a>relocate_code</h4><p>重定位，U-boot运行后将自己的代码段,数据段,BSS 段等搬到DRAM 中的另一个位置继续运行.</p>
<p><strong>目的：</strong></p>
<ol>
<li>为kernel腾出内存的低端空间，防止kernel解压覆盖uboot。</li>
<li>对于由静态存储器（spiflash nandflash）启动，这个relocation是必须的，将代码搬到DRAM中运行</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">relocate_code(addr_sp, id, addr);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>id: 之前在 U-boot 的 1M 空间中分配的 GD 结构体的地址<br>addr: U-boot 重新定位到 DRAM 之后的代码起始地址</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"> * void relocate_code (addr_sp, gd, addr_moni)</span><br><span class="line"> *</span><br><span class="line"> * This &quot;function&quot; does not return, instead it continues in RAM</span><br><span class="line"> * after relocating the monitor code.</span><br><span class="line"> *</span><br><span class="line"> * a0 = addr_sp</span><br><span class="line"> * a1 = gd</span><br><span class="line"> * a2 = destination address</span><br><span class="line"> */</span><br><span class="line">	.globl	relocate_code</span><br><span class="line">	.ent	relocate_code</span><br><span class="line">relocate_code:</span><br><span class="line">	move	sp, a0			# set new stack pointer</span><br><span class="line"></span><br><span class="line">	li	t0, CONFIG_SYS_MONITOR_BASE</span><br><span class="line">	sub	t6, a2, t0		# t6 &lt;-- relocation offset</span><br><span class="line"></span><br><span class="line">	la	t3, in_ram</span><br><span class="line">	lw	t2, -12(t3)		# t2 &lt;-- __image_copy_end</span><br><span class="line">	move	t1, a2</span><br><span class="line"></span><br><span class="line">	add	gp, t6			# adjust gp</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * t0 = source address</span><br><span class="line">	 * t1 = target address</span><br><span class="line">	 * t2 = source end address</span><br><span class="line">	 */</span><br><span class="line">1:</span><br><span class="line">	lw	t3, 0(t0)</span><br><span class="line">	sw	t3, 0(t1)</span><br><span class="line">	addu	t0, 4</span><br><span class="line">	blt	t0, t2, 1b</span><br><span class="line">	 addu	t1, 4</span><br><span class="line"></span><br><span class="line">	/* If caches were enabled, we would have to flush them here. */</span><br><span class="line"></span><br><span class="line">	/* flush d-cache */</span><br><span class="line">	li	t0, KSEG0</span><br><span class="line">	or	t1, t0, CONFIG_SYS_DCACHE_SIZE</span><br><span class="line">2:</span><br><span class="line">	cache	INDEX_WRITEBACK_INV_D, 0(t0)</span><br><span class="line">	bne	t0, t1, 2b</span><br><span class="line">	 addi	t0, CONFIG_SYS_CACHELINE_SIZE</span><br><span class="line"></span><br><span class="line">	sync</span><br><span class="line"></span><br><span class="line">	/* flush i-cache */</span><br><span class="line">	li	t0, KSEG0</span><br><span class="line">	or	t1, t0, CONFIG_SYS_ICACHE_SIZE</span><br><span class="line">3:</span><br><span class="line">	cache	INDEX_INVALIDATE_I, 0(t0)</span><br><span class="line">	bne	t0, t1, 3b</span><br><span class="line">	 addi	t0, CONFIG_SYS_CACHELINE_SIZE</span><br><span class="line"></span><br><span class="line">	/* Invalidate BTB */</span><br><span class="line">	mfc0	t0, CP0_CONFIG, 7</span><br><span class="line">	nop</span><br><span class="line">	ori	t0, 2</span><br><span class="line">	mtc0	t0, CP0_CONFIG, 7</span><br><span class="line">	nop</span><br><span class="line"></span><br><span class="line">	/* Jump to where we&#x27;ve relocated ourselves */</span><br><span class="line">	addi	t0, a2, in_ram - _start</span><br><span class="line">	jr	t0</span><br><span class="line">	 nop</span><br><span class="line"></span><br><span class="line">	.word	__rel_dyn_end</span><br><span class="line">	.word	__rel_dyn_start</span><br><span class="line">	.word	__image_copy_end</span><br><span class="line">	.word	_GLOBAL_OFFSET_TABLE_</span><br><span class="line">	.word	num_got_entries</span><br><span class="line"></span><br><span class="line">in_ram:</span><br><span class="line">	/*</span><br><span class="line">	 * Now we want to update GOT.</span><br><span class="line">	 *</span><br><span class="line">	 * GOT[0] is reserved. GOT[1] is also reserved for the dynamic object</span><br><span class="line">	 * generated by GNU ld. Skip these reserved entries from relocation.</span><br><span class="line">	 */</span><br><span class="line">	lw	t3, -4(t0)		# t3 &lt;-- num_got_entries</span><br><span class="line">	lw	t4, -8(t0)		# t4 &lt;-- _GLOBAL_OFFSET_TABLE_</span><br><span class="line">	add	t4, t6			# t4 now holds relocated _G_O_T_</span><br><span class="line">	addi	t4, t4, 8		# skipping first two entries</span><br><span class="line">	li	t2, 2</span><br><span class="line">1:</span><br><span class="line">	lw	t1, 0(t4)</span><br><span class="line">	beqz	t1, 2f</span><br><span class="line">	 add	t1, t6</span><br><span class="line">	sw	t1, 0(t4)</span><br><span class="line">2:</span><br><span class="line">	addi	t2, 1</span><br><span class="line">	blt	t2, t3, 1b</span><br><span class="line">	 addi	t4, 4</span><br><span class="line"></span><br><span class="line">	/* Update dynamic relocations */</span><br><span class="line">	lw	t1, -16(t0)		# t1 &lt;-- __rel_dyn_start</span><br><span class="line">	lw	t2, -20(t0)		# t2 &lt;-- __rel_dyn_end</span><br><span class="line"></span><br><span class="line">	b	2f			# skip first reserved entry</span><br><span class="line">	 addi	t1, 8</span><br><span class="line"></span><br><span class="line">1:</span><br><span class="line">	lw	t3, -4(t1)		# t3 &lt;-- relocation info</span><br><span class="line"></span><br><span class="line">	sub	t3, 3</span><br><span class="line">	bnez	t3, 2f			# skip non R_MIPS_REL32 entries</span><br><span class="line">	 nop</span><br><span class="line"></span><br><span class="line">	lw	t3, -8(t1)		# t3 &lt;-- location to fix up in FLASH</span><br><span class="line"></span><br><span class="line">	lw	t4, 0(t3)		# t4 &lt;-- original pointer</span><br><span class="line">	add	t4, t6			# t4 &lt;-- adjusted pointer</span><br><span class="line"></span><br><span class="line">	add	t3, t6			# t3 &lt;-- location to fix up in RAM</span><br><span class="line">	sw	t4, 0(t3)</span><br><span class="line"></span><br><span class="line">2:</span><br><span class="line">	blt	t1, t2, 1b</span><br><span class="line">	 addi	t1, 8			# each rel.dyn entry is 8 bytes</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * Clear BSS</span><br><span class="line">	 *</span><br><span class="line">	 * GOT is now relocated. Thus __bss_start and __bss_end can be</span><br><span class="line">	 * accessed directly via $gp.</span><br><span class="line">	 */</span><br><span class="line">	la	t1, __bss_start		# t1 &lt;-- __bss_start</span><br><span class="line">	la	t2, __bss_end		# t2 &lt;-- __bss_end</span><br><span class="line"></span><br><span class="line">1:</span><br><span class="line">	sw	zero, 0(t1)</span><br><span class="line">	blt	t1, t2, 1b</span><br><span class="line">	 addi	t1, 4</span><br><span class="line"></span><br><span class="line">	move	a0, a1			# a0 &lt;-- gd</span><br><span class="line">	la	t9, board_init_r</span><br><span class="line">	jr	t9</span><br><span class="line">	 move	a1, a2</span><br><span class="line"></span><br><span class="line">	.end	relocate_code</span><br></pre></td></tr></table></figure>

<ol>
<li>移动gp指针</li>
<li>复制代码到RAM中</li>
<li>刷新一下cache</li>
<li>跳到RAM代码当中去（in_ram）,in_ram的主要工作是：更新GOT;清空BSS段；最后跳到<code>board_init_r</code>。</li>
</ol>
<h5 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h5><ol>
<li>如何对函数进行寻址调用</li>
<li>如何对全局变量进行寻址操作（读写）</li>
<li>对于全局指针变量中存储的其他变量或函数地址在relocation之后如何操作</li>
</ol>
<h5 id="uboot-GOT"><a href="#uboot-GOT" class="headerlink" title="uboot GOT"></a>uboot GOT</h5><blockquote>
<p>GOTs(global offset tables):是uboot能跳转到不同空间运行的原理.</p>
</blockquote>
<p>一个完整可运行的bin文件，link时指定的链接地址，load时的加载地址，运行时的运行地址，这3个地址应该是一致的。但是<code>relocation</code>后运行地址不同于加载地址，特别是链接地址，uboot任何进行函数跳转？？？</p>
<p>compiler在cc时加入<code>-fpic</code>或<code>-fpie</code>选项，会在目标文件中生成GOT（global offset table），将本文件中需要relocate的值存放在GOT中，函数尾部的Label来存储GOT的offset以及其中变量的offset，变量寻址首先根据尾部Label相对寻址找到GOT地址，以及变量地址在GOT中的位置，从而确定变量地址，这样对于目标文件统一修改GOT中的值，就修改了变量地址的offset，完成了relocation。</p>
<p>ld时加入-pie选项，就会将GOT并入到<code>rel.dyn</code>段中，uboot在relocate_code中统一根据rel.dyn段修改需要relocation的数值</p>
<h5 id="划分RAM"><a href="#划分RAM" class="headerlink" title="划分RAM"></a>划分RAM</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+------------------+</span><br><span class="line">|                  |</span><br><span class="line">|    boot params   |</span><br><span class="line">+------------------+</span><br><span class="line">|                  |</span><br><span class="line">|    Global Data   |</span><br><span class="line">+------------------+</span><br><span class="line">|                  |</span><br><span class="line">|    Board Info    |</span><br><span class="line">+------------------+</span><br><span class="line">|                  |</span><br><span class="line">|   mallco(+env)   |</span><br><span class="line">+------------------+</span><br><span class="line">|                  |</span><br><span class="line">|   uboot code     |</span><br><span class="line">|                  |</span><br><span class="line">|                  |</span><br><span class="line">|                  |</span><br><span class="line">+------------------+</span><br></pre></td></tr></table></figure>

<h4 id="board-init-r-1"><a href="#board-init-r-1" class="headerlink" title="board_init_r"></a>board_init_r</h4><blockquote>
<p>This is the next part if the initialization sequence: we are now running from RAM and have a “normal” C environment, i. e. global data can be written, BSS has been cleared, the stack size in not that critical any more, etc.</p>
</blockquote>
<p>此时已在DRAM中运行。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">board_init_r</span><span class="params">(<span class="type">gd_t</span> *id, ulong dest_addr)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CONFIG_SYS_NO_FLASH</span></span><br><span class="line">	ulong size;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="type">bd_t</span> *bd;</span><br><span class="line"></span><br><span class="line">	gd = id;</span><br><span class="line">	gd-&gt;flags |= GD_FLG_RELOC;	<span class="comment">/* tell others: relocation done */</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Now running in RAM - U-Boot at: %08lx\n&quot;</span>, dest_addr);</span><br><span class="line"></span><br><span class="line">	gd-&gt;relocaddr = dest_addr;</span><br><span class="line">	gd-&gt;reloc_off = dest_addr - CONFIG_SYS_MONITOR_BASE;</span><br><span class="line"></span><br><span class="line">	monitor_flash_len = image_copy_end() - dest_addr;</span><br><span class="line"></span><br><span class="line">	board_early_init_r();</span><br><span class="line"></span><br><span class="line">	serial_initialize();</span><br><span class="line"></span><br><span class="line">	bd = gd-&gt;bd;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* The Malloc area is immediately below the monitor copy in DRAM */</span></span><br><span class="line">	mem_malloc_init(CONFIG_SYS_MONITOR_BASE + gd-&gt;reloc_off -</span><br><span class="line">			TOTAL_MALLOC_LEN, TOTAL_MALLOC_LEN);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CONFIG_SYS_NO_FLASH</span></span><br><span class="line">	<span class="comment">/* configure available FLASH banks */</span></span><br><span class="line">	size = flash_init();</span><br><span class="line">	display_flash_config(size);</span><br><span class="line">	bd-&gt;bi_flashstart = CONFIG_SYS_FLASH_BASE;</span><br><span class="line">	bd-&gt;bi_flashsize = size;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> CONFIG_SYS_MONITOR_BASE == CONFIG_SYS_FLASH_BASE</span></span><br><span class="line">	bd-&gt;bi_flashoffset = monitor_flash_len;	<span class="comment">/* reserved area for U-Boot */</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	bd-&gt;bi_flashoffset = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	bd-&gt;bi_flashstart = <span class="number">0</span>;</span><br><span class="line">	bd-&gt;bi_flashsize = <span class="number">0</span>;</span><br><span class="line">	bd-&gt;bi_flashoffset = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	...</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_GENERIC_MMC</span></span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;MMC:   &quot;</span>);</span><br><span class="line">	mmc_initialize(bd);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* relocate environment function pointers etc. */</span></span><br><span class="line">	env_relocate();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*leave this here (after malloc(), environment and PCI are working)*/</span></span><br><span class="line">	<span class="comment">/* Initialize stdio devices */</span></span><br><span class="line">	stdio_init();</span><br><span class="line"></span><br><span class="line">	jumptable_init();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Initialize the console (after the relocation and devices init) */</span></span><br><span class="line">	console_init_r();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Initialize from environment */</span></span><br><span class="line">	load_addr = getenv_ulong(<span class="string">&quot;loadaddr&quot;</span>, <span class="number">16</span>, load_addr);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_USB_GADGET</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">board_usb_init</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">	board_usb_init();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_MISC_INIT_R)</span></span><br><span class="line">	<span class="comment">/* miscellaneous platform dependent initialisations */</span></span><br><span class="line">	misc_init_r();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_BITBANGMII</span></span><br><span class="line">	bb_miiphy_init();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_CMD_NET)</span></span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;Net:   &quot;</span>);</span><br><span class="line">	eth_initialize(gd-&gt;bd);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* main_loop() can return to retry autoboot, if so just run it again. */</span></span><br><span class="line">	<span class="keyword">for</span> (;;)</span><br><span class="line">		main_loop();</span><br><span class="line">	<span class="comment">/*NOTREACHED - no way out of command loop except booting*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>初始化串口</li>
<li>初始化系统内存分配函数</li>
<li>如果使用MMC存储介质，初始化MMC设备</li>
<li>初始化环境变量的指针,将 env_ptr 指针及其指向的地址初始化，用来存放环境变量结构体，然后将 flash 中的环境变量拷贝到内存中。</li>
<li>初始化sdio设备</li>
<li>初始化网络设备</li>
<li>进去命令循环（即整个boot的工作循环），接受用户从串口输入的命令，然后进行相应的工作</li>
</ol>
<h3 id="main-loop"><a href="#main-loop" class="headerlink" title="main_loop"></a>main_loop</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">main_loop</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">	bootstage_mark_name(BOOTSTAGE_ID_MAIN_LOOP, <span class="string">&quot;main_loop&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*刷新LCD*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_UPDATE_TFTP)</span></span><br><span class="line">	update_tftp(<span class="number">0UL</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* CONFIG_UPDATE_TFTP */</span></span></span><br><span class="line"><span class="comment">/*从环境变量中取得bootdelay 内核等待延时*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_BOOTDELAY</span></span><br><span class="line">	process_boot_delay();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Main Loop for Monitor Command Processing</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		len = readline (CONFIG_SYS_PROMPT);</span><br><span class="line"></span><br><span class="line">		flag = <span class="number">0</span>;	<span class="comment">/* assume no special flags for now */</span></span><br><span class="line">		<span class="keyword">if</span> (len &gt; <span class="number">0</span>)</span><br><span class="line">			<span class="built_in">strcpy</span> (lastcommand, console_buffer);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (len == <span class="number">0</span>)</span><br><span class="line">			flag |= CMD_FLAG_REPEAT;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (len == <span class="number">-1</span>)</span><br><span class="line">			<span class="built_in">puts</span> (<span class="string">&quot;&lt;INTERRUPT&gt;\n&quot;</span>);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			rc = run_command(lastcommand, flag); <span class="comment">//执行命令</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (rc &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="comment">/* invalid command or not repeatable, forget it */</span></span><br><span class="line">			lastcommand[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>file:common&#x2F;main.c</p>
</blockquote>
<h3 id="do-bootm"><a href="#do-bootm" class="headerlink" title="do_bootm"></a>do_bootm</h3><p>将内核解压缩，然后调用do_bootm_linux引导内核</p>
<h3 id="do-bootm-linux"><a href="#do-bootm-linux" class="headerlink" title="do_bootm_linux"></a>do_bootm_linux</h3><p>启动内核</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><span class="exturl" data-url="aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2t5Zmx5aW5nMjAxMi9hcnRpY2xlL2RldGFpbHMvMzc2NjAyNjU=">uboot的relocation原理详细分析<i class="fa fa-external-link-alt"></i></span></li>
</ol>
]]></content>
      <categories>
        <category>uboot</category>
      </categories>
      <tags>
        <tag>uboot</tag>
      </tags>
  </entry>
  <entry>
    <title>uboot中的内存布局</title>
    <url>/post/3f3c28cc.html</url>
    <content><![CDATA[<p>arm64平台中spl+uboot的内存布局，比如代码段、堆栈等的位置。</p>
<ul>
<li>spl的大小限制，与堆栈大小的关系？</li>
<li>代码重定位？</li>
</ul>
<span id="more"></span>

<p>环境：</p>
<ul>
<li>CPU： <code>arm64</code>（cortex-a53）</li>
<li>uboot版本： <code>U-Boot 2021.01</code></li>
</ul>
<h2 id="SPL"><a href="#SPL" class="headerlink" title="SPL"></a>SPL</h2><p>在uboot代码中，通过宏<code>CONFIG_SPL_XXX</code>来区分SPL。</p>
<h3 id="SRAM空间"><a href="#SRAM空间" class="headerlink" title="SRAM空间"></a>SRAM空间</h3><p>SRAM是spl代码段、数据段的存储空间和运行空间，也就是所有的可操作的地址范围均在SRAM内，spl直接访问总线地址（物理地址）。<br>总大小<code>256KB</code>，地址范围<code>0xFF78 0000～0xFF7B FFFF</code><br>bootrom将spl外部存储介质拷贝到SRAM中特定地址（SPL代码段基址），并从该该地址跳转执行spl代码。</p>
<h3 id="自定义参数配置"><a href="#自定义参数配置" class="headerlink" title="自定义参数配置"></a>自定义参数配置</h3><p>spl编译生成后的大小限制，在menuconfig中进行配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CONFIG_SPL_SIZE_LIMIT=0x20000       #128KB</span><br><span class="line"></span><br><span class="line">CONFIG_SPL_TEXT_BASE=0xFF781000</span><br><span class="line"></span><br><span class="line">CONFIG_SPL_SYS_MALLOC_F_LEN=0x3000  #12KB</span><br></pre></td></tr></table></figure>
<p>也就是说当前uboot中编译生成的spl大小不能超过128KB，如果超过时uboot会在编译过程中警告提示。</p>
<ul>
<li><code>CONFIG_SPL_TEXT_BASE</code>: SPL中定义代码段基址</li>
<li><code>CONFIG_SPL_SIZE_LIMIT</code>: SPL中定义镜像大小的最大值</li>
<li><code>CONFIG_SPL_SYS_MALLOC_F_LEN</code>： SPL中定义堆栈空间的大小</li>
</ul>
<p>代码段与栈大小配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* Physical memory map */</span><br><span class="line">#define CONFIG_IRAM_BASE            0xFF780000                    #spl代码中无用，只在当前配置文件中使用</span><br><span class="line"></span><br><span class="line">#define CONFIG_SPL_MAX_SIZE         (SZ_128K - SZ_16K - SZ_4K)    #减4K ???，应该是想除去bootrom预留的4K</span><br><span class="line">#define SPL_STACK_BSS_ADDRESS       (CONFIG_IRAM_BASE + SZ_128K )</span><br><span class="line">#define CONFIG_SPL_BSS_MAX_SIZE     SZ_32K</span><br><span class="line"></span><br><span class="line">#define CONFIG_SPL_STACK            (SPL_STACK_BSS_ADDRESS-16)    #栈地址减16(0x10)？？？</span><br><span class="line"></span><br><span class="line">/*  BSS setup */</span><br><span class="line">#define CONFIG_SPL_BSS_START_ADDR   SPL_STACK_BSS_ADDRESS</span><br></pre></td></tr></table></figure>
<blockquote>
<p>uboot中的配置文件（include&#x2F;configs&#x2F;目录下）定义</p>
</blockquote>
<ul>
<li><code>CONFIG_SPL_MAX_SIZE</code>: spl镜像的最大大小，包括text, data, rodata, and linker lists sections，但是不包括BBS段</li>
<li><code>CONFIG_SPL_STACK</code>: spl栈的起始地址，<strong>栈的增长方向：由高地址到低地址</strong></li>
<li><code>CONFIG_SPL_BSS_START_ADDR</code>: spl的BBS链接地址</li>
<li><code>CONFIG_SPL_BSS_MAX_SIZE</code>: 分配给spl BBS的内存最大值</li>
</ul>
<h3 id="未使用参数配置"><a href="#未使用参数配置" class="headerlink" title="未使用参数配置"></a>未使用参数配置</h3><ul>
<li><code>CONFIG_SPL_MAX_FOOTPRINT</code>： 分配给SPL的最大内存大小，包括BSS。SPL链接器检查从<code>_start</code>到<code>__bss_end</code>使用的实际内存不超过它。<code>CONFIG_SPL_MAX_FOOTPRINT</code>和<code>CONFIG_SPL_BSS_MAX_SIZE</code>不能同时定义。</li>
<li><code>CONFIG_SYS_SPL_MALLOC_START</code>： SPL中使用的<code>malloc池</code>的起始地址。 当设置此选项时，在SPL中使用完整的malloc，在spl_init()函数之前，因为由它配置malloc池，如果定义了CONFIG_SYS_MALLOC_F，则可以使用简单的malloc()。</li>
<li><code>CONFIG_SYS_SPL_MALLOC_SIZE</code>： 配置SPL中malloc池的大小。</li>
</ul>
<h3 id="u-boot-spl-lds"><a href="#u-boot-spl-lds" class="headerlink" title="u-boot-spl.lds"></a>u-boot-spl.lds</h3><p>通用链接文件：<code>SPL_LDSCRIPT=arch/arm/cpu/u-boot-spl.lds</code></p>
<p>链接文件的处理命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">aarch64-none-linux-gnu-gcc -E -Wp,-MD,spl/.u-boot-spl.lds.d -D__KERNEL__ -D__UBOOT__  -DCONFIG_SPL_BUILD  -D__ARM__</span><br><span class="line">-mstrict-align  -ffunction-sections -fdata-sections -fno-common -ffixed-r9</span><br><span class="line">-fno-common -ffixed-x18 -pipe -march=armv8-a -D__LINUX_ARM_ARCH__=8</span><br><span class="line">-I./arch/arm/mach-vanxum/include -Ispl/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h</span><br><span class="line">-nostdinc -isystem /home/xx/tools/prebuilts/aarch64-none-linux-gnu/bin/../lib/gcc/aarch64-none-linux-gnu/10.2.1/include</span><br><span class="line">-include ./include/u-boot/u-boot.lds.h -include ./include/config.h -DCPUDIR=arch/arm/cpu/armv8</span><br><span class="line">-DIMAGE_MAX_SIZE=&quot;(SZ_64K + SZ_32K + SZ_16K -SZ_4K)&quot; -DIMAGE_TEXT_BASE=0xFF781000</span><br><span class="line">-ansi -D__ASSEMBLY__ -x assembler-with-cpp -std=c99 -P</span><br><span class="line">-o spl/u-boot-spl.lds arch/arm/cpu/armv8/u-boot-spl.lds</span><br></pre></td></tr></table></figure>

<p>编译后生产当前CPU的lds链接文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MEMORY &#123; .sram : ORIGIN = 0xFF781000,</span><br><span class="line">  LENGTH = (0x00010000 + 0x00008000 + 0x00004000 -0x00001000) &#125;</span><br><span class="line">MEMORY &#123; .sdram : ORIGIN = (0xFF780000 + 0x00020000 ),</span><br><span class="line">  LENGTH = 0x00008000 &#125;</span><br><span class="line">OUTPUT_FORMAT(&quot;elf64-littleaarch64&quot;, &quot;elf64-littleaarch64&quot;, &quot;elf64-littleaarch64&quot;)</span><br><span class="line">OUTPUT_ARCH(aarch64)</span><br><span class="line">ENTRY(_start)</span><br><span class="line">SECTIONS</span><br><span class="line">&#123;</span><br><span class="line"> .text : &#123;</span><br><span class="line">  . = ALIGN(8);</span><br><span class="line">  *(.__image_copy_start)</span><br><span class="line">  arch/arm/cpu/armv8/start.o (.text*)</span><br><span class="line">  *(.text*)</span><br><span class="line"> &#125; &gt;.sram</span><br><span class="line"> .rodata : &#123;</span><br><span class="line">  . = ALIGN(8);</span><br><span class="line">  *(SORT_BY_ALIGNMENT(SORT_BY_NAME(.rodata*)))</span><br><span class="line"> &#125; &gt;.sram</span><br><span class="line"> .data : &#123;</span><br><span class="line">  . = ALIGN(8);</span><br><span class="line">  *(.data*)</span><br><span class="line"> &#125; &gt;.sram</span><br><span class="line"> .u_boot_list : &#123;</span><br><span class="line">  . = ALIGN(8);</span><br><span class="line">  KEEP(*(SORT(.u_boot_list*)));</span><br><span class="line"> &#125; &gt;.sram</span><br><span class="line"> .image_copy_end : &#123;</span><br><span class="line">  . = ALIGN(8);</span><br><span class="line">  *(.__image_copy_end)</span><br><span class="line"> &#125; &gt;.sram</span><br><span class="line"> .end : &#123;</span><br><span class="line">  . = ALIGN(8);</span><br><span class="line">  *(.__end)</span><br><span class="line"> &#125; &gt;.sram</span><br><span class="line"> _image_binary_end = .;</span><br><span class="line"> .bss_start (NOLOAD) : &#123;</span><br><span class="line">  . = ALIGN(8);</span><br><span class="line">  KEEP(*(.__bss_start));</span><br><span class="line"> &#125; &gt;.sdram</span><br><span class="line"> .bss (NOLOAD) : &#123;</span><br><span class="line">  *(.bss*)</span><br><span class="line">   . = ALIGN(8);</span><br><span class="line"> &#125; &gt;.sdram</span><br><span class="line"> .bss_end (NOLOAD) : &#123;</span><br><span class="line">  KEEP(*(.__bss_end));</span><br><span class="line"> &#125; &gt;.sdram</span><br><span class="line"> /DISCARD/ : &#123; *(.dynsym) &#125;</span><br><span class="line"> /DISCARD/ : &#123; *(.dynstr*) &#125;</span><br><span class="line"> /DISCARD/ : &#123; *(.dynamic*) &#125;</span><br><span class="line"> /DISCARD/ : &#123; *(.plt*) &#125;</span><br><span class="line"> /DISCARD/ : &#123; *(.interp*) &#125;</span><br><span class="line"> /DISCARD/ : &#123; *(.gnu*) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="SARM的内存布局"><a href="#SARM的内存布局" class="headerlink" title="SARM的内存布局"></a>SARM的内存布局</h3><p><img data-src="/images/2022/08/uboot_spl_sram_%E5%B8%83%E5%B1%80.png" alt="uboot SPL SRAM 布局"></p>
<blockquote>
<p>空间大了，分配起来就是任性！<br><del>为了使SPL可用镜像尽可能的大，spl可以利用bootrom的堆栈空间，这样编译生成的spl镜像最大就可以到188KB，将BBS和栈空间移至最顶部bootrom使用的bbs和栈空间处。</del><br>SRAM的后半部分空间（0xff7a2000～0Xff7bffff）,大小0x1E000&#x3D;<code>120KB</code>，是为ATF阶段的bl31运行预留，这样上图中配置的32KB大小的BBS段，使用可用空间也只有<code>8KB</code>。</p>
</blockquote>
<ul>
<li>BBS段定义的过大，实际<code>2K</code>应该就差不多了。</li>
<li>栈空间只指定了起始地址，为啥没有定义其大小？？</li>
<li>malloc的地址范围？？？—— 当前SPL中没有配置这部分空间，因此也就无法使用malloc。</li>
</ul>
<p>实际spl中各段的地址与大小：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$aarch64-none-linux-gnu-readelf -S spl/u-boot-spl</span><br><span class="line">There are 21 section headers, starting at offset 0x1e7790:</span><br><span class="line"></span><br><span class="line">Section Headers:</span><br><span class="line">  [Nr] Name              Type             Address           Offset</span><br><span class="line">       Size              EntSize          Flags  Link  Info  Align</span><br><span class="line">  [ 0]                   NULL             0000000000000000  00000000</span><br><span class="line">       0000000000000000  0000000000000000           0     0     0</span><br><span class="line">  [ 1] .text             PROGBITS         00000000ff781000  00001000</span><br><span class="line">       00000000000153b4  0000000000000000  AX       0     0     8</span><br><span class="line">  [ 2] .rodata           PROGBITS         00000000ff7963b8  000163b8</span><br><span class="line">       0000000000003f46  0000000000000000   A       0     0     8</span><br><span class="line">  [ 3] .data             PROGBITS         00000000ff79a300  0001a300</span><br><span class="line">       000000000000031c  0000000000000000  WA       0     0     8</span><br><span class="line">  [ 4] .u_boot_list      PROGBITS         00000000ff79a620  0001a620</span><br><span class="line">       0000000000000fd8  0000000000000000  WA       0     0     8</span><br><span class="line">  [ 5] .image_copy_end   PROGBITS         00000000ff79b5f8  0001b5f8</span><br><span class="line">       0000000000000000  0000000000000000   W       0     0     1</span><br><span class="line">  [ 6] .end              PROGBITS         00000000ff79b5f8  0001b5f8</span><br><span class="line">       0000000000000000  0000000000000000  WA       0     0     1</span><br><span class="line">  [ 7] .bss_start        NOBITS           00000000ff7a0000  00020000</span><br><span class="line">       0000000000000000  0000000000000000  WA       0     0     1</span><br><span class="line">  [ 8] .bss              NOBITS           00000000ff7a0000  00020000</span><br><span class="line">       00000000000003c0  0000000000000000  WA       0     0     64</span><br><span class="line">  [ 9] .bss_end          NOBITS           00000000ff7a03c0  00020000</span><br><span class="line">       0000000000000000  0000000000000000  WA       0     0     1</span><br><span class="line">  [10] .debug_line       PROGBITS         0000000000000000  0001b5f8</span><br><span class="line">       0000000000037991  0000000000000000           0     0     1</span><br><span class="line">  [11] .debug_info       PROGBITS         0000000000000000  00052f89</span><br><span class="line">       00000000000acbaa  0000000000000000           0     0     1</span><br><span class="line">  [12] .debug_abbrev     PROGBITS         0000000000000000  000ffb33</span><br><span class="line">       0000000000019c78  0000000000000000           0     0     1</span><br><span class="line">  [13] .debug_aranges    PROGBITS         0000000000000000  001197b0</span><br><span class="line">       0000000000006580  0000000000000000           0     0     16</span><br><span class="line">  [14] .debug_str        PROGBITS         0000000000000000  0011fd30</span><br><span class="line">       000000000001021b  0000000000000001  MS       0     0     1</span><br><span class="line">  [15] .comment          PROGBITS         0000000000000000  0012ff4b</span><br><span class="line">       000000000000005d  0000000000000001  MS       0     0     1</span><br><span class="line">  [16] .debug_loc        PROGBITS         0000000000000000  0012ffa8</span><br><span class="line">       000000000009a9f1  0000000000000000           0     0     1</span><br><span class="line">  [17] .debug_ranges     PROGBITS         0000000000000000  001ca9a0</span><br><span class="line">       0000000000010850  0000000000000000           0     0     16</span><br><span class="line">  [18] .symtab           SYMTAB           0000000000000000  001db1f0</span><br><span class="line">       0000000000008eb0  0000000000000018          19   1051     8</span><br><span class="line">  [19] .strtab           STRTAB           0000000000000000  001e40a0</span><br><span class="line">       000000000000361d  0000000000000000           0     0     1</span><br><span class="line">  [20] .shstrtab         STRTAB           0000000000000000  001e76bd</span><br><span class="line">       00000000000000cc  0000000000000000           0     0     1</span><br><span class="line">Key to Flags:</span><br><span class="line">  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),</span><br><span class="line">  L (link order), O (extra OS processing required), G (group), T (TLS),</span><br><span class="line">  C (compressed), x (unknown), o (OS specific), E (exclude),</span><br><span class="line">  p (processor specific)</span><br></pre></td></tr></table></figure>


<h3 id="实际BBS段大小"><a href="#实际BBS段大小" class="headerlink" title="实际BBS段大小"></a>实际BBS段大小</h3><p>在spl的配置中，我们已经定义了BBS段的最大值，而是实际编译后的spl镜像中bbs段的实际大小是多少？</p>
<p>将spl镜像进行反汇编：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">aarch64-none-linux-gnu-objdump -D spl/u-boot-spl &gt; a.s</span></span><br></pre></td></tr></table></figure>

<p>清除BBS段内存：</p>
<figure class="highlight arm"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Clear BSS section</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="keyword">ldr</span> x0, <span class="symbol">=__bss_start</span>        <span class="comment">/* this is auto-relocated! */</span></span><br><span class="line">    <span class="keyword">ldr</span> x1, <span class="symbol">=__bss_end</span>          <span class="comment">/* this is auto-relocated! */</span></span><br><span class="line"><span class="symbol">clear_loop:</span></span><br><span class="line">    <span class="keyword">str</span> xzr, [x0], <span class="number">#8</span></span><br><span class="line">    <span class="keyword">cmp</span> x0, x1</span><br><span class="line">    b.lo    clear_loop</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* call board_init_r(gd_t *id, ulong dest_addr) */</span></span><br><span class="line">    <span class="keyword">mov</span> x0, x18             <span class="comment">/* gd_t */</span></span><br><span class="line">    <span class="keyword">ldr</span> x1, [x18, <span class="symbol">#GD_RELOCADDR</span>]    <span class="comment">/* dest_addr */</span></span><br><span class="line">    <span class="keyword">b</span>   board_init_r            <span class="comment">/* PC relative jump */</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>file: &#x2F;arch&#x2F;arm&#x2F;lib&#x2F;crt0_64.S</p>
</blockquote>
<p>其中<code>__bss_start</code>和<code>__bss_end</code>表示BBS段的起始和结束地址，这两个地址在lds链接文件中定义，实际编译时进行赋值。</p>
<p>反汇编后的实际结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00000000ff781708 &lt;_main&gt;:</span><br><span class="line">    ff781708:   58000300    ldr x0, ff781768 &lt;clear_loop+0x18&gt;</span><br><span class="line">    ff78170c:   927cec1f    and sp, x0, #0xfffffffffffffff0</span><br><span class="line">    ff781710:   910003e0    mov x0, sp</span><br><span class="line">    ...</span><br><span class="line">    ff781744:   9100001f    mov sp, x0</span><br><span class="line">    ff781748:   58000140    ldr x0, ff781770 &lt;clear_loop+0x20&gt;    #ldr x0, =__bss_start</span><br><span class="line">    ff78174c:   58000161    ldr x1, ff781778 &lt;clear_loop+0x28&gt;    #ldr x1, =__bss_end</span><br><span class="line"></span><br><span class="line">00000000ff781750 &lt;clear_loop&gt;:</span><br><span class="line">    ...</span><br><span class="line">    ff781768:   ff79fff0    .inst   0xff79fff0 ; undefined        #SPL栈的起始地址</span><br><span class="line">    ff78176c:   00000000    udf #0</span><br><span class="line">    ff781770:   ff7a0000    .inst   0xff7a0000 ; undefined        #BBS段的起始地址</span><br><span class="line">    ff781774:   00000000    udf #0</span><br><span class="line">    ff781778:   ff7a03c0    .inst   0xff7a03c0 ; undefined        #BBS段的结束地址</span><br><span class="line">    ff78177c:   00000000    udf #0</span><br></pre></td></tr></table></figure>
<p>BBS段的实际大小：0xff7a03c0 - 0xff7a0000 &#x3D; 0x3c0 &#x3D; <code>960Byte</code></p>
<ul>
<li>bbs段的大小检测：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#if defined(CONFIG_SPL_BSS_MAX_SIZE)</span><br><span class="line">ASSERT(__bss_end - __bss_start &lt;= (CONFIG_SPL_BSS_MAX_SIZE), \</span><br><span class="line">    &quot;SPL image BSS too big&quot;);</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
<blockquote>
<p>file: arch&#x2F;arm&#x2F;cpu&#x2F;u-boot-spl.lds</p>
</blockquote>
</li>
</ul>
<h3 id="堆栈空间的大小"><a href="#堆栈空间的大小" class="headerlink" title="堆栈空间的大小"></a>堆栈空间的大小</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define CONFIG_SPL_STACK            (SPL_STACK_BSS_ADDRESS-16)    #栈地址减16(0x10)？？？</span><br></pre></td></tr></table></figure>
<p><code>CONFIG_SPL_STACK</code>指定栈的起始地址时减去了16Byte，是为了防止栈地址在进行<code>16Byte对齐</code>时越界。</p>
<p>spl的<code>_main</code>函数部分：</p>
<figure class="highlight arm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">ENTRY</span>(_main)</span><br><span class="line">  <span class="keyword">ldr</span> x0, =(CONFIG_SPL_STACK)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">bic</span> <span class="built_in">sp</span>, x0, <span class="number">#0xf</span>    <span class="comment">/* 16-byte alignment for ABI compliance */</span></span><br><span class="line">  <span class="keyword">mov</span> x0, <span class="built_in">sp</span></span><br><span class="line">  <span class="keyword">bl</span>  board_init_f_alloc_reserve</span><br><span class="line">  <span class="keyword">mov</span> <span class="built_in">sp</span>, x0</span><br><span class="line">  <span class="comment">/* set up gd here, outside any C code */</span></span><br><span class="line">  <span class="keyword">mov</span> x18, x0</span><br><span class="line">  <span class="keyword">bl</span>  board_init_f_init_reserve</span><br><span class="line"></span><br><span class="line">  <span class="keyword">mov</span> x0, <span class="number">#0</span></span><br><span class="line">  <span class="keyword">bl</span>  board_init_f</span><br><span class="line"></span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>
<blockquote>
<p>file: arch&#x2F;arm&#x2F;lib&#x2F;crt0_64.S</p>
</blockquote>
<p>在SPL为啥没有指定栈空间大小，难道不担心栈溢出或覆盖吗？？？</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ulong <span class="title function_">board_init_f_alloc_reserve</span><span class="params">(ulong top)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*Reserve early malloc arena*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> CONFIG_VAL(SYS_MALLOC_F_LEN)</span></span><br><span class="line">    top -= CONFIG_VAL(SYS_MALLOC_F_LEN);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">/*LAST : reserve GD (rounded up to a multiple of 16 bytes)*/</span></span><br><span class="line">    top = rounddown(top-<span class="keyword">sizeof</span>(<span class="keyword">struct</span> global_data), <span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> top;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CONFIG_SPL_SYS_MALLOC_F_LEN=0x3000  #12KB</span><br></pre></td></tr></table></figure>
<p>因此<code>CONFIG_SPL_SYS_MALLOC_F_LEN</code>指定的<code>12KB</code>是栈空间大小。</p>
<p>同时<code>CONFIG_SPL_SYS_MALLOC_F_LEN</code>的目的也是为了在uboot将spl编译完后进行空间大小限制计算，防止运行过程中栈信息将代码段覆盖。</p>
<p>如果定义了<code>CONFIG_SPL_STACK_R</code>参数，将重定位堆栈信息，以上的确定的堆栈的起始地址，将发生变化。</p>
<h3 id="malloc"><a href="#malloc" class="headerlink" title="malloc"></a>malloc</h3><p>当前配置中没有使能malloc相关接口。</p>
<h4 id="early-malloc-arena"><a href="#early-malloc-arena" class="headerlink" title="early malloc arena"></a>early malloc arena</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">board_init_f_init_reserve</span><span class="params">(ulong base)</span></span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="meta">#<span class="keyword">if</span> CONFIG_VAL(SYS_MALLOC_F_LEN)</span></span><br><span class="line">    <span class="comment">/*go down one &#x27;early malloc arena&#x27;*/</span></span><br><span class="line">    gd-&gt;malloc_base = base;</span><br><span class="line">  <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只定义了堆的起始地址。</p>
<p>如果想要使用malloc相关接口函数，需要增加其他配置，这里暂不做详细描述。</p>
<h3 id="SPL镜像的大小限制计算"><a href="#SPL镜像的大小限制计算" class="headerlink" title="SPL镜像的大小限制计算"></a>SPL镜像的大小限制计算</h3><p>在spl编译阶段会根据以上定义的相关配置，计算spl的大小与实际SARM空间之间的限制，如果超过SARM时将会报出警告。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ifneq ($(CONFIG_SPL_SIZE_LIMIT),0x0)</span><br><span class="line">SPL_SIZE_CHECK = @$(call size_check,$@,$$(tools/spl_size_limit))</span><br><span class="line">else</span><br><span class="line">SPL_SIZE_CHECK =</span><br><span class="line">endif</span><br></pre></td></tr></table></figure>
<blockquote>
<p>file: Makefile</p>
</blockquote>
<p>在Makefile进行spl实际大小与配置的限制大小的检测，如果不符合限制要求，将报警告提示。而最终的限制大小是由<code>spl_size_limit</code>程序计算而来。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> spl_size_limit = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SPL_SIZE_LIMIT</span></span><br><span class="line">    spl_size_limit = CONFIG_SPL_SIZE_LIMIT;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SPL_SIZE_LIMIT_SUBTRACT_GD</span></span><br><span class="line">    spl_size_limit -= GENERATED_GBL_DATA_SIZE;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SPL_SIZE_LIMIT_SUBTRACT_MALLOC</span></span><br><span class="line">    spl_size_limit -= CONFIG_SPL_SYS_MALLOC_F_LEN;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SPL_SIZE_LIMIT_PROVIDE_STACK</span></span><br><span class="line">    spl_size_limit -= CONFIG_SPL_SIZE_LIMIT_PROVIDE_STACK;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, spl_size_limit);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>file: tools&#x2F;spl_size_limit.c</p>
</blockquote>
<p><code>CONFIG_SPL_SIZE_LIMIT</code>所限制的SPL大小，包含了堆栈空间的大小。</p>
<p>但是我认为在上面程序中应该减去BBS段的大小，这样剩余的空间就可以是代码段的大小，不然有可能spl过大导致代码段占用BBS段的空间，而使运行时出现异常。</p>
<h3 id="SPL的目的"><a href="#SPL的目的" class="headerlink" title="SPL的目的"></a>SPL的目的</h3><ul>
<li>初始化DDR，使用SRAM的小空间换去DDR的大空间。</li>
<li>加载uboot或kernel到DDR（大空间），并运行。</li>
</ul>
<p>为了进行DDR的初始化，就需要进行<code>时钟</code>的初始化，以及<code>串口</code>（为了调试信息输出）</p>
<p>spl在内存初始化完成后，将uboot从外部存储介质拷贝到DDR中的特定地址（uboot代码段基址），并从该地址跳转执行uboot代码。</p>
<p>spl确定uboot代码段基址的方法，先读取1个block的头部信息，并解析出其中uboot的加载地址（代码段基址）。</p>
<h2 id="ATF"><a href="#ATF" class="headerlink" title="ATF"></a>ATF</h2><ul>
<li>ATF阶段的代码是否存放DDR？？？</li>
<li>ATF运行阶段的运行栈空间？？？</li>
<li>进入内核阶段后ATF内存空间如何被保护？？？</li>
</ul>
<h3 id="bl31"><a href="#bl31" class="headerlink" title="bl31"></a>bl31</h3><figure class="highlight arm"><table><tr><td class="code"><pre><span class="line"><span class="number">00000000</span>ff7a2000 &lt;bl31_entrypoint&gt;:</span><br><span class="line"><span class="symbol">    ff7a2000:</span>	aa0003f4 	<span class="keyword">mov</span>	x20, x0</span><br><span class="line"><span class="symbol">    ff7a2004:</span>	aa0103f5 	<span class="keyword">mov</span>	x21, x1</span><br><span class="line"><span class="symbol">    ff7a2008:</span>	aa0203f6 	<span class="keyword">mov</span>	x22, x2</span><br><span class="line"><span class="symbol">    ff7a200c:</span>	aa0303f7 	<span class="keyword">mov</span>	x23, x3</span><br><span class="line"><span class="symbol">    ff7a2010:</span>	<span class="number">10023</span>f80 	<span class="keyword">adr</span>	x0, ff7a6800 &lt;sync_exception_sp_el0&gt;</span><br><span class="line"><span class="symbol">    ff7a2014:</span>	d51ec000 	<span class="keyword">msr</span>	vbar_el3, x0</span><br><span class="line"><span class="symbol">    ff7a2018:</span>	d5033fdf 	<span class="keyword">isb</span></span><br><span class="line"><span class="symbol">    ff7a201c:</span>	<span class="number">940002</span><span class="built_in">d7</span> 	<span class="keyword">bl</span>	ff7a2b78 &lt;reset_handler&gt;</span><br></pre></td></tr></table></figure>
<p>bl31的代码段和运行时的栈空间都在SRAM中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">atf &#123;</span><br><span class="line">    description = &quot;ARM Trusted Firmware&quot;;</span><br><span class="line">    data = /incbin/(&quot;bl31.bin&quot;);</span><br><span class="line">    type = &quot;firmware&quot;;</span><br><span class="line">    os = &quot;arm-trusted-firmware&quot;;</span><br><span class="line">    arch = &quot;arm64&quot;;</span><br><span class="line">    compression = &quot;none&quot;;</span><br><span class="line">    load = &lt;0xff7a2000&gt;;</span><br><span class="line">    entry = &lt;0xff7a2000&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>FIT格式的配置文件u-boot.its</p>
</blockquote>
<h2 id="uboot"><a href="#uboot" class="headerlink" title="uboot"></a>uboot</h2><p>uboot的运行空间在DDR中，因此编译生成的镜像是对DDR地址空间的划分。</p>
<p>uboot阶段包含atf和实际uboot程序。</p>
<h3 id="DDR"><a href="#DDR" class="headerlink" title="DDR"></a>DDR</h3><p>DDR容量的大小由具体的产品定义，可以是1G或者2G等，但是存在一个DDR可用容量的最大值，外部选取的DDR不能超过该值。</p>
<p>DDR可用容量的最大值：由SOC内部总线地址（DDR物理地址）的映射关系决定。</p>
<p>比如，SOC内部DDR地址范围映射为<code>0x0000 0000 ～ 0xFBFF FFFF</code>，那么DDR的最大可用容量就为0xFBFFFFFF&#x3D;3.9GB</p>
<ul>
<li><p>如果外部选用DDR超过最大容量会咋样？？？</p>
<p>涉及到的模块<code>DDR控制器</code>、<code>SOC内部总线地址宽度</code></p>
</li>
<li><p>如果外部DDR超过最大容量后，对SPL中DDR的初始化是否存在影响？？？</p>
</li>
</ul>
<h3 id="配置参数"><a href="#配置参数" class="headerlink" title="配置参数"></a>配置参数</h3><p>memconfig中定义的配置参数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CONFIG_SYS_TEXT_BASE=0x00200000</span><br><span class="line">CONFIG_SYS_MALLOC_F_LEN=0x3000  #12KB</span><br></pre></td></tr></table></figure>
<ul>
<li><code>CONFIG_SYS_TEXT_BASE</code>: 配置代码段基址</li>
<li><code>CONFIG_SYS_MALLOC_F_LEN</code>: 配置堆栈空间大小</li>
</ul>
<p>配置文件中定义的配置参数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define CONFIG_SYS_SDRAM_BASE       0x00000000</span><br><span class="line"></span><br><span class="line">#define CONFIG_SYS_INIT_SP_ADDR     0x00300000</span><br><span class="line">#define CONFIG_SYS_MALLOC_LEN       SZ_32M</span><br><span class="line"></span><br><span class="line">#define CONFIG_SYS_LOAD_ADDR        0x00880000</span><br><span class="line">#define CONFIG_SYS_BOOTM_LEN        SZ_64M</span><br></pre></td></tr></table></figure>
<ul>
<li><code>CONFIG_SYS_SDRAM_BASE</code>: 指定SDRAM的物理起始地址, <strong>这里必须是0</strong></li>
<li><code>CONFIG_SYS_INIT_SP_ADDR</code>: 指定栈的起始地址</li>
<li><code>CONFIG_SYS_MALLOC_LEN</code>: 指定为malloc()使用保留的DRAM大小。</li>
<li><code>CONFIG_SYS_LOAD_ADDR</code>: 指定kernel在DRAM中的加载地址， ？？？</li>
<li><code>CONFIG_SYS_BOOTM_LEN</code>: 指定kernel镜像的大小，默认8M，可以根据实际需求修改比如64M。</li>
</ul>
<h3 id="u-boot-lds"><a href="#u-boot-lds" class="headerlink" title="u-boot.lds"></a>u-boot.lds</h3><p>通用链接文件：<code>arch/arm/cpu/u-boot.lds</code></p>
<p>链接文件的处理命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">aarch64-none-linux-gnu-gcc -E -Wp,-MD,./.u-boot.lds.d -D__KERNEL__ -D__UBOOT__   -D__ARM__</span><br><span class="line">-fno-pic  -mstrict-align  -ffunction-sections -fdata-sections -fno-common -ffixed-r9</span><br><span class="line">-fno-common -ffixed-x18 -pipe -march=armv8-a -D__LINUX_ARM_ARCH__=8</span><br><span class="line">-I./arch/arm/mach-vanxum/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h</span><br><span class="line">-nostdinc -isystem /home/xx/tools/prebuilts/aarch64-none-linux-gnu/bin/../lib/gcc/aarch64-none-linux-gnu/10.2.1/include</span><br><span class="line">-ansi -include ./include/u-boot/u-boot.lds.h</span><br><span class="line">-DCPUDIR=arch/arm/cpu/armv8  -D__ASSEMBLY__ -x assembler-with-cpp -std=c99 -P</span><br><span class="line">-o u-boot.lds arch/arm/cpu/armv8/u-boot.lds</span><br></pre></td></tr></table></figure>

<p>编译后生成的特有链接文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">OUTPUT_FORMAT(&quot;elf64-littleaarch64&quot;, &quot;elf64-littleaarch64&quot;, &quot;elf64-littleaarch64&quot;)</span><br><span class="line">OUTPUT_ARCH(aarch64)</span><br><span class="line">ENTRY(_start)</span><br><span class="line">SECTIONS</span><br><span class="line">&#123;</span><br><span class="line"> . = 0x00000000;</span><br><span class="line"> . = ALIGN(8);</span><br><span class="line"> .text :</span><br><span class="line"> &#123;</span><br><span class="line">  *(.__image_copy_start)</span><br><span class="line">  arch/arm/cpu/armv8/start.o (.text*)</span><br><span class="line"> &#125;</span><br><span class="line"> .efi_runtime : &#123;</span><br><span class="line">                __efi_runtime_start = .;</span><br><span class="line">  *(.text.efi_runtime*)</span><br><span class="line">  *(.rodata.efi_runtime*)</span><br><span class="line">  *(.data.efi_runtime*)</span><br><span class="line">                __efi_runtime_stop = .;</span><br><span class="line"> &#125;</span><br><span class="line"> .text_rest :</span><br><span class="line"> &#123;</span><br><span class="line">  *(.text*)</span><br><span class="line"> &#125;</span><br><span class="line"> . = ALIGN(8);</span><br><span class="line"> .rodata : &#123; *(SORT_BY_ALIGNMENT(SORT_BY_NAME(.rodata*))) &#125;</span><br><span class="line"> . = ALIGN(8);</span><br><span class="line"> .data : &#123;</span><br><span class="line">  *(.data*)</span><br><span class="line"> &#125;</span><br><span class="line"> . = ALIGN(8);</span><br><span class="line"> . = .;</span><br><span class="line"> . = ALIGN(8);</span><br><span class="line"> .u_boot_list : &#123;</span><br><span class="line">  KEEP(*(SORT(.u_boot_list*)));</span><br><span class="line"> &#125;</span><br><span class="line"> . = ALIGN(8);</span><br><span class="line"> .efi_runtime_rel : &#123;</span><br><span class="line">                __efi_runtime_rel_start = .;</span><br><span class="line">  *(.rel*.efi_runtime)</span><br><span class="line">  *(.rel*.efi_runtime.*)</span><br><span class="line">                __efi_runtime_rel_stop = .;</span><br><span class="line"> &#125;</span><br><span class="line"> . = ALIGN(8);</span><br><span class="line"> .image_copy_end :</span><br><span class="line"> &#123;</span><br><span class="line">  *(.__image_copy_end)</span><br><span class="line"> &#125;</span><br><span class="line"> . = ALIGN(8);</span><br><span class="line"> .rel_dyn_start :</span><br><span class="line"> &#123;</span><br><span class="line">  *(.__rel_dyn_start)</span><br><span class="line"> &#125;</span><br><span class="line"> .rela.dyn : &#123;</span><br><span class="line">  *(.rela*)</span><br><span class="line"> &#125;</span><br><span class="line"> .rel_dyn_end :</span><br><span class="line"> &#123;</span><br><span class="line">  *(.__rel_dyn_end)</span><br><span class="line"> &#125;</span><br><span class="line"> _end = .;</span><br><span class="line"> . = ALIGN(8);</span><br><span class="line"> .bss_start : &#123;</span><br><span class="line">  KEEP(*(.__bss_start));</span><br><span class="line"> &#125;</span><br><span class="line"> .bss : &#123;</span><br><span class="line">  *(.bss*)</span><br><span class="line">   . = ALIGN(8);</span><br><span class="line"> &#125;</span><br><span class="line"> .bss_end : &#123;</span><br><span class="line">  KEEP(*(.__bss_end));</span><br><span class="line"> &#125;</span><br><span class="line"> /DISCARD/ : &#123; *(.dynsym) &#125;</span><br><span class="line"> /DISCARD/ : &#123; *(.dynstr*) &#125;</span><br><span class="line"> /DISCARD/ : &#123; *(.dynamic*) &#125;</span><br><span class="line"> /DISCARD/ : &#123; *(.plt*) &#125;</span><br><span class="line"> /DISCARD/ : &#123; *(.interp*) &#125;</span><br><span class="line"> /DISCARD/ : &#123; *(.gnu*) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>链接文件的开始地址为啥是<code>. = 0x00000000</code>？？？</li>
<li>地址是虚拟地址还是物理地址？？？</li>
<li>代码段基址是0x200000,链接文件开始地址是0？？？</li>
</ul>
<h3 id="DDR的内存布局"><a href="#DDR的内存布局" class="headerlink" title="DDR的内存布局"></a>DDR的内存布局</h3><p><img data-src="/images/2022/08/uboot%E5%86%85%E5%AD%98%E5%88%92%E5%88%86.png" alt="uboot内存划分"></p>
<p>uboot镜像的各段详细数据：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$aarch64-none-linux-gnu-readelf -S u-boot</span><br><span class="line">There are 24 section headers, starting at offset 0x48ff90:</span><br><span class="line"></span><br><span class="line">Section Headers:</span><br><span class="line">  [Nr] Name              Type             Address           Offset</span><br><span class="line">       Size              EntSize          Flags  Link  Info  Align</span><br><span class="line">  [ 0]                   NULL             0000000000000000  00000000</span><br><span class="line">       0000000000000000  0000000000000000           0     0     0</span><br><span class="line">  [ 1] .text             PROGBITS         0000000000200000  00010000</span><br><span class="line">       0000000000000158  0000000000000000  AX       0     0     8</span><br><span class="line">  [ 2] .text_rest        PROGBITS         0000000000200800  00010800</span><br><span class="line">       000000000005abfc  0000000000000000  AX       0     0     2048</span><br><span class="line">  [ 3] .rodata           PROGBITS         000000000025b400  0006b400</span><br><span class="line">       0000000000016f6e  0000000000000000   A       0     0     8</span><br><span class="line">  [ 4] .hash             HASH             0000000000272370  00082370</span><br><span class="line">       0000000000000018  0000000000000004   A       0     0     8</span><br><span class="line">  [ 5] .data             PROGBITS         0000000000272388  00082388</span><br><span class="line">       0000000000004688  0000000000000000  WA       0     0     8</span><br><span class="line">  [ 6] .got              PROGBITS         0000000000276a10  00086a10</span><br><span class="line">       0000000000000008  0000000000000008  WA       0     0     8</span><br><span class="line">  [ 7] .got.plt          PROGBITS         0000000000276a18  00086a18</span><br><span class="line">       0000000000000018  0000000000000008  WA       0     0     8</span><br><span class="line">  [ 8] .u_boot_list      PROGBITS         0000000000276a30  00086a30</span><br><span class="line">       0000000000002eb8  0000000000000000  WA       0     0     8</span><br><span class="line">  [ 9] .rela.dyn         RELA             00000000002798e8  000898e8</span><br><span class="line">       000000000000d428  0000000000000018   A       0     0     8</span><br><span class="line">  [10] .bss_start        PROGBITS         0000000000286d10  00096d10</span><br><span class="line">       0000000000000000  0000000000000000  WA       0     0     1</span><br><span class="line">  [11] .bss              NOBITS           0000000000286d40  00096d10</span><br><span class="line">       000000000000f988  0000000000000000  WA       0     0     64</span><br><span class="line">  [12] .bss_end          PROGBITS         00000000002966c8  000a66c8</span><br><span class="line">       0000000000000000  0000000000000000  WA       0     0     1</span><br><span class="line">  [13] .debug_line       PROGBITS         0000000000000000  000a66c8</span><br><span class="line">       0000000000078130  0000000000000000           0     0     1</span><br><span class="line">  [14] .debug_info       PROGBITS         0000000000000000  0011e7f8</span><br><span class="line">       000000000017ba49  0000000000000000           0     0     1</span><br><span class="line">  [15] .debug_abbrev     PROGBITS         0000000000000000  0029a241</span><br><span class="line">       00000000000349d3  0000000000000000           0     0     1</span><br><span class="line">  [16] .debug_aranges    PROGBITS         0000000000000000  002cec20</span><br><span class="line">       000000000000b3f0  0000000000000000           0     0     16</span><br><span class="line">  [17] .debug_str        PROGBITS         0000000000000000  002da010</span><br><span class="line">       000000000001e452  0000000000000001  MS       0     0     1</span><br><span class="line">  [18] .comment          PROGBITS         0000000000000000  002f8462</span><br><span class="line">       000000000000005d  0000000000000001  MS       0     0     1</span><br><span class="line">  [19] .debug_loc        PROGBITS         0000000000000000  002f84bf</span><br><span class="line">       0000000000145ff6  0000000000000000           0     0     1</span><br><span class="line">  [20] .debug_ranges     PROGBITS         0000000000000000  0043e4c0</span><br><span class="line">       0000000000026550  0000000000000000           0     0     16</span><br><span class="line">  [21] .symtab           SYMTAB           0000000000000000  00464a10</span><br><span class="line">       0000000000020568  0000000000000018          22   4116     8</span><br><span class="line">  [22] .strtab           STRTAB           0000000000000000  00484f78</span><br><span class="line">       000000000000af38  0000000000000000           0     0     1</span><br><span class="line">  [23] .shstrtab         STRTAB           0000000000000000  0048feb0</span><br><span class="line">       00000000000000e0  0000000000000000           0     0     1</span><br><span class="line">Key to Flags:</span><br><span class="line">  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),</span><br><span class="line">  L (link order), O (extra OS processing required), G (group), T (TLS),</span><br><span class="line">  C (compressed), x (unknown), o (OS specific), E (exclude),</span><br><span class="line">  p (processor specific)</span><br></pre></td></tr></table></figure>


<h3 id="BBS段大小"><a href="#BBS段大小" class="headerlink" title="BBS段大小"></a>BBS段大小</h3><p>BBS段在编辑阶段根据实际使用的大小确定，只是在uboot启动阶段将其对应的地址位置清除一下(与SPL中操作一样)。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">000000000020180c &lt;relocation_return&gt;:</span><br><span class="line">  20180c:   97fffa3d    bl  200100 &lt;c_runtime_cpu_setup&gt;</span><br><span class="line">  201810:   58000140    ldr x0, 201838 &lt;clear_loop+0x20&gt;</span><br><span class="line">  201814:   58000161    ldr x1, 201840 &lt;clear_loop+0x28&gt;</span><br><span class="line"></span><br><span class="line">0000000000201818 &lt;clear_loop&gt;:</span><br><span class="line">  201818:   f800841f    str xzr, [x0], #8</span><br><span class="line">  20181c:   eb01001f    cmp x0, x1</span><br><span class="line">  201820:   54ffffc3    b.cc    201818 &lt;clear_loop&gt;  // b.lo, b.ul, b.last</span><br><span class="line">  201824:   aa1203e0    mov x0, x18</span><br><span class="line">  201828:   f9403a41    ldr x1, [x18, #112]</span><br><span class="line">  20182c:   14005304    b   21643c &lt;board_init_r&gt;</span><br><span class="line">  201830:   00300000    .inst   0x00300000 ; NYI</span><br><span class="line">  201834:   00000000    udf #0</span><br><span class="line">  201838:   00286d10    .inst   0x00286d10 ; NYI       #__bss_start</span><br><span class="line">  20183c:   00000000    udf #0</span><br><span class="line">  201840:   002966c8    .inst   0x002966c8 ; NYI       #__bss_end</span><br><span class="line">  201844:   00000000    udf #0</span><br></pre></td></tr></table></figure>

<h3 id="堆栈空间大小"><a href="#堆栈空间大小" class="headerlink" title="堆栈空间大小"></a>堆栈空间大小</h3><p>栈空间的设置与SPL代码复用，只是配置参数不同，当前配置的栈大小相同，均为<code>12KB</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ulong <span class="title function_">board_init_f_alloc_reserve</span><span class="params">(ulong top)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* Reserve early malloc arena */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> CONFIG_VAL(SYS_MALLOC_F_LEN)</span></span><br><span class="line">    top -= CONFIG_VAL(SYS_MALLOC_F_LEN);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">/* LAST : reserve GD (rounded up to a multiple of 16 bytes) */</span></span><br><span class="line">    top = rounddown(top-<span class="keyword">sizeof</span>(<span class="keyword">struct</span> global_data), <span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> top;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>file: common&#x2F;init&#x2F;board_init.c</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CONFIG_SYS_MALLOC_F_LEN=0x3000  #12KB</span><br></pre></td></tr></table></figure>

<h3 id="malloc-1"><a href="#malloc-1" class="headerlink" title="malloc"></a>malloc</h3><h4 id="early-malloc-arena-1"><a href="#early-malloc-arena-1" class="headerlink" title="early malloc arena"></a>early malloc arena</h4><p>这部分malloc区域与栈空间共用，总大小12KB，栈空间向下增长，malloc向上增长。</p>
<h4 id="malloc-arena"><a href="#malloc-arena" class="headerlink" title="malloc arena"></a>malloc arena</h4><p>在配置文件中定义了malloc的空间大小<code>CONFIG_SYS_MALLOC_LEN=SZ_32M</code>，那其地址范围是？？？，也就是堆的起始地址。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If the environment is in RAM, allocate extra space for it in the malloc</span></span><br><span class="line"><span class="comment"> * region.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_ENV_IS_EMBEDDED)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TOTAL_MALLOC_LEN    CONFIG_SYS_MALLOC_LEN</span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> (CONFIG_ENV_ADDR + CONFIG_ENV_SIZE &lt; CONFIG_SYS_MONITOR_BASE) || \</span></span><br><span class="line"><span class="meta">      (CONFIG_ENV_ADDR &gt;= CONFIG_SYS_MONITOR_BASE + CONFIG_SYS_MONITOR_LEN) || \</span></span><br><span class="line"><span class="meta">      defined(CONFIG_ENV_IS_IN_NVRAM)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TOTAL_MALLOC_LEN    (CONFIG_SYS_MALLOC_LEN + CONFIG_ENV_SIZE)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TOTAL_MALLOC_LEN    CONFIG_SYS_MALLOC_LEN</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>file: include&#x2F;env_internal.h</p>
</blockquote>
<p><code>CONFIG_SYS_MALLOC_LEN</code>指定的malloc的大小，可能也与环境变量空间大小一起划分，因此最终需要的内存空间大小为<code>TOTAL_MALLOC_LEN</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">initr_malloc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  malloc_start = gd-&gt;relocaddr - TOTAL_MALLOC_LEN;</span><br><span class="line">     mem_malloc_init((ulong)map_sysmem(malloc_start, TOTAL_MALLOC_LEN),</span><br><span class="line">             TOTAL_MALLOC_LEN);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>initr_malloc</code>函数中对malloc进行初始化，此时可以其确定malloc的起始地址与<code>gd-&gt;relocaddr</code>相关。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">setup_dest_addr</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SYS_SDRAM_BASE</span></span><br><span class="line">  gd-&gt;ram_base = CONFIG_SYS_SDRAM_BASE;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  gd-&gt;ram_top = gd-&gt;ram_base + get_effective_memsize();</span><br><span class="line">  gd-&gt;ram_top = board_get_usable_ram_top(gd-&gt;mon_len);</span><br><span class="line">  gd-&gt;relocaddr = gd-&gt;ram_top;</span><br><span class="line">  debug(<span class="string">&quot;Ram top: %08lX\n&quot;</span>, (ulong)gd-&gt;ram_top);</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>setup_dest_addr</code>中配置了<code>gd-&gt;ram_top</code>和<code>gd-&gt;relocaddr</code>的值。</p>
<p>get_effective_memsize获取有效的内存大小<code>gd-&gt;ram_size</code>, 而ram_size是解析设备树中的<code>memory</code>节点获取。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">memory@00000000 &#123;</span><br><span class="line">    reg = &lt;0x0 0x0 0x0 0x78000000&gt;;</span><br><span class="line">    device_type = &quot;memory&quot;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>ram_size &#x3D; 0x78000000 &#x3D; 1920MB &#x3D; 1.9GB</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gd-&gt;ram_base = CONFIG_SYS_SDRAM_BASE = 0x0</span><br><span class="line">gd-&gt;ram_top = 0x78000000</span><br><span class="line">gd-&gt;relocaddr = 0x78000000</span><br></pre></td></tr></table></figure>

<p>因此malloc区域的起始地址<code>malloc_start = 0x78000000 - SZ_32M</code></p>
<h3 id="代码重定位"><a href="#代码重定位" class="headerlink" title="代码重定位"></a>代码重定位</h3><h3 id="MMU"><a href="#MMU" class="headerlink" title="MMU"></a>MMU</h3><h3 id="Cache"><a href="#Cache" class="headerlink" title="Cache"></a>Cache</h3><h3 id="虚拟物理地址映射"><a href="#虚拟物理地址映射" class="headerlink" title="虚拟物理地址映射"></a>虚拟物理地址映射</h3><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="编译步骤详细信息"><a href="#编译步骤详细信息" class="headerlink" title="编译步骤详细信息"></a>编译步骤详细信息</h3><p>在make后追加<code>V=1</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$make V=1 spl/u-boot-spl.bin</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$make V=1 u-boot.lds</span><br></pre></td></tr></table></figure>

<h3 id="asm-offset"><a href="#asm-offset" class="headerlink" title="asm-offset"></a>asm-offset</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    /* Round up to make sure size gives nice stack alignment */</span><br><span class="line">    DEFINE(GENERATED_GBL_DATA_SIZE,</span><br><span class="line">        (sizeof(struct global_data) + 15) &amp; ~15);</span><br><span class="line"></span><br><span class="line">    DEFINE(GENERATED_BD_INFO_SIZE,</span><br><span class="line">        (sizeof(struct bd_info) + 15) &amp; ~15);</span><br><span class="line"></span><br><span class="line">    DEFINE(GD_SIZE, sizeof(struct global_data));</span><br><span class="line"></span><br><span class="line">    DEFINE(GD_BD, offsetof(struct global_data, bd));</span><br><span class="line">#if CONFIG_VAL(SYS_MALLOC_F_LEN)</span><br><span class="line">    DEFINE(GD_MALLOC_BASE, offsetof(struct global_data, malloc_base));</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    DEFINE(GD_RELOCADDR, offsetof(struct global_data, relocaddr));</span><br><span class="line"></span><br><span class="line">    DEFINE(GD_RELOC_OFF, offsetof(struct global_data, reloc_off));</span><br><span class="line"></span><br><span class="line">    DEFINE(GD_START_ADDR_SP, offsetof(struct global_data, start_addr_sp));</span><br><span class="line"></span><br><span class="line">    DEFINE(GD_NEW_GD, offsetof(struct global_data, new_gd));</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>file: lib&#x2F;asm-offsets.c</p>
</blockquote>
<h3 id="gd结构体的定义"><a href="#gd结构体的定义" class="headerlink" title="gd结构体的定义"></a>gd结构体的定义</h3><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://winddoing.github.io/post/47503.html">uboot启动流程——MIPS</a></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpbnV4d2VpeWgvYXJ0aWNsZS9kZXRhaWxzLzEwMDE3OTk2OA==">【u-boot-2018.11】make工具之fixdep<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>uboot</category>
      </categories>
      <tags>
        <tag>内存</tag>
        <tag>uboot</tag>
      </tags>
  </entry>
  <entry>
    <title>GCC编译器内部预宏定义</title>
    <url>/post/37120.html</url>
    <content><![CDATA[<p>查看GCC编译器内部的预定义宏：</p>
<h2 id="Linux系统"><a href="#Linux系统" class="headerlink" title="Linux系统"></a>Linux系统</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -E -dM - &lt;/dev/null</span><br></pre></td></tr></table></figure>

<span id="more"></span>


<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">gcc --version</span></span><br><span class="line">gcc (Ubuntu 7.3.0-16ubuntu3) 7.3.0</span><br><span class="line">Copyright (C) 2017 Free Software Foundation, Inc.</span><br><span class="line">This is free software; see the source for copying conditions.  There is NO</span><br><span class="line">warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">gcc -E -dM - &lt;/dev/null</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __SSP_STRONG__ 3</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __DBL_MIN_EXP__ (-1021)</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __FLT32X_MAX_EXP__ 1024</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __UINT_LEAST16_MAX__ 0xffff</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __ATOMIC_ACQUIRE 2</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __FLT128_MAX_10_EXP__ 4932</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __FLT_MIN__ 1.17549435082228750796873653722224568e-38F</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __GCC_IEC_559_COMPLEX 2</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __UINT_LEAST8_TYPE__ unsigned char</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __SIZEOF_FLOAT80__ 16</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __INTMAX_C(c) c <span class="comment">## L</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __CHAR_BIT__ 8</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __UINT8_MAX__ 0xff</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __WINT_MAX__ 0xffffffffU</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __FLT32_MIN_EXP__ (-125)</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __ORDER_LITTLE_ENDIAN__ 1234</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __SIZE_MAX__ 0xffffffffffffffffUL</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __WCHAR_MAX__ 0x7fffffff</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_1 1</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_2 1</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_4 1</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __DBL_DENORM_MIN__ ((double)4.94065645841246544176568792868221372e-324L)</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_8 1</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __GCC_ATOMIC_CHAR_LOCK_FREE 2</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __GCC_IEC_559 2</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __FLT32X_DECIMAL_DIG__ 17</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __FLT_EVAL_METHOD__ 0</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __unix__ 1</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __FLT64_DECIMAL_DIG__ 17</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __GCC_ATOMIC_CHAR32_T_LOCK_FREE 2</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __x86_64 1</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __UINT_FAST64_MAX__ 0xffffffffffffffffUL</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __SIG_ATOMIC_TYPE__ int</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __DBL_MIN_10_EXP__ (-307)</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __FINITE_MATH_ONLY__ 0</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __GNUC_PATCHLEVEL__ 0</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __FLT32_HAS_DENORM__ 1</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __UINT_FAST8_MAX__ 0xff</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __has_include(STR) __has_include__(STR)</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __DEC64_MAX_EXP__ 385</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __INT8_C(c) c</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __INT_LEAST8_WIDTH__ 8</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __UINT_LEAST64_MAX__ 0xffffffffffffffffUL</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __SHRT_MAX__ 0x7fff</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __LDBL_MAX__ 1.18973149535723176502126385303097021e+4932L</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __FLT64X_MAX_10_EXP__ 4932</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __UINT_LEAST8_MAX__ 0xff</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __GCC_ATOMIC_BOOL_LOCK_FREE 2</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __FLT128_DENORM_MIN__ 6.47517511943802511092443895822764655e-4966F128</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __UINTMAX_TYPE__ long unsigned int</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __linux 1</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __DEC32_EPSILON__ 1E-6DF</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __FLT_EVAL_METHOD_TS_18661_3__ 0</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __unix 1</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __UINT32_MAX__ 0xffffffffU</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __LDBL_MAX_EXP__ 16384</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __FLT128_MIN_EXP__ (-16381)</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __WINT_MIN__ 0U</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __linux__ 1</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __FLT128_MIN_10_EXP__ (-4931)</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __INT_LEAST16_WIDTH__ 16</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __SCHAR_MAX__ 0x7f</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __FLT128_MANT_DIG__ 113</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __WCHAR_MIN__ (-__WCHAR_MAX__ - 1)</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __INT64_C(c) c <span class="comment">## L</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __DBL_DIG__ 15</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __GCC_ATOMIC_POINTER_LOCK_FREE 2</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __FLT64X_MANT_DIG__ 64</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __SIZEOF_INT__ 4</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __SIZEOF_POINTER__ 8</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __USER_LABEL_PREFIX__</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __FLT64X_EPSILON__ 1.08420217248550443400745280086994171e-19F64x</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __STDC_HOSTED__ 1</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __LDBL_HAS_INFINITY__ 1</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __FLT32_DIG__ 6</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __FLT_EPSILON__ 1.19209289550781250000000000000000000e-7F</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __SHRT_WIDTH__ 16</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __LDBL_MIN__ 3.36210314311209350626267781732175260e-4932L</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __STDC_UTF_16__ 1</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __DEC32_MAX__ 9.999999E96DF</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __FLT64X_DENORM_MIN__ 3.64519953188247460252840593361941982e-4951F64x</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __FLT32X_HAS_INFINITY__ 1</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __INT32_MAX__ 0x7fffffff</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __INT_WIDTH__ 32</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __SIZEOF_LONG__ 8</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __STDC_IEC_559__ 1</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __STDC_ISO_10646__ 201706L</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __UINT16_C(c) c</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __PTRDIFF_WIDTH__ 64</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __DECIMAL_DIG__ 21</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __FLT64_EPSILON__ 2.22044604925031308084726333618164062e-16F64</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __gnu_linux__ 1</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __INTMAX_WIDTH__ 64</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __has_include_next(STR) __has_include_next__(STR)</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __FLT64X_MIN_10_EXP__ (-4931)</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __LDBL_HAS_QUIET_NAN__ 1</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __FLT64_MANT_DIG__ 53</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __GNUC__ 7</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __pie__ 2</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __MMX__ 1</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __FLT_HAS_DENORM__ 1</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __SIZEOF_LONG_DOUBLE__ 16</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __BIGGEST_ALIGNMENT__ 16</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __FLT64_MAX_10_EXP__ 308</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __DBL_MAX__ ((double)1.79769313486231570814527423731704357e+308L)</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __INT_FAST32_MAX__ 0x7fffffffffffffffL</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __DBL_HAS_INFINITY__ 1</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __DEC32_MIN_EXP__ (-94)</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __INTPTR_WIDTH__ 64</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __FLT32X_HAS_DENORM__ 1</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __INT_FAST16_TYPE__ long int</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __LDBL_HAS_DENORM__ 1</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __FLT128_HAS_INFINITY__ 1</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __DEC128_MAX__ 9.999999999999999999999999999999999E6144DL</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __INT_LEAST32_MAX__ 0x7fffffff</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __DEC32_MIN__ 1E-95DF</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __DBL_MAX_EXP__ 1024</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __WCHAR_WIDTH__ 32</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __FLT32_MAX__ 3.40282346638528859811704183484516925e+38F32</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __DEC128_EPSILON__ 1E-33DL</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __SSE2_MATH__ 1</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __ATOMIC_HLE_RELEASE 131072</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __PTRDIFF_MAX__ 0x7fffffffffffffffL</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __amd64 1</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __STDC_NO_THREADS__ 1</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __ATOMIC_HLE_ACQUIRE 65536</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __FLT32_HAS_QUIET_NAN__ 1</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __LONG_LONG_MAX__ 0x7fffffffffffffffLL</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __SIZEOF_SIZE_T__ 8</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __FLT64X_MIN_EXP__ (-16381)</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __SIZEOF_WINT_T__ 4</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __LONG_LONG_WIDTH__ 64</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __FLT32_MAX_EXP__ 128</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __GCC_HAVE_DWARF2_CFI_ASM 1</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __GXX_ABI_VERSION 1011</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __FLT_MIN_EXP__ (-125)</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __FLT64X_HAS_QUIET_NAN__ 1</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __INT_FAST64_TYPE__ long int</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __FLT64_DENORM_MIN__ 4.94065645841246544176568792868221372e-324F64</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __DBL_MIN__ ((double)2.22507385850720138309023271733240406e-308L)</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __PIE__ 2</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __LP64__ 1</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __FLT32X_EPSILON__ 2.22044604925031308084726333618164062e-16F32x</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __DECIMAL_BID_FORMAT__ 1</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __FLT64_MIN_EXP__ (-1021)</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __FLT64_MIN_10_EXP__ (-307)</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __FLT64X_DECIMAL_DIG__ 21</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __DEC128_MIN__ 1E-6143DL</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __REGISTER_PREFIX__</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __UINT16_MAX__ 0xffff</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __DBL_HAS_DENORM__ 1</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __FLT32_MIN__ 1.17549435082228750796873653722224568e-38F32</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __UINT8_TYPE__ unsigned char</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __NO_INLINE__ 1</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __FLT_MANT_DIG__ 24</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __LDBL_DECIMAL_DIG__ 21</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __VERSION__ <span class="string">&quot;7.3.0&quot;</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __UINT64_C(c) c <span class="comment">## UL</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define _STDC_PREDEF_H 1</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __GCC_ATOMIC_INT_LOCK_FREE 2</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __FLT128_MAX_EXP__ 16384</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __FLT32_MANT_DIG__ 24</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __FLOAT_WORD_ORDER__ __ORDER_LITTLE_ENDIAN__</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __STDC_IEC_559_COMPLEX__ 1</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __FLT128_HAS_DENORM__ 1</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __FLT128_DIG__ 33</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __SCHAR_WIDTH__ 8</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __INT32_C(c) c</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __DEC64_EPSILON__ 1E-15DD</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __ORDER_PDP_ENDIAN__ 3412</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __DEC128_MIN_EXP__ (-6142)</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __FLT32_MAX_10_EXP__ 38</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __INT_FAST32_TYPE__ long int</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __UINT_LEAST16_TYPE__ short unsigned int</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __FLT64X_HAS_INFINITY__ 1</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define unix 1</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __INT16_MAX__ 0x7fff</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __SIZE_TYPE__ long unsigned int</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __UINT64_MAX__ 0xffffffffffffffffUL</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __FLT64X_DIG__ 18</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __INT8_TYPE__ signed char</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __ELF__ 1</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __GCC_ASM_FLAG_OUTPUTS__ 1</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __FLT_RADIX__ 2</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __INT_LEAST16_TYPE__ short int</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __LDBL_EPSILON__ 1.08420217248550443400745280086994171e-19L</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __UINTMAX_C(c) c <span class="comment">## UL</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __SSE_MATH__ 1</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __k8 1</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __SIG_ATOMIC_MAX__ 0x7fffffff</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __GCC_ATOMIC_WCHAR_T_LOCK_FREE 2</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __SIZEOF_PTRDIFF_T__ 8</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __FLT32X_MANT_DIG__ 53</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __x86_64__ 1</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __FLT32X_MIN_EXP__ (-1021)</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __DEC32_SUBNORMAL_MIN__ 0.000001E-95DF</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __INT_FAST16_MAX__ 0x7fffffffffffffffL</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __FLT64_DIG__ 15</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __UINT_FAST32_MAX__ 0xffffffffffffffffUL</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __UINT_LEAST64_TYPE__ long unsigned int</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __FLT_HAS_QUIET_NAN__ 1</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __FLT_MAX_10_EXP__ 38</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __LONG_MAX__ 0x7fffffffffffffffL</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __FLT64X_HAS_DENORM__ 1</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __DEC128_SUBNORMAL_MIN__ 0.000000000000000000000000000000001E-6143DL</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __FLT_HAS_INFINITY__ 1</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __UINT_FAST16_TYPE__ long unsigned int</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __DEC64_MAX__ 9.999999999999999E384DD</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __INT_FAST32_WIDTH__ 64</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __CHAR16_TYPE__ short unsigned int</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __PRAGMA_REDEFINE_EXTNAME 1</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __SIZE_WIDTH__ 64</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __SEG_FS 1</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __INT_LEAST16_MAX__ 0x7fff</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __DEC64_MANT_DIG__ 16</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __INT64_MAX__ 0x7fffffffffffffffL</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __UINT_LEAST32_MAX__ 0xffffffffU</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __SEG_GS 1</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __FLT32_DENORM_MIN__ 1.40129846432481707092372958328991613e-45F32</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __GCC_ATOMIC_LONG_LOCK_FREE 2</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __SIG_ATOMIC_WIDTH__ 32</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __INT_LEAST64_TYPE__ long int</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __INT16_TYPE__ short int</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __INT_LEAST8_TYPE__ signed char</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __STDC_VERSION__ 201112L</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __DEC32_MAX_EXP__ 97</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __INT_FAST8_MAX__ 0x7f</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __FLT128_MAX__ 1.18973149535723176508575932662800702e+4932F128</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __INTPTR_MAX__ 0x7fffffffffffffffL</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define linux 1</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __FLT64_HAS_QUIET_NAN__ 1</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __FLT32_MIN_10_EXP__ (-37)</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __SSE2__ 1</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __FLT32X_DIG__ 15</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __LDBL_MANT_DIG__ 64</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __DBL_HAS_QUIET_NAN__ 1</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __FLT64_HAS_INFINITY__ 1</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __FLT64X_MAX__ 1.18973149535723176502126385303097021e+4932F64x</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __SIG_ATOMIC_MIN__ (-__SIG_ATOMIC_MAX__ - 1)</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __code_model_small__ 1</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __k8__ 1</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __INTPTR_TYPE__ long int</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __UINT16_TYPE__ short unsigned int</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __WCHAR_TYPE__ int</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __SIZEOF_FLOAT__ 4</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __pic__ 2</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __UINTPTR_MAX__ 0xffffffffffffffffUL</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __INT_FAST64_WIDTH__ 64</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __DEC64_MIN_EXP__ (-382)</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __FLT32_DECIMAL_DIG__ 9</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __INT_FAST64_MAX__ 0x7fffffffffffffffL</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __GCC_ATOMIC_TEST_AND_SET_TRUEVAL 1</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __FLT_DIG__ 6</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __FLT32_HAS_INFINITY__ 1</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __FLT64X_MAX_EXP__ 16384</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __UINT_FAST64_TYPE__ long unsigned int</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __INT_MAX__ 0x7fffffff</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __amd64__ 1</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __INT64_TYPE__ long int</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __FLT_MAX_EXP__ 128</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __ORDER_BIG_ENDIAN__ 4321</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __DBL_MANT_DIG__ 53</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __SIZEOF_FLOAT128__ 16</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __INT_LEAST64_MAX__ 0x7fffffffffffffffL</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __GCC_ATOMIC_CHAR16_T_LOCK_FREE 2</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __DEC64_MIN__ 1E-383DD</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __WINT_TYPE__ unsigned int</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __UINT_LEAST32_TYPE__ unsigned int</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __SIZEOF_SHORT__ 2</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __SSE__ 1</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __LDBL_MIN_EXP__ (-16381)</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __FLT64_MAX__ 1.79769313486231570814527423731704357e+308F64</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __WINT_WIDTH__ 32</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __INT_LEAST8_MAX__ 0x7f</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __FLT32X_MAX_10_EXP__ 308</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __SIZEOF_INT128__ 16</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __LDBL_MAX_10_EXP__ 4932</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __ATOMIC_RELAXED 0</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __DBL_EPSILON__ ((double)2.22044604925031308084726333618164062e-16L)</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __FLT128_MIN__ 3.36210314311209350626267781732175260e-4932F128</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define _LP64 1</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __UINT8_C(c) c</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __FLT64_MAX_EXP__ 1024</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __INT_LEAST32_TYPE__ int</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __SIZEOF_WCHAR_T__ 4</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __UINT64_TYPE__ long unsigned int</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __FLT128_HAS_QUIET_NAN__ 1</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __INT_FAST8_TYPE__ signed char</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __FLT64X_MIN__ 3.36210314311209350626267781732175260e-4932F64x</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __GNUC_STDC_INLINE__ 1</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __FLT64_HAS_DENORM__ 1</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __FLT32_EPSILON__ 1.19209289550781250000000000000000000e-7F32</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __DBL_DECIMAL_DIG__ 17</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __STDC_UTF_32__ 1</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __INT_FAST8_WIDTH__ 8</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __FXSR__ 1</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __DEC_EVAL_METHOD__ 2</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __FLT32X_MAX__ 1.79769313486231570814527423731704357e+308F32x</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __UINT32_C(c) c <span class="comment">## U</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __INTMAX_MAX__ 0x7fffffffffffffffL</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __BYTE_ORDER__ __ORDER_LITTLE_ENDIAN__</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __FLT_DENORM_MIN__ 1.40129846432481707092372958328991613e-45F</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __INT8_MAX__ 0x7f</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __LONG_WIDTH__ 64</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __PIC__ 2</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __UINT_FAST32_TYPE__ long unsigned int</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __CHAR32_TYPE__ unsigned int</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __FLT_MAX__ 3.40282346638528859811704183484516925e+38F</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __INT32_TYPE__ int</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __SIZEOF_DOUBLE__ 8</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __FLT_MIN_10_EXP__ (-37)</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __FLT64_MIN__ 2.22507385850720138309023271733240406e-308F64</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __INT_LEAST32_WIDTH__ 32</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __INTMAX_TYPE__ long int</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __DEC128_MAX_EXP__ 6145</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __FLT32X_HAS_QUIET_NAN__ 1</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __ATOMIC_CONSUME 1</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __GNUC_MINOR__ 3</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __INT_FAST16_WIDTH__ 64</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __UINTMAX_MAX__ 0xffffffffffffffffUL</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __DEC32_MANT_DIG__ 7</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __FLT32X_DENORM_MIN__ 4.94065645841246544176568792868221372e-324F32x</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __DBL_MAX_10_EXP__ 308</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __LDBL_DENORM_MIN__ 3.64519953188247460252840593361941982e-4951L</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __INT16_C(c) c</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __STDC__ 1</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __PTRDIFF_TYPE__ long int</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __ATOMIC_SEQ_CST 5</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __UINT32_TYPE__ unsigned int</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __FLT32X_MIN_10_EXP__ (-307)</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __UINTPTR_TYPE__ long unsigned int</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __DEC64_SUBNORMAL_MIN__ 0.000000000000001E-383DD</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __DEC128_MANT_DIG__ 34</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __LDBL_MIN_10_EXP__ (-4931)</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __FLT128_EPSILON__ 1.92592994438723585305597794258492732e-34F128</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __SIZEOF_LONG_LONG__ 8</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __FLT128_DECIMAL_DIG__ 36</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __GCC_ATOMIC_LLONG_LOCK_FREE 2</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __FLT32X_MIN__ 2.22507385850720138309023271733240406e-308F32x</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __LDBL_DIG__ 18</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __FLT_DECIMAL_DIG__ 9</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __UINT_FAST16_MAX__ 0xffffffffffffffffUL</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __GCC_ATOMIC_SHORT_LOCK_FREE 2</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __INT_LEAST64_WIDTH__ 64</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __UINT_FAST8_TYPE__ unsigned char</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __ATOMIC_ACQ_REL 4</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __ATOMIC_RELEASE 3</span></span><br></pre></td></tr></table></figure>

<h2 id="Window系统"><a href="#Window系统" class="headerlink" title="Window系统"></a>Window系统</h2><figure class="highlight bat"><table><tr><td class="code"><pre><span class="line">gcc -E -dM - &lt; <span class="built_in">NUL</span></span><br></pre></td></tr></table></figure>


<figure class="highlight bat"><table><tr><td class="code"><pre><span class="line"><span class="function">C:&gt;<span class="title">gcc</span> --<span class="title">version</span></span></span><br><span class="line"><span class="function"><span class="title">gcc.exe</span> (<span class="title">x86_64</span>-<span class="title">posix</span>-<span class="title">seh</span>-<span class="title">rev0</span>, <span class="title">Built</span> <span class="title">by</span> <span class="title">MinGW</span>-<span class="title">W64</span> <span class="title">project</span>) 8.1.0</span></span><br><span class="line"><span class="function"><span class="title">Copyright</span> (<span class="title">C</span>) 2018 <span class="title">Free</span> <span class="title">Software</span> <span class="title">Foundation</span>, <span class="title">Inc</span>.</span></span><br><span class="line"><span class="function"><span class="title">This</span> <span class="title">is</span> <span class="title">free</span> <span class="title">software</span>; <span class="title">see</span> <span class="title">the</span> <span class="title">source</span> <span class="title">for</span> <span class="title">copying</span> <span class="title">conditions</span>.  <span class="title">There</span> <span class="title">is</span> <span class="title">NO</span></span></span><br><span class="line"><span class="function"><span class="title">warranty</span>; <span class="title">not</span> <span class="title">even</span> <span class="title">for</span> <span class="title">MERCHANTABILITY</span> <span class="title">or</span> <span class="title">FITNESS</span> <span class="title">FOR</span> <span class="title">A</span> <span class="title">PARTICULAR</span> <span class="title">PURPOSE</span>.</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">C</span>:&gt;<span class="title">gcc</span> -<span class="title">E</span> -<span class="title">dM</span> - &lt; <span class="title">NUL</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__DBL_MIN_EXP__</span> (-1021)</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FLT32X_MAX_EXP__</span> 1024</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__UINT_LEAST16_MAX__</span> 0<span class="title">xffff</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__ATOMIC_ACQUIRE</span> 2</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FLT128_MAX_10_EXP__</span> 4932</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FLT_MIN__</span> 1.17549435082228750796873653722224568<span class="title">e</span>-38<span class="title">F</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__GCC_IEC_559_COMPLEX</span> 2</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__UINT_LEAST8_TYPE__</span> <span class="title">unsigned</span> <span class="title">char</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__SIZEOF_FLOAT80__</span> 16</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">_WIN32</span> 1</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__INTMAX_C</span>(<span class="title">c</span>) <span class="title">c</span> ## <span class="title">LL</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__CHAR_BIT__</span> 8</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__UINT8_MAX__</span> 0<span class="title">xff</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">_WIN64</span> 1</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__WINT_MAX__</span> 0<span class="title">xffff</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FLT32_MIN_EXP__</span> (-125)</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__ORDER_LITTLE_ENDIAN__</span> 1234</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__SIZE_MAX__</span> 0<span class="title">xffffffffffffffffULL</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__WCHAR_MAX__</span> 0<span class="title">xffff</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__GCC_HAVE_SYNC_COMPARE_AND_SWAP_1</span> 1</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__GCC_HAVE_SYNC_COMPARE_AND_SWAP_2</span> 1</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__GCC_HAVE_SYNC_COMPARE_AND_SWAP_4</span> 1</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__DBL_DENORM_MIN__</span> ((<span class="title">double</span>)4.94065645841246544176568792868221372<span class="title">e</span>-324<span class="title">L</span>)</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__GCC_HAVE_SYNC_COMPARE_AND_SWAP_8</span> 1</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__GCC_ATOMIC_CHAR_LOCK_FREE</span> 2</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__GCC_IEC_559</span> 2</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FLT32X_DECIMAL_DIG__</span> 17</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FLT_EVAL_METHOD__</span> 0</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FLT64_DECIMAL_DIG__</span> 17</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__GCC_ATOMIC_CHAR32_T_LOCK_FREE</span> 2</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__x86_64</span> 1</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__UINT_FAST64_MAX__</span> 0<span class="title">xffffffffffffffffULL</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__SIG_ATOMIC_TYPE__</span> <span class="title">int</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__DBL_MIN_10_EXP__</span> (-307)</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FINITE_MATH_ONLY__</span> 0</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__GNUC_PATCHLEVEL__</span> 0</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FLT32_HAS_DENORM__</span> 1</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__UINT_FAST8_MAX__</span> 0<span class="title">xff</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__has_include</span>(<span class="title">STR</span>) <span class="title">__has_include__</span>(<span class="title">STR</span>)</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">_stdcall</span> <span class="title">__attribute__</span>((<span class="title">__stdcall__</span>))</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__DEC64_MAX_EXP__</span> 385</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__INT8_C</span>(<span class="title">c</span>) <span class="title">c</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__INT_LEAST8_WIDTH__</span> 8</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__UINT_LEAST64_MAX__</span> 0<span class="title">xffffffffffffffffULL</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__SHRT_MAX__</span> 0<span class="title">x7fff</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__LDBL_MAX__</span> 1.18973149535723176502126385303097021<span class="title">e</span>+4932<span class="title">L</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FLT64X_MAX_10_EXP__</span> 4932</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__UINT_LEAST8_MAX__</span> 0<span class="title">xff</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__GCC_ATOMIC_BOOL_LOCK_FREE</span> 2</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FLT128_DENORM_MIN__</span> 6.47517511943802511092443895822764655<span class="title">e</span>-4966<span class="title">F128</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__UINTMAX_TYPE__</span> <span class="title">long</span> <span class="title">long</span> <span class="title">unsigned</span> <span class="title">int</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__DEC32_EPSILON__</span> 1<span class="title">E</span>-6<span class="title">DF</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FLT_EVAL_METHOD_TS_18661_3__</span> 0</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__UINT32_MAX__</span> 0<span class="title">xffffffffU</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__LDBL_MAX_EXP__</span> 16384</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FLT128_MIN_EXP__</span> (-16381)</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__WINT_MIN__</span> 0</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FLT128_MIN_10_EXP__</span> (-4931)</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__INT_LEAST16_WIDTH__</span> 16</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__SCHAR_MAX__</span> 0<span class="title">x7f</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FLT128_MANT_DIG__</span> 113</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__WCHAR_MIN__</span> 0</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__INT64_C</span>(<span class="title">c</span>) <span class="title">c</span> ## <span class="title">LL</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__DBL_DIG__</span> 15</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__GCC_ATOMIC_POINTER_LOCK_FREE</span> 2</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FLT64X_MANT_DIG__</span> 64</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__SIZEOF_INT__</span> 4</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__SIZEOF_POINTER__</span> 8</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__USER_LABEL_PREFIX__</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FLT64X_EPSILON__</span> 1.08420217248550443400745280086994171<span class="title">e</span>-19<span class="title">F64x</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__STDC_HOSTED__</span> 1</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__WIN32</span> 1</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__LDBL_HAS_INFINITY__</span> 1</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__WIN64</span> 1</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FLT32_DIG__</span> 6</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FLT_EPSILON__</span> 1.19209289550781250000000000000000000<span class="title">e</span>-7<span class="title">F</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__SHRT_WIDTH__</span> 16</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__LDBL_MIN__</span> 3.36210314311209350626267781732175260<span class="title">e</span>-4932<span class="title">L</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__STDC_UTF_16__</span> 1</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__DEC32_MAX__</span> 9.999999<span class="title">E96DF</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FLT64X_DENORM_MIN__</span> 3.64519953188247460252840593361941982<span class="title">e</span>-4951<span class="title">F64x</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__MINGW32__</span> 1</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FLT32X_HAS_INFINITY__</span> 1</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__INT32_MAX__</span> 0<span class="title">x7fffffff</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__INT_WIDTH__</span> 32</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__SIZEOF_LONG__</span> 4</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__UINT16_C</span>(<span class="title">c</span>) <span class="title">c</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__PTRDIFF_WIDTH__</span> 64</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__DECIMAL_DIG__</span> 21</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FLT64_EPSILON__</span> 2.22044604925031308084726333618164062<span class="title">e</span>-16<span class="title">F64</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__INTMAX_WIDTH__</span> 64</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__has_include_next</span>(<span class="title">STR</span>) <span class="title">__has_include_next__</span>(<span class="title">STR</span>)</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FLT64X_MIN_10_EXP__</span> (-4931)</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__LDBL_HAS_QUIET_NAN__</span> 1</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FLT64_MANT_DIG__</span> 53</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">_REENTRANT</span> 1</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__GNUC__</span> 8</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">_cdecl</span> <span class="title">__attribute__</span>((<span class="title">__cdecl__</span>))</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__MMX__</span> 1</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FLT_HAS_DENORM__</span> 1</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__SIZEOF_LONG_DOUBLE__</span> 16</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__BIGGEST_ALIGNMENT__</span> 16</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FLT64_MAX_10_EXP__</span> 308</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__DBL_MAX__</span> ((<span class="title">double</span>)1.79769313486231570814527423731704357<span class="title">e</span>+308<span class="title">L</span>)</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">_thiscall</span> <span class="title">__attribute__</span>((<span class="title">__thiscall__</span>))</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__INT_FAST32_MAX__</span> 0<span class="title">x7fffffff</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__WINNT</span> 1</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__DBL_HAS_INFINITY__</span> 1</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__WINNT__</span> 1</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__DEC32_MIN_EXP__</span> (-94)</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__INTPTR_WIDTH__</span> 64</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FLT32X_HAS_DENORM__</span> 1</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__INT_FAST16_TYPE__</span> <span class="title">short</span> <span class="title">int</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">_fastcall</span> <span class="title">__attribute__</span>((<span class="title">__fastcall__</span>))</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__LDBL_HAS_DENORM__</span> 1</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FLT128_HAS_INFINITY__</span> 1</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__DEC128_MAX__</span> 9.999999999999999999999999999999999<span class="title">E6144DL</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__INT_LEAST32_MAX__</span> 0<span class="title">x7fffffff</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__DEC32_MIN__</span> 1<span class="title">E</span>-95<span class="title">DF</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__DBL_MAX_EXP__</span> 1024</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__WCHAR_WIDTH__</span> 16</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FLT32_MAX__</span> 3.40282346638528859811704183484516925<span class="title">e</span>+38<span class="title">F32</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__DEC128_EPSILON__</span> 1<span class="title">E</span>-33<span class="title">DL</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__SSE2_MATH__</span> 1</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__ATOMIC_HLE_RELEASE</span> 131072</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__WIN32__</span> 1</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__PTRDIFF_MAX__</span> 0<span class="title">x7fffffffffffffffLL</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__amd64</span> 1</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__tune_core2__</span> 1</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__ATOMIC_HLE_ACQUIRE</span> 65536</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FLT32_HAS_QUIET_NAN__</span> 1</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__LONG_LONG_MAX__</span> 0<span class="title">x7fffffffffffffffLL</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__SIZEOF_SIZE_T__</span> 8</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FLT64X_MIN_EXP__</span> (-16381)</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__SIZEOF_WINT_T__</span> 2</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__LONG_LONG_WIDTH__</span> 64</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FLT32_MAX_EXP__</span> 128</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__GXX_ABI_VERSION</span> 1012</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FLT_MIN_EXP__</span> (-125)</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FLT64X_HAS_QUIET_NAN__</span> 1</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__INT_FAST64_TYPE__</span> <span class="title">long</span> <span class="title">long</span> <span class="title">int</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FLT64_DENORM_MIN__</span> 4.94065645841246544176568792868221372<span class="title">e</span>-324<span class="title">F64</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__DBL_MIN__</span> ((<span class="title">double</span>)2.22507385850720138309023271733240406<span class="title">e</span>-308<span class="title">L</span>)</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FLT32X_EPSILON__</span> 2.22044604925031308084726333618164062<span class="title">e</span>-16<span class="title">F32x</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__DECIMAL_BID_FORMAT__</span> 1</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FLT64_MIN_EXP__</span> (-1021)</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__GXX_TYPEINFO_EQUALITY_INLINE</span> 0</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FLT64_MIN_10_EXP__</span> (-307)</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FLT64X_DECIMAL_DIG__</span> 21</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__DEC128_MIN__</span> 1<span class="title">E</span>-6143<span class="title">DL</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__REGISTER_PREFIX__</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__UINT16_MAX__</span> 0<span class="title">xffff</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__DBL_HAS_DENORM__</span> 1</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__cdecl</span> <span class="title">__attribute__</span>((<span class="title">__cdecl__</span>))</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FLT32_MIN__</span> 1.17549435082228750796873653722224568<span class="title">e</span>-38<span class="title">F32</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__UINT8_TYPE__</span> <span class="title">unsigned</span> <span class="title">char</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__NO_INLINE__</span> 1</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FLT_MANT_DIG__</span> 24</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__LDBL_DECIMAL_DIG__</span> 21</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__VERSION__</span> &quot;8.1.0&quot;</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__UINT64_C</span>(<span class="title">c</span>) <span class="title">c</span> ## <span class="title">ULL</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__GCC_ATOMIC_INT_LOCK_FREE</span> 2</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FLT128_MAX_EXP__</span> 16384</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FLT32_MANT_DIG__</span> 24</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FLOAT_WORD_ORDER__</span> <span class="title">__ORDER_LITTLE_ENDIAN__</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FLT128_HAS_DENORM__</span> 1</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FLT128_DIG__</span> 33</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__SCHAR_WIDTH__</span> 8</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__INT32_C</span>(<span class="title">c</span>) <span class="title">c</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__DEC64_EPSILON__</span> 1<span class="title">E</span>-15<span class="title">DD</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__ORDER_PDP_ENDIAN__</span> 3412</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__DEC128_MIN_EXP__</span> (-6142)</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FLT32_MAX_10_EXP__</span> 38</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__INT_FAST32_TYPE__</span> <span class="title">int</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__UINT_LEAST16_TYPE__</span> <span class="title">short</span> <span class="title">unsigned</span> <span class="title">int</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FLT64X_HAS_INFINITY__</span> 1</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__INT16_MAX__</span> 0<span class="title">x7fff</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__SIZE_TYPE__</span> <span class="title">long</span> <span class="title">long</span> <span class="title">unsigned</span> <span class="title">int</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__UINT64_MAX__</span> 0<span class="title">xffffffffffffffffULL</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FLT64X_DIG__</span> 18</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__INT8_TYPE__</span> <span class="title">signed</span> <span class="title">char</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__GCC_ASM_FLAG_OUTPUTS__</span> 1</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FLT_RADIX__</span> 2</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__INT_LEAST16_TYPE__</span> <span class="title">short</span> <span class="title">int</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__LDBL_EPSILON__</span> 1.08420217248550443400745280086994171<span class="title">e</span>-19<span class="title">L</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__UINTMAX_C</span>(<span class="title">c</span>) <span class="title">c</span> ## <span class="title">ULL</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__SSE_MATH__</span> 1</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__SEH__</span> 1</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__SIG_ATOMIC_MAX__</span> 0<span class="title">x7fffffff</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__GCC_ATOMIC_WCHAR_T_LOCK_FREE</span> 2</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__SIZEOF_PTRDIFF_T__</span> 8</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FLT32X_MANT_DIG__</span> 53</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__x86_64__</span> 1</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FLT32X_MIN_EXP__</span> (-1021)</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__DEC32_SUBNORMAL_MIN__</span> 0.000001<span class="title">E</span>-95<span class="title">DF</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__MSVCRT__</span> 1</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__INT_FAST16_MAX__</span> 0<span class="title">x7fff</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FLT64_DIG__</span> 15</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__UINT_FAST32_MAX__</span> 0<span class="title">xffffffffU</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__UINT_LEAST64_TYPE__</span> <span class="title">long</span> <span class="title">long</span> <span class="title">unsigned</span> <span class="title">int</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FLT_HAS_QUIET_NAN__</span> 1</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FLT_MAX_10_EXP__</span> 38</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__LONG_MAX__</span> 0<span class="title">x7fffffffL</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FLT64X_HAS_DENORM__</span> 1</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__DEC128_SUBNORMAL_MIN__</span> 0.000000000000000000000000000000001<span class="title">E</span>-6143<span class="title">DL</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FLT_HAS_INFINITY__</span> 1</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__UINT_FAST16_TYPE__</span> <span class="title">short</span> <span class="title">unsigned</span> <span class="title">int</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__DEC64_MAX__</span> 9.999999999999999<span class="title">E384DD</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__INT_FAST32_WIDTH__</span> 32</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__CHAR16_TYPE__</span> <span class="title">short</span> <span class="title">unsigned</span> <span class="title">int</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__PRAGMA_REDEFINE_EXTNAME</span> 1</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__SIZE_WIDTH__</span> 64</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__SEG_FS</span> 1</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__INT_LEAST16_MAX__</span> 0<span class="title">x7fff</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__DEC64_MANT_DIG__</span> 16</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__INT64_MAX__</span> 0<span class="title">x7fffffffffffffffLL</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__UINT_LEAST32_MAX__</span> 0<span class="title">xffffffffU</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__SEG_GS</span> 1</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FLT32_DENORM_MIN__</span> 1.40129846432481707092372958328991613<span class="title">e</span>-45<span class="title">F32</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__GCC_ATOMIC_LONG_LOCK_FREE</span> 2</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__SIG_ATOMIC_WIDTH__</span> 32</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__INT_LEAST64_TYPE__</span> <span class="title">long</span> <span class="title">long</span> <span class="title">int</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__INT16_TYPE__</span> <span class="title">short</span> <span class="title">int</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__INT_LEAST8_TYPE__</span> <span class="title">signed</span> <span class="title">char</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__STDC_VERSION__</span> 201710<span class="title">L</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__DEC32_MAX_EXP__</span> 97</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__INT_FAST8_MAX__</span> 0<span class="title">x7f</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FLT128_MAX__</span> 1.18973149535723176508575932662800702<span class="title">e</span>+4932<span class="title">F128</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__INTPTR_MAX__</span> 0<span class="title">x7fffffffffffffffLL</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__GXX_MERGED_TYPEINFO_NAMES</span> 0</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FLT64_HAS_QUIET_NAN__</span> 1</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__stdcall</span> <span class="title">__attribute__</span>((<span class="title">__stdcall__</span>))</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FLT32_MIN_10_EXP__</span> (-37)</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__SSE2__</span> 1</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FLT32X_DIG__</span> 15</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__LDBL_MANT_DIG__</span> 64</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__DBL_HAS_QUIET_NAN__</span> 1</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FLT64_HAS_INFINITY__</span> 1</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FLT64X_MAX__</span> 1.18973149535723176502126385303097021<span class="title">e</span>+4932<span class="title">F64x</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__SIG_ATOMIC_MIN__</span> (-<span class="title">__SIG_ATOMIC_MAX__</span> - 1)</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__INTPTR_TYPE__</span> <span class="title">long</span> <span class="title">long</span> <span class="title">int</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__UINT16_TYPE__</span> <span class="title">short</span> <span class="title">unsigned</span> <span class="title">int</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__WCHAR_TYPE__</span> <span class="title">short</span> <span class="title">unsigned</span> <span class="title">int</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__SIZEOF_FLOAT__</span> 4</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__pic__</span> 1</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__UINTPTR_MAX__</span> 0<span class="title">xffffffffffffffffULL</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__INT_FAST64_WIDTH__</span> 64</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__DEC64_MIN_EXP__</span> (-382)</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FLT32_DECIMAL_DIG__</span> 9</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__INT_FAST64_MAX__</span> 0<span class="title">x7fffffffffffffffLL</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__GCC_ATOMIC_TEST_AND_SET_TRUEVAL</span> 1</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FLT_DIG__</span> 6</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FLT32_HAS_INFINITY__</span> 1</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FLT64X_MAX_EXP__</span> 16384</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__UINT_FAST64_TYPE__</span> <span class="title">long</span> <span class="title">long</span> <span class="title">unsigned</span> <span class="title">int</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__INT_MAX__</span> 0<span class="title">x7fffffff</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__amd64__</span> 1</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">WIN32</span> 1</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__nocona</span> 1</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__code_model_medium__</span> 1</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__INT64_TYPE__</span> <span class="title">long</span> <span class="title">long</span> <span class="title">int</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FLT_MAX_EXP__</span> 128</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">WIN64</span> 1</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__ORDER_BIG_ENDIAN__</span> 4321</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__DBL_MANT_DIG__</span> 53</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__SIZEOF_FLOAT128__</span> 16</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__INT_LEAST64_MAX__</span> 0<span class="title">x7fffffffffffffffLL</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__GCC_ATOMIC_CHAR16_T_LOCK_FREE</span> 2</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__DEC64_MIN__</span> 1<span class="title">E</span>-383<span class="title">DD</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__WINT_TYPE__</span> <span class="title">short</span> <span class="title">unsigned</span> <span class="title">int</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__UINT_LEAST32_TYPE__</span> <span class="title">unsigned</span> <span class="title">int</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__SIZEOF_SHORT__</span> 2</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__SSE__</span> 1</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__LDBL_MIN_EXP__</span> (-16381)</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FLT64_MAX__</span> 1.79769313486231570814527423731704357<span class="title">e</span>+308<span class="title">F64</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__WINT_WIDTH__</span> 16</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__INT_LEAST8_MAX__</span> 0<span class="title">x7f</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FLT32X_MAX_10_EXP__</span> 308</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__SIZEOF_INT128__</span> 16</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__LDBL_MAX_10_EXP__</span> 4932</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__ATOMIC_RELAXED</span> 0</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__DBL_EPSILON__</span> ((<span class="title">double</span>)2.22044604925031308084726333618164062<span class="title">e</span>-16<span class="title">L</span>)</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__thiscall</span> <span class="title">__attribute__</span>((<span class="title">__thiscall__</span>))</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FLT128_MIN__</span> 3.36210314311209350626267781732175260<span class="title">e</span>-4932<span class="title">F128</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__UINT8_C</span>(<span class="title">c</span>) <span class="title">c</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FLT64_MAX_EXP__</span> 1024</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__INT_LEAST32_TYPE__</span> <span class="title">int</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__SIZEOF_WCHAR_T__</span> 2</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__UINT64_TYPE__</span> <span class="title">long</span> <span class="title">long</span> <span class="title">unsigned</span> <span class="title">int</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FLT128_HAS_QUIET_NAN__</span> 1</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__INT_FAST8_TYPE__</span> <span class="title">signed</span> <span class="title">char</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__fastcall</span> <span class="title">__attribute__</span>((<span class="title">__fastcall__</span>))</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FLT64X_MIN__</span> 3.36210314311209350626267781732175260<span class="title">e</span>-4932<span class="title">F64x</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__GNUC_STDC_INLINE__</span> 1</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FLT64_HAS_DENORM__</span> 1</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FLT32_EPSILON__</span> 1.19209289550781250000000000000000000<span class="title">e</span>-7<span class="title">F32</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__DBL_DECIMAL_DIG__</span> 17</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__STDC_UTF_32__</span> 1</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__INT_FAST8_WIDTH__</span> 8</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FXSR__</span> 1</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__DEC_EVAL_METHOD__</span> 2</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FLT32X_MAX__</span> 1.79769313486231570814527423731704357<span class="title">e</span>+308<span class="title">F32x</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__MINGW64__</span> 1</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__UINT32_C</span>(<span class="title">c</span>) <span class="title">c</span> ## <span class="title">U</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__INTMAX_MAX__</span> 0<span class="title">x7fffffffffffffffLL</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__BYTE_ORDER__</span> <span class="title">__ORDER_LITTLE_ENDIAN__</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">WINNT</span> 1</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FLT_DENORM_MIN__</span> 1.40129846432481707092372958328991613<span class="title">e</span>-45<span class="title">F</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__INT8_MAX__</span> 0<span class="title">x7f</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__LONG_WIDTH__</span> 32</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__PIC__</span> 1</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__UINT_FAST32_TYPE__</span> <span class="title">unsigned</span> <span class="title">int</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__CHAR32_TYPE__</span> <span class="title">unsigned</span> <span class="title">int</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FLT_MAX__</span> 3.40282346638528859811704183484516925<span class="title">e</span>+38<span class="title">F</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__INT32_TYPE__</span> <span class="title">int</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__SIZEOF_DOUBLE__</span> 8</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FLT_MIN_10_EXP__</span> (-37)</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FLT64_MIN__</span> 2.22507385850720138309023271733240406<span class="title">e</span>-308<span class="title">F64</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__INT_LEAST32_WIDTH__</span> 32</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__INTMAX_TYPE__</span> <span class="title">long</span> <span class="title">long</span> <span class="title">int</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">_INTEGRAL_MAX_BITS</span> 64</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__DEC128_MAX_EXP__</span> 6145</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FLT32X_HAS_QUIET_NAN__</span> 1</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__ATOMIC_CONSUME</span> 1</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__nocona__</span> 1</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__GNUC_MINOR__</span> 1</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__INT_FAST16_WIDTH__</span> 16</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__UINTMAX_MAX__</span> 0<span class="title">xffffffffffffffffULL</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__DEC32_MANT_DIG__</span> 7</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FLT32X_DENORM_MIN__</span> 4.94065645841246544176568792868221372<span class="title">e</span>-324<span class="title">F32x</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__DBL_MAX_10_EXP__</span> 308</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__LDBL_DENORM_MIN__</span> 3.64519953188247460252840593361941982<span class="title">e</span>-4951<span class="title">L</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__INT16_C</span>(<span class="title">c</span>) <span class="title">c</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__STDC__</span> 1</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__PTRDIFF_TYPE__</span> <span class="title">long</span> <span class="title">long</span> <span class="title">int</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__ATOMIC_SEQ_CST</span> 5</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__GCC_HAVE_SYNC_COMPARE_AND_SWAP_16</span> 1</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__UINT32_TYPE__</span> <span class="title">unsigned</span> <span class="title">int</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FLT32X_MIN_10_EXP__</span> (-307)</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__UINTPTR_TYPE__</span> <span class="title">long</span> <span class="title">long</span> <span class="title">unsigned</span> <span class="title">int</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__DEC64_SUBNORMAL_MIN__</span> 0.000000000000001<span class="title">E</span>-383<span class="title">DD</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__DEC128_MANT_DIG__</span> 34</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__LDBL_MIN_10_EXP__</span> (-4931)</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FLT128_EPSILON__</span> 1.92592994438723585305597794258492732<span class="title">e</span>-34<span class="title">F128</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__SIZEOF_LONG_LONG__</span> 8</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FLT128_DECIMAL_DIG__</span> 36</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__GCC_ATOMIC_LLONG_LOCK_FREE</span> 2</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FLT32X_MIN__</span> 2.22507385850720138309023271733240406<span class="title">e</span>-308<span class="title">F32x</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__LDBL_DIG__</span> 18</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__FLT_DECIMAL_DIG__</span> 9</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__UINT_FAST16_MAX__</span> 0<span class="title">xffff</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__GCC_ATOMIC_SHORT_LOCK_FREE</span> 2</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__INT_LEAST64_WIDTH__</span> 64</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__SSE3__</span> 1</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__UINT_FAST8_TYPE__</span> <span class="title">unsigned</span> <span class="title">char</span></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__WIN64__</span> 1</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__ATOMIC_ACQ_REL</span> 4</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__ATOMIC_RELEASE</span> 3</span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">__declspec</span>(<span class="title">x</span>) <span class="title">__attribute__</span>((<span class="title">x</span>))</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>编译工具</category>
      </categories>
      <tags>
        <tag>gcc</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenGL历史与API变化</title>
    <url>/post/32043.html</url>
    <content><![CDATA[<p>OpenGL API在不同的版本中的扩展。</p>
<span id="more"></span>

<h2 id="OpenGL-4-6-2017"><a href="#OpenGL-4-6-2017" class="headerlink" title="OpenGL 4.6 (2017)"></a>OpenGL 4.6 (2017)</h2><table>
<thead>
<tr>
<th>Addition</th>
<th><span class="exturl" data-url="aHR0cHM6Ly93d3cua2hyb25vcy5vcmcvb3BlbmdsL3dpa2kvRXh0ZW5zaW9uI0NvcmVfRXh0ZW5zaW9ucw==">Core Extension<i class="fa fa-external-link-alt"></i></span></th>
</tr>
</thead>
<tbody><tr>
<td>The <span class="exturl" data-url="aHR0cHM6Ly93d3cua2hyb25vcy5vcmcvb3BlbmdsL3dpa2kvU1BJUi1W">SPIR-V<i class="fa fa-external-link-alt"></i></span> language can be used to define shaders.</td>
<td><span class="exturl" data-url="aHR0cDovL3d3dy5vcGVuZ2wub3JnL3JlZ2lzdHJ5L3NwZWNzL0FSQi9nbF9zcGlydi50eHQ=">ARB_gl_spirv<i class="fa fa-external-link-alt"></i></span>, <span class="exturl" data-url="aHR0cDovL3d3dy5vcGVuZ2wub3JnL3JlZ2lzdHJ5L3NwZWNzL0FSQi9zcGlydl9leHRlbnNpb25zLnR4dA==">ARB_spirv_extensions<i class="fa fa-external-link-alt"></i></span></td>
</tr>
<tr>
<td><span class="exturl" data-url="aHR0cHM6Ly93d3cua2hyb25vcy5vcmcvb3BlbmdsL3dpa2kvVmVydGV4X1NoYWRlciNPdGhlcl9pbnB1dHM=">Vertex shaders<i class="fa fa-external-link-alt"></i></span> can get the draw ID and base vertex&#x2F;instance values from rendering commands.</td>
<td><span class="exturl" data-url="aHR0cDovL3d3dy5vcGVuZ2wub3JnL3JlZ2lzdHJ5L3NwZWNzL0FSQi9zaGFkZXJfZHJhd19wYXJhbWV0ZXJzLnR4dA==">ARB_shader_draw_parameters<i class="fa fa-external-link-alt"></i></span></td>
</tr>
<tr>
<td>Multi-draw indirect rendering commands that can fetch the number of draws from a buffer.</td>
<td><span class="exturl" data-url="aHR0cDovL3d3dy5vcGVuZ2wub3JnL3JlZ2lzdHJ5L3NwZWNzL0FSQi9pbmRpcmVjdF9wYXJhbWV0ZXJzLnR4dA==">ARB_indirect_parameters<i class="fa fa-external-link-alt"></i></span></td>
</tr>
<tr>
<td>Statistics and transform feedback overflow queries.</td>
<td><span class="exturl" data-url="aHR0cDovL3d3dy5vcGVuZ2wub3JnL3JlZ2lzdHJ5L3NwZWNzL0FSQi9waXBlbGluZV9zdGF0aXN0aWNzX3F1ZXJ5LnR4dA==">ARB_pipeline_statistics_query<i class="fa fa-external-link-alt"></i></span>, <span class="exturl" data-url="aHR0cDovL3d3dy5vcGVuZ2wub3JnL3JlZ2lzdHJ5L3NwZWNzL0FSQi90cmFuc2Zvcm1fZmVlZGJhY2tfb3ZlcmZsb3dfcXVlcnkudHh0">ARB_transform_feedback_overflow_query<i class="fa fa-external-link-alt"></i></span></td>
</tr>
<tr>
<td><span class="exturl" data-url="aHR0cHM6Ly93d3cua2hyb25vcy5vcmcvb3BlbmdsL3dpa2kvQW5pc290cm9waWNfRmlsdGVyaW5n">Anisotropic Filtering<i class="fa fa-external-link-alt"></i></span></td>
<td><span class="exturl" data-url="aHR0cDovL3d3dy5vcGVuZ2wub3JnL3JlZ2lzdHJ5L3NwZWNzL0FSQi90ZXh0dXJlX2ZpbHRlcl9hbmlzb3Ryb3BpYy50eHQ=">ARB_texture_filter_anisotropic<i class="fa fa-external-link-alt"></i></span></td>
</tr>
<tr>
<td>Clamping polygon offsets</td>
<td><span class="exturl" data-url="aHR0cDovL3d3dy5vcGVuZ2wub3JnL3JlZ2lzdHJ5L3NwZWNzL0FSQi9wb2x5Z29uX29mZnNldF9jbGFtcC50eHQ=">ARB_polygon_offset_clamp<i class="fa fa-external-link-alt"></i></span></td>
</tr>
<tr>
<td><span class="exturl" data-url="aHR0cHM6Ly93d3cua2hyb25vcy5vcmcvb3BlbmdsL3dpa2kvT3BlbkdMX0NvbnRleHQ=">OpenGL Contexts<i class="fa fa-external-link-alt"></i></span> can be created that <span class="exturl" data-url="aHR0cHM6Ly93d3cua2hyb25vcy5vcmcvb3BlbmdsL3dpa2kvT3BlbkdMX0Vycm9yI05vX2Vycm9yX2NvbnRleHRz">do not report errors<i class="fa fa-external-link-alt"></i></span> of any kind.</td>
<td><span class="exturl" data-url="aHR0cDovL3d3dy5vcGVuZ2wub3JnL3JlZ2lzdHJ5L3NwZWNzL0tIUi9ub19lcnJvci50eHQ=">KHR_no_error<i class="fa fa-external-link-alt"></i></span></td>
</tr>
<tr>
<td>More operations for <span class="exturl" data-url="aHR0cHM6Ly93d3cua2hyb25vcy5vcmcvb3BlbmdsL3dpa2kvQXRvbWljX0NvdW50ZXI=">Atomic Counters<i class="fa fa-external-link-alt"></i></span>.</td>
<td><span class="exturl" data-url="aHR0cDovL3d3dy5vcGVuZ2wub3JnL3JlZ2lzdHJ5L3NwZWNzL0FSQi9zaGFkZXJfYXRvbWljX2NvdW50ZXJfb3BzLnR4dA==">ARB_shader_atomic_counter_ops<i class="fa fa-external-link-alt"></i></span></td>
</tr>
<tr>
<td>Avoiding divergent shader invocations, where they are unnecessary.</td>
<td><span class="exturl" data-url="aHR0cDovL3d3dy5vcGVuZ2wub3JnL3JlZ2lzdHJ5L3NwZWNzL0FSQi9zaGFkZXJfZ3JvdXBfdm90ZS50eHQ=">ARB_shader_group_vote<i class="fa fa-external-link-alt"></i></span></td>
</tr>
</tbody></table>
<p>Links:</p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9raHJvbm9zLm9yZy9yZWdpc3RyeS9PcGVuR0wvc3BlY3MvZ2wvZ2xzcGVjNDYuY29yZS5wZGY=">OpenGL 4.6 Core Profile Specification<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9raHJvbm9zLm9yZy9yZWdpc3RyeS9PcGVuR0wvc3BlY3MvZ2wvZ2xzcGVjNDYuY29tcGF0aWJpbGl0eS5wZGY=">OpenGL 4.6 Compatibility Profile Specification<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9raHJvbm9zLm9yZy9yZWdpc3RyeS9PcGVuR0wvc3BlY3MvZ2wvR0xTTGFuZ1NwZWMuNC42MC5wZGY=">OpenGL Shading Language 4.60 Specification<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<h2 id="OpenGL-4-5-2014"><a href="#OpenGL-4-5-2014" class="headerlink" title="OpenGL 4.5 (2014)"></a>OpenGL 4.5 (2014)</h2><table>
<thead>
<tr>
<th>Addition</th>
<th><span class="exturl" data-url="aHR0cHM6Ly93d3cua2hyb25vcy5vcmcvb3BlbmdsL3dpa2kvRXh0ZW5zaW9uI0NvcmVfRXh0ZW5zaW9ucw==">Core Extension<i class="fa fa-external-link-alt"></i></span></th>
</tr>
</thead>
<tbody><tr>
<td>Additional clip control modes to configure how clip space is mapped to window space.</td>
<td><span class="exturl" data-url="aHR0cDovL3d3dy5vcGVuZ2wub3JnL3JlZ2lzdHJ5L3NwZWNzL0FSQi9jbGlwX2NvbnRyb2wudHh0">ARB_clip_control<i class="fa fa-external-link-alt"></i></span></td>
</tr>
<tr>
<td>Adds a new GLSL gl_CullDistance shader output, similar to gl_ClipDistance, but used for whole primitive culling.</td>
<td><span class="exturl" data-url="aHR0cDovL3d3dy5vcGVuZ2wub3JnL3JlZ2lzdHJ5L3NwZWNzL0FSQi9jdWxsX2Rpc3RhbmNlLnR4dA==">ARB_cull_distance<i class="fa fa-external-link-alt"></i></span></td>
</tr>
<tr>
<td>Compatibility with OpenGL ES 3.1</td>
<td><span class="exturl" data-url="aHR0cDovL3d3dy5vcGVuZ2wub3JnL3JlZ2lzdHJ5L3NwZWNzL0FSQi9FUzNfMV9jb21wYXRpYmlsaXR5LnR4dA==">ARB_ES3_1_compatibility<i class="fa fa-external-link-alt"></i></span></td>
</tr>
<tr>
<td>Adds new modes to <span class="exturl" data-url="aHR0cHM6Ly93d3cua2hyb25vcy5vcmcvb3BlbmdsL3dpa2kvR0xBUEkvZ2xCZWdpbkNvbmRpdGlvbmFsUmVuZGVy">glBeginConditionalRender<i class="fa fa-external-link-alt"></i></span> which invert condition used to determine whether to draw or not.</td>
<td><span class="exturl" data-url="aHR0cDovL3d3dy5vcGVuZ2wub3JnL3JlZ2lzdHJ5L3NwZWNzL0FSQi9jb25kaXRpb25hbF9yZW5kZXJfaW52ZXJ0ZWQudHh0">ARB_conditional_render_inverted<i class="fa fa-external-link-alt"></i></span></td>
</tr>
<tr>
<td>Provides control over the spacial granularity at which the underlying implementation computes derivatives.</td>
<td><span class="exturl" data-url="aHR0cDovL3d3dy5vcGVuZ2wub3JnL3JlZ2lzdHJ5L3NwZWNzL0FSQi9kZXJpdmF0aXZlX2NvbnRyb2wudHh0">ARB_derivative_control<i class="fa fa-external-link-alt"></i></span></td>
</tr>
<tr>
<td>Allows <span class="exturl" data-url="aHR0cHM6Ly93d3cua2hyb25vcy5vcmcvb3BlbmdsL3dpa2kvRGlyZWN0X1N0YXRlX0FjY2Vzcw==">modifying and querying object state without binding objects<i class="fa fa-external-link-alt"></i></span>.</td>
<td><span class="exturl" data-url="aHR0cDovL3d3dy5vcGVuZ2wub3JnL3JlZ2lzdHJ5L3NwZWNzL0FSQi9kaXJlY3Rfc3RhdGVfYWNjZXNzLnR4dA==">ARB_direct_state_access<i class="fa fa-external-link-alt"></i></span></td>
</tr>
<tr>
<td>Adds a new function to get sub-regions of texture images.</td>
<td><span class="exturl" data-url="aHR0cDovL3d3dy5vcGVuZ2wub3JnL3JlZ2lzdHJ5L3NwZWNzL0FSQi9nZXRfdGV4dHVyZV9zdWJfaW1hZ2UudHh0">ARB_get_texture_sub_image<i class="fa fa-external-link-alt"></i></span></td>
</tr>
<tr>
<td>Upgrades the <span class="exturl" data-url="aHR0cDovL3d3dy5vcGVuZ2wub3JnL3JlZ2lzdHJ5L3NwZWNzL0FSQi9yb2J1c3RuZXNzLnR4dA==">ARB_robustness<i class="fa fa-external-link-alt"></i></span> functionality to meet ES 3.1 standards.</td>
<td><span class="exturl" data-url="aHR0cDovL3d3dy5vcGVuZ2wub3JnL3JlZ2lzdHJ5L3NwZWNzL0tIUi9yb2J1c3RuZXNzLnR4dA==">KHR_robustness<i class="fa fa-external-link-alt"></i></span></td>
</tr>
<tr>
<td>Provides GLSL built-in functions allowing shaders to query the number of samples of a texture.</td>
<td><span class="exturl" data-url="aHR0cDovL3d3dy5vcGVuZ2wub3JnL3JlZ2lzdHJ5L3NwZWNzL0FSQi9zaGFkZXJfdGV4dHVyZV9pbWFnZV9zYW1wbGVzLnR4dA==">ARB_shader_texture_image_samples<i class="fa fa-external-link-alt"></i></span></td>
</tr>
<tr>
<td>Relaxes the restrictions on rendering to a currently bound texture and <span class="exturl" data-url="aHR0cHM6Ly93d3cua2hyb25vcy5vcmcvb3BlbmdsL3dpa2kvVGV4dHVyZV9CYXJyaWVy">provides a mechanism to avoid read-after-write hazards<i class="fa fa-external-link-alt"></i></span>.</td>
<td><span class="exturl" data-url="aHR0cDovL3d3dy5vcGVuZ2wub3JnL3JlZ2lzdHJ5L3NwZWNzL0FSQi90ZXh0dXJlX2JhcnJpZXIudHh0">ARB_texture_barrier<i class="fa fa-external-link-alt"></i></span></td>
</tr>
</tbody></table>
<p>Links:</p>
<ul>
<li><span class="exturl" data-url="aHR0cDovL3d3dy5vcGVuZ2wub3JnL3JlZ2lzdHJ5L2RvYy9nbHNwZWM0NS5jb3JlLnBkZg==">OpenGL 4.5 Core Profile Specification<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL3d3dy5vcGVuZ2wub3JnL3JlZ2lzdHJ5L2RvYy9nbHNwZWM0NS5jb21wYXRpYmlsaXR5LnBkZg==">OpenGL 4.5 Compatibility Profile Specification<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL3d3dy5vcGVuZ2wub3JnL3JlZ2lzdHJ5L2RvYy9HTFNMYW5nU3BlYy40LjUwLnBkZg==">OpenGL Shading Language 4.50 Specification<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<h2 id="OpenGL-4-4-2013"><a href="#OpenGL-4-4-2013" class="headerlink" title="OpenGL 4.4 (2013)"></a>OpenGL 4.4 (2013)</h2><table>
<thead>
<tr>
<th>Addition</th>
<th><span class="exturl" data-url="aHR0cHM6Ly93d3cua2hyb25vcy5vcmcvb3BlbmdsL3dpa2kvRXh0ZW5zaW9uI0NvcmVfRXh0ZW5zaW9ucw==">Core Extension<i class="fa fa-external-link-alt"></i></span></th>
</tr>
</thead>
<tbody><tr>
<td><span class="exturl" data-url="aHR0cHM6Ly93d3cua2hyb25vcy5vcmcvb3BlbmdsL3dpa2kvSW1tdXRhYmxlX0J1ZmZlcl9TdG9yYWdl">Immutable storage for buffer objects,<i class="fa fa-external-link-alt"></i></span> including the ability to use buffers while they are mapped.</td>
<td><span class="exturl" data-url="aHR0cDovL3d3dy5vcGVuZ2wub3JnL3JlZ2lzdHJ5L3NwZWNzL0FSQi9idWZmZXJfc3RvcmFnZS50eHQ=">ARB_buffer_storage<i class="fa fa-external-link-alt"></i></span></td>
</tr>
<tr>
<td><span class="exturl" data-url="aHR0cHM6Ly93d3cua2hyb25vcy5vcmcvb3BlbmdsL3dpa2kvQ2xlYXJfVGV4dHVyZQ==">Direct clearing of a texture image.<i class="fa fa-external-link-alt"></i></span></td>
<td><span class="exturl" data-url="aHR0cDovL3d3dy5vcGVuZ2wub3JnL3JlZ2lzdHJ5L3NwZWNzL0FSQi9jbGVhcl90ZXh0dXJlLnR4dA==">ARB_clear_texture<i class="fa fa-external-link-alt"></i></span></td>
</tr>
<tr>
<td><span class="exturl" data-url="aHR0cHM6Ly93d3cua2hyb25vcy5vcmcvb3BlbmdsL3dpa2kvTGF5b3V0X1F1YWxpZmllcl8oR0xTTCk=">A number of enhancements to layout qualifiers:<i class="fa fa-external-link-alt"></i></span> Integer layout qualifiers can take any <span class="exturl" data-url="aHR0cHM6Ly93d3cua2hyb25vcy5vcmcvb3BlbmdsL3dpa2kvQ29uc3RhbnRfRXhwcmVzc2lvbg==">constant expression<i class="fa fa-external-link-alt"></i></span>, not just integer literals. <span class="exturl" data-url="aHR0cHM6Ly93d3cua2hyb25vcy5vcmcvb3BlbmdsL3dpa2kvQnVmZmVyX0JhY2tlZF9JbnRlcmZhY2VfQmxvY2s=">Explicit layout requests for buffer-backed interface blocks.<i class="fa fa-external-link-alt"></i></span> <span class="exturl" data-url="aHR0cHM6Ly93d3cua2hyb25vcy5vcmcvb3BlbmdsL3dpa2kvTGF5b3V0X0NvbXBvbmVudA==">Tight packing of disparate input&#x2F;output variables<i class="fa fa-external-link-alt"></i></span>. <span class="exturl" data-url="aHR0cHM6Ly93d3cua2hyb25vcy5vcmcvb3BlbmdsL3dpa2kvRmVlZGJhY2tfSW5fU2hhZGVyX0JpbmRpbmc=">In-shader specification of transform feedback parameters.<i class="fa fa-external-link-alt"></i></span> <span class="exturl" data-url="aHR0cHM6Ly93d3cua2hyb25vcy5vcmcvb3BlbmdsL3dpa2kvTGF5b3V0X0Jsb2NrX01lbWJlcl9Mb2NhdGlvbg==">Locations can be set on input&#x2F;output interface blocks<i class="fa fa-external-link-alt"></i></span>, for packing purposes.</td>
<td><span class="exturl" data-url="aHR0cDovL3d3dy5vcGVuZ2wub3JnL3JlZ2lzdHJ5L3NwZWNzL0FSQi9lbmhhbmNlZF9sYXlvdXRzLnR4dA==">ARB_enhanced_layouts<i class="fa fa-external-link-alt"></i></span></td>
</tr>
<tr>
<td>Bind an <span class="exturl" data-url="aHR0cHM6Ly93d3cua2hyb25vcy5vcmcvb3BlbmdsL3dpa2kvTXVsdGliaW5k">array of objects of the same type to a sequential range of indexed binding targets<i class="fa fa-external-link-alt"></i></span> in one call.</td>
<td><span class="exturl" data-url="aHR0cDovL3d3dy5vcGVuZ2wub3JnL3JlZ2lzdHJ5L3NwZWNzL0FSQi9tdWx0aV9iaW5kLnR4dA==">ARB_multi_bind<i class="fa fa-external-link-alt"></i></span></td>
</tr>
<tr>
<td>Values from Query Objects values can be written to a <span class="exturl" data-url="aHR0cHM6Ly93d3cua2hyb25vcy5vcmcvb3BlbmdsL3dpa2kvUXVlcnlfQnVmZmVyX09iamVjdA==">buffer object instead of directly to client memory.<i class="fa fa-external-link-alt"></i></span></td>
<td><span class="exturl" data-url="aHR0cDovL3d3dy5vcGVuZ2wub3JnL3JlZ2lzdHJ5L3NwZWNzL0FSQi9xdWVyeV9idWZmZXJfb2JqZWN0LnR4dA==">ARB_query_buffer_object<i class="fa fa-external-link-alt"></i></span></td>
</tr>
<tr>
<td>A <span class="exturl" data-url="aHR0cHM6Ly93d3cua2hyb25vcy5vcmcvb3BlbmdsL3dpa2kvRWRnZV9TYW1wbGluZw==">special clamping mode<i class="fa fa-external-link-alt"></i></span> that doubles the size of the texture in each dimension, mirroring it exactly once in the negative texture coordinate directions.</td>
<td><span class="exturl" data-url="aHR0cDovL3d3dy5vcGVuZ2wub3JnL3JlZ2lzdHJ5L3NwZWNzL0FSQi90ZXh0dXJlX21pcnJvcl9jbGFtcF90b19lZGdlLnR4dA==">ARB_texture_mirror_clamp_to_edge<i class="fa fa-external-link-alt"></i></span></td>
</tr>
<tr>
<td>One of the <span class="exturl" data-url="aHR0cHM6Ly93d3cua2hyb25vcy5vcmcvb3BlbmdsL3dpa2kvU3RlbmNpbF9JbWFnZV9Gb3JtYXQ=">stencil-only image formats<i class="fa fa-external-link-alt"></i></span> can be used for textures, and 8-bit stencil is a <span class="exturl" data-url="aHR0cHM6Ly93d3cua2hyb25vcy5vcmcvb3BlbmdsL3dpa2kvUmVxdWlyZWRfSW1hZ2VfRm9ybWF0">required format<i class="fa fa-external-link-alt"></i></span>.</td>
<td><span class="exturl" data-url="aHR0cDovL3d3dy5vcGVuZ2wub3JnL3JlZ2lzdHJ5L3NwZWNzL0FSQi90ZXh0dXJlX3N0ZW5jaWw4LnR4dA==">ARB_texture_stencil8<i class="fa fa-external-link-alt"></i></span></td>
</tr>
<tr>
<td>Provides a packed, 3-component 11F&#x2F;11F&#x2F;10F format for <span class="exturl" data-url="aHR0cHM6Ly93d3cua2hyb25vcy5vcmcvb3BlbmdsL3dpa2kvVmVydGV4X0Zvcm1hdF9UeXBl">vertex attributes<i class="fa fa-external-link-alt"></i></span>.</td>
<td><span class="exturl" data-url="aHR0cDovL3d3dy5vcGVuZ2wub3JnL3JlZ2lzdHJ5L3NwZWNzL0FSQi92ZXJ0ZXhfdHlwZV8xMGZfMTFmXzExZl9yZXYudHh0">ARB_vertex_type_10f_11f_11f_rev<i class="fa fa-external-link-alt"></i></span></td>
</tr>
</tbody></table>
<p>While a number of features made it into core OpenGL, a number of  other features were left to specific extensions. These offer certainly  functionality that lesser 4.x hardware would be unable to handle.</p>
<p>Links:</p>
<ul>
<li><span class="exturl" data-url="aHR0cDovL3d3dy5vcGVuZ2wub3JnL3JlZ2lzdHJ5L2RvYy9nbHNwZWM0NC5jb3JlLnBkZg==">OpenGL 4.4 Core Profile Specification<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL3d3dy5vcGVuZ2wub3JnL3JlZ2lzdHJ5L2RvYy9nbHNwZWM0NC5jb21wYXRpYmlsaXR5LnBkZg==">OpenGL 4.4 Compatibility Profile Specification<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL3d3dy5vcGVuZ2wub3JnL3JlZ2lzdHJ5L2RvYy9HTFNMYW5nU3BlYy40LjQwLnBkZg==">OpenGL Shading Language 4.40 Specification<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<h2 id="OpenGL-4-3-2012"><a href="#OpenGL-4-3-2012" class="headerlink" title="OpenGL 4.3 (2012)"></a>OpenGL 4.3 (2012)</h2><table>
<thead>
<tr>
<th>Addition</th>
<th><span class="exturl" data-url="aHR0cHM6Ly93d3cua2hyb25vcy5vcmcvb3BlbmdsL3dpa2kvRXh0ZW5zaW9uI0NvcmVfRXh0ZW5zaW9ucw==">Core Extension<i class="fa fa-external-link-alt"></i></span></th>
</tr>
</thead>
<tbody><tr>
<td><span class="exturl" data-url="aHR0cHM6Ly93d3cua2hyb25vcy5vcmcvb3BlbmdsL3dpa2kvRGVidWdfT3V0cHV0">Debug messaging<i class="fa fa-external-link-alt"></i></span></td>
<td><span class="exturl" data-url="aHR0cDovL3d3dy5vcGVuZ2wub3JnL3JlZ2lzdHJ5L3NwZWNzL0tIUi9kZWJ1Zy50eHQ=">KHR_debug<i class="fa fa-external-link-alt"></i></span></td>
</tr>
<tr>
<td><span class="exturl" data-url="aHR0cHM6Ly93d3cua2hyb25vcy5vcmcvb3BlbmdsL3dpa2kvQXJyYXlzX09mX0FycmF5cw==">GLSL multidimensional arrays<i class="fa fa-external-link-alt"></i></span></td>
<td><span class="exturl" data-url="aHR0cDovL3d3dy5vcGVuZ2wub3JnL3JlZ2lzdHJ5L3NwZWNzL0FSQi9hcnJheXNfb2ZfYXJyYXlzLnR4dA==">ARB_arrays_of_arrays<i class="fa fa-external-link-alt"></i></span></td>
</tr>
<tr>
<td><span class="exturl" data-url="aHR0cHM6Ly93d3cua2hyb25vcy5vcmcvb3BlbmdsL3dpa2kvQnVmZmVyX0NsZWFyaW5n">Clear Buffer Objects<i class="fa fa-external-link-alt"></i></span> to specific values, ala memset</td>
<td><span class="exturl" data-url="aHR0cDovL3d3dy5vcGVuZ2wub3JnL3JlZ2lzdHJ5L3NwZWNzL0FSQi9jbGVhcl9idWZmZXJfb2JqZWN0LnR4dA==">ARB_clear_buffer_object<i class="fa fa-external-link-alt"></i></span></td>
</tr>
<tr>
<td>Arbitrary <span class="exturl" data-url="aHR0cHM6Ly93d3cua2hyb25vcy5vcmcvb3BlbmdsL3dpa2kvQ29tcHV0ZV9TaGFkZXI=">Compute Shaders<i class="fa fa-external-link-alt"></i></span></td>
<td><span class="exturl" data-url="aHR0cDovL3d3dy5vcGVuZ2wub3JnL3JlZ2lzdHJ5L3NwZWNzL0FSQi9jb21wdXRlX3NoYWRlci50eHQ=">ARB_compute_shader<i class="fa fa-external-link-alt"></i></span></td>
</tr>
<tr>
<td><span class="exturl" data-url="aHR0cHM6Ly93d3cua2hyb25vcy5vcmcvb3BlbmdsL3dpa2kvQ29weV9UZXh0dXJl">Arbitrary image copying<i class="fa fa-external-link-alt"></i></span></td>
<td><span class="exturl" data-url="aHR0cDovL3d3dy5vcGVuZ2wub3JnL3JlZ2lzdHJ5L3NwZWNzL0FSQi9jb3B5X2ltYWdlLnR4dA==">ARB_copy_image<i class="fa fa-external-link-alt"></i></span></td>
</tr>
<tr>
<td>Compatibility with OpenGL ES 3.0</td>
<td><span class="exturl" data-url="aHR0cDovL3d3dy5vcGVuZ2wub3JnL3JlZ2lzdHJ5L3NwZWNzL0FSQi9FUzNfY29tcGF0aWJpbGl0eS50eHQ=">ARB_ES3_compatibility<i class="fa fa-external-link-alt"></i></span></td>
</tr>
<tr>
<td>Specifying <span class="exturl" data-url="aHR0cHM6Ly93d3cua2hyb25vcy5vcmcvb3BlbmdsL3dpa2kvTGF5b3V0X1VuaWZvcm1fTG9jYXRpb24=">uniform locations in a shader<i class="fa fa-external-link-alt"></i></span></td>
<td><span class="exturl" data-url="aHR0cDovL3d3dy5vcGVuZ2wub3JnL3JlZ2lzdHJ5L3NwZWNzL0FSQi9leHBsaWNpdF91bmlmb3JtX2xvY2F0aW9uLnR4dA==">ARB_explicit_uniform_location<i class="fa fa-external-link-alt"></i></span></td>
</tr>
<tr>
<td><span class="exturl" data-url="aHR0cHM6Ly93d3cua2hyb25vcy5vcmcvb3BlbmdsL3dpa2kvRnJhZ21lbnRfU2hhZGVyI1N5c3RlbV9pbnB1dHM=">Layer and viewport indices<i class="fa fa-external-link-alt"></i></span> available from the fragment shader</td>
<td><span class="exturl" data-url="aHR0cDovL3d3dy5vcGVuZ2wub3JnL3JlZ2lzdHJ5L3NwZWNzL0FSQi9mcmFnbWVudF9sYXllcl92aWV3cG9ydC50eHQ=">ARB_fragment_layer_viewport<i class="fa fa-external-link-alt"></i></span></td>
</tr>
<tr>
<td>Rendering to a <span class="exturl" data-url="aHR0cHM6Ly93d3cua2hyb25vcy5vcmcvb3BlbmdsL3dpa2kvRnJhbWVidWZmZXJfT2JqZWN0">Framebuffer Object<i class="fa fa-external-link-alt"></i></span> that <span class="exturl" data-url="aHR0cHM6Ly93d3cua2hyb25vcy5vcmcvb3BlbmdsL3dpa2kvRW1wdHlfRnJhbWVidWZmZXI=">has no attachments<i class="fa fa-external-link-alt"></i></span></td>
<td><span class="exturl" data-url="aHR0cDovL3d3dy5vcGVuZ2wub3JnL3JlZ2lzdHJ5L3NwZWNzL0FSQi9mcmFtZWJ1ZmZlcl9ub19hdHRhY2htZW50cy50eHQ=">ARB_framebuffer_no_attachments<i class="fa fa-external-link-alt"></i></span></td>
</tr>
<tr>
<td><span class="exturl" data-url="aHR0cHM6Ly93d3cua2hyb25vcy5vcmcvb3BlbmdsL3dpa2kvUXVlcnlfSW1hZ2VfRm9ybWF0">Generalized queries for information<i class="fa fa-external-link-alt"></i></span> about <span class="exturl" data-url="aHR0cHM6Ly93d3cua2hyb25vcy5vcmcvb3BlbmdsL3dpa2kvSW1hZ2VfRm9ybWF0">Image Formats<i class="fa fa-external-link-alt"></i></span></td>
<td><span class="exturl" data-url="aHR0cDovL3d3dy5vcGVuZ2wub3JnL3JlZ2lzdHJ5L3NwZWNzL0FSQi9pbnRlcm5hbGZvcm1hdF9xdWVyeTIudHh0">ARB_internalformat_query2<i class="fa fa-external-link-alt"></i></span></td>
</tr>
<tr>
<td><span class="exturl" data-url="aHR0cHM6Ly93d3cua2hyb25vcy5vcmcvb3BlbmdsL3dpa2kvVGV4dHVyZV9JbnZhbGlkYXRpb24=">Texture<i class="fa fa-external-link-alt"></i></span>, <span class="exturl" data-url="aHR0cHM6Ly93d3cua2hyb25vcy5vcmcvb3BlbmdsL3dpa2kvQnVmZmVyX0ludmFsaWRhdGlvbg==">buffer object<i class="fa fa-external-link-alt"></i></span>, and <span class="exturl" data-url="aHR0cHM6Ly93d3cua2hyb25vcy5vcmcvb3BlbmdsL3dpa2kvRnJhbWVidWZmZXJfSW52YWxpZGF0aW9u">framebuffer<i class="fa fa-external-link-alt"></i></span> invalidation.</td>
<td><span class="exturl" data-url="aHR0cDovL3d3dy5vcGVuZ2wub3JnL3JlZ2lzdHJ5L3NwZWNzL0FSQi9pbnZhbGlkYXRlX3N1YmRhdGEudHh0">ARB_invalidate_subdata<i class="fa fa-external-link-alt"></i></span></td>
</tr>
<tr>
<td>Issuing <span class="exturl" data-url="aHR0cHM6Ly93d3cua2hyb25vcy5vcmcvb3BlbmdsL3dpa2kvSW5kaXJlY3RfRHJhd2luZw==">multiple indirect rendering commands<i class="fa fa-external-link-alt"></i></span> from a single drawing command.</td>
<td><span class="exturl" data-url="aHR0cDovL3d3dy5vcGVuZ2wub3JnL3JlZ2lzdHJ5L3NwZWNzL0FSQi9tdWx0aV9kcmF3X2luZGlyZWN0LnR4dA==">ARB_multi_draw_indirect<i class="fa fa-external-link-alt"></i></span></td>
</tr>
<tr>
<td>Improved API for <span class="exturl" data-url="aHR0cHM6Ly93d3cua2hyb25vcy5vcmcvb3BlbmdsL3dpa2kvUHJvZ3JhbV9JbnRlcmZhY2VfUXVlcnk=">getting info about program object interfaces<i class="fa fa-external-link-alt"></i></span></td>
<td><span class="exturl" data-url="aHR0cDovL3d3dy5vcGVuZ2wub3JnL3JlZ2lzdHJ5L3NwZWNzL0FSQi9wcm9ncmFtX2ludGVyZmFjZV9xdWVyeS50eHQ=">ARB_program_interface_query<i class="fa fa-external-link-alt"></i></span></td>
</tr>
<tr>
<td><span class="exturl" data-url="aHR0cHM6Ly93d3cua2hyb25vcy5vcmcvb3BlbmdsL3dpa2kvSW1hZ2VfTG9hZF9TdG9yZSNJbWFnZV9zaXpl">Get size<i class="fa fa-external-link-alt"></i></span> of <span class="exturl" data-url="aHR0cHM6Ly93d3cua2hyb25vcy5vcmcvb3BlbmdsL3dpa2kvSW1hZ2VfTG9hZF9TdG9yZQ==">images<i class="fa fa-external-link-alt"></i></span> from GLSL</td>
<td><span class="exturl" data-url="aHR0cDovL3d3dy5vcGVuZ2wub3JnL3JlZ2lzdHJ5L3NwZWNzL0FSQi9zaGFkZXJfaW1hZ2Vfc2l6ZS50eHQ=">ARB_shader_image_size<i class="fa fa-external-link-alt"></i></span></td>
</tr>
<tr>
<td><span class="exturl" data-url="aHR0cHM6Ly93d3cua2hyb25vcy5vcmcvb3BlbmdsL3dpa2kvU2hhZGVyX1N0b3JhZ2VfQnVmZmVyX09iamVjdA==">Buffer object read-write access from shader<i class="fa fa-external-link-alt"></i></span>, via a uniform-block style mechanism</td>
<td><span class="exturl" data-url="aHR0cDovL3d3dy5vcGVuZ2wub3JnL3JlZ2lzdHJ5L3NwZWNzL0FSQi9zaGFkZXJfc3RvcmFnZV9idWZmZXJfb2JqZWN0LnR4dA==">ARB_shader_storage_buffer_object<i class="fa fa-external-link-alt"></i></span></td>
</tr>
<tr>
<td><span class="exturl" data-url="aHR0cHM6Ly93d3cua2hyb25vcy5vcmcvb3BlbmdsL3dpa2kvU3RlbmNpbF9UZXh0dXJpbmc=">Accessing the stencil values from a depth&#x2F;stencil texture<i class="fa fa-external-link-alt"></i></span></td>
<td><span class="exturl" data-url="aHR0cDovL3d3dy5vcGVuZ2wub3JnL3JlZ2lzdHJ5L3NwZWNzL0FSQi9zdGVuY2lsX3RleHR1cmluZy50eHQ=">ARB_stencil_texturing<i class="fa fa-external-link-alt"></i></span></td>
</tr>
<tr>
<td><span class="exturl" data-url="aHR0cHM6Ly93d3cua2hyb25vcy5vcmcvb3BlbmdsL3dpa2kvQnVmZmVyX1RleHR1cmU=">Buffer Textures<i class="fa fa-external-link-alt"></i></span> can now be <span class="exturl" data-url="aHR0cHM6Ly93d3cua2hyb25vcy5vcmcvb3BlbmdsL3dpa2kvQnVmZmVyX1RleHR1cmUjQnVmZmVyX3RleHR1cmVfcmFuZ2U=">bound to a range of a buffer object<i class="fa fa-external-link-alt"></i></span> rather than the whole thing</td>
<td><span class="exturl" data-url="aHR0cDovL3d3dy5vcGVuZ2wub3JnL3JlZ2lzdHJ5L3NwZWNzL0FSQi90ZXh0dXJlX2J1ZmZlcl9yYW5nZS50eHQ=">ARB_texture_buffer_range<i class="fa fa-external-link-alt"></i></span></td>
</tr>
<tr>
<td>GLSL can detect the available mipmap pyramid of a <span class="exturl" data-url="aHR0cHM6Ly93d3cua2hyb25vcy5vcmcvb3BlbmdsL3dpa2kvU2FtcGxlcl8oR0xTTCkjVGV4dHVyZV9taXBtYXBfcmV0cmlldmFs">sampler<i class="fa fa-external-link-alt"></i></span> or <span class="exturl" data-url="aHR0cHM6Ly93d3cua2hyb25vcy5vcmcvb3BlbmdsL3dpa2kvSW1hZ2VfTG9hZF9TdG9yZSNJbWFnZV9taXBtYXA=">image<i class="fa fa-external-link-alt"></i></span></td>
<td><span class="exturl" data-url="aHR0cDovL3d3dy5vcGVuZ2wub3JnL3JlZ2lzdHJ5L3NwZWNzL0FSQi90ZXh0dXJlX3F1ZXJ5X2xldmVscy50eHQ=">ARB_texture_query_levels<i class="fa fa-external-link-alt"></i></span></td>
</tr>
<tr>
<td>Immutable storage for <span class="exturl" data-url="aHR0cHM6Ly93d3cua2hyb25vcy5vcmcvb3BlbmdsL3dpa2kvSW1tdXRhYmxlX1N0b3JhZ2VfVGV4dHVyZQ==">multisample textures<i class="fa fa-external-link-alt"></i></span></td>
<td><span class="exturl" data-url="aHR0cDovL3d3dy5vcGVuZ2wub3JnL3JlZ2lzdHJ5L3NwZWNzL0FSQi90ZXh0dXJlX3N0b3JhZ2VfbXVsdGlzYW1wbGUudHh0">ARB_texture_storage_multisample<i class="fa fa-external-link-alt"></i></span></td>
</tr>
<tr>
<td><span class="exturl" data-url="aHR0cHM6Ly93d3cua2hyb25vcy5vcmcvb3BlbmdsL3dpa2kvVmlld190ZXh0dXJl">The ability to create a new texture<i class="fa fa-external-link-alt"></i></span>, with a new internal format, that references an existing texture’s storage</td>
<td><span class="exturl" data-url="aHR0cDovL3d3dy5vcGVuZ2wub3JnL3JlZ2lzdHJ5L3NwZWNzL0FSQi90ZXh0dXJlX3ZpZXcudHh0">ARB_texture_view<i class="fa fa-external-link-alt"></i></span></td>
</tr>
<tr>
<td><span class="exturl" data-url="aHR0cHM6Ly93d3cua2hyb25vcy5vcmcvb3BlbmdsL3dpa2kvU2VwYXJhdGVfQXR0cmlidXRlX0Zvcm1hdA==">Separation of vertex format from buffer object<i class="fa fa-external-link-alt"></i></span></td>
<td><span class="exturl" data-url="aHR0cDovL3d3dy5vcGVuZ2wub3JnL3JlZ2lzdHJ5L3NwZWNzL0FSQi92ZXJ0ZXhfYXR0cmliX2JpbmRpbmcudHh0">ARB_vertex_attrib_binding<i class="fa fa-external-link-alt"></i></span></td>
</tr>
<tr>
<td>Addition</td>
<td>Promoted from</td>
</tr>
<tr>
<td>More robustness of API</td>
<td><span class="exturl" data-url="aHR0cDovL3d3dy5vcGVuZ2wub3JnL3JlZ2lzdHJ5L3NwZWNzL0FSQi9yb2J1c3RfYnVmZmVyX2FjY2Vzc19iZWhhdmlvci50eHQ=">ARB_robust_buffer_access_behavior<i class="fa fa-external-link-alt"></i></span>, <span class="exturl" data-url="aHR0cDovL3d3dy5vcGVuZ2wub3JnL3JlZ2lzdHJ5L3NwZWNzL0FSQi9yb2J1c3RuZXNzX2lzb2xhdGlvbi50eHQ=">ARB_robustness_isolation<i class="fa fa-external-link-alt"></i></span>, <span class="exturl" data-url="aHR0cDovL3d3dy5vcGVuZ2wub3JnL3JlZ2lzdHJ5L3NwZWNzL0FSQi93Z2xfcm9idXN0bmVzc19pc29sYXRpb24udHh0">WGL_ARB_robustness_isolation<i class="fa fa-external-link-alt"></i></span>, <span class="exturl" data-url="aHR0cDovL3d3dy5vcGVuZ2wub3JnL3JlZ2lzdHJ5L3NwZWNzL0FSQi9nbHhfcm9idXN0bmVzc19pc29sYXRpb24udHh0">GLX_ARB_robustness_isolation<i class="fa fa-external-link-alt"></i></span></td>
</tr>
<tr>
<td>EAC and ETC compressed image formats.</td>
<td></td>
</tr>
</tbody></table>
<p>Links:</p>
<ul>
<li><span class="exturl" data-url="aHR0cDovL3d3dy5vcGVuZ2wub3JnL3JlZ2lzdHJ5L2RvYy9nbHNwZWM0My5jb3JlLjIwMTMwMjE0LnBkZg==">OpenGL 4.3 Core Profile Specification<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL3d3dy5vcGVuZ2wub3JnL3JlZ2lzdHJ5L2RvYy9nbHNwZWM0My5jb21wYXRpYmlsaXR5LjIwMTMwMjE0LnBkZg==">OpenGL 4.3 Compatibility Profile Specification<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL3d3dy5vcGVuZ2wub3JnL3JlZ2lzdHJ5L2RvYy9HTFNMYW5nU3BlYy40LjMwLjgucGRm">OpenGL Shading Language 4.30 Specification<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<h2 id="OpenGL-4-2-2011"><a href="#OpenGL-4-2-2011" class="headerlink" title="OpenGL 4.2 (2011)"></a>OpenGL 4.2 (2011)</h2><table>
<thead>
<tr>
<th>Addition</th>
<th><span class="exturl" data-url="aHR0cHM6Ly93d3cua2hyb25vcy5vcmcvb3BlbmdsL3dpa2kvRXh0ZW5zaW9uI0NvcmVfRXh0ZW5zaW9ucw==">Core Extension<i class="fa fa-external-link-alt"></i></span></th>
</tr>
</thead>
<tbody><tr>
<td>Allows atomically <span class="exturl" data-url="aHR0cHM6Ly93d3cua2hyb25vcy5vcmcvb3BlbmdsL3dpa2kvQXRvbWljX0NvdW50ZXI=">incrementing&#x2F;decrementing and fetching of buffer object memory locations from shaders<i class="fa fa-external-link-alt"></i></span></td>
<td><span class="exturl" data-url="aHR0cDovL3d3dy5vcGVuZ2wub3JnL3JlZ2lzdHJ5L3NwZWNzL0FSQi9zaGFkZXJfYXRvbWljX2NvdW50ZXJzLnR4dA==">ARB_shader_atomic_counters<i class="fa fa-external-link-alt"></i></span></td>
</tr>
<tr>
<td>Allows shaders to <span class="exturl" data-url="aHR0cHM6Ly93d3cua2hyb25vcy5vcmcvb3BlbmdsL3dpa2kvSW1hZ2VfTG9hZF9TdG9yZQ==">read and write images<i class="fa fa-external-link-alt"></i></span>, with <span class="exturl" data-url="aHR0cHM6Ly93d3cua2hyb25vcy5vcmcvb3BlbmdsL3dpa2kvSW5jb2hlcmVudF9NZW1vcnlfQWNjZXNz">few but difficult restrictions<i class="fa fa-external-link-alt"></i></span></td>
<td><span class="exturl" data-url="aHR0cDovL3d3dy5vcGVuZ2wub3JnL3JlZ2lzdHJ5L3NwZWNzL0FSQi9zaGFkZXJfaW1hZ2VfbG9hZF9zdG9yZS50eHQ=">ARB_shader_image_load_store<i class="fa fa-external-link-alt"></i></span></td>
</tr>
<tr>
<td>Allows texture objects to have <span class="exturl" data-url="aHR0cHM6Ly93d3cua2hyb25vcy5vcmcvb3BlbmdsL3dpa2kvSW1tdXRhYmxlX1N0b3JhZ2VfVGV4dHVyZQ==">immutable storage, and allocating all mipmap levels and images in one call<i class="fa fa-external-link-alt"></i></span>. The storage becomes immutable, but the contents of the storage are not</td>
<td><span class="exturl" data-url="aHR0cDovL3d3dy5vcGVuZ2wub3JnL3JlZ2lzdHJ5L3NwZWNzL0FSQi90ZXh0dXJlX3N0b3JhZ2UudHh0">ARB_texture_storage<i class="fa fa-external-link-alt"></i></span></td>
</tr>
<tr>
<td>Allows <span class="exturl" data-url="aHR0cHM6Ly93d3cua2hyb25vcy5vcmcvb3BlbmdsL3dpa2kvRHJhd19UcmFuc2Zvcm1fRmVlZGJhY2s=">instanced rendering of data written by transform feedback operations<i class="fa fa-external-link-alt"></i></span></td>
<td><span class="exturl" data-url="aHR0cDovL3d3dy5vcGVuZ2wub3JnL3JlZ2lzdHJ5L3NwZWNzL0FSQi90cmFuc2Zvcm1fZmVlZGJhY2tfaW5zdGFuY2VkLnR4dA==">ARB_transform_feedback_instanced<i class="fa fa-external-link-alt"></i></span></td>
</tr>
<tr>
<td>Allows the setting of <span class="exturl" data-url="aHR0cHM6Ly93d3cua2hyb25vcy5vcmcvb3BlbmdsL3dpa2kvSW4tU2hhZGVyX1VuaWZvcm1fQmluZGluZw==">Uniform Buffer Object<i class="fa fa-external-link-alt"></i></span> and <span class="exturl" data-url="aHR0cHM6Ly93d3cua2hyb25vcy5vcmcvb3BlbmdsL3dpa2kvSW4tU2hhZGVyX1RleHR1cmVfVW5pdA==">sampler<i class="fa fa-external-link-alt"></i></span> binding points directly from GLSL, among <span class="exturl" data-url="aHR0cHM6Ly93d3cua2hyb25vcy5vcmcvb3BlbmdsL3dpa2kvUXVhbGlmaWVyX09yZGVy">many other<i class="fa fa-external-link-alt"></i></span> small changes</td>
<td><span class="exturl" data-url="aHR0cDovL3d3dy5vcGVuZ2wub3JnL3JlZ2lzdHJ5L3NwZWNzL0FSQi9zaGFkaW5nX2xhbmd1YWdlXzQyMHBhY2sudHh0">ARB_shading_language_420pack<i class="fa fa-external-link-alt"></i></span></td>
</tr>
<tr>
<td>Allows instanced rendering with a <span class="exturl" data-url="aHR0cHM6Ly93d3cua2hyb25vcy5vcmcvb3BlbmdsL3dpa2kvSW5zdGFuY2luZw==">starting instance value<i class="fa fa-external-link-alt"></i></span>.</td>
<td><span class="exturl" data-url="aHR0cDovL3d3dy5vcGVuZ2wub3JnL3JlZ2lzdHJ5L3NwZWNzL0FSQi9iYXNlX2luc3RhbmNlLnR4dA==">ARB_base_instance<i class="fa fa-external-link-alt"></i></span></td>
</tr>
<tr>
<td>Allows the user to <span class="exturl" data-url="aHR0cHM6Ly93d3cua2hyb25vcy5vcmcvb3BlbmdsL3dpa2kvUXVlcnlfSW1hZ2VfRm9ybWF0">detect the maximum number of samples possible<i class="fa fa-external-link-alt"></i></span> for a particular <span class="exturl" data-url="aHR0cHM6Ly93d3cua2hyb25vcy5vcmcvb3BlbmdsL3dpa2kvSW1hZ2VfRm9ybWF0">image format<i class="fa fa-external-link-alt"></i></span> and <span class="exturl" data-url="aHR0cHM6Ly93d3cua2hyb25vcy5vcmcvb3BlbmdsL3dpa2kvVGV4dHVyZSNUaGVvcnk=">texture type<i class="fa fa-external-link-alt"></i></span></td>
<td><span class="exturl" data-url="aHR0cDovL3d3dy5vcGVuZ2wub3JnL3JlZ2lzdHJ5L3NwZWNzL0FSQi9pbnRlcm5hbGZvcm1hdF9xdWVyeS50eHQ=">ARB_internalformat_query<i class="fa fa-external-link-alt"></i></span></td>
</tr>
<tr>
<td>Allows for sub-rectangle selection when transferring compressed texture data.</td>
<td><span class="exturl" data-url="aHR0cDovL3d3dy5vcGVuZ2wub3JnL3JlZ2lzdHJ5L3NwZWNzL0FSQi9jb21wcmVzc2VkX3RleHR1cmVfcGl4ZWxfc3RvcmFnZS50eHQ=">ARB_compressed_texture_pixel_storage<i class="fa fa-external-link-alt"></i></span></td>
</tr>
<tr>
<td>Allows unpacking 16-bit floats from a 32-bit unsigned integer value in shaders.</td>
<td><span class="exturl" data-url="aHR0cDovL3d3dy5vcGVuZ2wub3JnL3JlZ2lzdHJ5L3NwZWNzL0FSQi9zaGFkaW5nX2xhbmd1YWdlX3BhY2tpbmcudHh0">ARB_shading_language_packing<i class="fa fa-external-link-alt"></i></span></td>
</tr>
<tr>
<td>Allows querying of the <span class="exturl" data-url="aHR0cHM6Ly93d3cua2hyb25vcy5vcmcvb3BlbmdsL3dpa2kvQnVmZmVyX09iamVjdCNBbGlnbm1lbnQ=">alignment for pointers<i class="fa fa-external-link-alt"></i></span> returned from <span class="exturl" data-url="aHR0cHM6Ly93d3cua2hyb25vcy5vcmcvb3BlbmdsL3dpa2kvTWFwX0J1ZmZlcl9SYW5nZQ==">buffer object mapping operations<i class="fa fa-external-link-alt"></i></span></td>
<td><span class="exturl" data-url="aHR0cDovL3d3dy5vcGVuZ2wub3JnL3JlZ2lzdHJ5L3NwZWNzL0FSQi9tYXBfYnVmZmVyX2FsaWdubWVudC50eHQ=">ARB_map_buffer_alignment<i class="fa fa-external-link-alt"></i></span></td>
</tr>
<tr>
<td>Allows explicitly defining how a <span class="exturl" data-url="aHR0cHM6Ly93d3cua2hyb25vcy5vcmcvb3BlbmdsL3dpa2kvRnJhZ21lbnRfU2hhZGVyX091dHB1dA==">fragment shader will modify the depth value<i class="fa fa-external-link-alt"></i></span>, so that the system can optimize these cases better</td>
<td><span class="exturl" data-url="aHR0cDovL3d3dy5vcGVuZ2wub3JnL3JlZ2lzdHJ5L3NwZWNzL0FSQi9jb25zZXJ2YXRpdmVfZGVwdGgudHh0">ARB_conservative_depth<i class="fa fa-external-link-alt"></i></span></td>
</tr>
<tr>
<td>Addition</td>
<td>Promoted from</td>
</tr>
<tr>
<td>Allows the use of <span class="exturl" data-url="aHR0cHM6Ly93d3cua2hyb25vcy5vcmcvb3BlbmdsL3dpa2kvQlBUQ19UZXh0dXJlX0NvbXByZXNzaW9u">BPTC compressed image formats<i class="fa fa-external-link-alt"></i></span>.</td>
<td><span class="exturl" data-url="aHR0cDovL3d3dy5vcGVuZ2wub3JnL3JlZ2lzdHJ5L3NwZWNzL0FSQi90ZXh0dXJlX2NvbXByZXNzaW9uX2JwdGMudHh0">ARB_texture_compression_BPTC<i class="fa fa-external-link-alt"></i></span></td>
</tr>
</tbody></table>
<p>Links:</p>
<ul>
<li><span class="exturl" data-url="aHR0cDovL3d3dy5vcGVuZ2wub3JnL3JlZ2lzdHJ5L2RvYy9nbHNwZWM0Mi5jb3JlLjIwMTEwODA4LnBkZg==">OpenGL 4.2 Core Profile Specification<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL3d3dy5vcGVuZ2wub3JnL3JlZ2lzdHJ5L2RvYy9nbHNwZWM0Mi5jb21wYXRpYmlsaXR5LjIwMTEwODA4LnBkZg==">OpenGL 4.2 Compatibility Profile Specification<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL3d3dy5vcGVuZ2wub3JnL3JlZ2lzdHJ5L2RvYy9HTFNMYW5nU3BlYy40LjIwLjYuY2xlYW4ucGRm">OpenGL Shading Language 4.20.6 Specification<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<h2 id="OpenGL-4-1-2010"><a href="#OpenGL-4-1-2010" class="headerlink" title="OpenGL 4.1 (2010)"></a>OpenGL 4.1 (2010)</h2><table>
<thead>
<tr>
<th>Addition</th>
<th><span class="exturl" data-url="aHR0cHM6Ly93d3cua2hyb25vcy5vcmcvb3BlbmdsL3dpa2kvRXh0ZW5zaW9uI0NvcmVfRXh0ZW5zaW9ucw==">Core Extension<i class="fa fa-external-link-alt"></i></span></th>
</tr>
</thead>
<tbody><tr>
<td><span class="exturl" data-url="aHR0cHM6Ly93d3cua2hyb25vcy5vcmcvb3BlbmdsL3dpa2kvUHJvZ3JhbV9CaW5hcnk=">Query and load a binary blob for program objects<i class="fa fa-external-link-alt"></i></span></td>
<td><span class="exturl" data-url="aHR0cDovL3d3dy5vcGVuZ2wub3JnL3JlZ2lzdHJ5L3NwZWNzL0FSQi9nZXRfcHJvZ3JhbV9iaW5hcnkudHh0">ARB_get_program_binary<i class="fa fa-external-link-alt"></i></span></td>
</tr>
<tr>
<td>Ability to <span class="exturl" data-url="aHR0cHM6Ly93d3cua2hyb25vcy5vcmcvb3BlbmdsL3dpa2kvR0xTTF9PYmplY3QjUHJvZ3JhbV9zZXBhcmF0aW9u">bind programs individually to programmable stages<i class="fa fa-external-link-alt"></i></span></td>
<td><span class="exturl" data-url="aHR0cDovL3d3dy5vcGVuZ2wub3JnL3JlZ2lzdHJ5L3NwZWNzL0FSQi9zZXBhcmF0ZV9zaGFkZXJfb2JqZWN0cy50eHQ=">ARB_separate_shader_objects<i class="fa fa-external-link-alt"></i></span></td>
</tr>
<tr>
<td>Pulling missing functionality from <span class="exturl" data-url="aHR0cHM6Ly93d3cua2hyb25vcy5vcmcvb3BlbmdsL3dpa2kvT3BlbkdMX0VT">OpenGL ES<i class="fa fa-external-link-alt"></i></span> 2.0 into OpenGL</td>
<td><span class="exturl" data-url="aHR0cDovL3d3dy5vcGVuZ2wub3JnL3JlZ2lzdHJ5L3NwZWNzL0FSQi9FUzJfY29tcGF0aWJpbGl0eS50eHQ=">ARB_ES2_compatibility<i class="fa fa-external-link-alt"></i></span></td>
</tr>
<tr>
<td>Documents precision requirements for several FP operations</td>
<td><span class="exturl" data-url="aHR0cDovL3d3dy5vcGVuZ2wub3JnL3JlZ2lzdHJ5L3NwZWNzL0FSQi9zaGFkZXJfcHJlY2lzaW9uLnR4dA==">ARB_shader_precision<i class="fa fa-external-link-alt"></i></span></td>
</tr>
<tr>
<td>Provides <span class="exturl" data-url="aHR0cHM6Ly93d3cua2hyb25vcy5vcmcvb3BlbmdsL3dpa2kvVmVydGV4X0Zvcm1hdA==">64-bit floating-point component vertex attributes<i class="fa fa-external-link-alt"></i></span></td>
<td><span class="exturl" data-url="aHR0cDovL3d3dy5vcGVuZ2wub3JnL3JlZ2lzdHJ5L3NwZWNzL0FSQi92ZXJ0ZXhfYXR0cmliXzY0Yml0LnR4dA==">ARB_vertex_attrib_64_bit<i class="fa fa-external-link-alt"></i></span></td>
</tr>
<tr>
<td>Multiple <span class="exturl" data-url="aHR0cHM6Ly93d3cua2hyb25vcy5vcmcvb3BlbmdsL3dpa2kvVmlld3BvcnQ=">Viewports<i class="fa fa-external-link-alt"></i></span> for the same rendering surface, or one per surface</td>
<td><span class="exturl" data-url="aHR0cDovL3d3dy5vcGVuZ2wub3JnL3JlZ2lzdHJ5L3NwZWNzL0FSQi92aWV3cG9ydF9hcnJheS50eHQ=">ARB_viewport_array<i class="fa fa-external-link-alt"></i></span></td>
</tr>
</tbody></table>
<p>Links:</p>
<ul>
<li><span class="exturl" data-url="aHR0cDovL3d3dy5vcGVuZ2wub3JnL3JlZ2lzdHJ5L2RvYy9nbHNwZWM0MS5jb3JlLjIwMTAwNzI1LnBkZg==">OpenGL 4.1 Core Profile Specification<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL3d3dy5vcGVuZ2wub3JnL3JlZ2lzdHJ5L2RvYy9nbHNwZWM0MS5jb21wYXRpYmlsaXR5LjIwMTAwNzI1LnBkZg==">OpenGL 4.1 Compatibility Profile Specification<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL3d3dy5vcGVuZ2wub3JnL3JlZ2lzdHJ5L2RvYy9HTFNMYW5nU3BlYy40LjEwLjYuY2xlYW4ucGRm">OpenGL Shading Language 4.10.6 Specification<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<h2 id="OpenGL-4-0-2010"><a href="#OpenGL-4-0-2010" class="headerlink" title="OpenGL 4.0 (2010)"></a>OpenGL 4.0 (2010)</h2><table>
<thead>
<tr>
<th>Addition</th>
<th><span class="exturl" data-url="aHR0cHM6Ly93d3cua2hyb25vcy5vcmcvb3BlbmdsL3dpa2kvRXh0ZW5zaW9uI0NvcmVfRXh0ZW5zaW9ucw==">Core Extension<i class="fa fa-external-link-alt"></i></span></th>
</tr>
</thead>
<tbody><tr>
<td>Shading language 4.00</td>
<td><span class="exturl" data-url="aHR0cDovL3d3dy5vcGVuZ2wub3JnL3JlZ2lzdHJ5L3NwZWNzL0FSQi90ZXh0dXJlX3F1ZXJ5X2xvZC50eHQ=">ARB_texture_query_lod<i class="fa fa-external-link-alt"></i></span>, <span class="exturl" data-url="aHR0cDovL3d3dy5vcGVuZ2wub3JnL3JlZ2lzdHJ5L3NwZWNzL0FSQi9ncHVfc2hhZGVyNS50eHQ=">ARB_gpu_shader5<i class="fa fa-external-link-alt"></i></span>, <span class="exturl" data-url="aHR0cDovL3d3dy5vcGVuZ2wub3JnL3JlZ2lzdHJ5L3NwZWNzL0FSQi9ncHVfc2hhZGVyX2ZwNjQudHh0">ARB_gpu_shader_fp64<i class="fa fa-external-link-alt"></i></span>, <span class="exturl" data-url="aHR0cDovL3d3dy5vcGVuZ2wub3JnL3JlZ2lzdHJ5L3NwZWNzL0FSQi9zaGFkZXJfc3Vicm91dGluZS50eHQ=">ARB_shader_subroutine<i class="fa fa-external-link-alt"></i></span>, <span class="exturl" data-url="aHR0cDovL3d3dy5vcGVuZ2wub3JnL3JlZ2lzdHJ5L3NwZWNzL0FSQi90ZXh0dXJlX2dhdGhlci50eHQ=">ARB_texture_gather<i class="fa fa-external-link-alt"></i></span></td>
</tr>
<tr>
<td><span class="exturl" data-url="aHR0cHM6Ly93d3cua2hyb25vcy5vcmcvb3BlbmdsL3dpa2kvSW5kaXJlY3RfRHJhd2luZw==">Indirect Drawing<i class="fa fa-external-link-alt"></i></span>, without multidraw</td>
<td><span class="exturl" data-url="aHR0cDovL3d3dy5vcGVuZ2wub3JnL3JlZ2lzdHJ5L3NwZWNzL0FSQi9kcmF3X2luZGlyZWN0LnR4dA==">ARB_draw_indirect<i class="fa fa-external-link-alt"></i></span></td>
</tr>
<tr>
<td>Request minimum number of fragment inputs</td>
<td><span class="exturl" data-url="aHR0cDovL3d3dy5vcGVuZ2wub3JnL3JlZ2lzdHJ5L3NwZWNzL0FSQi9zYW1wbGVfc2hhZGluZy50eHQ=">ARB_sample_shading<i class="fa fa-external-link-alt"></i></span></td>
</tr>
<tr>
<td><span class="exturl" data-url="aHR0cHM6Ly93d3cua2hyb25vcy5vcmcvb3BlbmdsL3dpa2kvVGVzc2VsbGF0aW9u">Tessellation<i class="fa fa-external-link-alt"></i></span>, with shader stages</td>
<td><span class="exturl" data-url="aHR0cDovL3d3dy5vcGVuZ2wub3JnL3JlZ2lzdHJ5L3NwZWNzL0FSQi90ZXNzZWxsYXRpb25fc2hhZGVyLnR4dA==">ARB_tessellation_shader<i class="fa fa-external-link-alt"></i></span></td>
</tr>
<tr>
<td><span class="exturl" data-url="aHR0cHM6Ly93d3cua2hyb25vcy5vcmcvb3BlbmdsL3dpa2kvQnVmZmVyX1RleHR1cmU=">Buffer Texture<i class="fa fa-external-link-alt"></i></span> formats RGB32F, RGB32I, RGB32UI</td>
<td><span class="exturl" data-url="aHR0cDovL3d3dy5vcGVuZ2wub3JnL3JlZ2lzdHJ5L3NwZWNzL0FSQi90ZXh0dXJlX2J1ZmZlcl9vYmplY3RfcmdiMzIudHh0">ARB_texture_buffer_object_rgb32<i class="fa fa-external-link-alt"></i></span></td>
</tr>
<tr>
<td><span class="exturl" data-url="aHR0cHM6Ly93d3cua2hyb25vcy5vcmcvb3BlbmdsL3dpa2kvQ3ViZW1hcF9BcnJheV9UZXh0dXJl">Cubemap Array Texture<i class="fa fa-external-link-alt"></i></span></td>
<td><span class="exturl" data-url="aHR0cDovL3d3dy5vcGVuZ2wub3JnL3JlZ2lzdHJ5L3NwZWNzL0FSQi90ZXh0dXJlX2N1YmVfbWFwX2FycmF5LnR4dA==">ARB_texture_cube_map_array<i class="fa fa-external-link-alt"></i></span></td>
</tr>
<tr>
<td><span class="exturl" data-url="aHR0cHM6Ly93d3cua2hyb25vcy5vcmcvb3BlbmdsL3dpa2kvVHJhbnNmb3JtX0ZlZWRiYWNr">Transform Feedback<i class="fa fa-external-link-alt"></i></span> objects and multiple feedback stream output.</td>
<td><span class="exturl" data-url="aHR0cDovL3d3dy5vcGVuZ2wub3JnL3JlZ2lzdHJ5L3NwZWNzL0FSQi90cmFuc2Zvcm1fZmVlZGJhY2syLnR4dA==">ARB_transform_feedback2<i class="fa fa-external-link-alt"></i></span>, <span class="exturl" data-url="aHR0cDovL3d3dy5vcGVuZ2wub3JnL3JlZ2lzdHJ5L3NwZWNzL0FSQi90cmFuc2Zvcm1fZmVlZGJhY2szLnR4dA==">ARB_transform_feedback3<i class="fa fa-external-link-alt"></i></span></td>
</tr>
<tr>
<td>Addition</td>
<td>Promoted from</td>
</tr>
<tr>
<td><span class="exturl" data-url="aHR0cHM6Ly93d3cua2hyb25vcy5vcmcvb3BlbmdsL3dpa2kvRHJhd19CdWZmZXJfQmxlbmQ=">Individual blend equations for each color output<i class="fa fa-external-link-alt"></i></span></td>
<td><span class="exturl" data-url="aHR0cDovL3d3dy5vcGVuZ2wub3JnL3JlZ2lzdHJ5L3NwZWNzL0FSQi9kcmF3X2J1ZmZlcnNfYmxlbmQudHh0">ARB_draw_buffers_blend<i class="fa fa-external-link-alt"></i></span></td>
</tr>
</tbody></table>
<p>Links:</p>
<ul>
<li><span class="exturl" data-url="aHR0cDovL3d3dy5vcGVuZ2wub3JnL3JlZ2lzdHJ5L2RvYy9nbHNwZWM0MC5jb3JlLjIwMTAwMzExLnBkZg==">OpenGL 4.0 Core Profile Specification<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL3d3dy5vcGVuZ2wub3JnL3JlZ2lzdHJ5L2RvYy9nbHNwZWM0MC5jb21wYXRpYmlsaXR5LjIwMTAwMzExLnBkZg==">OpenGL 4.0 Compatibility Profile Specification<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL3d3dy5vcGVuZ2wub3JnL3JlZ2lzdHJ5L2RvYy9HTFNMYW5nU3BlYy40LjAwLjkuY2xlYW4ucGRm">OpenGL Shading Language 4.00.9 Specification<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cua2hyb25vcy5vcmcvb3BlbmdsL3dpa2kvSGlzdG9yeV9vZl9PcGVuR0w=">History of OpenGL<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cua2hyb25vcy5vcmcvcmVnaXN0cnkvT3BlbkdML3NwZWNzL2dsL2dsc3BlYzQ2LmNvbXBhdGliaWxpdHkud2l0aGNoYW5nZXMucGRm">OpenGL4.6规范<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>多媒体</category>
        <category>OpenGL</category>
      </categories>
      <tags>
        <tag>opengl</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenGL进行RGBA转NV12</title>
    <url>/post/ab7c39de.html</url>
    <content><![CDATA[<p>通过OpenGL使用GPU进行色彩空间的转换可以加速转换时间，提高效率。</p>
<span id="more"></span>

<h2 id="RGBA"><a href="#RGBA" class="headerlink" title="RGBA"></a>RGBA</h2><p>RGB图像具有三个通道 R、G、B，分别对应红、绿、蓝三个分量，由三个分量的值决定颜色；通常，会给RGB图像加一个通道alpha，即透明度，于是共有四个分量共同控制颜色。</p>
<h3 id="像素存储格式"><a href="#像素存储格式" class="headerlink" title="像素存储格式"></a>像素存储格式</h3><p>一个<code>6x4</code>的图像，示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">RGBA RGBA RGBA RGBA RGBA RGBA</span><br><span class="line">RGBA RGBA RGBA RGBA RGBA RGBA</span><br><span class="line">RGBA RGBA RGBA RGBA RGBA RGBA</span><br><span class="line">RGBA RGBA RGBA RGBA RGBA RGBA</span><br><span class="line">          - RGBA -</span><br></pre></td></tr></table></figure>
<p>内存空间大小：6x4x(8x4)&#x3D;768bit</p>
<h2 id="NV12"><a href="#NV12" class="headerlink" title="NV12"></a>NV12</h2><h3 id="像素存储格式-1"><a href="#像素存储格式-1" class="headerlink" title="像素存储格式"></a>像素存储格式</h3><p>一个<code>6x4</code>的图像，示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Y Y Y Y Y Y</span><br><span class="line">Y Y Y Y Y Y</span><br><span class="line">Y Y Y Y Y Y</span><br><span class="line">Y Y Y Y Y Y</span><br><span class="line">U V U V U V</span><br><span class="line">U V U V U V</span><br><span class="line"> - NV12 -</span><br></pre></td></tr></table></figure>
<p>内存空间大小：6x(4+4&#x2F;2)x8&#x3D;288bit</p>
<h2 id="RGBA转NV12-计算公式"><a href="#RGBA转NV12-计算公式" class="headerlink" title="RGBA转NV12-计算公式"></a>RGBA转NV12-计算公式</h2>
$$
\begin{bmatrix}
   Y \\
   U \\
   V \\
\end{bmatrix} =
\begin{bmatrix}
   0.299  & 0.587  & 0.114 \\
   -0.169 & -0.331 & 0.5   \\
   0.5    & 0.419  & -0.081 \\
\end{bmatrix}
\begin{bmatrix}
   R \\
   G \\
   B \\
\end{bmatrix} +
\begin{bmatrix}
   0 \\
   128 \\
   128 \\
\end{bmatrix} \tag{RGB to YUV}
$$

$$
\begin{bmatrix}
   R \\
   G \\
   B
\end{bmatrix} =
\begin{bmatrix}
   1 & -0.00093 & 1.401687 \\
   1 & -0.3437  & -0.71417 \\
   1 & 1.77216  & 0.00099
\end{bmatrix}
\begin{bmatrix}
   Y \\
   U - 128 \\
   V -128
\end{bmatrix} \tag{ YUV to RGB}
$$


<p>根据上面公式单个像素点的RGB转YUV计算方式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Y =  0.299R + 0.587G + 0.114B</span><br><span class="line">U = -0.169R - 0.331G + 0.500B</span><br><span class="line">V =  0.500R - 0.419G - 0.081B</span><br></pre></td></tr></table></figure>

<h2 id="shader转换"><a href="#shader转换" class="headerlink" title="shader转换"></a>shader转换</h2><p>需求：在实际业务中渲染后的最终结果将输出一张RGBA格式的纹理，但是编码器的输入格式为NV12,因此需要将一个RGBA的纹理转换为一个NV12格式的纹理，并且可以一次性读取NV12格式的数据（glReadPixels）.</p>
<p>shader实现RGB转YUV原理图：</p>
<h3 id="片段着色器处理"><a href="#片段着色器处理" class="headerlink" title="片段着色器处理"></a>片段着色器处理</h3><p>参考实现代码：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dpdGh1Ymhhb2hhby9OREtfT3BlbkdMRVNfM18wL2FwcC9zcmMvbWFpbi9jcHAvc2FtcGxlL1JHQjJOVjIxU2FtcGxlLmNwcA==">https://github.com/githubhaohao/NDK_OpenGLES_3_0/app/src/main/cpp/sample/RGB2NV21Sample.cpp<i class="fa fa-external-link-alt"></i></span></p>
<p>RGBA转成YUYV<br><img data-src="/images/2022/09/opengl_rgba_to_yuv.png" alt="opengl rgba to yuv"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#version 300 es</span><br><span class="line">precision mediump float;</span><br><span class="line">in vec2 v_texCoord;</span><br><span class="line">layout(location = 0) out vec4 outColor;</span><br><span class="line">uniform sampler2D s_TextureMap;//RGBA纹理, 输入纹理参数</span><br><span class="line">uniform float u_Offset;//采样偏移</span><br><span class="line"></span><br><span class="line">//RGB to YUV</span><br><span class="line">//Y =  0.299R + 0.587G + 0.114B</span><br><span class="line">//U = -0.147R - 0.289G + 0.436B</span><br><span class="line">//V =  0.615R - 0.515G - 0.100B</span><br><span class="line"></span><br><span class="line">const vec3 COEF_Y = vec3( 0.299,  0.587,  0.114);</span><br><span class="line">const vec3 COEF_U = vec3(-0.147, -0.289,  0.436);</span><br><span class="line">const vec3 COEF_V = vec3( 0.615, -0.515, -0.100);</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">    vec2 texelOffset = vec2(u_Offset, 0.0);</span><br><span class="line">    vec4 color0 = texture(s_TextureMap, v_texCoord);</span><br><span class="line">    //偏移 offset 采样</span><br><span class="line">    vec4 color1 = texture(s_TextureMap, v_texCoord + texelOffset);</span><br><span class="line"></span><br><span class="line">    float y0 = dot(color0.rgb, COEF_Y);</span><br><span class="line">    float u0 = dot(color0.rgb, COEF_U) + 0.5;</span><br><span class="line">    float v0 = dot(color0.rgb, COEF_V) + 0.5;</span><br><span class="line">    float y1 = dot(color1.rgb, COEF_Y);</span><br><span class="line"></span><br><span class="line">    outColor = vec4(y0, u0, y1, v0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="为什么UV分量要加0-5"><a href="#为什么UV分量要加0-5" class="headerlink" title="为什么UV分量要加0.5"></a>为什么UV分量要加<code>0.5</code></h4><p>因为<code>归一化</code></p>
<p>YUV格式图像<code>UV分量</code>的默认值分别是<code>127</code>，<code>Y分量</code>默认值是<code>0</code> ，8个bit位的取值范围是<code>0 ~ 255</code>，由于在shader中纹理采样值需要进行归一化，所以<code>UV分量</code>的采样值需要分别加<code>0.5</code>，确保RGB到YUV正确转换</p>
<blockquote>
<p><code>归一化</code>的目的就是使得预处理的数据被限定在一定的范围内（比如[0,1]或者[-1,1]），从而消除奇异样本数据导致的不良影响</p>
</blockquote>
<blockquote>
<p>纹理格式:</p>
<p>OpenGL默认以无符号<code>归一化</code>格式存储纹理；当数据以无符号归一化格式存储时，<strong>纹素的值在内存中以整数存储，整数在读进着色器时转化为浮点数，并且用整数对应的最大值来除，最后生成[0.0, 1.0]的数据传给着色器</strong>。如果提供的是_SNORM修改符（例如GL_RGBA8_SNORM），数据是有符号的归一化；此时在内存中的数据是有符号整数，并且在它返回给着色器前，转换为浮点数，并被对应的最大有符号整数除，生成范围在[-1.0, 1.0]的浮点数值并传给着色器</p>
</blockquote>
<p>YUV默认值<code>[0, 127, 127]</code>的情况下，着色器读取数据时进行归一化(每个分量除以最大值255)，将变为<code>[0, 0.5, 0.5]</code>；而RGB默认值<code>[0, 0, 0]</code>, 进行归一化，后依然为<code>[0, 0, 0]</code>，因此在shader中进行转换时需要考虑归一化后的参数，RGB转YUV时，UV分量需要加<code>0.5</code>，而YUV转RGB时，UV分量需要减<code>0.5</code>。</p>
<h3 id="计算着色器处理"><a href="#计算着色器处理" class="headerlink" title="计算着色器处理"></a>计算着色器处理</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#extension GL_NV_image_formats : enable</span><br><span class="line">layout (rgba8, binding = 0) readonly uniform lowp image2D rgbaImage;  //输入纹理ID</span><br><span class="line">layout (r8, binding = 1) writeonly uniform lowp image2D yImage;       //输出纹理ID</span><br><span class="line">layout (local_size_x = 16, local_size_y = 16) in;   //以16x16像素块为处理单元</span><br><span class="line">layout(location = 2) uniform int height;            //输入参数纹理高度</span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">    ivec2 storePos = ivec2(gl_GlobalInvocationID.xy);</span><br><span class="line">    ivec2 nvPos;</span><br><span class="line">    ivec2 ypos;</span><br><span class="line">    vec4 vr;  //right</span><br><span class="line">    vec4 vl;  //left</span><br><span class="line">    vec4 vld;</span><br><span class="line">    vec4 vrd;</span><br><span class="line">    vec4 sumUV;</span><br><span class="line">    vec4 yvec;</span><br><span class="line">    float y0,u0,v0,y1,u1,v1,y2,u2,v2,y3,u3,v3;</span><br><span class="line">    if(storePos.y &gt;= height)</span><br><span class="line">    &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    if(storePos.x % 2 == 0 &amp;&amp; storePos.y % 2 == 0)</span><br><span class="line">    &#123;</span><br><span class="line">        nvPos = storePos;</span><br><span class="line">        ypos = storePos;</span><br><span class="line">        vl = imageLoad(rgbaImage, storePos);</span><br><span class="line">        storePos.x+=1;</span><br><span class="line">        vr = imageLoad(rgbaImage, storePos);</span><br><span class="line">        storePos.y+=1;</span><br><span class="line">        vrd = imageLoad(rgbaImage, storePos);</span><br><span class="line">        storePos.x-=1;</span><br><span class="line">        vld = imageLoad(rgbaImage, storePos);</span><br><span class="line"></span><br><span class="line">        y0 = 0.299*vl.r + 0.587 *vl.g + 0.114*vl.b;</span><br><span class="line">        u0 = (-0.169*vl.r - 0.331*vl.g + 0.500*vl.b) + 0.5;</span><br><span class="line">        v0 = ( 0.500*vl.r - 0.419*vl.g - 0.081*vl.b) + 0.5;</span><br><span class="line"></span><br><span class="line">        y1 = 0.299*vr.r + 0.587 *vr.g + 0.114*vr.b;</span><br><span class="line">        u1 = (-0.169*vr.r - 0.331*vr.g + 0.500*vr.b) + 0.5;</span><br><span class="line">        v1 = ( 0.500*vr.r - 0.419*vr.g - 0.081*vr.b) + 0.5;</span><br><span class="line"></span><br><span class="line">        y2 = 0.299*vrd.r + 0.587 *vrd.g + 0.114*vrd.b;</span><br><span class="line">        u2 = (-0.169*vrd.r - 0.331*vrd.g + 0.500*vrd.b) + 0.5;</span><br><span class="line">        v2 = ( 0.500*vrd.r - 0.419*vrd.g - 0.081*vrd.b) + 0.5;</span><br><span class="line"></span><br><span class="line">        y3 = 0.299*vld.r + 0.587 *vld.g + 0.114*vld.b;</span><br><span class="line">        u3 = (-0.169*vld.r - 0.331*vld.g + 0.500*vld.b) + 0.5;</span><br><span class="line">        v3 = ( 0.500*vld.r - 0.419*vld.g - 0.081*vld.b) + 0.5;</span><br><span class="line"></span><br><span class="line">        sumUV.x = (u0+u1+u2+u3)/4.0;</span><br><span class="line">        sumUV.y = (v0+v1+v2+v3)/4.0;</span><br><span class="line"></span><br><span class="line">        // calculate position of NV components</span><br><span class="line">        nvPos.x = nvPos.x;</span><br><span class="line">        nvPos.y = nvPos.y/2;</span><br><span class="line"></span><br><span class="line">        // update start position of NV buffer</span><br><span class="line">        nvPos.y += height;</span><br><span class="line"></span><br><span class="line">        imageStore(yImage, nvPos, sumUV);</span><br><span class="line">        sumUV.x = sumUV.y;</span><br><span class="line">        nvPos.x += 1;</span><br><span class="line">        imageStore(yImage, nvPos, sumUV);</span><br><span class="line"></span><br><span class="line">        yvec.x = y0;</span><br><span class="line">        imageStore(yImage, ypos, yvec);</span><br><span class="line">        ypos.x = ypos.x+1;</span><br><span class="line">        yvec.x = y1;</span><br><span class="line">        imageStore(yImage, ypos, yvec);</span><br><span class="line">        ypos.y = ypos.y+1;</span><br><span class="line">        yvec.x = y2;</span><br><span class="line">        imageStore(yImage, ypos, yvec);</span><br><span class="line">        ypos.x = ypos.x-1;</span><br><span class="line">        yvec.x = y3;</span><br><span class="line">        imageStore(yImage, ypos, yvec);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输入输出纹理传入shader需要<code>glGetTextureImage</code>进行绑定。</p>
<p>片段着色器和计算着色器在同一个OpenGL上下文中无法使用，会导致渲染后的生成的像素点变为白色。</p>
<p>因此实际操作中需要以渲染上下文为基础，创建一个共享上下文进行转换（转换上下文），这样也可以实现渲染与转换的异步操作，提供部分性能。</p>
<h2 id="另一种处理方式—输出y和uv两个纹理"><a href="#另一种处理方式—输出y和uv两个纹理" class="headerlink" title="另一种处理方式—输出y和uv两个纹理"></a>另一种处理方式—输出y和uv两个纹理</h2><p>参考：<span class="exturl" data-url="aHR0cHM6Ly9zdGFja29vbS5jb20vY25fZW4vcXVlc3Rpb24vM2tBZHU=">https://stackoom.com/cn_en/question/3kAdu<i class="fa fa-external-link-alt"></i></span></p>
<p>着色器代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#version 450 core</span><br><span class="line">layout(local_size_x = 32, local_size_y = 32) in;</span><br><span class="line">layout(binding = 0) uniform sampler2D src;</span><br><span class="line">layout(binding = 0) uniform writeonly image2D dst_y;</span><br><span class="line">layout(binding = 1) uniform writeonly image2D dst_uv;</span><br><span class="line">void main() &#123;</span><br><span class="line">    ivec2 id = ivec2(gl_GlobalInvocationID.xy);</span><br><span class="line">    vec3 yuv = rgb_to_yuv(texelFetch(src, id).rgb);</span><br><span class="line">    imageStore(dst_y, id, vec4(yuv.x,0,0,0));</span><br><span class="line">    imageStore(dst_uv, id, vec4(yuv.yz,0,0));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有很多不同的YUV约定，我不知道您的编码器应该使用哪种约定(上面的转换公式)。因此，将上面的rgb_to_yuv替换为YUV-&gt; RGB转换的倒数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GLuint in_rgb = ...; // rgb(a) input texture</span><br><span class="line">int width = ..., height = ...; // the size of in_rgb</span><br><span class="line"></span><br><span class="line">GLuint tex[2]; // output textures (Y plane, UV plane)</span><br><span class="line"></span><br><span class="line">glCreateTextures(GL_TEXTURE_2D, tex, 2);</span><br><span class="line">glTextureStorage2D(tex[0], 1, GL_R8, width, height); // Y plane</span><br><span class="line"></span><br><span class="line">// UV plane -- TWO mipmap levels</span><br><span class="line">glTextureStorage2D(tex[1], 2, GL_RG8, width, height);</span><br><span class="line"></span><br><span class="line">// use this instead if you need signed UV planes:</span><br><span class="line">//glTextureStorage2D(tex[1], 2, GL_RG8_SNORM, width, height);</span><br><span class="line"></span><br><span class="line">glBindTextures(0, 1, &amp;in_rgb);</span><br><span class="line">glBindImageTextures(0, 2, tex);</span><br><span class="line">glUseProgram(compute); // the above compute shader</span><br><span class="line"></span><br><span class="line">int wgs[3];</span><br><span class="line">glGetProgramiv(compute, GL_COMPUTE_WORK_GROUP_SIZE, wgs);</span><br><span class="line">glDispatchCompute(width/wgs[0], height/wgs[1], 1);</span><br><span class="line"></span><br><span class="line">glUseProgram(0);</span><br><span class="line">glGenerateTextureMipmap(tex[1]); // downsamples tex[1]</span><br><span class="line"></span><br><span class="line">// copy data to the CPU memory:</span><br><span class="line">uint8_t *data = (uint8_t*)malloc(width*height*3/2);</span><br><span class="line">glGetTextureImage(tex[0], 0, GL_RED, GL_UNSIGNED_BYTE, width*height, data);</span><br><span class="line">glGetTextureImage(tex[1], 1, GL_RG, GL_UNSIGNED_BYTE, width*height/2,</span><br><span class="line">    data + width*height);</span><br></pre></td></tr></table></figure>
<ul>
<li>此代码未经测试。</li>
<li>假定宽度和高度可以被32整除。</li>
<li>它可能在某处缺少内存障碍。</li>
<li>这不是从GPU中读取数据的最有效方法-您可能需要至少在读取下一帧的同时计算下一帧。</li>
</ul>
<h2 id="代码实现——参考（未测试）"><a href="#代码实现——参考（未测试）" class="headerlink" title="代码实现——参考（未测试）"></a>代码实现——参考（未测试）</h2><p>参考代码来自：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2NvaGVucm90ZW0vUmdiMk5WMTIv">https://github.com/cohenrotem/Rgb2NV12/<i class="fa fa-external-link-alt"></i></span></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//https://software.intel.com/en-us/node/503873</span><br><span class="line">//YCbCr Color Model:</span><br><span class="line">//    The YCbCr color space is used for component digital video and was developed as part of the ITU-R BT.601 Recommendation. YCbCr is a scaled and offset version of the YUV color space.</span><br><span class="line">//    The Intel IPP functions use the following basic equations [Jack01] to convert between R&#x27;G&#x27;B&#x27; in the range 0-255 and Y&#x27;Cb&#x27;Cr&#x27; (this notation means that all components are derived from gamma-corrected R&#x27;G&#x27;B&#x27;):</span><br><span class="line">//    Y&#x27; = 0.257*R&#x27; + 0.504*G&#x27; + 0.098*B&#x27; + 16</span><br><span class="line">//    Cb&#x27; = -0.148*R&#x27; - 0.291*G&#x27; + 0.439*B&#x27; + 128</span><br><span class="line">//    Cr&#x27; = 0.439*R&#x27; - 0.368*G&#x27; - 0.071*B&#x27; + 128</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//Y&#x27; = 0.257*R&#x27; + 0.504*G&#x27; + 0.098*B&#x27; + 16</span><br><span class="line">static float Rgb2Y(float r0, float g0, float b0)</span><br><span class="line">&#123;</span><br><span class="line">    float y0 = 0.257f*r0 + 0.504f*g0 + 0.098f*b0 + 16.0f;</span><br><span class="line">    return y0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//U equals Cb&#x27;</span><br><span class="line">//Cb&#x27; = -0.148*R&#x27; - 0.291*G&#x27; + 0.439*B&#x27; + 128</span><br><span class="line">static float Rgb2U(float r0, float g0, float b0)</span><br><span class="line">&#123;</span><br><span class="line">    float u0 = -0.148f*r0 - 0.291f*g0 + 0.439f*b0 + 128.0f;</span><br><span class="line">    return u0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//V equals Cr&#x27;</span><br><span class="line">//Cr&#x27; = 0.439*R&#x27; - 0.368*G&#x27; - 0.071*B&#x27; + 128</span><br><span class="line">static float Rgb2V(float r0, float g0, float b0)</span><br><span class="line">&#123;</span><br><span class="line">    float v0 = 0.439f*r0 - 0.368f*g0 - 0.071f*b0 + 128.0f;</span><br><span class="line">    return v0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//Convert two rows from RGB to two Y rows, and one row of interleaved U,V.</span><br><span class="line">//I0 and I1 points two sequential source rows.</span><br><span class="line">//I0 -&gt; rgbrgbrgbrgbrgbrgb...</span><br><span class="line">//I1 -&gt; rgbrgbrgbrgbrgbrgb...</span><br><span class="line">//Y0 and Y1 points two sequential destination rows of Y plane.</span><br><span class="line">//Y0 -&gt; yyyyyy</span><br><span class="line">//Y1 -&gt; yyyyyy</span><br><span class="line">//UV0 points destination rows of interleaved UV plane.</span><br><span class="line">//UV0 -&gt; uvuvuv</span><br><span class="line">static void Rgb2NV12TwoRows(const unsigned char I0[],</span><br><span class="line">                            const unsigned char I1[],</span><br><span class="line">                            int step,</span><br><span class="line">                            const int image_width,</span><br><span class="line">                            unsigned char Y0[],</span><br><span class="line">                            unsigned char Y1[],</span><br><span class="line">                            unsigned char UV0[])</span><br><span class="line">&#123;</span><br><span class="line">    int x;  //Column index</span><br><span class="line"></span><br><span class="line">    //Process 4 source pixels per iteration (2 pixels of row I0 and 2 pixels of row I1).</span><br><span class="line">    for (x = 0; x &lt; image_width; x += 2)</span><br><span class="line">    &#123;</span><br><span class="line">        //Load R,G,B elements from first row (and convert to float).</span><br><span class="line">        float r00 = (float)I0[x*step + 0];</span><br><span class="line">        float g00 = (float)I0[x*step + 1];</span><br><span class="line">        float b00 = (float)I0[x*step + 2];</span><br><span class="line"></span><br><span class="line">        //Load next R,G,B elements from first row (and convert to float).</span><br><span class="line">        float r01 = (float)I0[x*step + step+0];</span><br><span class="line">        float g01 = (float)I0[x*step + step+1];</span><br><span class="line">        float b01 = (float)I0[x*step + step+2];</span><br><span class="line"></span><br><span class="line">        //Load R,G,B elements from second row (and convert to float).</span><br><span class="line">        float r10 = (float)I1[x*step + 0];</span><br><span class="line">        float g10 = (float)I1[x*step + 1];</span><br><span class="line">        float b10 = (float)I1[x*step + 2];</span><br><span class="line"></span><br><span class="line">        //Load next R,G,B elements from second row (and convert to float).</span><br><span class="line">        float r11 = (float)I1[x*step + step+0];</span><br><span class="line">        float g11 = (float)I1[x*step + step+1];</span><br><span class="line">        float b11 = (float)I1[x*step + step+2];</span><br><span class="line"></span><br><span class="line">        //Calculate 4 Y elements.</span><br><span class="line">        float y00 = Rgb2Y(r00, g00, b00);</span><br><span class="line">        float y01 = Rgb2Y(r01, g01, b01);</span><br><span class="line">        float y10 = Rgb2Y(r10, g10, b10);</span><br><span class="line">        float y11 = Rgb2Y(r11, g11, b11);</span><br><span class="line"></span><br><span class="line">        //Calculate 4 U elements.</span><br><span class="line">        float u00 = Rgb2U(r00, g00, b00);</span><br><span class="line">        float u01 = Rgb2U(r01, g01, b01);</span><br><span class="line">        float u10 = Rgb2U(r10, g10, b10);</span><br><span class="line">        float u11 = Rgb2U(r11, g11, b11);</span><br><span class="line"></span><br><span class="line">        //Calculate 4 V elements.</span><br><span class="line">        float v00 = Rgb2V(r00, g00, b00);</span><br><span class="line">        float v01 = Rgb2V(r01, g01, b01);</span><br><span class="line">        float v10 = Rgb2V(r10, g10, b10);</span><br><span class="line">        float v11 = Rgb2V(r11, g11, b11);</span><br><span class="line"></span><br><span class="line">        //Calculate destination U element: average of 2x2 &quot;original&quot; U elements.</span><br><span class="line">        float u0 = (u00 + u01 + u10 + u11)*0.25f;</span><br><span class="line"></span><br><span class="line">        //Calculate destination V element: average of 2x2 &quot;original&quot; V elements.</span><br><span class="line">        float v0 = (v00 + v01 + v10 + v11)*0.25f;</span><br><span class="line"></span><br><span class="line">        //Store 4 Y elements (two in first row and two in second row).</span><br><span class="line">        Y0[x + 0]    = (unsigned char)(y00 + 0.5f);</span><br><span class="line">        Y0[x + 1]    = (unsigned char)(y01 + 0.5f);</span><br><span class="line">        Y1[x + 0]    = (unsigned char)(y10 + 0.5f);</span><br><span class="line">        Y1[x + 1]    = (unsigned char)(y11 + 0.5f);</span><br><span class="line"></span><br><span class="line">        //Store destination U element.</span><br><span class="line">        UV0[x + 0]    = (unsigned char)(u0 + 0.5f);</span><br><span class="line"></span><br><span class="line">        //Store destination V element (next to stored U element).</span><br><span class="line">        UV0[x + 1]    = (unsigned char)(v0 + 0.5f);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//Convert image I from pixel ordered RGB to NV12 format.</span><br><span class="line">//I - Input image in pixel ordered RGB format</span><br><span class="line">//image_width - Number of columns of I</span><br><span class="line">//image_height - Number of rows of I</span><br><span class="line">//J - Destination &quot;image&quot; in NV12 format.</span><br><span class="line"></span><br><span class="line">//I is pixel ordered RGB color format (size in bytes is image_width*image_height*3):</span><br><span class="line">//RGBRGBRGBRGBRGBRGB</span><br><span class="line">//RGBRGBRGBRGBRGBRGB</span><br><span class="line">//RGBRGBRGBRGBRGBRGB</span><br><span class="line">//RGBRGBRGBRGBRGBRGB</span><br><span class="line">//</span><br><span class="line">//J is in NV12 format (size in bytes is image_width*image_height*3/2):</span><br><span class="line">//YYYYYY</span><br><span class="line">//YYYYYY</span><br><span class="line">//UVUVUV</span><br><span class="line">//Each element of destination U is average of 2x2 &quot;original&quot; U elements</span><br><span class="line">//Each element of destination V is average of 2x2 &quot;original&quot; V elements</span><br><span class="line">//</span><br><span class="line">//Limitations:</span><br><span class="line">//1. image_width must be a multiple of 2.</span><br><span class="line">//2. image_height must be a multiple of 2.</span><br><span class="line">//3. I and J must be two separate arrays (in place computation is not supported).</span><br><span class="line">void Rgb2NV12(const unsigned char I[], int step,</span><br><span class="line">              const int image_width,</span><br><span class="line">              const int image_height,</span><br><span class="line">              unsigned char J[])</span><br><span class="line">&#123;</span><br><span class="line">    //In NV12 format, UV plane starts below Y plane.</span><br><span class="line">    unsigned char *UV = &amp;J[image_width*image_height];</span><br><span class="line"></span><br><span class="line">    //I0 and I1 points two sequential source rows.</span><br><span class="line">    const unsigned char *I0;  //I0 -&gt; rgbrgbrgbrgbrgbrgb...</span><br><span class="line">    const unsigned char *I1;  //I1 -&gt; rgbrgbrgbrgbrgbrgb...</span><br><span class="line"></span><br><span class="line">    //Y0 and Y1 points two sequential destination rows of Y plane.</span><br><span class="line">    unsigned char *Y0;    //Y0 -&gt; yyyyyy</span><br><span class="line">    unsigned char *Y1;    //Y1 -&gt; yyyyyy</span><br><span class="line"></span><br><span class="line">    //UV0 points destination rows of interleaved UV plane.</span><br><span class="line">    unsigned char *UV0; //UV0 -&gt; uvuvuv</span><br><span class="line"></span><br><span class="line">    int y;  //Row index</span><br><span class="line"></span><br><span class="line">    //In each iteration: process two rows of Y plane, and one row of interleaved UV plane.</span><br><span class="line">    for (y = 0; y &lt; image_height; y += 2)</span><br><span class="line">    &#123;</span><br><span class="line">        I0 = &amp;I[y*image_width*step];        //Input row width is image_width*3 bytes (each pixel is R,G,B).</span><br><span class="line">        I1 = &amp;I[(y+1)*image_width*step];</span><br><span class="line"></span><br><span class="line">        Y0 = &amp;J[y*image_width];            //Output Y row width is image_width bytes (one Y element per pixel).</span><br><span class="line">        Y1 = &amp;J[(y+1)*image_width];</span><br><span class="line"></span><br><span class="line">        UV0 = &amp;UV[(y/2)*image_width];    //Output UV row - width is same as Y row width.</span><br><span class="line"></span><br><span class="line">        //Process two source rows into: Two Y destination row, and one destination interleaved U,V row.</span><br><span class="line">        Rgb2NV12TwoRows(I0,</span><br><span class="line">                        I1,</span><br><span class="line">                        step,</span><br><span class="line">                        image_width,</span><br><span class="line">                        Y0,</span><br><span class="line">                        Y1,</span><br><span class="line">                        UV0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC9kYTJhNjgyYWU5NjQ=">RGB YUV420sp 互相转换 nv21<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vcG9zdC82OTY2NjA4MDgyMDQyMzU1NzI1">OpenGL ES 将 RGB 图像转换为 YUV 格式。<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9zdGFja29vbS5jb20vY25fZW4vcXVlc3Rpb24vM2tBZHU=">如何使用OpenGL将RGBA转换为NV12？<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vbWF6aGVueXUvcC83MjQwNDA3Lmh0bWw=">【OpenGL】用OpenGL shader实现将YUV(YUV420,YV12)转RGB-(直接调用GPU实现，纯硬件方式，效率高) <i class="fa fa-external-link-alt"></i></span> —— 多个纹理处理</li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC8xOTczMTliMGIwMDc=">OpenGL ES：rgb转换yuv<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>多媒体</category>
        <category>OpenGL</category>
      </categories>
      <tags>
        <tag>opengl</tag>
        <tag>rgba</tag>
        <tag>yuv</tag>
      </tags>
  </entry>
  <entry>
    <title>TGSI for Mesa</title>
    <url>/post/58638.html</url>
    <content><![CDATA[<blockquote>
<p><code>TGSI</code>	Tungsten Graphics Shader Infrastructure</p>
</blockquote>
<span id="more"></span>

<blockquote>
<p>In a Gallium driver, these are first transformed into TGSI by the state tracker and are then transformed into something that will run on the card by the driver.<span class="exturl" data-url="aHR0cDovL3d3dy5pbmZvcm1pdC5jb20vYXJ0aWNsZXMvYXJ0aWNsZS5hc3B4P3A9MTU1NDIwMCZzZXFOdW09NQ==">^link<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<blockquote>
<p>TGSI, Tungsten Graphics Shader Infrastructure, is an intermediate language for describing shaders. Since Gallium is inherently shaderful, shaders are an important part of the API. TGSI is the only intermediate representation used by all drivers.</p>
</blockquote>
<p><img data-src="/images/2019/09/shader_irs_2015.png" alt="shader_IRs_2015"><br><img data-src="/images/2019/09/new_shader_ir.png" alt="new_shader_ir"></p>
<p><img data-src="/images/2020/07/mesa_layers_of_crap_2016_for_ir.svg" alt="Mesa_layers_of_crap_2016_for_IR"></p>
<blockquote>
<p>来自:<span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTWVzYV8oY29tcHV0ZXJfZ3JhcGhpY3Mp">wikipedia mesa<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<p>TGSI是Gallium框架中的所有驱动程序使用着色器的唯一中间表示形式,这里<code>特指</code>的是<code>着色器</code>的中间形式，着色器对驱动而言的所有格式将是TGSI。</p>
<h2 id="TGSI中间语言"><a href="#TGSI中间语言" class="headerlink" title="TGSI中间语言"></a>TGSI中间语言</h2><p>介于在着色器（GLSL）代码与GPU指令之间的一种中间语言，类似与C语言与CPU指令之间存在的汇编语言一样。</p>
<p>在Mesa上，GLSL首先被编译器翻译成tgsi中间语言，然后显卡特定的驱动将这些tgsi语言的代码编译成GPU指令。</p>
<p><img data-src="/images/2019/09/shader_tgsi.png" alt="shader_gtsi"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">glxgears: shader</span><br><span class="line">FRAG</span><br><span class="line">PROPERTY FS_COLOR0_WRITES_ALL_CBUFS 1</span><br><span class="line">DCL IN[0], COLOR, COLOR</span><br><span class="line">DCL OUT[0], COLOR</span><br><span class="line">  0: MOV OUT[0], IN[0]</span><br><span class="line">  1: END</span><br><span class="line"></span><br><span class="line">glxgears: shader</span><br><span class="line">VERT</span><br><span class="line">DCL IN[0]</span><br><span class="line">DCL OUT[0], POSITION</span><br><span class="line">DCL OUT[1], COLOR</span><br><span class="line">DCL CONST[0..10]</span><br><span class="line">DCL TEMP[0..3]</span><br><span class="line">IMM[0] FLT32 &#123;0x00000000, 0x3f800000, 0x00000000, 0x00000000&#125;</span><br><span class="line">  0: MUL TEMP[0], IN[0].xxxx, CONST[0]</span><br><span class="line">  1: MAD TEMP[0], IN[0].yyyy, CONST[1], TEMP[0]</span><br><span class="line">  2: MAD TEMP[0], IN[0].zzzz, CONST[2], TEMP[0]</span><br><span class="line">  3: MAD OUT[0], IN[0].wwww, CONST[3], TEMP[0]</span><br><span class="line">  4: DP3 TEMP[1].x, CONST[4], CONST[4]</span><br><span class="line">  5: RSQ TEMP[1].x, |TEMP[1]|</span><br><span class="line">  6: MUL TEMP[0], CONST[4], TEMP[1].xxxx</span><br><span class="line">  7: MOV TEMP[2], CONST[5]</span><br><span class="line">  8: MOV_SAT OUT[1], TEMP[2]</span><br><span class="line">  9: DP3 TEMP[3], TEMP[0], CONST[6]</span><br><span class="line"> 10: MAX TEMP[1], IMM[0].xxxy, TEMP[3]</span><br><span class="line"> 11: SLT TEMP[1].z, IMM[0].xxxx, TEMP[3]</span><br><span class="line"> 12: ADD TEMP[2], CONST[8], TEMP[2]</span><br><span class="line"> 13: MAD TEMP[2], TEMP[1].yyyy, CONST[9], TEMP[2]</span><br><span class="line"> 14: MAD_SAT OUT[1].xyz, TEMP[1].zzzz, CONST[10], TEMP[2]</span><br><span class="line"> 15: END</span><br></pre></td></tr></table></figure>
<blockquote>
<p>glxgears在渲染中生成的部分TGSI代码</p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9mcmVlZGVza3RvcC5vcmcvd2lraS9Tb2Z0d2FyZS9nYWxsaXVtL3Rnc2ktc3BlY2lmaWNhdGlvbi5wZGY=">TGSI specification<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9nYWxsaXVtLnJlYWR0aGVkb2NzLmlvL2VuL2xhdGVzdC90Z3NpLmh0bWwjaW5zdHJ1Y3Rpb24tc2V0">TGSI Instruction Set<i class="fa fa-external-link-alt"></i></span></li>
</ul>
</blockquote>
<ul>
<li><code>FRAG</code>:fragment片元着色器</li>
<li><code>VERT</code>:vertex顶点着色器</li>
<li><code>DCL</code>: declaration 申明resources</li>
<li><code>IMM</code>: immediate 立即数</li>
<li><code>PROPERTY</code> : property 性质</li>
</ul>
<h2 id="着色器的编译链接"><a href="#着色器的编译链接" class="headerlink" title="着色器的编译链接"></a>着色器的编译链接</h2><p><img data-src="/images/2019/11/glsl_build_link.png" alt="glsl_build_link"></p>
<blockquote>
<p>GLSL中则通过两种对象——<code>着色器对象</code>和<code>着色器程序对象</code>——来分别处理编译过程和连接过程</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">call glShaderSource(shader=58, count=3, )</span><br><span class="line">string[0]=&#123;#version 140</span><br><span class="line">#extension GL_ARB_shader_bit_encoding : require</span><br><span class="line">&#125;</span><br><span class="line">string[1]=&#123;in vec4 in_0;</span><br><span class="line">in vec4 in_1;</span><br><span class="line"></span><br><span class="line">  smooth                     out  vec4 vso_g0A0_f;</span><br><span class="line">uniform float winsys_adjust_y;</span><br><span class="line">vec4 temp0[1];</span><br><span class="line">uniform uvec4 vsconst0[8];</span><br><span class="line">&#125;</span><br><span class="line">string[2]=&#123;void main(void)</span><br><span class="line">&#123;</span><br><span class="line">temp0[0] = vec4((((in_0.xxxx) * uintBitsToFloat(vsconst0[0]))));</span><br><span class="line">temp0[0] = vec4(((in_0.yyyy) * uintBitsToFloat(vsconst0[1]) +  temp0[0] ));</span><br><span class="line">temp0[0] = vec4(((in_0.zzzz) * uintBitsToFloat(vsconst0[2]) +  temp0[0] ));</span><br><span class="line">gl_Position = vec4(((in_0.wwww) * uintBitsToFloat(vsconst0[3]) +  temp0[0] ));</span><br><span class="line">temp0[0] = vec4((((in_1.xxxx) * uintBitsToFloat(vsconst0[4]))));</span><br><span class="line">temp0[0] = vec4(((in_1.yyyy) * uintBitsToFloat(vsconst0[5]) +  temp0[0] ));</span><br><span class="line">temp0[0] = vec4(((in_1.zzzz) * uintBitsToFloat(vsconst0[6]) +  temp0[0] ));</span><br><span class="line">vso_g0A0_f = vec4(((in_1.wwww) * uintBitsToFloat(vsconst0[7]) +  temp0[0] ));</span><br><span class="line">gl_Position.y = gl_Position.y * winsys_adjust_y;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">call glCompileShader(58)</span><br><span class="line">call glGetShaderiv(shader=58, pname=0x8b81, params=1)</span><br><span class="line">call glCreateProgram(): 60</span><br><span class="line">call glAttachShader(program=60, shader=58)</span><br><span class="line">call glAttachShader(program=60, shader=59)</span><br><span class="line">call glBindAttribLocation(60, 0, in_0)</span><br><span class="line">call glBindAttribLocation(60, 1, in_1)</span><br><span class="line">call glLinkProgram(program=60)</span><br><span class="line">call glGetProgramiv(60, 0x8b82, 833648032)</span><br><span class="line">call glGetUniformLocation(program=60, name=winsys_adjust_y): val=0</span><br><span class="line">call glUseProgram(60)</span><br></pre></td></tr></table></figure>

<ul>
<li><code>glShaderSource</code>: 替换着色器对象中的源代码</li>
<li><code>glCompileShader</code>: 编译一个着色器对象</li>
<li><code>glGetShaderiv</code>: 从着色器对象返回一个参数</li>
<li><code>glCreateProgram</code>: 创建一个空program对象并返回一个可以被引用的非零值（program ID）</li>
<li><code>glUseProgram</code>: 安装program对象作为当前渲染状态的一部分</li>
</ul>
<p><img data-src="/images/2019/11/shader_create_flowchart.png" alt="shader_create_flowchart"></p>
<h2 id="GLSL使用"><a href="#GLSL使用" class="headerlink" title="GLSL使用"></a>GLSL使用</h2><p>着色器代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span> vertex_shader[] =</span><br><span class="line"><span class="string">&quot;attribute vec3 position;\n&quot;</span></span><br><span class="line"><span class="string">&quot;attribute vec3 normal;\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;uniform mat4 ModelViewProjectionMatrix;\n&quot;</span></span><br><span class="line"><span class="string">&quot;uniform mat4 NormalMatrix;\n&quot;</span></span><br><span class="line"><span class="string">&quot;uniform vec4 LightSourcePosition;\n&quot;</span></span><br><span class="line"><span class="string">&quot;uniform vec4 MaterialColor;\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;varying vec4 Color;\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;void main(void)\n&quot;</span></span><br><span class="line"><span class="string">&quot;&#123;\n&quot;</span></span><br><span class="line"><span class="string">&quot;    // Transform the normal to eye coordinates\n&quot;</span></span><br><span class="line"><span class="string">&quot;    vec3 N = normalize(vec3(NormalMatrix * vec4(normal, 1.0)));\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;    // The LightSourcePosition is actually its direction for directional light\n&quot;</span></span><br><span class="line"><span class="string">&quot;    vec3 L = normalize(LightSourcePosition.xyz);\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;    // Multiply the diffuse value by the vertex color (which is fixed in this case)\n&quot;</span></span><br><span class="line"><span class="string">&quot;    // to get the actual color that we will use to draw this vertex with\n&quot;</span></span><br><span class="line"><span class="string">&quot;    float diffuse = max(dot(N, L), 0.0);\n&quot;</span></span><br><span class="line"><span class="string">&quot;    Color = diffuse * MaterialColor;\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;    // Transform the position to clip coordinates\n&quot;</span></span><br><span class="line"><span class="string">&quot;    gl_Position = ModelViewProjectionMatrix * vec4(position, 1.0);\n&quot;</span></span><br><span class="line"><span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span> fragment_shader[] =</span><br><span class="line"><span class="string">&quot;precision mediump float;\n&quot;</span></span><br><span class="line"><span class="string">&quot;varying vec4 Color;\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;void main(void)\n&quot;</span></span><br><span class="line"><span class="string">&quot;&#123;\n&quot;</span></span><br><span class="line"><span class="string">&quot;    gl_FragColor = Color;\n&quot;</span></span><br><span class="line"><span class="string">&quot;&#125;&quot;</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Compile the vertex shader */</span></span><br><span class="line">p = vertex_shader;</span><br><span class="line">v = glCreateShader(GL_VERTEX_SHADER);</span><br><span class="line">glShaderSource(v, <span class="number">1</span>, &amp;p, <span class="literal">NULL</span>);</span><br><span class="line">glCompileShader(v);</span><br><span class="line">glGetShaderInfoLog(v, <span class="keyword">sizeof</span> msg, <span class="literal">NULL</span>, msg);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;vertex shader info: %s\n&quot;</span>, msg);</span><br></pre></td></tr></table></figure>

<p><code>glCompileShader</code>主要编译着色器的源代码（即vertex_shader中的GLSL代码）</p>
<ul>
<li>编译后的代码是TGSI中间代码？</li>
<li>如果是在哪个阶段进行的转换？</li>
<li>在virgl驱动中的着色器代码是否进行了转换？</li>
</ul>
<h3 id="glCompileShader"><a href="#glCompileShader" class="headerlink" title="glCompileShader"></a>glCompileShader</h3><blockquote>
<p><code>glCompileShader</code> compiles the source code strings that have been stored in the shader object specified by shader.</p>
</blockquote>
<p>在mesa中的函数调用流程：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_mesa_CompileShader (src/mesa/main/shaderapi.c)</span><br><span class="line"> \-&gt;_mesa_compile_shader</span><br><span class="line">     \-&gt;ensure_builtin_types</span><br><span class="line">     |-&gt;_mesa_glsl_compile_shader</span><br></pre></td></tr></table></figure>
<blockquote>
<p>版本：19.3.0-devel 237c7636ca4c429d4dbfce95b6e3281a8309eac7</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Shader intermediate representation.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note that if the driver requests something other than TGSI, it must</span></span><br><span class="line"><span class="comment"> * always be prepared to receive TGSI in addition to its preferred IR.</span></span><br><span class="line"><span class="comment"> * If the driver requests TGSI as its preferred IR, it will *always*</span></span><br><span class="line"><span class="comment"> * get TGSI.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note that PIPE_SHADER_IR_TGSI should be zero for backwards compat with</span></span><br><span class="line"><span class="comment"> * state trackers that only understand TGSI.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">pipe_shader_ir</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   PIPE_SHADER_IR_TGSI = <span class="number">0</span>,</span><br><span class="line">   PIPE_SHADER_IR_NATIVE,</span><br><span class="line">   PIPE_SHADER_IR_NIR,</span><br><span class="line">   PIPE_SHADER_IR_NIR_SERIALIZED,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Plug in the program and shader-related device driver functions.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">st_init_program_functions</span><span class="params">(<span class="keyword">struct</span> dd_function_table *functions)</span></span><br><span class="line">&#123;</span><br><span class="line">   functions-&gt;NewProgram = st_new_program;</span><br><span class="line">   functions-&gt;DeleteProgram = st_delete_program;</span><br><span class="line">   functions-&gt;ProgramStringNotify = st_program_string_notify;</span><br><span class="line">   functions-&gt;NewATIfs = st_new_ati_fs;</span><br><span class="line">   functions-&gt;LinkShader = st_link_shader;</span><br><span class="line">   functions-&gt;SetMaxShaderCompilerThreads = st_max_shader_compiler_threads;</span><br><span class="line">   functions-&gt;GetShaderProgramCompletionStatus =</span><br><span class="line">      st_get_shader_program_completion_status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>file:  src&#x2F;mesa&#x2F;state_tracker&#x2F;st_cb_program.c</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Link a shader.</span></span><br><span class="line"><span class="comment"> * Called via ctx-&gt;Driver.LinkShader()</span></span><br><span class="line"><span class="comment"> * This is a shared function that branches off to either GLSL IR -&gt; TGSI or</span></span><br><span class="line"><span class="comment"> * GLSL IR -&gt; NIR</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">GLboolean</span><br><span class="line"><span class="title function_">st_link_shader</span><span class="params">(<span class="keyword">struct</span> gl_context *ctx, <span class="keyword">struct</span> gl_shader_program *prog)</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>file: src&#x2F;mesa&#x2F;state_tracker&#x2F;st_glsl_to_ir.cpp</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Link a shader.</span></span><br><span class="line"><span class="comment"> * This actually involves converting GLSL IR into an intermediate TGSI-like IR</span></span><br><span class="line"><span class="comment"> * with code lowering and other optimizations.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> GLboolean</span><br><span class="line"> <span class="title function_">st_link_tgsi</span><span class="params">(<span class="keyword">struct</span> gl_context *ctx, <span class="keyword">struct</span> gl_shader_program *prog)</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>file: src&#x2F;mesa&#x2F;state_tracker&#x2F;st_glsl_to_tgsi.cpp</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">st_link_shader</span><br><span class="line">\/</span><br><span class="line">st_link_tgsi</span><br></pre></td></tr></table></figure>
<h2 id="virgl中着色器的转换"><a href="#virgl中着色器的转换" class="headerlink" title="virgl中着色器的转换"></a>virgl中着色器的转换</h2><p>amdgpu使用开源驱动</p>
<p><img data-src="/images/2019/11/virgl_shader_switch.png" alt="virgl_shader_switch"></p>
<blockquote>
<p>Then, 3D commands. These are close to what we can find in a API like Vulkan. We can setup a viewport, scissor state, create a VBO, and draw it. Shaders are also supported, but we first need to translate them to TGSI; an assembly-like representation. Once on the host, they will be re-translated to GLSL and sent to OpenGL.<br><span class="exturl" data-url="aHR0cHM6Ly9zdHVkaW9waXhsLmNvbS8yMDE3LTA4LTI3LzNkLWFjY2VsZXJhdGlvbi11c2luZy12aXJ0aW8uaHRtbA==">https://studiopixl.com/2017-08-27/3d-acceleration-using-virtio.html<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<ul>
<li>在tgsi的传输中为什么不直接使用tgsi token进行传输，而要转换为text的形式传输？？？<ul>
<li>地址空间的不同是否相关？</li>
<li>tgsi text转换为tgsi token的过程中与当前使用到的纹理数据等其他资源进行关联？</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tgsi_instruction</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="type">unsigned</span> Type       : <span class="number">4</span>;  <span class="comment">/* TGSI_TOKEN_TYPE_INSTRUCTION */</span></span><br><span class="line">   <span class="type">unsigned</span> NrTokens   : <span class="number">8</span>;  <span class="comment">/* UINT */</span></span><br><span class="line">   <span class="type">unsigned</span> Opcode     : <span class="number">8</span>;  <span class="comment">/* TGSI_OPCODE_ */</span></span><br><span class="line">   <span class="type">unsigned</span> Saturate   : <span class="number">1</span>;  <span class="comment">/* BOOL */</span></span><br><span class="line">   <span class="type">unsigned</span> NumDstRegs : <span class="number">2</span>;  <span class="comment">/* UINT */</span></span><br><span class="line">   <span class="type">unsigned</span> NumSrcRegs : <span class="number">4</span>;  <span class="comment">/* UINT */</span></span><br><span class="line">   <span class="type">unsigned</span> Label      : <span class="number">1</span>;</span><br><span class="line">   <span class="type">unsigned</span> Texture    : <span class="number">1</span>;</span><br><span class="line">   <span class="type">unsigned</span> Memory     : <span class="number">1</span>;</span><br><span class="line">   <span class="type">unsigned</span> Precise    : <span class="number">1</span>;</span><br><span class="line">   <span class="type">unsigned</span> Padding    : <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tgsi_instruction_texture</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="type">unsigned</span> Texture  : <span class="number">8</span>;    <span class="comment">/* TGSI_TEXTURE_ */</span></span><br><span class="line">   <span class="type">unsigned</span> NumOffsets : <span class="number">4</span>;</span><br><span class="line">   <span class="type">unsigned</span> ReturnType : <span class="number">3</span>; <span class="comment">/* TGSI_RETURN_TYPE_x */</span></span><br><span class="line">   <span class="type">unsigned</span> Padding : <span class="number">17</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"> * If tgsi_instruction::Label is TRUE, tgsi_instruction_label follows.</span><br><span class="line"> *</span><br><span class="line"> * If tgsi_instruction::Texture is TRUE, tgsi_instruction_texture follows.</span><br><span class="line"> *   if texture instruction has a number of offsets,</span><br><span class="line"> *   then tgsi_instruction::Texture::NumOffset of tgsi_texture_offset follow.</span><br><span class="line"> *</span><br><span class="line"> * Then, tgsi_instruction::NumDstRegs of tgsi_dst_register follow.</span><br><span class="line"> *</span><br><span class="line"> * Then, tgsi_instruction::NumSrcRegs of tgsi_src_register follow.</span><br><span class="line"> *</span><br><span class="line"> * tgsi_instruction::NrTokens contains the total number of words that make the</span><br><span class="line"> * instruction, including the instruction word.</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>
<blockquote>
<p>tgsi_instruction_texture:表明存在指令纹理，其与纹理资源数据之间的关系？</p>
</blockquote>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">glxgears: shader</span><br><span class="line">FRAG</span><br><span class="line">PROPERTY FS_COLOR0_WRITES_ALL_CBUFS 1</span><br><span class="line">DCL IN[0], COLOR, COLOR</span><br><span class="line">DCL OUT[0], COLOR</span><br><span class="line">  0: MOV OUT[0], IN[0]</span><br><span class="line">  1: END</span><br><span class="line"></span><br><span class="line">glxgears: GLSL:glxgears: #version 140</span><br><span class="line"></span><br><span class="line">   in  vec4 ex_c0;</span><br><span class="line">out vec4 fsout_c0;</span><br><span class="line">out vec4 fsout_c1;</span><br><span class="line">out vec4 fsout_c2;</span><br><span class="line">out vec4 fsout_c3;</span><br><span class="line">out vec4 fsout_c4;</span><br><span class="line">out vec4 fsout_c5;</span><br><span class="line">out vec4 fsout_c6;</span><br><span class="line">out vec4 fsout_c7;</span><br><span class="line">void main(void)</span><br><span class="line">&#123;</span><br><span class="line">fsout_c0 = vec4(((ex_c0)));</span><br><span class="line">fsout_c1 = fsout_c0;</span><br><span class="line">fsout_c2 = fsout_c0;</span><br><span class="line">fsout_c3 = fsout_c0;</span><br><span class="line">fsout_c4 = fsout_c0;</span><br><span class="line">fsout_c5 = fsout_c0;</span><br><span class="line">fsout_c6 = fsout_c0;</span><br><span class="line">fsout_c7 = fsout_c0;</span><br><span class="line">&#125;</span><br><span class="line">glxgears:</span><br></pre></td></tr></table></figure>
<blockquote>
<p>TGSI转换成GLSL</p>
</blockquote>
<h2 id="amdgpu中着色器的转换"><a href="#amdgpu中着色器的转换" class="headerlink" title="amdgpu中着色器的转换"></a>amdgpu中着色器的转换</h2><p>在radeonsi用户空间驱动中tgsi的使用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Setup actions for TGSI memory opcode, including texture opcodes.</span><br></pre></td></tr></table></figure>
<blockquote>
<p>TGSI与texture之间在渲染时，之间的联系？？</p>
</blockquote>
<h3 id="radeonsi-for-shader"><a href="#radeonsi-for-shader" class="headerlink" title="radeonsi for shader"></a>radeonsi for shader</h3><p>目前LLVM是amdgpu的后端编译器，在mesa19.3中使用<code>ACO</code>（AMD COmpiler）编译着色器代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TGSI-&gt;LLVM</span><br></pre></td></tr></table></figure>

<blockquote>
<p>It was just two days ago that Valve’s performance-focused “ACO” shader compiler was submitted for review to be included in Mesa for the “RADV” Radeon Vulkan driver. Just minutes ago that new shader compiler back-end was merged for Mesa 19.3.</p>
<p>ACO, short for the AMD COmpiler, is the effort led by Valve at creating a more performant and optimized shader compiler for the Radeon Linux graphics driver. Besides trying to generate the fastest shaders, ACO also aims to provide speedy shader compilation too, as an alternative to the AMDGPU LLVM shader compiler back-end. Initially ACO is for the RADV Vulkan driver but it may be brought to the RadeonSI OpenGL driver in the future. At the moment ACO is in good shape for Volcanic Islands through Vega while the Navi shader support is in primitive form.</p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cucGhvcm9uaXguY29tL3NjYW4ucGhwP3BhZ2U9bmV3c19pdGVtJnB4PU1lc2EtMTkuMy1MYW5kcy1SQURWLUFDTw==">Valve’s ACO Shader Compiler For The Mesa Radeon Vulkan Driver Just Landed<i class="fa fa-external-link-alt"></i></span></li>
</ul>
</blockquote>
<h3 id="ISA-Code"><a href="#ISA-Code" class="headerlink" title="ISA Code"></a>ISA Code</h3><p>Instruction Set Architecture(指令集架构) —— ISA</p>
<blockquote>
<p>The AMDGPU backend provides <code>ISA code</code> generation for AMD GPUs, starting with the R600 family up until the current GCN families. It lives in the lib&#x2F;Target&#x2F;AMDGPU directory.</p>
</blockquote>
<blockquote>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cubGx2bS5vcmcvZG9jcy9BTURHUFVVc2FnZS5odG1sI2FtZGdwdS1pbnRyaW5zaWNz">User Guide for AMDGPU Backend<i class="fa fa-external-link-alt"></i></span></li>
</ul>
</blockquote>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9yb2NtLWRvY3VtZW50YXRpb24ucmVhZHRoZWRvY3MuaW8vZW4vbGF0ZXN0L0dDTl9JU0FfTWFudWFscy90ZXN0ZG9jYm9vay5odG1sI3Rlc3Rkb2Nib29r">“Vega” Instruction Set Architecture<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9yb2NtLWRvY3VtZW50YXRpb24ucmVhZHRoZWRvY3MuaW8vZW4vbGF0ZXN0L0dDTl9JU0FfTWFudWFscy9HQ04tSVNBLU1hbnVhbHMuaHRtbA==">GCN ISA Manuals<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<h3 id="着色器形式的转换"><a href="#着色器形式的转换" class="headerlink" title="着色器形式的转换"></a>着色器形式的转换</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+-------+     +---------+    +---------+     +------+     +------+    +-------+</span><br><span class="line">|       |     |         |    |         |     |      |     |      |    |       |</span><br><span class="line">| GLSL  +-----&gt; GLSL IR +----&gt;   NIR   +-----&gt; TGSI +-----&gt; LLVM +----&gt;  ISA  |</span><br><span class="line">|       |     |         |    |         |     |      |     |      |    |       |</span><br><span class="line">+--+----+     +---------+    +---------+     +--+---+     +------+    +----+--+</span><br><span class="line">   |                                            |                          |</span><br><span class="line">   |                                            |      radeonsi_dri.so     |</span><br><span class="line">   |                common                      |           amdgpu         |</span><br></pre></td></tr></table></figure>

<h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h2><h3 id="GLSL着色器"><a href="#GLSL着色器" class="headerlink" title="GLSL着色器"></a>GLSL着色器</h3><ul>
<li>vertex shader</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//vertex顶点着色器</span><br><span class="line">varying vec3 lightDir, normal;</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">        lightDir = normalize(vec3(gl_LightSource[0].position));</span><br><span class="line">        normal = normalize(gl_NormalMatrix * gl_Normal);</span><br><span class="line"></span><br><span class="line">        gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>fragment shader</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//fragment片元着色器</span><br><span class="line">varying vec3 lightDir, normal;</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">        float intensity;</span><br><span class="line">        vec3 n;</span><br><span class="line">        vec4 color;</span><br><span class="line"></span><br><span class="line">        n = normalize(normal);</span><br><span class="line"></span><br><span class="line">        intensity = max(dot(lightDir,n),0.0);</span><br><span class="line">        color = vec4(1.0, 0, 1.0, 1) * intensity;</span><br><span class="line"></span><br><span class="line">        gl_FragColor = color;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="TGSI-text"><a href="#TGSI-text" class="headerlink" title="TGSI text"></a>TGSI text</h3><p>通过mesa编译后生成的TGSI token进行dump出的text</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">VIRGL_DEBUG=tgsi ./a.out</span><br></pre></td></tr></table></figure>

<ul>
<li>vertex shader</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TGSI:</span><br><span class="line">---8&lt;---</span><br><span class="line">VERT</span><br><span class="line">DCL IN[0]</span><br><span class="line">DCL IN[1]</span><br><span class="line">DCL OUT[0], POSITION</span><br><span class="line">DCL OUT[1], GENERIC[9]</span><br><span class="line">DCL OUT[2].xy, GENERIC[10]</span><br><span class="line">DCL CONST[0..14]</span><br><span class="line">DCL TEMP[0..2], LOCAL</span><br><span class="line">  0: MUL TEMP[0].xyz, CONST[8].xyzz, IN[1].xxxx</span><br><span class="line">  1: MAD TEMP[0].xyz, CONST[9].xyzz, IN[1].yyyy, TEMP[0].xyzz</span><br><span class="line">  2: MAD TEMP[0].xyz, CONST[10].xyzz, IN[1].zzzz, TEMP[0].xyzz</span><br><span class="line">  3: DP3 TEMP[1].x, TEMP[0].xyzz, TEMP[0].xyzz</span><br><span class="line">  4: RSQ TEMP[1].x, TEMP[1].xxxx</span><br><span class="line">  5: MUL TEMP[0].xyz, TEMP[0].xyzz, TEMP[1].xxxx</span><br><span class="line">  6: MUL TEMP[1], CONST[11], IN[0].xxxx</span><br><span class="line">  7: MAD TEMP[1], CONST[12], IN[0].yyyy, TEMP[1]</span><br><span class="line">  8: MAD TEMP[1], CONST[13], IN[0].zzzz, TEMP[1]</span><br><span class="line">  9: MAD TEMP[1], CONST[14], IN[0].wwww, TEMP[1]</span><br><span class="line"> 10: DP3 TEMP[2].x, CONST[3].xyzz, CONST[3].xyzz</span><br><span class="line"> 11: RSQ TEMP[2].x, TEMP[2].xxxx</span><br><span class="line"> 12: MUL TEMP[2].xyz, CONST[3].xyzz, TEMP[2].xxxx</span><br><span class="line"> 13: MOV TEMP[2].w, TEMP[0].xxxx</span><br><span class="line"> 14: MOV OUT[2].xy, TEMP[0].yzyy</span><br><span class="line"> 15: MOV OUT[0], TEMP[1]</span><br><span class="line"> 16: MOV OUT[1], TEMP[2]</span><br><span class="line"> 17: END</span><br><span class="line"></span><br><span class="line">---8&lt;---</span><br></pre></td></tr></table></figure>

<ul>
<li>fragment shader</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TGSI:</span><br><span class="line">---8&lt;---</span><br><span class="line">FRAG</span><br><span class="line">PROPERTY FS_COLOR0_WRITES_ALL_CBUFS 1</span><br><span class="line">DCL IN[0], GENERIC[9], PERSPECTIVE</span><br><span class="line">DCL IN[1].xy, GENERIC[10], PERSPECTIVE</span><br><span class="line">DCL OUT[0], COLOR</span><br><span class="line">DCL TEMP[0..1], LOCAL</span><br><span class="line">IMM[0] FLT32 &#123;0x3f800000, 0x00000000, 0x00000000, 0x00000000&#125;</span><br><span class="line">  0: MOV TEMP[0].x, IN[0].wwww</span><br><span class="line">  1: MOV TEMP[0].yz, IN[1].yxyy</span><br><span class="line">  2: DP3 TEMP[1].x, TEMP[0].xyzz, TEMP[0].xyzz</span><br><span class="line">  3: RSQ TEMP[1].x, TEMP[1].xxxx</span><br><span class="line">  4: MUL TEMP[0].xyz, TEMP[0].xyzz, TEMP[1].xxxx</span><br><span class="line">  5: DP3 TEMP[0].x, IN[0].xyzz, TEMP[0].xyzz</span><br><span class="line">  6: MAX TEMP[0].x, TEMP[0].xxxx, IMM[0].yyyy</span><br><span class="line">  7: MUL TEMP[0], IMM[0].xyxx, TEMP[0].xxxx</span><br><span class="line">  8: MOV OUT[0], TEMP[0]</span><br><span class="line">  9: END</span><br><span class="line"></span><br><span class="line">---8&lt;---</span><br></pre></td></tr></table></figure>

<h3 id="TGSI转换GLSL"><a href="#TGSI转换GLSL" class="headerlink" title="TGSI转换GLSL"></a>TGSI转换GLSL</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">VREND_DEBUG=shader virgl_test_server</span><br></pre></td></tr></table></figure>

<ul>
<li>vertex shader</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a.out: shader</span><br><span class="line">VERT</span><br><span class="line">DCL IN[0]</span><br><span class="line">DCL IN[1]</span><br><span class="line">DCL OUT[0], POSITION</span><br><span class="line">DCL OUT[1], GENERIC[9]</span><br><span class="line">DCL OUT[2].xy, GENERIC[10]</span><br><span class="line">DCL CONST[0..14]</span><br><span class="line">DCL TEMP[0..2], LOCAL</span><br><span class="line">  0: MUL TEMP[0].xyz, CONST[8].xyzz, IN[1].xxxx</span><br><span class="line">  1: MAD TEMP[0].xyz, CONST[9].xyzz, IN[1].yyyy, TEMP[0].xyzz</span><br><span class="line">  2: MAD TEMP[0].xyz, CONST[10].xyzz, IN[1].zzzz, TEMP[0].xyzz</span><br><span class="line">  3: DP3 TEMP[1].x, TEMP[0].xyzz, TEMP[0].xyzz</span><br><span class="line">  4: RSQ TEMP[1].x, TEMP[1].xxxx</span><br><span class="line">  5: MUL TEMP[0].xyz, TEMP[0].xyzz, TEMP[1].xxxx</span><br><span class="line">  6: MUL TEMP[1], CONST[11], IN[0].xxxx</span><br><span class="line">  7: MAD TEMP[1], CONST[12], IN[0].yyyy, TEMP[1]</span><br><span class="line">  8: MAD TEMP[1], CONST[13], IN[0].zzzz, TEMP[1]</span><br><span class="line">  9: MAD TEMP[1], CONST[14], IN[0].wwww, TEMP[1]</span><br><span class="line"> 10: DP3 TEMP[2].x, CONST[3].xyzz, CONST[3].xyzz</span><br><span class="line"> 11: RSQ TEMP[2].x, TEMP[2].xxxx</span><br><span class="line"> 12: MUL TEMP[2].xyz, CONST[3].xyzz, TEMP[2].xxxx</span><br><span class="line"> 13: MOV TEMP[2].w, TEMP[0].xxxx</span><br><span class="line"> 14: MOV OUT[2].xy, TEMP[0].yzyy</span><br><span class="line"> 15: MOV OUT[0], TEMP[1]</span><br><span class="line"> 16: MOV OUT[1], TEMP[2]</span><br><span class="line"> 17: END</span><br><span class="line"></span><br><span class="line">a.out: GLSL:a.out: #version 140</span><br><span class="line">#extension GL_ARB_shader_bit_encoding : require</span><br><span class="line">in vec4 in_0;</span><br><span class="line">in vec4 in_1;</span><br><span class="line"></span><br><span class="line">                             out  vec4 vso_g9A0_f;</span><br><span class="line"></span><br><span class="line">                             out  vec4 vso_g10A0_f;</span><br><span class="line">uniform float winsys_adjust_y;</span><br><span class="line">vec4 temp0[3];</span><br><span class="line">uniform uvec4 vsconst0[15];</span><br><span class="line">void main(void)</span><br><span class="line">&#123;</span><br><span class="line">temp0[0].xyz = vec3(((uintBitsToFloat(vsconst0[8].xyzz) * (in_1.xxxx))).xyz);</span><br><span class="line">temp0[0].xyz = vec3((uintBitsToFloat(vsconst0[9].xyzz) * (in_1.yyyy) +  temp0[0].xyzz ).xyz);</span><br><span class="line">temp0[0].xyz = vec3((uintBitsToFloat(vsconst0[10].xyzz) * (in_1.zzzz) +  temp0[0].xyzz ).xyz);</span><br><span class="line">temp0[1].x = float(dot(vec3( temp0[0].xyzz ), vec3( temp0[0].xyzz )));</span><br><span class="line">temp0[1].x = float(inversesqrt( temp0[1].xxxx .x));</span><br><span class="line">temp0[0].xyz = vec3((( temp0[0].xyzz  *  temp0[1].xxxx )).xyz);</span><br><span class="line">temp0[1] = vec4(((uintBitsToFloat(vsconst0[11]) * (in_0.xxxx))));</span><br><span class="line">temp0[1] = vec4((uintBitsToFloat(vsconst0[12]) * (in_0.yyyy) +  temp0[1] ));</span><br><span class="line">temp0[1] = vec4((uintBitsToFloat(vsconst0[13]) * (in_0.zzzz) +  temp0[1] ));</span><br><span class="line">temp0[1] = vec4((uintBitsToFloat(vsconst0[14]) * (in_0.wwww) +  temp0[1] ));</span><br><span class="line">temp0[2].x = float(dot(vec3(uintBitsToFloat(vsconst0[3].xyzz)), vec3(uintBitsToFloat(vsconst0[3].xyzz))));</span><br><span class="line">temp0[2].x = float(inversesqrt( temp0[2].xxxx .x));</span><br><span class="line">temp0[2].xyz = vec3(((uintBitsToFloat(vsconst0[3].xyzz) *  temp0[2].xxxx )).xyz);</span><br><span class="line">temp0[2].w = float(( temp0[0].xxxx .w));</span><br><span class="line">vso_g10A0_f.xy = vec2(( temp0[0].yzyy .xy));</span><br><span class="line">gl_Position = vec4(( temp0[1] ));</span><br><span class="line">vso_g9A0_f = vec4(( temp0[2] ));</span><br><span class="line">gl_Position.y = gl_Position.y * winsys_adjust_y;</span><br><span class="line">&#125;</span><br><span class="line">a.out:</span><br><span class="line">a.out: GLSL:a.out: #version 140</span><br><span class="line"></span><br><span class="line">smooth    in  vec4 vso_g9A0_f;</span><br><span class="line"></span><br><span class="line">smooth    in  vec4 vso_g10A0_f;</span><br><span class="line">out vec4 fsout_c0;</span><br><span class="line">out vec4 fsout_c1;</span><br><span class="line">out vec4 fsout_c2;</span><br><span class="line">out vec4 fsout_c3;</span><br><span class="line">out vec4 fsout_c4;</span><br><span class="line">out vec4 fsout_c5;</span><br><span class="line">out vec4 fsout_c6;</span><br><span class="line">out vec4 fsout_c7;</span><br><span class="line">vec4 temp0[2];</span><br><span class="line">void main(void)</span><br><span class="line">&#123;</span><br><span class="line">temp0[0].x = float(((vso_g9A0_f.wwww).x));</span><br><span class="line">temp0[0].yz = vec2(((vso_g10A0_f.yxyy).yz));</span><br><span class="line">temp0[1].x = float(dot(vec3( temp0[0].xyzz ), vec3( temp0[0].xyzz )));</span><br><span class="line">temp0[1].x = float(inversesqrt( temp0[1].xxxx .x));</span><br><span class="line">temp0[0].xyz = vec3((( temp0[0].xyzz  *  temp0[1].xxxx )).xyz);</span><br><span class="line">temp0[0].x = float(dot(vec3((vso_g9A0_f.xyzz)), vec3( temp0[0].xyzz )));</span><br><span class="line">temp0[0].x = float((max( temp0[0].xxxx , (vec4(0,0,0,0)))).x);</span><br><span class="line">temp0[0] = vec4((((vec4(1,0,1,1)) *  temp0[0].xxxx )));</span><br><span class="line">fsout_c0 = vec4(( temp0[0] ));</span><br><span class="line">fsout_c1 = fsout_c0;</span><br><span class="line">fsout_c2 = fsout_c0;</span><br><span class="line">fsout_c3 = fsout_c0;</span><br><span class="line">fsout_c4 = fsout_c0;</span><br><span class="line">fsout_c5 = fsout_c0;</span><br><span class="line">fsout_c6 = fsout_c0;</span><br><span class="line">fsout_c7 = fsout_c0;</span><br><span class="line">&#125;</span><br><span class="line">a.out:</span><br><span class="line">a.out: GLSL:a.out: #version 140</span><br><span class="line">#extension GL_ARB_shader_bit_encoding : require</span><br><span class="line">in vec4 in_0;</span><br><span class="line">in vec4 in_1;</span><br><span class="line"></span><br><span class="line">  smooth                     out  vec4 vso_g9A0_f;</span><br><span class="line"></span><br><span class="line">  smooth                     out  vec4 vso_g10A0_f;</span><br><span class="line">uniform float winsys_adjust_y;</span><br><span class="line">vec4 temp0[3];</span><br><span class="line">uniform uvec4 vsconst0[15];</span><br><span class="line">void main(void)</span><br><span class="line">&#123;</span><br><span class="line">temp0[0].xyz = vec3(((uintBitsToFloat(vsconst0[8].xyzz) * (in_1.xxxx))).xyz);</span><br><span class="line">temp0[0].xyz = vec3((uintBitsToFloat(vsconst0[9].xyzz) * (in_1.yyyy) +  temp0[0].xyzz ).xyz);</span><br><span class="line">temp0[0].xyz = vec3((uintBitsToFloat(vsconst0[10].xyzz) * (in_1.zzzz) +  temp0[0].xyzz ).xyz);</span><br><span class="line">temp0[1].x = float(dot(vec3( temp0[0].xyzz ), vec3( temp0[0].xyzz )));</span><br><span class="line">temp0[1].x = float(inversesqrt( temp0[1].xxxx .x));</span><br><span class="line">temp0[0].xyz = vec3((( temp0[0].xyzz  *  temp0[1].xxxx )).xyz);</span><br><span class="line">temp0[1] = vec4(((uintBitsToFloat(vsconst0[11]) * (in_0.xxxx))));</span><br><span class="line">temp0[1] = vec4((uintBitsToFloat(vsconst0[12]) * (in_0.yyyy) +  temp0[1] ));</span><br><span class="line">temp0[1] = vec4((uintBitsToFloat(vsconst0[13]) * (in_0.zzzz) +  temp0[1] ));</span><br><span class="line">temp0[1] = vec4((uintBitsToFloat(vsconst0[14]) * (in_0.wwww) +  temp0[1] ));</span><br><span class="line">temp0[2].x = float(dot(vec3(uintBitsToFloat(vsconst0[3].xyzz)), vec3(uintBitsToFloat(vsconst0[3].xyzz))));</span><br><span class="line">temp0[2].x = float(inversesqrt( temp0[2].xxxx .x));</span><br><span class="line">temp0[2].xyz = vec3(((uintBitsToFloat(vsconst0[3].xyzz) *  temp0[2].xxxx )).xyz);</span><br><span class="line">temp0[2].w = float(( temp0[0].xxxx .w));</span><br><span class="line">vso_g10A0_f.xy = vec2(( temp0[0].yzyy .xy));</span><br><span class="line">gl_Position = vec4(( temp0[1] ));</span><br><span class="line">vso_g9A0_f = vec4(( temp0[2] ));</span><br><span class="line">gl_Position.y = gl_Position.y * winsys_adjust_y;</span><br><span class="line">&#125;</span><br><span class="line">a.out:</span><br></pre></td></tr></table></figure>

<ul>
<li>fragment shader</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a.out: shader</span><br><span class="line">FRAG</span><br><span class="line">PROPERTY FS_COLOR0_WRITES_ALL_CBUFS 1</span><br><span class="line">DCL IN[0], GENERIC[9], PERSPECTIVE</span><br><span class="line">DCL IN[1].xy, GENERIC[10], PERSPECTIVE</span><br><span class="line">DCL OUT[0], COLOR</span><br><span class="line">DCL TEMP[0..1], LOCAL</span><br><span class="line">IMM[0] FLT32 &#123;0x3f800000, 0x00000000, 0x00000000, 0x00000000&#125;</span><br><span class="line">  0: MOV TEMP[0].x, IN[0].wwww</span><br><span class="line">  1: MOV TEMP[0].yz, IN[1].yxyy</span><br><span class="line">  2: DP3 TEMP[1].x, TEMP[0].xyzz, TEMP[0].xyzz</span><br><span class="line">  3: RSQ TEMP[1].x, TEMP[1].xxxx</span><br><span class="line">  4: MUL TEMP[0].xyz, TEMP[0].xyzz, TEMP[1].xxxx</span><br><span class="line">  5: DP3 TEMP[0].x, IN[0].xyzz, TEMP[0].xyzz</span><br><span class="line">  6: MAX TEMP[0].x, TEMP[0].xxxx, IMM[0].yyyy</span><br><span class="line">  7: MUL TEMP[0], IMM[0].xyxx, TEMP[0].xxxx</span><br><span class="line">  8: MOV OUT[0], TEMP[0]</span><br><span class="line">  9: END</span><br><span class="line"></span><br><span class="line">a.out: GLSL:a.out: #version 140</span><br><span class="line"></span><br><span class="line">smooth    in  vec4 vso_g9A0_f;</span><br><span class="line"></span><br><span class="line">smooth    in  vec4 vso_g10A0_f;</span><br><span class="line">out vec4 fsout_c0;</span><br><span class="line">out vec4 fsout_c1;</span><br><span class="line">out vec4 fsout_c2;</span><br><span class="line">out vec4 fsout_c3;</span><br><span class="line">out vec4 fsout_c4;</span><br><span class="line">out vec4 fsout_c5;</span><br><span class="line">out vec4 fsout_c6;</span><br><span class="line">out vec4 fsout_c7;</span><br><span class="line">vec4 temp0[2];</span><br><span class="line">void main(void)</span><br><span class="line">&#123;</span><br><span class="line">temp0[0].x = float(((vso_g9A0_f.wwww).x));</span><br><span class="line">temp0[0].yz = vec2(((vso_g10A0_f.yxyy).yz));</span><br><span class="line">temp0[1].x = float(dot(vec3( temp0[0].xyzz ), vec3( temp0[0].xyzz )));</span><br><span class="line">temp0[1].x = float(inversesqrt( temp0[1].xxxx .x));</span><br><span class="line">temp0[0].xyz = vec3((( temp0[0].xyzz  *  temp0[1].xxxx )).xyz);</span><br><span class="line">temp0[0].x = float(dot(vec3((vso_g9A0_f.xyzz)), vec3( temp0[0].xyzz )));</span><br><span class="line">temp0[0].x = float((max( temp0[0].xxxx , (vec4(0,0,0,0)))).x);</span><br><span class="line">temp0[0] = vec4((((vec4(1,0,1,1)) *  temp0[0].xxxx )));</span><br><span class="line">fsout_c0 = vec4(( temp0[0] ));</span><br><span class="line">fsout_c1 = fsout_c0;</span><br><span class="line">fsout_c2 = fsout_c0;</span><br><span class="line">fsout_c3 = fsout_c0;</span><br><span class="line">fsout_c4 = fsout_c0;</span><br><span class="line">fsout_c5 = fsout_c0;</span><br><span class="line">fsout_c6 = fsout_c0;</span><br><span class="line">fsout_c7 = fsout_c0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul>
<li>打印着色器程序相关的所有参数和字段<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ST_DEBUG=mesa ./a.out</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Print all of a program&#x27;s parameters/fields to stderr.</span><br><span class="line"> */</span><br><span class="line">void</span><br><span class="line">_mesa_print_program_parameters(struct gl_context *ctx, const struct gl_program *prog)</span><br><span class="line">&#123;</span><br><span class="line">   _mesa_fprint_program_parameters(stderr, ctx, prog);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>file: mesa&#x2F;program&#x2F;prog_print.c</p>
</blockquote>
</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9nYWxsaXVtLnJlYWR0aGVkb2NzLmlvL2VuL2xhdGVzdC90Z3NpLmh0bWw=">TGSI<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9mcmVlZGVza3RvcC5vcmcvd2lraS9Tb2Z0d2FyZS9nYWxsaXVtL2dhbGxpdW0zZC14ZHMyMDA3LnBkZg==">gallium3d-xds2007<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL25kZXNoMjYuZ2l0aHViLmlvL3Byb2dyYW1taW5nLzIwMTYvMDcvMDQvQS1CZWdpbm5lcnMtZ3VpZGUtdG8tVEdTSS8=">A beginners guide to TGSI<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL3d3dy5pbmZvcm1pdC5jb20vYXJ0aWNsZXMvYXJ0aWNsZS5hc3B4P3A9MTU1NDIwMA==">The State of Open Source 3D<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9sZWFybm9wZW5nbC5jb20vR2V0dGluZy1zdGFydGVkL1NoYWRlcnM=">learnopengl–Shaders<i class="fa fa-external-link-alt"></i></span>|<span class="exturl" data-url="aHR0cHM6Ly9sZWFybm9wZW5nbC1jbi5naXRodWIuaW8vIw==">【CN】<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vc2hvZW1ha2VyL3AvbGludXhfZ3JhcGhpY3MxMS5odG1s">Linux环境下的图形系统和AMD R600显卡编程(11)——R600指令集<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cueC5vcmcvd2lraS9FdmVudHMvWERDMjAxNS9Qcm9ncmFtL3R1cm5lcl9nbHNsX2NvbXBpbGVyLnBkZg==">GLSL compiler<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9zdHVkaW9waXhsLmNvbS8yMDE3LTA4LTI3LzNkLWFjY2VsZXJhdGlvbi11c2luZy12aXJ0aW8uaHRtbA==">GSoC 2017 - 3D acceleration using VirtIOGPU<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLm1lY2hleWUubmV0LzIwMTIvMDYvdGhlLWxpbnV4LWdyYXBoaWNzLXN0YWNrLyNyZW5kZXJpbmctc3RhY2s=">The Linux Graphics Stack<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cucGhvcm9uaXguY29tL3NjYW4ucGhwP3BhZ2U9YXJ0aWNsZSZpdGVtPWdsc2xfdG9fdGdzaSZudW09MQ==">Testing Out Mesa’s GLSL-To-TGSI Translator<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cucmVzZWFyY2hnYXRlLm5ldC9wdWJsaWNhdGlvbi8yMzI2MjY2NDRfSW50cm9kdWN0aW9uX3RvX0dQVV9Qcm9ncmFtbWluZ193aXRoX0dMU0w=">Introduction to GPU Programming with GLSL<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9uZGVzaDI2LmdpdGh1Yi5pby9wcm9ncmFtbWluZy8yMDE2LzA3LzA0L0EtQmVnaW5uZXJzLWd1aWRlLXRvLVRHU0kv">A beginners guide to TGSI<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9uZGVzaDI2LmdpdGh1Yi5pby9wcm9ncmFtbWluZy8yMDE2LzA5LzI2L0ltcGxlbWVudGluZy1CaWN1YmljLVNjYWxpbmctaW4tVEdTSS8=">Implementing Bicubic Scaling in TGSI<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>多媒体</category>
        <category>mesa</category>
      </categories>
      <tags>
        <tag>mesa</tag>
      </tags>
  </entry>
  <entry>
    <title>图像压缩编码——JPEG</title>
    <url>/post/59613.html</url>
    <content><![CDATA[<p><img data-src="/images/2019/05/jpeg_8x8_block.png" alt="jpeg_8x8_block"></p>
<blockquote>
<p>在JPEG中的数据处理单元是<code>8x8</code>block</p>
</blockquote>
<p>在JPEG中编码器和解码器是<code>互逆</code>的，因此在编解码过程中提供的表说明完全一致</p>
<span id="more"></span>

<h2 id="数据格式-YUV"><a href="#数据格式-YUV" class="headerlink" title="数据格式-YUV"></a>数据格式-YUV</h2><p>标准色彩空间：一个或三个组件。 对于三个组件，YCbCr</p>
<h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><p><img data-src="/images/2019/05/jpeg_encoder.png" alt="jpeg_encoder"></p>
<h2 id="解码"><a href="#解码" class="headerlink" title="解码"></a>解码</h2><p><img data-src="/images/2019/05/jpeg_decoder.png" alt="jpeg_decoder"></p>
<h2 id="DCT变换"><a href="#DCT变换" class="headerlink" title="DCT变换"></a>DCT变换</h2><p>在计算FDCT之前，对应输入数据进行<code>层平移</code>处理，即把输入数据变成带符号的2的补码表示。对于8位输入精度，层平移通过<code>减128</code>来完成。</p>
<ul>
<li>FDCT：</li>
</ul>
<p>$F(u, v) &#x3D; \dfrac{1}{4}c(u)(v)\left[\sum_{i&#x3D;0}^{7}\sum_{j&#x3D;0}^{7}f(i, j)\cos\dfrac{(2i+1)u\pi}{16}\cos\dfrac{(2j+1)v\pi}{16}\right]$</p>
<ul>
<li>IDCT：</li>
</ul>
<p>$f(i, j) &#x3D; \dfrac{1}{4}c(u)c(v)\left[\sum_{u&#x3D;0}^{7}\sum_{v&#x3D;0}^{7}F(u, v)\cos\dfrac{(2i+1)u\pi}{16}\cos\dfrac{(2j+i)v\pi}{16}\right]$</p>
<p>$Cu, Cv &#x3D; 1&#x2F;\sqrt{2}$  为  $u, v &#x3D; 0$<br>$Cu, Cv &#x3D; 1$  除此以外</p>
<h2 id="量化"><a href="#量化" class="headerlink" title="量化"></a>量化</h2><p>所谓量化就是用<code>像素值</code>÷<code>量化表对应值</code>所得的结果。由于量化表左上角的值较小，右上角的值较大，这样就起到了保持低频分量，抑制高频分量的目的。</p>
<blockquote>
<p>Y分量代表了亮度信息，UV分量代表了色差信息,因此量化表通常两张。</p>
</blockquote>
<ul>
<li>编码时</li>
</ul>
<p>$Sq_{vu}&#x3D;round\left(\dfrac{S_{vu}}{Q_{vu}}\right)$</p>
<ul>
<li>解码时</li>
</ul>
<p>$R_{vu} &#x3D; Sq_{vu} \times Q_{vu}$</p>
<h3 id="量化表"><a href="#量化表" class="headerlink" title="量化表"></a>量化表</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//亮度分量量化表</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> quant_y[<span class="number">8</span>][<span class="number">8</span>] = &#123;</span><br><span class="line">    &#123;<span class="number">16</span>, <span class="number">11</span>, <span class="number">10</span>, <span class="number">16</span>, <span class="number">24</span>,  <span class="number">40</span>,  <span class="number">51</span>,  <span class="number">61</span>&#125;,</span><br><span class="line">    &#123;<span class="number">12</span>, <span class="number">12</span>, <span class="number">14</span>, <span class="number">19</span>, <span class="number">26</span>,  <span class="number">58</span>,  <span class="number">60</span>,  <span class="number">55</span>&#125;,</span><br><span class="line">    &#123;<span class="number">14</span>, <span class="number">13</span>, <span class="number">16</span>, <span class="number">24</span>, <span class="number">40</span>,  <span class="number">57</span>,  <span class="number">69</span>,  <span class="number">56</span>&#125;,</span><br><span class="line">    &#123;<span class="number">14</span>, <span class="number">17</span>, <span class="number">22</span>, <span class="number">29</span>, <span class="number">51</span>,  <span class="number">87</span>,  <span class="number">80</span>,  <span class="number">62</span>&#125;,</span><br><span class="line">    &#123;<span class="number">18</span>, <span class="number">22</span>, <span class="number">37</span>, <span class="number">56</span>, <span class="number">68</span>,  <span class="number">109</span>, <span class="number">103</span>, <span class="number">77</span>&#125;,</span><br><span class="line">    &#123;<span class="number">24</span>, <span class="number">35</span>, <span class="number">55</span>, <span class="number">64</span>, <span class="number">81</span>,  <span class="number">104</span>, <span class="number">113</span>, <span class="number">92</span>&#125;,</span><br><span class="line">    &#123;<span class="number">49</span>, <span class="number">64</span>, <span class="number">78</span>, <span class="number">87</span>, <span class="number">103</span>, <span class="number">121</span>, <span class="number">120</span>, <span class="number">101</span>&#125;,</span><br><span class="line">    &#123;<span class="number">72</span>, <span class="number">92</span>, <span class="number">95</span>, <span class="number">98</span>, <span class="number">112</span>, <span class="number">100</span>, <span class="number">103</span>, <span class="number">99</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//色度分量量化表</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> quant_uv[<span class="number">8</span>][<span class="number">8</span>] = &#123;</span><br><span class="line">    &#123;<span class="number">17</span>, <span class="number">18</span>, <span class="number">24</span>, <span class="number">47</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>&#125;,</span><br><span class="line">    &#123;<span class="number">18</span>, <span class="number">21</span>, <span class="number">26</span>, <span class="number">66</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>&#125;,</span><br><span class="line">    &#123;<span class="number">24</span>, <span class="number">26</span>, <span class="number">56</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>&#125;,</span><br><span class="line">    &#123;<span class="number">47</span>, <span class="number">66</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>&#125;,</span><br><span class="line">    &#123;<span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>&#125;,</span><br><span class="line">    &#123;<span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>&#125;,</span><br><span class="line">    &#123;<span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>&#125;,</span><br><span class="line">    &#123;<span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>所谓JPEG的有损压缩，损的是量化过程中的高频部分; 因为对于人眼而言<code>低频部分比高频部分要重要得多</code></p>
</blockquote>
<h2 id="8×8块样本与DCT系数的关系"><a href="#8×8块样本与DCT系数的关系" class="headerlink" title="8×8块样本与DCT系数的关系"></a>8×8块样本与DCT系数的关系</h2><p><img data-src="/images/2019/05/jpeg_8x8block%E4%B8%8Edct%E7%B3%BB%E6%95%B0%E5%85%B3%E7%B3%BB.png" alt="jpeg_8x8block与DCT系数关系"></p>
<h2 id="编码分类"><a href="#编码分类" class="headerlink" title="编码分类"></a>编码分类</h2><p><img data-src="/images/2019/05/zigzag.png" alt="zigzag"></p>
<ul>
<li>一类是每个8<em>8格子中的[0,0]位置上元素，即<code>DC</code>(直流分量)，代表8</em>8个子块的平均值,采用<code>差分编码DPCM</code><ul>
<li>$DIFF &#x3D; DC_i - PRED$</li>
<li>在扫描行和每个重启动间隔的开始时，将DC系数的预测值(PRED)初始化为<code>0</code>.</li>
</ul>
</li>
<li>二类是每个8*8格子中的其余63个元素，即<code>AC</code>(交流分量)，采用<code>行程编码RLE</code><ul>
<li>为了保证低频分量先出现，高频分量后出现，以增加行程中连续“0”的个数，这63个元素采用了“Z”字型(Zig-Zag)的排列方法</li>
<li>如果“Z”序列中的剩余系数全为0，那么可直接使用块结束符（EOB）进行编码</li>
</ul>
</li>
</ul>
<h3 id="zigzag"><a href="#zigzag" class="headerlink" title="zigzag"></a>zigzag</h3><p><img data-src="/images/2019/05/jpeg_zig_zag_table.png" alt="jpeg_zig_zag_table"></p>
<h2 id="熵编码"><a href="#熵编码" class="headerlink" title="熵编码"></a>熵编码</h2><p>熵编码指熵保持编码，编码时，平均信息量保持不变。</p>
<h3 id="Huffman编码"><a href="#Huffman编码" class="headerlink" title="Huffman编码"></a>Huffman编码</h3><ul>
<li>对出现频率较高的符号，设计较短的码字，反之，用最长的码字</li>
<li>Huffman编码表事先定义好</li>
</ul>
<h4 id="编码表"><a href="#编码表" class="headerlink" title="编码表"></a>编码表</h4><ul>
<li>亮度<code>Y</code>的<code>DC</code> huffman码表</li>
<li>色度<code>U\V</code>的<code>DC</code> huffman码表</li>
<li>亮度<code>Y</code>的<code>AC</code> huffman码表</li>
<li>色度<code>U\V</code>的<code>AC</code> huffman码表</li>
</ul>
<blockquote>
<p><span class="exturl" data-url="aHR0cDovL3d3dy5jbmJsb2dzLmNvbS9keHM5NTkyMjk2NDAvcC8zODUzNzkwLmh0bWw=">JPEG Huffman Coding Table<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<p>编码表的生成：<span class="exturl" data-url="aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL1dpbmRkb2luZy9Db2RlV2hlZWwvbWFzdGVyL2pwZWcvanBlZ19odWZmbWFuX2FjX2RjX3RhYmxlLmM=">https://raw.githubusercontent.com/Winddoing/CodeWheel/master/jpeg/jpeg_huffman_ac_dc_table.c<i class="fa fa-external-link-alt"></i></span></p>
<p>主要生成<code>EHUFSI</code>和<code>EHUFCO</code>两类表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">亮度DC系数:</span><br><span class="line">===&gt; size, EHUFSI_DC:</span><br><span class="line">===&gt; dump: &#123;</span><br><span class="line">    2     3     3     3     3     3     4     5     6     7     8     9</span><br><span class="line">&#125;</span><br><span class="line">===&gt; code, EHUFCO_DC:</span><br><span class="line">===&gt; dump: &#123;</span><br><span class="line">    0     2     3     4     5     6    14    30    62   126   254   510</span><br><span class="line">&#125;</span><br><span class="line">色差DC系数:</span><br><span class="line">===&gt; size, EHUFSI_DC:</span><br><span class="line">===&gt; dump: &#123;</span><br><span class="line">    2     2     2     3     4     5     6     7     8     9    10    11</span><br><span class="line">&#125;</span><br><span class="line">===&gt; code, EHUFCO_DC:</span><br><span class="line">===&gt; dump: &#123;</span><br><span class="line">    0     1     2     6    14    30    62   126   254   510  1022  2046</span><br><span class="line">&#125;</span><br><span class="line">亮度AC系数:</span><br><span class="line">===&gt; size, EHUFSI_AC:</span><br><span class="line">===&gt; dump: &#123;</span><br><span class="line">    4     2     2     3     4     5     7     8    10    16    16     0     0     0     0     0</span><br><span class="line">    0     4     5     7     9    11    16    16    16    16    16     0     0     0     0     0</span><br><span class="line">    0     5     8    10    12    16    16    16    16    16    16     0     0     0     0     0</span><br><span class="line">    0     6     9    12    16    16    16    16    16    16    16     0     0     0     0     0</span><br><span class="line">    0     6    10    16    16    16    16    16    16    16    16     0     0     0     0     0</span><br><span class="line">    0     7    11    16    16    16    16    16    16    16    16     0     0     0     0     0</span><br><span class="line">    0     7    12    16    16    16    16    16    16    16    16     0     0     0     0     0</span><br><span class="line">    0     8    12    16    16    16    16    16    16    16    16     0     0     0     0     0</span><br><span class="line">    0     9    15    16    16    16    16    16    16    16    16     0     0     0     0     0</span><br><span class="line">    0     9    16    16    16    16    16    16    16    16    16     0     0     0     0     0</span><br><span class="line">    0     9    16    16    16    16    16    16    16    16    16     0     0     0     0     0</span><br><span class="line">    0    10    16    16    16    16    16    16    16    16    16     0     0     0     0     0</span><br><span class="line">    0    10    16    16    16    16    16    16    16    16    16     0     0     0     0     0</span><br><span class="line">    0    11    16    16    16    16    16    16    16    16    16     0     0     0     0     0</span><br><span class="line">    0    16    16    16    16    16    16    16    16    16    16     0     0     0     0     0</span><br><span class="line">   11    16    16    16    16    16    16    16    16    16    16</span><br><span class="line">&#125;</span><br><span class="line">===&gt; code, EHUFCO_AC:</span><br><span class="line">===&gt; dump: &#123;</span><br><span class="line">   10     0     1     4    11    26   120   248  1014 65410 65411     0     0     0     0     0</span><br><span class="line">    0    12    27   121   502  2038 65412 65413 65414 65415 65416     0     0     0     0     0</span><br><span class="line">    0    28   249  1015  4084 65417 65418 65419 65420 65421 65422     0     0     0     0     0</span><br><span class="line">    0    58   503  4085 65423 65424 65425 65426 65427 65428 65429     0     0     0     0     0</span><br><span class="line">    0    59  1016 65430 65431 65432 65433 65434 65435 65436 65437     0     0     0     0     0</span><br><span class="line">    0   122  2039 65438 65439 65440 65441 65442 65443 65444 65445     0     0     0     0     0</span><br><span class="line">    0   123  4086 65446 65447 65448 65449 65450 65451 65452 65453     0     0     0     0     0</span><br><span class="line">    0   250  4087 65454 65455 65456 65457 65458 65459 65460 65461     0     0     0     0     0</span><br><span class="line">    0   504 32704 65462 65463 65464 65465 65466 65467 65468 65469     0     0     0     0     0</span><br><span class="line">    0   505 65470 65471 65472 65473 65474 65475 65476 65477 65478     0     0     0     0     0</span><br><span class="line">    0   506 65479 65480 65481 65482 65483 65484 65485 65486 65487     0     0     0     0     0</span><br><span class="line">    0  1017 65488 65489 65490 65491 65492 65493 65494 65495 65496     0     0     0     0     0</span><br><span class="line">    0  1018 65497 65498 65499 65500 65501 65502 65503 65504 65505     0     0     0     0     0</span><br><span class="line">    0  2040 65506 65507 65508 65509 65510 65511 65512 65513 65514     0     0     0     0     0</span><br><span class="line">    0 65515 65516 65517 65518 65519 65520 65521 65522 65523 65524     0     0     0     0     0</span><br><span class="line"> 2041 65525 65526 65527 65528 65529 65530 65531 65532 65533 65534</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="编码流程"><a href="#编码流程" class="headerlink" title="编码流程"></a>编码流程</h4><p>编码过程是根据一组扩展表<code>XHUFCO</code>和<code>XHUFSI</code>定义的，它们包含所有可能差值的完整霍夫曼CODE和SIZE集合</p>
<h5 id="DC系数Huffman编码"><a href="#DC系数Huffman编码" class="headerlink" title="DC系数Huffman编码"></a>DC系数Huffman编码</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SIZE = XHUFSI(DIFF)</span><br><span class="line">CODE = XHUFCO(DIFF)</span><br><span class="line">code SIZE bits of CODE</span><br></pre></td></tr></table></figure>
<blockquote>
<p>XHUFSI和XHUFCO从编码器表<code>EHUFSI</code>和<code>EHUFCO</code>产生， 使用DIFF作为两个表的索引。</p>
</blockquote>
<p>代码实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Encode the DC coefficient difference per section F.1.2.1 */</span></span><br><span class="line"></span><br><span class="line">temp = temp2 = block[<span class="number">0</span>] - last_dc_val;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* This is a well-known technique for obtaining the absolute value without a</span></span><br><span class="line"><span class="comment"> * branch.  It is derived from an assembly language technique presented in</span></span><br><span class="line"><span class="comment"> * &quot;How to Optimize for the Pentium Processors&quot;, Copyright (c) 1996, 1997 by</span></span><br><span class="line"><span class="comment"> * Agner Fog.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">temp3 = temp &gt;&gt; (CHAR_BIT * <span class="keyword">sizeof</span>(<span class="type">int</span>) - <span class="number">1</span>);</span><br><span class="line">temp ^= temp3;</span><br><span class="line">temp -= temp3;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* For a negative input, want temp2 = bitwise complement of abs(input) */</span></span><br><span class="line"><span class="comment">/* This code assumes we are on a two&#x27;s complement machine */</span></span><br><span class="line">temp2 += temp3;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Find the number of bits needed for the magnitude of the coefficient */</span></span><br><span class="line">nbits = JPEG_NBITS(temp); <span class="comment">//查表计算位宽</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Emit the Huffman-coded symbol for the number of bits */</span></span><br><span class="line">code = dctbl-&gt;ehufco[nbits];</span><br><span class="line">size = dctbl-&gt;ehufsi[nbits];</span><br><span class="line">EMIT_BITS(code, size)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Mask off any extra bits in code */</span></span><br><span class="line">temp2 &amp;= (((JLONG)<span class="number">1</span>) &lt;&lt; nbits) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Emit that number of bits of the value, if positive, */</span></span><br><span class="line"><span class="comment">/* or the complement of its magnitude, if negative. */</span></span><br><span class="line">EMIT_BITS(temp2, nbits)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>libjpeg-turbo: <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2xpYmpwZWctdHVyYm8vbGlianBlZy10dXJiby9ibG9iL21hc3Rlci9qY2h1ZmYuYw==">jchuff.c<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<h5 id="AC系数Huffman编码"><a href="#AC系数Huffman编码" class="headerlink" title="AC系数Huffman编码"></a>AC系数Huffman编码</h5><p>ZZ中的每个非零AC系数由一个复合的8位值RS描述:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">RS = binary ’RRRRSSSS’</span><br></pre></td></tr></table></figure>
<ul>
<li>后面4个低有效位（<code>SSSS</code>）为ZZ中下一个非0系数的幅值定义类别</li>
<li>前面4个高有效位（<code>RRRR</code>）给出ZZ中相对与先前非0系数位置（也就是非0系数之间的0系数行程）</li>
</ul>
<p>由于0系数的行程可能超过15，故定义值<code>’RRRRSSSS‘ = ’0xf0‘</code>来表示行程为15的0系数组，后跟一0幅值的系数。另外，特殊值<code>’RRRRSSSS’ = ‘00000000’</code>用于对块结束符<code>EOB</code>进行编码（当块中的所有剩余系数为0时）。</p>
<p><img data-src="/images/2019/05/jpeg_huffman_ac_code.png" alt="jpeg_huffman_ac_code"></p>
<p><img data-src="/images/2019/05/jpeg_huffman_ac_code1.png" alt="jpeg_huffman_ac_code1"></p>
<p><img data-src="/images/2019/05/jpeg_huffman_ac_code2.png" alt="jpeg_huffman_ac_code2"></p>
<h2 id="示例：8x8block"><a href="#示例：8x8block" class="headerlink" title="示例：8x8block"></a>示例：8x8block</h2><p>一个8x8的量化后的亮度块，已完成zigzag排序：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">系数： 12   5   -2   0   2   0   0   0   1    0     -1     0</span><br><span class="line">下标： 0    1    2   3   4   5   6   7   8  9 ~ 30  31  32 ~ 63</span><br></pre></td></tr></table></figure>

<h3 id="DC系数编码"><a href="#DC系数编码" class="headerlink" title="DC系数编码"></a>DC系数编码</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DIFF = 12； //&#x27;1100b&#x27;</span><br><span class="line">SSSS = 4；  //12位宽表示类别</span><br><span class="line">SIZE = EHUFSI_DC(SSSS) = 3 = 11b</span><br><span class="line">CODE = EHUFCO_DC(SSSS) = 5 = 101b</span><br><span class="line">RESULT = `101b`</span><br><span class="line">RESULT += DIFF = `1011100`</span><br></pre></td></tr></table></figure>

<h3 id="AC系数编码"><a href="#AC系数编码" class="headerlink" title="AC系数编码"></a>AC系数编码</h3><ul>
<li>ZZ(1) &#x3D; 5: 它与ZZ(0)之间无0系数R&#x3D;0，RRRR&#x3D;0；幅值5落入第3类，SSSS&#x3D;3；即’RRRRSSSS‘ &#x3D; ’0&#x2F;3‘。查AC Huffman<a href="#%E7%BC%96%E7%A0%81%E8%A1%A8">编码表</a>为<code>100</code>。幅值5的编码为<code>101</code>，故ZZ(1)的编码为<code>100101</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ZZ(1) = 5; //&#x27;101b&#x27;</span><br><span class="line">R = 0;     //R当前系数与前一个系数之间0的个数</span><br><span class="line">SSSS = CSIZE(ZZ(1)) = 3;</span><br><span class="line">RS = 16 * R + SSSS = 16*0 + 3 = 3;</span><br><span class="line">SIZE = EHUFSI_AC[RS] = 3 = 11b</span><br><span class="line">CODE = EHUFCO_AC[RS] = 4 = 100b</span><br><span class="line">RESULT = `100b`</span><br><span class="line">RESULT += ZZ(1) = `100101b`</span><br></pre></td></tr></table></figure>
<ul>
<li>ZZ(2) &#x3D; -2, ‘RRRRSSSS’ &#x3D; ‘0&#x2F;2’, 查AC Huffman编码表是<code>01</code>，幅值-2落入第2类，ZZ(2) - 1 &#x3D; -3, -3用补码表示并<code>取后两位</code>（-2除去符号位占两个位宽）为<code>01</code>， 因此ZZ(2)的编码<code>0101</code></li>
<li>ZZ(3) &#x3D; 0</li>
<li>ZZ(4) &#x3D; 2, 编码：<code>1101110</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ZZ(4) = 2; //10b</span><br><span class="line">R = 1;</span><br><span class="line">SSSS = CSIZE(ZZ(4)) = 2;</span><br><span class="line">RS = 16 * R + SSSS = 16*1 + 2 = 18;</span><br><span class="line">SIZE = EHUFSI_AC[RS] = 5 = 101b</span><br><span class="line">CODE = EHUFCO_AC[RS] = 27 = 11011b</span><br><span class="line">RESULT = &#x27;11011&#x27;</span><br><span class="line">RESULT += ZZ(4) = &#x27;1101110&#x27;</span><br></pre></td></tr></table></figure>
<ul>
<li>ZZ(5) ~ ZZ(7) &#x3D; 0</li>
<li>ZZ(8) &#x3D; 1, 编码：<code>1110101</code></li>
<li>ZZ(0) ~ ZZ(30) &#x3D; 0, ZZ(31) &#x3D; -1;由于RRRR&#x3D;22 &gt; 15,故先编一个F&#x2F;0,huffman编码为<code>11111111001</code>。然后RRRR&#x3D;22 - 16 &#x3D; 6，这时RRRRSSSS&#x3D;6&#x2F;1， Huffman编码<code>1111011</code>；幅值-1在第1类，取（-1-1&#x3D;-2）补码的最后一位<code>0</code>，最后编码<code>11110110</code></li>
<li>ZZ(32) ~ ZZ(63) &#x3D; 0,直接用一个EOB(0&#x2F;0)结束，编码<code>1010</code></li>
</ul>
<h2 id="JPEG文件"><a href="#JPEG文件" class="headerlink" title="JPEG文件"></a>JPEG文件</h2><h3 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h3><p>JPEG的每个标记都是由 2个字节组成，其前一个字节是固定值<code>0xFF</code>，每个标记之前还可以添加数目不限的0xFF填充字节(fill byte)</p>
<table>
<thead>
<tr>
<th align="center">标记</th>
<th align="center">数值</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">SOI（Start Of Image）</td>
<td align="center">0xD8</td>
<td align="center">图像开始</td>
</tr>
<tr>
<td align="center">APP0</td>
<td align="center">0xEO</td>
<td align="center">JFIF应用数据块</td>
</tr>
<tr>
<td align="center">APPn</td>
<td align="center">0xE1 ~ 0xEF</td>
<td align="center">其他的应用数据块(n, 1～15)</td>
</tr>
<tr>
<td align="center">DQT</td>
<td align="center">0xDB</td>
<td align="center">量化表</td>
</tr>
<tr>
<td align="center">SOF0(Start Of Frame)</td>
<td align="center">0xC0</td>
<td align="center">帧开始</td>
</tr>
<tr>
<td align="center">DHT</td>
<td align="center">0xC4</td>
<td align="center">霍夫曼(Huffman)表</td>
</tr>
<tr>
<td align="center">SOS</td>
<td align="center">0xDA</td>
<td align="center">扫描线开始</td>
</tr>
<tr>
<td align="center">EOI</td>
<td align="center">0xD9</td>
<td align="center">图像结束</td>
</tr>
</tbody></table>
<h3 id="jpeg文件解析示例"><a href="#jpeg文件解析示例" class="headerlink" title="jpeg文件解析示例"></a>jpeg文件解析示例</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Frame 1: 345637 bytes on wire (2765096 bits), 345637 bytes captured (2765096 bits)</span><br><span class="line">MIME file</span><br><span class="line">JPEG File Interchange Format</span><br><span class="line">    Marker: Start of Image (0xffd8)</span><br><span class="line">    Marker segment: Reserved for application segments - 0 (0xFFE0)</span><br><span class="line">        Marker: Reserved for application segments - 0 (0xffe0)</span><br><span class="line">        Length: 16</span><br><span class="line">        Identifier: JFIF</span><br><span class="line">        Version: 1.1</span><br><span class="line">            Major Version: 1</span><br><span class="line">            Minor Version: 1</span><br><span class="line">        Units: Dots per inch (1)</span><br><span class="line">        Xdensity: 0</span><br><span class="line">        Ydensity: 0</span><br><span class="line">        Xthumbnail: 0</span><br><span class="line">        Ythumbnail: 0</span><br><span class="line">    Marker segment: Define quantization table(s) (0xFFDB)</span><br><span class="line">        Marker: Define quantization table(s) (0xffdb)</span><br><span class="line">        Length: 67</span><br><span class="line">        Remaining segment data: 65 bytes</span><br><span class="line">    Marker segment: Define quantization table(s) (0xFFDB)</span><br><span class="line">        Marker: Define quantization table(s) (0xffdb)</span><br><span class="line">        Length: 67</span><br><span class="line">        Remaining segment data: 65 bytes</span><br><span class="line">    Start of Frame header: Start of Frame (non-differential, Huffman coding) - Baseline DCT (0xFFC0)</span><br><span class="line">        Marker: Start of Frame (non-differential, Huffman coding) - Baseline DCT (0xffc0)</span><br><span class="line">        Length: 17</span><br><span class="line">        Sample Precision (bits): 8</span><br><span class="line">        Lines: 1080</span><br><span class="line">        Samples per line: 1920</span><br><span class="line">        Number of image components in frame: 3</span><br><span class="line">        Component identifier: 1</span><br><span class="line">        0010 .... = Horizontal sampling factor: 2</span><br><span class="line">        .... 0010 = Vertical sampling factor: 2</span><br><span class="line">        Quantization table destination selector: 0</span><br><span class="line">        Component identifier: 2</span><br><span class="line">        0001 .... = Horizontal sampling factor: 1</span><br><span class="line">        .... 0001 = Vertical sampling factor: 1</span><br><span class="line">        Quantization table destination selector: 1</span><br><span class="line">        Component identifier: 3</span><br><span class="line">        0001 .... = Horizontal sampling factor: 1</span><br><span class="line">        .... 0001 = Vertical sampling factor: 1</span><br><span class="line">        Quantization table destination selector: 1</span><br><span class="line">    Marker segment: Define Huffman table(s) (0xFFC4)</span><br><span class="line">        Marker: Define Huffman table(s) (0xffc4)</span><br><span class="line">        Length: 27</span><br><span class="line">        Remaining segment data: 25 bytes</span><br><span class="line">    Marker segment: Define Huffman table(s) (0xFFC4)</span><br><span class="line">        Marker: Define Huffman table(s) (0xffc4)</span><br><span class="line">        Length: 73</span><br><span class="line">        Remaining segment data: 71 bytes</span><br><span class="line">    Marker segment: Define Huffman table(s) (0xFFC4)</span><br><span class="line">        Marker: Define Huffman table(s) (0xffc4)</span><br><span class="line">        Length: 26</span><br><span class="line">        Remaining segment data: 24 bytes</span><br><span class="line">    Marker segment: Define Huffman table(s) (0xFFC4)</span><br><span class="line">        Marker: Define Huffman table(s) (0xffc4)</span><br><span class="line">        Length: 51</span><br><span class="line">        Remaining segment data: 49 bytes</span><br><span class="line">    Start of Segment header: Start of Scan (0xFFDA)</span><br><span class="line">        Marker: Start of Scan (0xffda)</span><br><span class="line">        Length: 12</span><br><span class="line">        Number of image components in scan: 3</span><br><span class="line">        Scan component selector: 1</span><br><span class="line">        0000 .... = DC entropy coding table destination selector: 0</span><br><span class="line">        .... 0000 = AC entropy coding table destination selector: 0</span><br><span class="line">        Scan component selector: 2</span><br><span class="line">        0001 .... = DC entropy coding table destination selector: 1</span><br><span class="line">        .... 0001 = AC entropy coding table destination selector: 1</span><br><span class="line">        Scan component selector: 3</span><br><span class="line">        0001 .... = DC entropy coding table destination selector: 1</span><br><span class="line">        .... 0001 = AC entropy coding table destination selector: 1</span><br><span class="line">        Start of spectral or predictor selection: 0</span><br><span class="line">        End of spectral selection: 63</span><br><span class="line">        0000 .... = Successive approximation bit position high: 0</span><br><span class="line">        .... 0000 = Successive approximation bit position low or point transform: 0</span><br><span class="line">    Entropy-coded segment (dissection is not yet implemented): f9354ef5d8ab0a2b96af8daa0006ad822804c0d54d18906a...</span><br><span class="line">    Marker: End of Image (0xffd9)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>wireshark解析</p>
</blockquote>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cudzMub3JnL0dyYXBoaWNzL0pQRUcvaXR1LXQ4MS5wZGY=">itu-t81.pdf<i class="fa fa-external-link-alt"></i></span> —— 图像数字压缩和编码</li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215X2hhcHB5X2xpZmUvYXJ0aWNsZS9kZXRhaWxzLzgyOTk3NTk3">JPEG图像编码<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cudzMub3JnL0dyYXBoaWNzL0pQRUcvamZpZjMucGRm">JPEG File Interchange Format，JFIF<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>多媒体</category>
        <category>编码</category>
      </categories>
      <tags>
        <tag>jpeg</tag>
      </tags>
  </entry>
  <entry>
    <title>线程--pthread</title>
    <url>/post/8868.html</url>
    <content><![CDATA[<p>Linux系统下的多线程遵循<code>POSIX线程</code>接口，称为<code>pthread</code>。编写Linux下的多线程程序，需要使用头文件<code>&lt;pthread.h&gt;</code>，链接时需要使用库libpthread.so。Linux下pthread的实现是通过系统调用<code>clone()</code>来实现的。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc pthread_create.c -o pthread_create -lpthread</span><br></pre></td></tr></table></figure>
<ul>
<li>pthread<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">$ldd pthread_create</span><br><span class="line">	linux-vdso.so<span class="number">.1</span> (<span class="number">0x00007fff45dfe000</span>)</span><br><span class="line">	libpthread.so<span class="number">.0</span> =&gt; /lib/x86_64-linux-gnu/libpthread.so<span class="number">.0</span> (<span class="number">0x00007f5a42a08000</span>)</span><br><span class="line">	libc.so<span class="number">.6</span> =&gt; /lib/x86_64-linux-gnu/libc.so<span class="number">.6</span> (<span class="number">0x00007f5a42617000</span>)</span><br><span class="line">	/lib64/ld-linux-x86<span class="number">-64.</span>so<span class="number">.2</span> (<span class="number">0x00007f5a42e29000</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
<span id="more"></span>

<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p><code>进程</code>是程序执行时的一个<code>实例</code>，即它是程序已经执行到何种程度的数据结构的汇集。从内核的观点看，进程的目的就是担当<code>分配系统资源</code>（CPU时间、内存等）的基本单位。</p>
<p><code>线程</code>是进程的一个<code>执行流</code>，是CPU调度和分派的基本单位，它是比进程更小的能独立运行的基本单位。一个进程由几个线程组成（拥有很多相对独立的执行流的用户程序共享应用程序的大部分数据结构），线程与同属一个进程的其他的线程共享进程所拥有的全部资源。</p>
<blockquote>
<p>“进程——资源分配的最小单位，线程——程序执行的最小单位”</p>
</blockquote>
<blockquote>
<p>进程有独立的地址空间，线程没有单独的地址空间（同一进程内的线程共享进程的地址空间）</p>
</blockquote>
<p>优点：</p>
<ul>
<li>提高应用程序响应。这对图形界面的程序尤其有意义，当一个操作耗时很长时，整个系统都会等待这个操作，此时程序不会响应键盘、鼠标、菜单的操作，而使用多线程技术，将耗时长的操作（time consuming）置于一个新的线程，可以避免这种尴尬的情况。</li>
<li>使多CPU系统更加有效。操作系统会保证当线程数不大于CPU数目时，不同的线程运行于不同的CPU上。</li>
<li>改善程序结构。一个既长又复杂的进程可以考虑分为多个线程，成为几个独立或半独立的运行部分，这样的程序会利于理解和修改。</li>
</ul>
<h2 id="使用多线程的理由"><a href="#使用多线程的理由" class="headerlink" title="使用多线程的理由"></a>使用多线程的理由</h2><ol>
<li><p>理由之一是和进程相比，它是一种非常”节俭”的多任务操作方式。我们知道，在Linux系统下，启动一个新的进程必须分配给它独立的地址空间，建立众多的数据表来维护它的代码段、堆栈段和数据段，这是一种”昂贵”的多任务工作方式。而运行于一个进程中的多个线程，它们彼此之间使用相同的地址空间，共享大部分数据，<code>启动一个线程所花费的空间远远小于启动一个进程所花费的空间</code>，而且，<code>线程间彼此切换所需的时间也远远小于进程间切换所需要的时间</code>。据统计，总的说来，一个进程的开销大约是一个线程开销的<code>30倍</code>左右，当然，在具体的系统上，这个数据可能会有较大的区别。</p>
</li>
<li><p>理由之二是线程间方便的<code>通信机制</code>。对不同进程来说，它们具有独立的数据空间，要进行数据的传递只能通过通信的方式进行，这种方式不仅费时，而且很不方便。线程则不然，由于同一进程下的线程之间共享数据空间，所以一个线程的数据可以直接为其它线程所用，这不仅快捷，而且方便。当然，数据的共享也带来其他一些问题，有的变量不能同时被两个线程所修改，有的子程序中声明为static的数据更有可能给多线程程序带来灾难性的打击，这些正是编写多线程程序时最需要注意的地方。</p>
</li>
</ol>
<p>从函数调用上来说，进程创建使用<code>fork()</code>操作；线程创建使用<code>clone()</code>操作。Richard Stevens大师这样说过：</p>
<blockquote>
<p>fork is expensive. Memory is copied from the parent to the child, all descriptors are duplicated in the child, and so on. Current implementations use a technique called copy-on-write, which avoids a copy of the parent’s data space to the child until the child needs its own copy. But, regardless of this optimization, fork is expensive.</p>
</blockquote>
<blockquote>
<p>IPC is required to pass information between the parent and child after the fork. Passing information from the parent to the child before the fork is easy, since the child starts with a copy of the parent’s data space and with a copy of all the parent’s descriptors. But, returning information from the child to the parent takes more work.</p>
</blockquote>
<blockquote>
<p>Threads help with both problems. Threads are sometimes called lightweight processes since a thread is “lighter weight” than a process. That is, thread creation can be 10–100 times faster than process creation.</p>
</blockquote>
<blockquote>
<p>All threads within a process share the same global memory. This makes the sharing of information easy between the threads, but along with this simplicity comes the problem of synchronization.</p>
</blockquote>
<h2 id="pthread接口"><a href="#pthread接口" class="headerlink" title="pthread接口"></a>pthread接口</h2><blockquote>
<p><code>#include &lt;pthread.h&gt; </code>  #&#x2F;usr&#x2F;include&#x2F;pthread.h</p>
</blockquote>
<h3 id="pthread-create"><a href="#pthread-create" class="headerlink" title="pthread_create"></a>pthread_create</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Create a new thread, starting with execution of START-ROUTINE</span></span><br><span class="line"><span class="comment">   getting passed ARG.  Creation attributed come from ATTR.  The new</span></span><br><span class="line"><span class="comment">   handle is stored in *NEWTHREAD.  */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">pthread_create</span> <span class="params">(<span class="type">pthread_t</span> *__restrict __newthread,</span></span><br><span class="line"><span class="params">               <span class="type">const</span> <span class="type">pthread_attr_t</span> *__restrict __attr,</span></span><br><span class="line"><span class="params">               <span class="type">void</span> *(*__start_routine) (<span class="type">void</span> *),</span></span><br><span class="line"><span class="params">               <span class="type">void</span> *__restrict __arg)</span> __THROWNL __<span class="title function_">nonnull</span> <span class="params">((<span class="number">1</span>, <span class="number">3</span>))</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>用于创建一个线程，成功返回0，否则返回Exxx（为正数）。</p>
<h3 id="pthread-exit"><a href="#pthread-exit" class="headerlink" title="pthread_exit"></a>pthread_exit</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Terminate calling thread.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   The registered cleanup handlers are called via exception handling</span></span><br><span class="line"><span class="comment">   so we cannot mark this function with __THROW.*/</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">pthread_exit</span> <span class="params">(<span class="type">void</span> *__retval)</span> __<span class="title function_">attribute__</span> <span class="params">((__noreturn__))</span>;</span><br></pre></td></tr></table></figure>
<p>用于终止线程，可以指定返回值，以便其他线程通过pthread_join函数获取该线程的返回值。</p>
<h3 id="pthread-join"><a href="#pthread-join" class="headerlink" title="pthread_join"></a>pthread_join</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Make calling thread wait for termination of the thread TH.  The</span></span><br><span class="line"><span class="comment">   exit status of the thread is stored in *THREAD_RETURN, if THREAD_RETURN</span></span><br><span class="line"><span class="comment">   is not NULL.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   This function is a cancellation point and therefore not marked with</span></span><br><span class="line"><span class="comment">   __THROW.  */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">pthread_join</span> <span class="params">(<span class="type">pthread_t</span> __th, <span class="type">void</span> **__thread_return)</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>以<code>阻塞</code>的方式等待thread指定的线程结束。当函数返回时，被等待线程的资源被收回。如果线程已经结束，那么该函数会立即返回。并且thread指定的线程必须是joinable的。</p>
</blockquote>
<p>作用：</p>
<ul>
<li>主线程等待子线程的终止</li>
<li>在子线程调用了&#96;pthread_join()&#96;&#96;方法后面的代码，只有等到子线程结束了才能执行。</li>
</ul>
<h3 id="pthread-detach"><a href="#pthread-detach" class="headerlink" title="pthread_detach"></a>pthread_detach</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Indicate that the thread TH is never to be joined with PTHREAD_JOIN.</span></span><br><span class="line"><span class="comment">   The resources of TH will therefore be freed immediately when it</span></span><br><span class="line"><span class="comment">   terminates, instead of waiting for another thread to perform PTHREAD_JOIN</span></span><br><span class="line"><span class="comment">   on it.  */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">pthread_detach</span> <span class="params">(<span class="type">pthread_t</span> __th)</span> __THROW;</span><br></pre></td></tr></table></figure>
<p>用于是指定线程变为分离状态，就像进程脱离终端而变为后台进程类似。成功返回0，否则返回Exxx（为正数）。变为分离状态的线程，如果线程退出，它的所有资源将全部释放。而如果不是分离状态，线程必须保留它的线程ID，退出状态直到其它线程对它调用了pthread_join。</p>
<h3 id="pthread-self"><a href="#pthread-self" class="headerlink" title="pthread_self"></a>pthread_self</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Obtain the identifier of the current thread.  */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">pthread_t</span> <span class="title function_">pthread_self</span> <span class="params">(<span class="type">void</span>)</span> __THROW __<span class="title function_">attribute__</span> <span class="params">((__const__))</span>;</span><br></pre></td></tr></table></figure>
<p>获取线程自身的ID，该id由线程库维护，其id空间是各个进程独立的（即不同进程中的线程可能有相同的id）。</p>
<ul>
<li>比较两个线程ID<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Compare two thread identifiers.  */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">pthread_equal</span> <span class="params">(<span class="type">pthread_t</span> __thread1, <span class="type">pthread_t</span> __thread2)</span></span><br><span class="line">  __THROW __<span class="title function_">attribute__</span> <span class="params">((__const__))</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="线程属性"><a href="#线程属性" class="headerlink" title="线程属性"></a>线程属性</h3><p>线程属性结构体<code>pthread_attr_t</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> etachstate;     <span class="comment">//线程的分离状态</span></span><br><span class="line">    <span class="type">int</span> schedpolicy;    <span class="comment">//线程的调度策略</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span>　<span class="title">sched</span> <span class="title">schedparam</span>;</span><span class="comment">//线程的调度参数</span></span><br><span class="line">    <span class="type">int</span> inheritsched;   <span class="comment">//线程的继承性</span></span><br><span class="line">    <span class="type">int</span> scope;          <span class="comment">//线程的作用域</span></span><br><span class="line">    <span class="type">size_t</span> guardsize;   <span class="comment">//线程栈末尾的警戒缓冲区大小</span></span><br><span class="line">    <span class="type">int</span> stackaddr_set;  <span class="comment">//线程栈的设置</span></span><br><span class="line">    <span class="type">void</span>* stackaddr;    <span class="comment">//线程栈的启始位置</span></span><br><span class="line">    <span class="type">size_t</span> stacksize;   <span class="comment">//线程栈大小</span></span><br><span class="line">&#125;<span class="type">pthread_attr_t</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>操作接口函数：</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Initialize thread attribute *ATTR with default attributes</span></span><br><span class="line"><span class="comment">   (detachstate is PTHREAD_JOINABLE, scheduling policy is SCHED_OTHER,</span></span><br><span class="line"><span class="comment">    no user-provided stack).  */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">pthread_attr_init</span> <span class="params">(<span class="type">pthread_attr_t</span> *__attr)</span> __THROW __<span class="title function_">nonnull</span> <span class="params">((<span class="number">1</span>))</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Destroy thread attribute *ATTR.  */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">pthread_attr_destroy</span> <span class="params">(<span class="type">pthread_attr_t</span> *__attr)</span></span><br><span class="line">     __THROW __<span class="title function_">nonnull</span> <span class="params">((<span class="number">1</span>))</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Get detach state attribute.  */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">pthread_attr_getdetachstate</span> <span class="params">(<span class="type">const</span> <span class="type">pthread_attr_t</span> *__attr,</span></span><br><span class="line"><span class="params">                    <span class="type">int</span> *__detachstate)</span></span><br><span class="line">     __THROW __<span class="title function_">nonnull</span> <span class="params">((<span class="number">1</span>, <span class="number">2</span>))</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Set detach state attribute.  */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">pthread_attr_setdetachstate</span> <span class="params">(<span class="type">pthread_attr_t</span> *__attr,</span></span><br><span class="line"><span class="params">                    <span class="type">int</span> __detachstate)</span></span><br><span class="line">     __THROW __<span class="title function_">nonnull</span> <span class="params">((<span class="number">1</span>))</span>;</span><br></pre></td></tr></table></figure>

<h3 id="线程之间互斥"><a href="#线程之间互斥" class="headerlink" title="线程之间互斥"></a>线程之间互斥</h3><p>互斥锁：</p>
<blockquote>
<p>使用互斥锁（互斥）可以使线程按顺序执行。通常，互斥锁通过确保一次只有一个线程执行代码的临界段来同步多个线程。互斥锁还可以保护单线程代码。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Mutex handling.  */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Initialize a mutex.  */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">pthread_mutex_init</span> <span class="params">(<span class="type">pthread_mutex_t</span> *__mutex,</span></span><br><span class="line"><span class="params">                   <span class="type">const</span> <span class="type">pthread_mutexattr_t</span> *__mutexattr)</span></span><br><span class="line">     __THROW __<span class="title function_">nonnull</span> <span class="params">((<span class="number">1</span>))</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Destroy a mutex.  */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">pthread_mutex_destroy</span> <span class="params">(<span class="type">pthread_mutex_t</span> *__mutex)</span></span><br><span class="line">     __THROW __<span class="title function_">nonnull</span> <span class="params">((<span class="number">1</span>))</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Try locking a mutex.  */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">pthread_mutex_trylock</span> <span class="params">(<span class="type">pthread_mutex_t</span> *__mutex)</span></span><br><span class="line">     __THROWNL __<span class="title function_">nonnull</span> <span class="params">((<span class="number">1</span>))</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Lock a mutex.  */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">pthread_mutex_lock</span> <span class="params">(<span class="type">pthread_mutex_t</span> *__mutex)</span></span><br><span class="line">     __THROWNL __<span class="title function_">nonnull</span> <span class="params">((<span class="number">1</span>))</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Unlock a mutex.  */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">pthread_mutex_unlock</span> <span class="params">(<span class="type">pthread_mutex_t</span> *__mutex)</span></span><br><span class="line">     __THROWNL __<span class="title function_">nonnull</span> <span class="params">((<span class="number">1</span>))</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Get the priority ceiling of MUTEX.  */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">pthread_mutex_getprioceiling</span> <span class="params">(<span class="type">const</span> <span class="type">pthread_mutex_t</span> *</span></span><br><span class="line"><span class="params">                     __restrict __mutex,</span></span><br><span class="line"><span class="params">                     <span class="type">int</span> *__restrict __prioceiling)</span></span><br><span class="line">     __THROW __<span class="title function_">nonnull</span> <span class="params">((<span class="number">1</span>, <span class="number">2</span>))</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Set the priority ceiling of MUTEX to PRIOCEILING, return old</span></span><br><span class="line"><span class="comment">   priority ceiling value in *OLD_CEILING.  */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">pthread_mutex_setprioceiling</span> <span class="params">(<span class="type">pthread_mutex_t</span> *__restrict __mutex,</span></span><br><span class="line"><span class="params">                     <span class="type">int</span> __prioceiling,</span></span><br><span class="line"><span class="params">                     <span class="type">int</span> *__restrict __old_ceiling)</span></span><br><span class="line">     __THROW __<span class="title function_">nonnull</span> <span class="params">((<span class="number">1</span>, <span class="number">3</span>))</span>;</span><br></pre></td></tr></table></figure>

<p>临界资源保护：</p>
<ol>
<li>声明<code>pthread_mutex_t </code>类型的变量，并初始化<code>pthread_mutex_init</code></li>
<li>对临界资源加锁<code>pthread_mutex_lock</code></li>
<li>其他操作（Do something）</li>
<li>对临界资源解锁<code>pthread_mutex_unlock</code></li>
</ol>
<h3 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h3><p>信号量：</p>
<blockquote>
<p>使用条件变量（信号量）可以以原子方式阻塞线程，直到某个特定条件为真为止。条件变量始终与互斥锁一起使用。对条件的测试是在互斥锁（互斥）的保护下进行的。如果条件为假，线程通常会基于条件变量阻塞，并以原子方式释放等待条件变化的互斥锁。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Functions for handling conditional variables.  */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Initialize condition variable COND using attributes ATTR, or use</span></span><br><span class="line"><span class="comment">   the default values if later is NULL.  */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">pthread_cond_init</span> <span class="params">(<span class="type">pthread_cond_t</span> *__restrict __cond,</span></span><br><span class="line"><span class="params">                  <span class="type">const</span> <span class="type">pthread_condattr_t</span> *__restrict __cond_attr)</span></span><br><span class="line">     __THROW __<span class="title function_">nonnull</span> <span class="params">((<span class="number">1</span>))</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Destroy condition variable COND.  */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">pthread_cond_destroy</span> <span class="params">(<span class="type">pthread_cond_t</span> *__cond)</span></span><br><span class="line">     __THROW __<span class="title function_">nonnull</span> <span class="params">((<span class="number">1</span>))</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Wake up one thread waiting for condition variable COND.  */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">pthread_cond_signal</span> <span class="params">(<span class="type">pthread_cond_t</span> *__cond)</span></span><br><span class="line">     __THROWNL __<span class="title function_">nonnull</span> <span class="params">((<span class="number">1</span>))</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Wake up all threads waiting for condition variables COND.  */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">pthread_cond_broadcast</span> <span class="params">(<span class="type">pthread_cond_t</span> *__cond)</span></span><br><span class="line">     __THROWNL __<span class="title function_">nonnull</span> <span class="params">((<span class="number">1</span>))</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Wait for condition variable COND to be signaled or broadcast.</span></span><br><span class="line"><span class="comment">   MUTEX is assumed to be locked before.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   This function is a cancellation point and therefore not marked with</span></span><br><span class="line"><span class="comment">   __THROW.  */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">pthread_cond_wait</span> <span class="params">(<span class="type">pthread_cond_t</span> *__restrict __cond,</span></span><br><span class="line"><span class="params">                  <span class="type">pthread_mutex_t</span> *__restrict __mutex)</span></span><br><span class="line">     __<span class="title function_">nonnull</span> <span class="params">((<span class="number">1</span>, <span class="number">2</span>))</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Wait for condition variable COND to be signaled or broadcast until</span></span><br><span class="line"><span class="comment">   ABSTIME.  MUTEX is assumed to be locked before.  ABSTIME is an</span></span><br><span class="line"><span class="comment">   absolute time specification; zero is the beginning of the epoch</span></span><br><span class="line"><span class="comment">   (00:00:00 GMT, January 1, 1970).</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   This function is a cancellation point and therefore not marked with</span></span><br><span class="line"><span class="comment">   __THROW.  */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">pthread_cond_timedwait</span> <span class="params">(<span class="type">pthread_cond_t</span> *__restrict __cond,</span></span><br><span class="line"><span class="params">                   <span class="type">pthread_mutex_t</span> *__restrict __mutex,</span></span><br><span class="line"><span class="params">                   <span class="type">const</span> <span class="keyword">struct</span> timespec *__restrict __abstime)</span></span><br><span class="line">     __<span class="title function_">nonnull</span> <span class="params">((<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>))</span>;</span><br></pre></td></tr></table></figure>
<p><code>pthread_cond_wait</code>用于等待某个特定的条件为真，<code>pthread_cond_signal</code>用于通知阻塞的线程某个特定的条件为真了。在调用者两个函数之前需要声明一个<code>pthread_cond_t</code>类型的变量，用于这两个函数的参数。</p>
<blockquote>
<p><code>pthread_cond_wait</code>只是唤醒等待某个条件变量的一个线程。如果需要唤醒所有等待某个条件变量的线程，需要调用：</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_broadcast</span> <span class="params">(<span class="type">pthread_cond_t</span> *__cond)</span></span><br></pre></td></tr></table></figure>

<h3 id="pthread-barrier-xxx"><a href="#pthread-barrier-xxx" class="headerlink" title="pthread_barrier_xxx"></a>pthread_barrier_xxx</h3><p>线程同步，<code>pthread_barrier_*</code>其实只做且只能做一件事，就是充当栏杆（barrier意为栏杆)。形象的说就是把先后到达的多个线程挡在同一栏杆前，直到所有线程到齐，然后撤下栏杆同时放行。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Initialize BARRIER with the attributes in ATTR.  The barrier is</span></span><br><span class="line"><span class="comment">   opened when COUNT waiters arrived.  */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">pthread_barrier_init</span> <span class="params">(<span class="type">pthread_barrier_t</span> *__restrict __barrier,</span></span><br><span class="line"><span class="params">                 <span class="type">const</span> <span class="type">pthread_barrierattr_t</span> *__restrict</span></span><br><span class="line"><span class="params">                 __attr, <span class="type">unsigned</span> <span class="type">int</span> __count)</span></span><br><span class="line">     __THROW __<span class="title function_">nonnull</span> <span class="params">((<span class="number">1</span>))</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Destroy a previously dynamically initialized barrier BARRIER.  */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">pthread_barrier_destroy</span> <span class="params">(<span class="type">pthread_barrier_t</span> *__barrier)</span></span><br><span class="line">     __THROW __<span class="title function_">nonnull</span> <span class="params">((<span class="number">1</span>))</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Wait on barrier BARRIER.  */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">pthread_barrier_wait</span> <span class="params">(<span class="type">pthread_barrier_t</span> *__barrier)</span></span><br><span class="line">     __THROWNL __<span class="title function_">nonnull</span> <span class="params">((<span class="number">1</span>))</span>;</span><br></pre></td></tr></table></figure>
<ol>
<li>init函数负责指定要等待的线程个数</li>
<li>wait()函数由每个线程主动调用，它告诉栏杆“我到起跑线前了”。<ul>
<li>wait(）执行末尾栏杆会检查是否所有人都到栏杆前了</li>
<li>如果是，栏杆就消失所有线程继续执行下一句代码</li>
<li>如果不是，则所有已到wait()的线程等待，剩下没执行到wait()的线程继续执行</li>
</ul>
</li>
<li>destroy函数释放init申请的资源。</li>
</ol>
<p>应用场景：</p>
<blockquote>
<p>比如A和B两人相约在某一个地点C集合去打猎，A和B都知道地方C，但是他们到达的时间不确定，因此谁先到就需要在C点等。</p>
</blockquote>
<h3 id="pthread-once"><a href="#pthread-once" class="headerlink" title="pthread_once"></a>pthread_once</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Guarantee that the initialization function INIT_ROUTINE will be called</span></span><br><span class="line"><span class="comment">   only once, even if pthread_once is executed several times with the</span></span><br><span class="line"><span class="comment">   same ONCE_CONTROL argument. ONCE_CONTROL must point to a static or</span></span><br><span class="line"><span class="comment">   extern variable initialized to PTHREAD_ONCE_INIT.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   The initialization functions might throw exception which is why</span></span><br><span class="line"><span class="comment">   this function is not marked with __THROW.  */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">pthread_once</span> <span class="params">(<span class="type">pthread_once_t</span> *__once_control,</span></span><br><span class="line"><span class="params">             <span class="type">void</span> (*__init_routine) (<span class="type">void</span>))</span> __<span class="title function_">nonnull</span> <span class="params">((<span class="number">1</span>, <span class="number">2</span>))</span>;</span><br></pre></td></tr></table></figure>

<p>pthread_once能够保证<code>__init_routine</code>只被调用一次，具体在哪个线程中执行是不定的</p>
<ul>
<li>用法:<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">pthread_once_t</span> once=PTHREAD_ONCE_INIT;</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    pthread_once(&amp;once,once_init_routine);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="线程私有数据Thread-Specific-Data-TSD"><a href="#线程私有数据Thread-Specific-Data-TSD" class="headerlink" title="线程私有数据Thread Specific Data (TSD)"></a>线程私有数据Thread Specific Data (TSD)</h2><p>在单线程程序中，我们经常使用 “全局变量” 以实现多个函数间共享数据，在多线程环境下，由于数据空间是共享的，因此全局变量也为所有线程所共享。但有时应用程序设计中有必要提供<code>线程私有的全局变量</code>，仅在某个线程中有效，但却可以跨多个函数访问</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Functions for handling thread-specific data.  */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Create a key value identifying a location in the thread-specific</span></span><br><span class="line"><span class="comment">   data area.  Each thread maintains a distinct thread-specific data</span></span><br><span class="line"><span class="comment">   area.  DESTR_FUNCTION, if non-NULL, is called with the value</span></span><br><span class="line"><span class="comment">   associated to that key when the key is destroyed.</span></span><br><span class="line"><span class="comment">   DESTR_FUNCTION is not called if the value associated is NULL when</span></span><br><span class="line"><span class="comment">   the key is destroyed.  */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">pthread_key_create</span> <span class="params">(<span class="type">pthread_key_t</span> *__key,</span></span><br><span class="line"><span class="params">                   <span class="type">void</span> (*__destr_function) (<span class="type">void</span> *))</span></span><br><span class="line">     __THROW __<span class="title function_">nonnull</span> <span class="params">((<span class="number">1</span>))</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Destroy KEY.  */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">pthread_key_delete</span> <span class="params">(<span class="type">pthread_key_t</span> __key)</span> __THROW;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Return current value of the thread-specific data slot identified by KEY.  */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> *<span class="title function_">pthread_getspecific</span> <span class="params">(<span class="type">pthread_key_t</span> __key)</span> __THROW;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Store POINTER in the thread-specific data slot identified by KEY. */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">pthread_setspecific</span> <span class="params">(<span class="type">pthread_key_t</span> __key,</span></span><br><span class="line"><span class="params">                <span class="type">const</span> <span class="type">void</span> *__pointer)</span> __THROW ;</span><br></pre></td></tr></table></figure>


<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><blockquote>
<p>&#x2F;usr&#x2F;include&#x2F;x86_64-linux-gnu&#x2F;bits&#x2F;pthreadtypes.h</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Thread identifiers.  The structure of the attribute type is not</span></span><br><span class="line"><span class="comment">   exposed on purpose.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> <span class="type">pthread_t</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Keys for thread-specific data */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="type">pthread_key_t</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Once-only execution */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> __ONCE_ALIGNMENT <span class="type">pthread_once_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">pthread_attr_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">char</span> __size[__SIZEOF_PTHREAD_ATTR_T];</span><br><span class="line">  <span class="type">long</span> <span class="type">int</span> __align;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __have_pthread_attr_t</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> <span class="title">pthread_attr_t</span> <span class="title">pthread_attr_t</span>;</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __have_pthread_attr_t 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">pthread_mutex_s</span> __<span class="title">data</span>;</span></span><br><span class="line">  <span class="type">char</span> __size[__SIZEOF_PTHREAD_MUTEX_T];</span><br><span class="line">  <span class="type">long</span> <span class="type">int</span> __align;</span><br><span class="line">&#125; <span class="type">pthread_mutex_t</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">pthread_cond_s</span> __<span class="title">data</span>;</span></span><br><span class="line">  <span class="type">char</span> __size[__SIZEOF_PTHREAD_COND_T];</span><br><span class="line">  __extension__ <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> __align;</span><br><span class="line">&#125; <span class="type">pthread_cond_t</span>;</span><br></pre></td></tr></table></figure>

<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL1dpbmRkb2luZy9Db2RlV2hlZWwvbWFzdGVyL0MvcHRocmVhZC9wdGhyZWFkLmM=">pthread.c<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1dpbmRkb2luZy9Db2RlV2hlZWwvdHJlZS9tYXN0ZXIvQy9wdGhyZWFkL3RocmVhZHBvb2w=">threadpool<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><span class="exturl" data-url="aHR0cDovL3d3dy5jbmJsb2dzLmNvbS9za3luZXQvYXJjaGl2ZS8yMDEwLzEwLzMwLzE4NjUyNjcuaHRtbA==">Linux多线程编程（不限Linux)<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuaWJtLmNvbS9kZXZlbG9wZXJ3b3Jrcy9jbi9saW51eC9sLXB0aHJlZC8jaWJtLXBjb24=">pthreads 的基本用法<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>程序设计</category>
        <category>C</category>
      </categories>
      <tags>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title>X Sever —— Xorg</title>
    <url>/post/39845.html</url>
    <content><![CDATA[<p>Xorg：基于<code>X11</code>协议的服务端。管理硬件设备（驱动），键盘鼠标显示器等</p>
<span id="more"></span>


<h2 id="Xorg配置文件"><a href="#Xorg配置文件" class="headerlink" title="Xorg配置文件"></a>Xorg配置文件</h2><p>生成配置文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Xorg -configure :0</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>:0</code>显示窗口，在Xorg启动的情况下，无法获取当前的Xorg配置文件，可以随意指定数字</p>
</blockquote>
<blockquote>
<p><strong>多显示器</strong></p>
<blockquote>
<p>multiple X screens on a single X display (:0.0 and :0.1, where the notation is :<display>.<screen></p>
</blockquote>
</blockquote>
<h3 id="xorg-conf"><a href="#xorg-conf" class="headerlink" title="xorg.conf"></a>xorg.conf</h3><blockquote>
<p>具体参数说明：<code>man xorg.conf</code></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Section &quot;ServerLayout&quot;</span><br><span class="line">	Identifier     &quot;X.org Configured&quot;</span><br><span class="line">	Screen      0  &quot;Screen0&quot; 0 0</span><br><span class="line">	Screen      1  &quot;Screen1&quot; RightOf &quot;Screen0&quot;</span><br><span class="line">	InputDevice    &quot;Mouse0&quot; &quot;CorePointer&quot;</span><br><span class="line">	InputDevice    &quot;Keyboard0&quot; &quot;CoreKeyboard&quot;</span><br><span class="line">EndSection</span><br><span class="line"></span><br><span class="line">Section &quot;Files&quot;</span><br><span class="line">	ModulePath   &quot;/usr/lib/xorg/modules&quot;</span><br><span class="line">	FontPath     &quot;/usr/share/fonts/X11/misc&quot;</span><br><span class="line">	FontPath     &quot;/usr/share/fonts/X11/cyrillic&quot;</span><br><span class="line">	FontPath     &quot;/usr/share/fonts/X11/100dpi/:unscaled&quot;</span><br><span class="line">	FontPath     &quot;/usr/share/fonts/X11/75dpi/:unscaled&quot;</span><br><span class="line">	FontPath     &quot;/usr/share/fonts/X11/Type1&quot;</span><br><span class="line">	FontPath     &quot;/usr/share/fonts/X11/100dpi&quot;</span><br><span class="line">	FontPath     &quot;/usr/share/fonts/X11/75dpi&quot;</span><br><span class="line">	FontPath     &quot;built-ins&quot;</span><br><span class="line">EndSection</span><br><span class="line"></span><br><span class="line">Section &quot;Module&quot;</span><br><span class="line">	Load  &quot;glx&quot;</span><br><span class="line">EndSection</span><br><span class="line"></span><br><span class="line">Section &quot;InputDevice&quot;</span><br><span class="line">	Identifier  &quot;Keyboard0&quot;</span><br><span class="line">	Driver      &quot;kbd&quot;</span><br><span class="line">EndSection</span><br><span class="line"></span><br><span class="line">Section &quot;InputDevice&quot;</span><br><span class="line">	Identifier  &quot;Mouse0&quot;</span><br><span class="line">	Driver      &quot;mouse&quot;</span><br><span class="line">	Option	    &quot;Protocol&quot; &quot;auto&quot;</span><br><span class="line">	Option	    &quot;Device&quot; &quot;/dev/input/mice&quot;</span><br><span class="line">	Option	    &quot;ZAxisMapping&quot; &quot;4 5 6 7&quot;</span><br><span class="line">EndSection</span><br><span class="line"></span><br><span class="line">Section &quot;Monitor&quot;</span><br><span class="line">	Identifier   &quot;Monitor0&quot;</span><br><span class="line">	VendorName   &quot;Monitor Vendor&quot;</span><br><span class="line">	ModelName    &quot;Monitor Model&quot;</span><br><span class="line">EndSection</span><br><span class="line"></span><br><span class="line">Section &quot;Monitor&quot;</span><br><span class="line">	Identifier   &quot;Monitor1&quot;</span><br><span class="line">	VendorName   &quot;Monitor Vendor&quot;</span><br><span class="line">	ModelName    &quot;Monitor Model&quot;</span><br><span class="line">EndSection</span><br><span class="line"></span><br><span class="line">Section &quot;Device&quot;</span><br><span class="line">        ### Available Driver options are:-</span><br><span class="line">        ### Values: &lt;i&gt;: integer, &lt;f&gt;: float, &lt;bool&gt;: &quot;True&quot;/&quot;False&quot;,</span><br><span class="line">        ### &lt;string&gt;: &quot;String&quot;, &lt;freq&gt;: &quot;&lt;f&gt; Hz/kHz/MHz&quot;,</span><br><span class="line">        ### &lt;percent&gt;: &quot;&lt;f&gt;%&quot;</span><br><span class="line">        ### [arg]: arg optional</span><br><span class="line">        #Option     &quot;Accel&quot;              	# [&lt;bool&gt;]</span><br><span class="line">        #Option     &quot;SWcursor&quot;           	# [&lt;bool&gt;]</span><br><span class="line">        #Option     &quot;EnablePageFlip&quot;     	# [&lt;bool&gt;]</span><br><span class="line">        #Option     &quot;SubPixelOrder&quot;      	# [&lt;str&gt;]</span><br><span class="line">        #Option     &quot;ZaphodHeads&quot;        	# &lt;str&gt;</span><br><span class="line">        #Option     &quot;AccelMethod&quot;        	# &lt;str&gt;</span><br><span class="line">        #Option     &quot;DRI3&quot;               	# [&lt;bool&gt;]</span><br><span class="line">        #Option     &quot;DRI&quot;                	# &lt;i&gt;</span><br><span class="line">        #Option     &quot;ShadowPrimary&quot;      	# [&lt;bool&gt;]</span><br><span class="line">        #Option     &quot;TearFree&quot;           	# [&lt;bool&gt;]</span><br><span class="line">        #Option     &quot;DeleteUnusedDP12Displays&quot; 	# [&lt;bool&gt;]</span><br><span class="line">	Identifier  &quot;Card0&quot;</span><br><span class="line">	Driver      &quot;amdgpu&quot;</span><br><span class="line">	BusID       &quot;PCI:1:0:0&quot;</span><br><span class="line">EndSection</span><br><span class="line"></span><br><span class="line">Section &quot;Device&quot;</span><br><span class="line">        ### Available Driver options are:-</span><br><span class="line">        ### Values: &lt;i&gt;: integer, &lt;f&gt;: float, &lt;bool&gt;: &quot;True&quot;/&quot;False&quot;,</span><br><span class="line">        ### &lt;string&gt;: &quot;String&quot;, &lt;freq&gt;: &quot;&lt;f&gt; Hz/kHz/MHz&quot;,</span><br><span class="line">        ### &lt;percent&gt;: &quot;&lt;f&gt;%&quot;</span><br><span class="line">        ### [arg]: arg optional</span><br><span class="line">        #Option     &quot;Accel&quot;              	# [&lt;bool&gt;]</span><br><span class="line">        #Option     &quot;SWcursor&quot;           	# [&lt;bool&gt;]</span><br><span class="line">        #Option     &quot;EnablePageFlip&quot;     	# [&lt;bool&gt;]</span><br><span class="line">        #Option     &quot;SubPixelOrder&quot;      	# [&lt;str&gt;]</span><br><span class="line">        #Option     &quot;ZaphodHeads&quot;        	# &lt;str&gt;</span><br><span class="line">        #Option     &quot;AccelMethod&quot;        	# &lt;str&gt;</span><br><span class="line">        #Option     &quot;DRI3&quot;               	# [&lt;bool&gt;]</span><br><span class="line">        #Option     &quot;DRI&quot;                	# &lt;i&gt;</span><br><span class="line">        #Option     &quot;ShadowPrimary&quot;      	# [&lt;bool&gt;]</span><br><span class="line">        #Option     &quot;TearFree&quot;           	# [&lt;bool&gt;]</span><br><span class="line">        #Option     &quot;DeleteUnusedDP12Displays&quot; 	# [&lt;bool&gt;]</span><br><span class="line">	Identifier  &quot;Card1&quot;</span><br><span class="line">	Driver      &quot;amdgpu&quot;</span><br><span class="line">	BusID       &quot;PCI:1:0:1&quot;</span><br><span class="line">EndSection</span><br><span class="line"></span><br><span class="line">Section &quot;Screen&quot;</span><br><span class="line">	Identifier &quot;Screen0&quot;</span><br><span class="line">	Device     &quot;Card0&quot;</span><br><span class="line">	Monitor    &quot;Monitor0&quot;</span><br><span class="line">	SubSection &quot;Display&quot;</span><br><span class="line">		Viewport   0 0</span><br><span class="line">		Depth     1</span><br><span class="line">	EndSubSection</span><br><span class="line">	SubSection &quot;Display&quot;</span><br><span class="line">		Viewport   0 0</span><br><span class="line">		Depth     4</span><br><span class="line">	EndSubSection</span><br><span class="line">	SubSection &quot;Display&quot;</span><br><span class="line">		Viewport   0 0</span><br><span class="line">		Depth     8</span><br><span class="line">	EndSubSection</span><br><span class="line">	SubSection &quot;Display&quot;</span><br><span class="line">		Viewport   0 0</span><br><span class="line">		Depth     15</span><br><span class="line">	EndSubSection</span><br><span class="line">	SubSection &quot;Display&quot;</span><br><span class="line">		Viewport   0 0</span><br><span class="line">		Depth     16</span><br><span class="line">	EndSubSection</span><br><span class="line">	SubSection &quot;Display&quot;</span><br><span class="line">		Viewport   0 0</span><br><span class="line">		Depth     24</span><br><span class="line">	EndSubSection</span><br><span class="line">EndSection</span><br><span class="line"></span><br><span class="line">Section &quot;Screen&quot;</span><br><span class="line">	Identifier &quot;Screen1&quot;</span><br><span class="line">	Device     &quot;Card1&quot;</span><br><span class="line">	Monitor    &quot;Monitor1&quot;</span><br><span class="line">	SubSection &quot;Display&quot;</span><br><span class="line">		Viewport   0 0</span><br><span class="line">		Depth     1</span><br><span class="line">	EndSubSection</span><br><span class="line">	SubSection &quot;Display&quot;</span><br><span class="line">		Viewport   0 0</span><br><span class="line">		Depth     4</span><br><span class="line">	EndSubSection</span><br><span class="line">	SubSection &quot;Display&quot;</span><br><span class="line">		Viewport   0 0</span><br><span class="line">		Depth     8</span><br><span class="line">	EndSubSection</span><br><span class="line">	SubSection &quot;Display&quot;</span><br><span class="line">		Viewport   0 0</span><br><span class="line">		Depth     15</span><br><span class="line">	EndSubSection</span><br><span class="line">	SubSection &quot;Display&quot;</span><br><span class="line">		Viewport   0 0</span><br><span class="line">		Depth     16</span><br><span class="line">	EndSubSection</span><br><span class="line">	SubSection &quot;Display&quot;</span><br><span class="line">		Viewport   0 0</span><br><span class="line">		Depth     24</span><br><span class="line">	EndSubSection</span><br><span class="line">EndSection</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>：在<code>xorg.conf</code>中配置显卡总线地址<code>BusID</code>时，必须以<code>十进制</code>表示，比如<code>lspci</code>总线地址（以十六进制显示）为<code>91:00.0</code>，将其转换为十进制<code>145:00:0</code>（16x9+1）配置在xorg.conf中。<br>细节有两点:</p>
<ol>
<li>总线地址的进制转换(十六进制转十进制)</li>
<li>总线地址的分隔符,在xorg.conf中,地址均为<code>:</code>分隔</li>
</ol>
</blockquote>
<ul>
<li><code>Driver</code>的选择必须根据使用的显卡和系统的支持情况配置,在系统不支持的情况下可以使用<code>modesetting</code>代替测试，不一定配置成功<ul>
<li>centos系统支持的驱动在<code>/lib64/xorg/modules/drivers/</code><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">ls</span> /lib64/xorg/modules/drivers/</span></span><br><span class="line">ati_drv.so  dummy_drv.so  fbdev_drv.so  modesetting_drv.so  nouveau_drv.so  qxl_drv.so  radeon_drv.so  v4l_drv.so</span><br></pre></td></tr></table></figure></li>
<li>ubuntu系统支持的驱动在<code>/usr/lib/xorg/modules/drivers/</code><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls /usr/lib/xorg/modules/drivers/</span><br><span class="line">amdgpu_drv.so  ati_drv.so  fbdev_drv.so  intel_drv.so  modesetting_drv.so  nouveau_drv.so  qxl_drv.so  radeon_drv.so  vesa_drv.so  vmware_drv.so</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<blockquote>
<p>在用户空间驱动不在系统默认路径下时，可以通过<code>Section &quot;Files&quot;</code>的<code>ModulePath</code>参数指定</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Section &quot;Files&quot;</span><br><span class="line">   ModulePath &quot;/usr/local/lib/xorg/modules/&quot;</span><br><span class="line">EndSection</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$man Xorg</span><br><span class="line">$man xorg.conf</span><br><span class="line">$man Xserver</span><br><span class="line">$man modesetting</span><br><span class="line">$man fbdevhw</span><br><span class="line">$man Xwrapper.config</span><br><span class="line"></span><br><span class="line">$man Xephyr</span><br><span class="line">$man exa</span><br><span class="line">$man cvt</span><br><span class="line">$man gtf</span><br></pre></td></tr></table></figure>

<ul>
<li><code>Xephyr</code>: X服务器输出到预先存在的X显示器上的窗口</li>
</ul>
<h2 id="应用示例"><a href="#应用示例" class="headerlink" title="应用示例"></a>应用示例</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># nvidia-settings: X configuration file generated by nvidia-settings</span><br><span class="line"># nvidia-settings:  version 440.82</span><br><span class="line"></span><br><span class="line">Section &quot;ServerLayout&quot;</span><br><span class="line">    Identifier     &quot;Layout0&quot;</span><br><span class="line">    Screen      0  &quot;Screen0&quot; 0 0</span><br><span class="line">    InputDevice    &quot;Keyboard0&quot; &quot;CoreKeyboard&quot;</span><br><span class="line">    InputDevice    &quot;Mouse0&quot; &quot;CorePointer&quot;</span><br><span class="line">    Option         &quot;Xinerama&quot; &quot;0&quot;</span><br><span class="line">EndSection</span><br><span class="line"></span><br><span class="line">Section &quot;Files&quot;</span><br><span class="line">EndSection</span><br><span class="line"></span><br><span class="line">Section &quot;InputDevice&quot;</span><br><span class="line">    # generated from default</span><br><span class="line">    Identifier     &quot;Mouse0&quot;</span><br><span class="line">    Driver         &quot;mouse&quot;</span><br><span class="line">    Option         &quot;Protocol&quot; &quot;auto&quot;</span><br><span class="line">    Option         &quot;Device&quot; &quot;/dev/input/mice&quot;</span><br><span class="line">    Option         &quot;Emulate3Buttons&quot; &quot;no&quot;</span><br><span class="line">    Option         &quot;ZAxisMapping&quot; &quot;4 5&quot;</span><br><span class="line">EndSection</span><br><span class="line"></span><br><span class="line">Section &quot;InputDevice&quot;</span><br><span class="line">    # generated from default</span><br><span class="line">    Identifier     &quot;Keyboard0&quot;</span><br><span class="line">    Driver         &quot;kbd&quot;</span><br><span class="line">EndSection</span><br><span class="line"></span><br><span class="line">Section &quot;Monitor&quot;</span><br><span class="line">    # HorizSync source: edid, VertRefresh source: edid</span><br><span class="line">    Identifier     &quot;Monitor0&quot;</span><br><span class="line">    VendorName     &quot;Unknown&quot;</span><br><span class="line">    ModelName      &quot;Philips PHL 237E7&quot;</span><br><span class="line">    HorizSync       30.0 - 83.0</span><br><span class="line">    VertRefresh     56.0 - 76.0</span><br><span class="line">    Option         &quot;DPMS&quot;</span><br><span class="line">EndSection</span><br><span class="line"></span><br><span class="line">Section &quot;Device&quot;</span><br><span class="line">    Identifier     &quot;Device0&quot;</span><br><span class="line">    Driver         &quot;nvidia&quot;</span><br><span class="line">    VendorName     &quot;NVIDIA Corporation&quot;</span><br><span class="line">    BoardName      &quot;Quadro P6000&quot;</span><br><span class="line">EndSection</span><br><span class="line"></span><br><span class="line">Section &quot;Screen&quot;</span><br><span class="line">    Identifier     &quot;Screen0&quot;</span><br><span class="line">    Device         &quot;Device0&quot;</span><br><span class="line">    Monitor        &quot;Monitor0&quot;</span><br><span class="line">    DefaultDepth    24</span><br><span class="line">    Option         &quot;Stereo&quot; &quot;0&quot;</span><br><span class="line">    Option         &quot;nvidiaXineramaInfoOrder&quot; &quot;DFP-8&quot;</span><br><span class="line">    Option         &quot;metamodes&quot; &quot;DP-5: nvidia-auto-select +1920+0, DP-7: nvidia-auto-select +0+0&quot;</span><br><span class="line">    Option         &quot;SLI&quot; &quot;Off&quot;</span><br><span class="line">    Option         &quot;MultiGPU&quot; &quot;Off&quot;</span><br><span class="line">    Option         &quot;BaseMosaic&quot; &quot;off&quot;</span><br><span class="line">    SubSection     &quot;Display&quot;</span><br><span class="line">      Depth       24</span><br><span class="line">    EndSection</span><br></pre></td></tr></table></figure>

<h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">startx -- -layout seat0 -seat seat0 -novtswitch -sharevts</span><br></pre></td></tr></table></figure>
<blockquote>
<p>参数详解： <code>man Xorg</code></p>
</blockquote>
<ul>
<li><code>-novtswitch </code>: 如果操作系统支持，请禁用自动启动服务器时将X服务器重置和关机自动切换到激活的VT的功能</li>
<li><code>-sharevts</code>: 如果操作系统支持，则与另一个X服务器共享虚拟终端。</li>
</ul>
<h2 id="xinitrc"><a href="#xinitrc" class="headerlink" title="xinitrc"></a>xinitrc</h2><blockquote>
<p><code>$HOME/.xinitrc</code>指定启动的桌面环境,比如xterm</p>
</blockquote>
<p><code>~/.xinitrc</code>由xinit执行，通常通过startx调用。 登录后将执行该程序：首先登录文本控制台，然后使用startx启动GUI。<code>.xinitrc</code>的作用是启动会话的GUI部分，通常是通过设置一些与GUI相关的设置，例如键绑定（使用xmodmap或xkbcomp），X资源（使用xrdb）等，以及启动会话管理器或窗口管理器（可能是桌面环境的一部分）。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">xinit /etc/X11/xinitrc -- /usr/bin/X :1 -config /etc/X11/xorg.conf.new -novtswitch -sharevts vt2 -keeptty -listen tcp</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">X :1 -config /etc/X11/xorg.conf.new -novtswitch -sharevts vt2 -keeptty -listen tcp</span></span><br></pre></td></tr></table></figure>

<h3 id="窗口管理器"><a href="#窗口管理器" class="headerlink" title="窗口管理器"></a>窗口管理器</h3><ul>
<li>fvwm:虚拟窗口管理器,占用资源少</li>
<li>twm:(Tab Window Manager for the X Window System)</li>
</ul>
<h2 id="驱动模块——Driver"><a href="#驱动模块——Driver" class="headerlink" title="驱动模块——Driver"></a>驱动模块——Driver</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash"><span class="built_in">ls</span> /usr/lib/xorg/modules/drivers/</span></span><br><span class="line">amdgpu_drv.so  ati_drv.so  fbdev_drv.so  intel_drv.so  modesetting_drv.so  nouveau_drv.so  qxl_drv.so  radeon_drv.so  vesa_drv.so  vmware_drv.so</span><br></pre></td></tr></table></figure>

<p>每一个驱动模块的详细信息，可以通过<code>man</code>手册进行查看，比如<code>man modesetting</code>、<code>man intel</code>、<code>man amdgpu</code>等</p>
<h3 id="modesetting"><a href="#modesetting" class="headerlink" title="modesetting"></a>modesetting</h3><blockquote>
<p><code>modesetting</code> is an Xorg driver for KMS devices.</p>
</blockquote>
<p>The modesetting driver supports all hardware where a KMS driver is available. modesetting uses the Linux DRM KMS ioctls and dumb object create&#x2F;map.</p>
<p>modesetting是KMS设备的Xorg驱动程序。 该驱动程序支持在帧缓冲区深度为15、16、24和30的TrueColor视觉效果。multi-head配置支持RandR 1.2。 对于至少支持OpenGL ES 2.0或OpenGL 2.1的设备，可以通过glamor进行加速。 如果未启用魅力，则根据KMS驱动程序的偏好配置阴影帧缓冲区（除非帧缓冲区为每像素24位，在这种情况下始终使用阴影帧缓冲区）。</p>
<h3 id="vesa"><a href="#vesa" class="headerlink" title="vesa"></a>vesa</h3><p><code>vesa</code>是用于通用VESA视频卡的Xorg驱动程序。 它可以驱动大多数与VESA兼容的视频卡，但仅使用这些卡通用的基本标准VESA内核。驱动程序支持深度8、15、16和24。</p>
<h3 id="Driver配置的缺失"><a href="#Driver配置的缺失" class="headerlink" title="Driver配置的缺失"></a>Driver配置的缺失</h3><p>如果在xorg.conf的配置中将Driver字段的配置缺失，系统会默认选择加载<code>modeseting</code>、<code>fbdev</code>、<code>vesa</code>驱动。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Section &quot;Device&quot;</span><br><span class="line">  Identifier &quot;devname&quot;</span><br><span class="line">  #Driver &quot;modesetting&quot; #将该字段注释掉，Xorg将自动进行加载</span><br><span class="line">  BusID  &quot;pci:bus:dev:func&quot;</span><br><span class="line">  ...</span><br><span class="line">EndSection</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">(II) xfree86: Adding drm device (/dev/dri/card2)</span><br><span class="line">(II) Platform probe for /sys/devices/pci0000:ae/0000:ae:00.0/0000:af:00.0/0000:b0:10.0/0000:bb:00.0/0000:bc:01.0/0000:bd:00.0/drm/card2</span><br><span class="line">(II) &quot;glx&quot; will be loaded. This was enabled by default and also specified in the config file.</span><br><span class="line">(II) LoadModule: &quot;glx&quot;</span><br><span class="line">(II) Loading /usr/lib64/xorg/modules/extensions/libglx.so</span><br><span class="line">(II) Module glx: vendor=&quot;X.Org Foundation&quot;</span><br><span class="line">   compiled for 1.20.4, module version = 1.0.0</span><br><span class="line">   ABI class: X.Org Server Extension, version 10.0</span><br><span class="line"></span><br><span class="line">(==) Matched modesetting as autoconfigured driver 0</span><br><span class="line">(==) Matched fbdev as autoconfigured driver 1</span><br><span class="line">(==) Matched vesa as autoconfigured driver 2</span><br><span class="line">(==) Assigned the driver to the xf86ConfigLayout</span><br><span class="line"></span><br><span class="line">(II) LoadModule: &quot;modesetting&quot;</span><br><span class="line">(II) Loading /usr/lib64/xorg/modules/drivers/modesetting_drv.so</span><br><span class="line">(II) Module modesetting: vendor=&quot;X.Org Foundation&quot;</span><br><span class="line">   compiled for 1.20.4, module version = 1.20.4</span><br><span class="line">   Module class: X.Org Video Driver</span><br><span class="line">   ABI class: X.Org Video Driver, version 24.0</span><br><span class="line">(II) LoadModule: &quot;fbdev&quot;</span><br><span class="line">(II) Loading /usr/lib64/xorg/modules/drivers/fbdev_drv.so</span><br><span class="line">(II) Module fbdev: vendor=&quot;X.Org Foundation&quot;</span><br><span class="line">   compiled for 1.20.1, module version = 0.5.0</span><br><span class="line">   Module class: X.Org Video Driver</span><br><span class="line">   ABI class: X.Org Video Driver, version 24.0</span><br><span class="line">(II) LoadModule: &quot;vesa&quot;</span><br><span class="line">(II) Loading /usr/lib64/xorg/modules/drivers/vesa_drv.so</span><br><span class="line">(II) Module vesa: vendor=&quot;X.Org Foundation&quot;</span><br><span class="line">   compiled for 1.20.1, module version = 2.4.0</span><br><span class="line">   Module class: X.Org Video Driver</span><br><span class="line">   ABI class: X.Org Video Driver, version 24.0</span><br><span class="line">(II) modesetting: Driver for Modesetting Kernel Drivers: kms</span><br><span class="line">(II) FBDEV: driver for framebuffer: fbdev</span><br><span class="line">(II) VESA: driver for VESA chipsets: vesa</span><br><span class="line">(II) modeset(0): using drv /dev/dri/card2</span><br></pre></td></tr></table></figure>

<h2 id="DISPLAY环境变量"><a href="#DISPLAY环境变量" class="headerlink" title="DISPLAY环境变量"></a>DISPLAY环境变量</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export DISPLAY=:0</span><br><span class="line">export DISPLAY=192.168.1.1:0</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export DISPLAY=[hostname][:number[.screen_number]]</span><br></pre></td></tr></table></figure>
<ul>
<li><code>hostname</code>: 指定物理连接显示器的主机的名称, 主机名后加上单冒号（:)或双冒号（::)。</li>
<li><code>number</code>: 指定该主机上Xserver的编号,在此显示编号后加上句点(.),一个CPU可以有多个显示器, 多个显示通常从零开始编号。</li>
<li><code>screen_number</code>: 指定要在该服务器上使用的屏幕，单个Xserver可以控制多个屏幕，screen_number设置一个内部变量，如果使用的是C以外的语言，则可以使用<code>DefaultScreen()</code>宏或<code>XDefaultScreen()</code>函数进行访问（请参见“(Display Macros)[<span class="exturl" data-url="aHR0cHM6Ly90cm9uY2hlLmNvbS9ndWkveC94bGliL2Rpc3BsYXkvaW5mb3JtYXRpb24uaHRtbCNkaXNwbGF5XSVFMiU4MCU5RCVFRiVCQyU4OSVFMyU4MCU4Mg==">https://tronche.com/gui/x/xlib/display/information.html#display]”）。<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<h2 id="无显示器启动X-Server"><a href="#无显示器启动X-Server" class="headerlink" title="无显示器启动X Server"></a>无显示器启动X Server</h2><p>安装Nvidia驱动后，如果没有接显示器，那么X Server在启动的时候会报错：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NVIDIA(0): Failed to assign any connected display devices to X screen 0. Set AllowEmptyInitialConfiguration if you want the server to start anyway</span><br></pre></td></tr></table></figure>

<h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h3><p>重新生产<code>xorg.conf</code>配置文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo nvidia-xconfig --allow-empty-initial-configuration</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Section &quot;Screen&quot;</span><br><span class="line">    Identifier     &quot;Screen0&quot;</span><br><span class="line">    Device         &quot;Device0&quot;</span><br><span class="line">    Monitor        &quot;Monitor0&quot;</span><br><span class="line">    DefaultDepth    24</span><br><span class="line">    Option         &quot;AllowEmptyInitialConfiguration&quot; &quot;True&quot;</span><br><span class="line">    SubSection     &quot;Display&quot;</span><br><span class="line">        Depth       24</span><br><span class="line">    EndSubSection</span><br><span class="line">EndSection</span><br></pre></td></tr></table></figure>
<blockquote>
<p>主要添加配置：<code>Option &quot;AllowEmptyInitialConfiguration&quot; &quot;True&quot;</code></p>
</blockquote>
<h3 id="方法二：-Nvidia显卡启动Xorg使用虚拟设备连接"><a href="#方法二：-Nvidia显卡启动Xorg使用虚拟设备连接" class="headerlink" title="方法二： Nvidia显卡启动Xorg使用虚拟设备连接"></a>方法二： Nvidia显卡启动Xorg使用虚拟设备连接</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Section &quot;Device&quot;</span><br><span class="line">	Identifier  &quot;Card0&quot;</span><br><span class="line">	Driver      &quot;nvidia&quot;</span><br><span class="line">	BusID       &quot;PCI:26:0:0&quot;</span><br><span class="line">  #for NVIDIA Xorg configure</span><br><span class="line">	Option      &quot;ConnectedMonitor&quot;  &quot;DFP-0&quot;</span><br><span class="line">	Option      &quot;MetaModes&quot;         &quot;DFP-0: 1920x1080&quot;</span><br><span class="line">	Option      &quot;HorizSync&quot;         &quot;DFP-0: 40-70&quot;</span><br><span class="line">	Option      &quot;VertRefresh&quot;       &quot;DFP-0: 60&quot;</span><br><span class="line">	Option      &quot;ConnectToAcpid&quot;    &quot;false&quot;</span><br><span class="line">	Option      &quot;UseEDID&quot;           &quot;false&quot;</span><br><span class="line">	Option      &quot;UseEDIDDpi&quot;        &quot;false&quot;</span><br><span class="line">	Option      &quot;ModeValidation&quot;    &quot;NoEdidModes&quot;</span><br><span class="line">EndSection</span><br></pre></td></tr></table></figure>

<h3 id="方法三："><a href="#方法三：" class="headerlink" title="方法三："></a>方法三：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Section &quot;Device&quot;</span><br><span class="line">	Identifier  &quot;Card0&quot;</span><br><span class="line">	Driver      &quot;nvidia&quot;</span><br><span class="line">	BusID       &quot;PCI:59:0:0&quot;</span><br><span class="line">  Option &quot;UseDisplayDevice&quot; &quot;none&quot;</span><br><span class="line">EndSection</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Option “UseDisplayDevice” “string”</p>
<p> The “UseDisplayDevice” X configuration option is a list of one or more display devices, which limits the display devices the NVIDIA X driver will consider for an X screen. The display device names used in the option may be either specific (with a numeric suffix; e.g., “DFP-1”) or general (without a numeric suffix; e.g., “DFP”).</p>
<p>  When assigning display devices to X screens, the NVIDIA X driver walks through the list of all (not already assigned) display devices detected as connected. When the “UseDisplayDevice” X configuration option is specified, the X driver will only consider connected display devices which are also included in the “UseDisplayDevice” list. This can be thought of as a “mask” against the connected (and not already assigned) display devices.</p>
<p>  Note the subtle difference between this option and the “ConnectedMonitor” option: the “ConnectedMonitor” option overrides which display devices are actually detected, while the “UseDisplayDevice” option controls which of the detected display devices will be used on this X screen.</p>
<p>  Of the list of display devices considered for this X screen (either all connected display devices, or a subset limited by the “UseDisplayDevice” option), the NVIDIA X driver first looks at CRTs, then at DFPs. For example, if both a CRT and a DFP are connected, by default the X driver would assign the CRT to this X screen. However, by specifying:</p>
<pre><code>  Option &quot;UseDisplayDevice&quot; &quot;DFP&quot;
</code></pre>
<p>  the X screen would use the DFP instead. Or, if CRT-0, DFP-0, and DFP-1 are connected, the X driver would assign CRT-0 and DFP-0 to the X screen. However, by specifying:</p>
<pre><code>  Option &quot;UseDisplayDevice&quot; &quot;CRT-0, DFP-1&quot;
</code></pre>
<p>  the X screen would use CRT-0 and DFP-1 instead.</p>
<p>  Additionally, the special value “none” can be specified for the “UseDisplayDevice” option. When this value is given, any programming of the display hardware is disabled. The NVIDIA driver will not perform any mode validation or mode setting for this X screen. This is intended for use in conjunction with CUDA or in remote graphics solutions such as VNC or Hewlett Packard’s Remote Graphics Software (RGS).</p>
<p>  “UseDisplayDevice” defaults to “none” on GPUs that have no display capabilities, such as some Tesla GPUs and some mobile GPUs used in Optimus notebook configurations.</p>
<p>  Note the following restrictions for setting the “UseDisplayDevice” to “none”:</p>
<p>  OpenGL SyncToVBlank will have no effect.</p>
<p>  None of Stereo, Overlay, CIOverlay, or SLI are allowed when “UseDisplayDevice” is set to “none”.</p>
<blockquote>
<p><span class="exturl" data-url="aHR0cDovL2h0dHAuZG93bmxvYWQubnZpZGlhLmNvbS9YRnJlZTg2L0xpbnV4LXg4Ni8zOTAuMTQ0L1JFQURNRS94Y29uZmlnb3B0aW9ucy5odG1s">http://http.download.nvidia.com/XFree86/Linux-x86/390.144/README/xconfigoptions.html<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
</blockquote>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2EzNzkwMzkyMzMvYXJ0aWNsZS9kZXRhaWxzLzgwNzgyMzUx">X,X11,Xorg,XServer,XClient,Xlib<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vdWV0dWNjaS9wLzc3OTQzMzUuaHRtbA==">Linux学习-X Server 配置文件解析与设定<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NlYXNoaXAvYXJ0aWNsZS9kZXRhaWxzLzk1NDgxMTU0">xorg的配置文件<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29oYXBweXRpbWUvYXJ0aWNsZS9kZXRhaWxzLzczODQwMDE=">xorg.conf 配置详解<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vcmlja2VybGlhbmcvcC81NjczMDE1Lmh0bWw=">nvidia gpu fan speed control<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL2h0dHAuZG93bmxvYWQubnZpZGlhLmNvbS9YRnJlZTg2L0xpbnV4LXg4Ni8xLjAtODc3NC9SRUFETUUvYXBwZW5kaXgtZC5odG1s">Nvidia-Appendix D. X Config Options<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL2h0dHAuZG93bmxvYWQubnZpZGlhLmNvbS9YRnJlZTg2L0xpbnV4LXg4Ni8zOTAuMTQ0L1JFQURNRS94Y29uZmlnb3B0aW9ucy5odG1s">Nvidia-Appendix B. X Config Options Part II. Appendices<i class="fa fa-external-link-alt"></i></span> –  驱动版本390.144</li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cueC5vcmcvcmVsZWFzZXMvY3VycmVudC9kb2MvbWFuL21hbjUveG9yZy5jb25mLjUueGh0bWw=">xorg.conf<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly91bml4LnN0YWNrZXhjaGFuZ2UuY29tL3F1ZXN0aW9ucy8yODE4NTgvZGlmZmVyZW5jZS1iZXR3ZWVuLXhpbml0cmMteHNlc3Npb24tYW5kLXhzZXNzaW9ucmM=">Difference between .xinitrc, .xsession and .xsessionrc<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9kb3dubG9hZC5udmlkaWEuY29tL1hGcmVlODYvTGludXgteDg2XzY0LzMwNC4xMzcvUkVBRE1FL2NvbmZpZ3R3aW52aWV3Lmh0bWw=">Chapter 13. Configuring Multiple Display Devices on One X Screen<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly90cm9uY2hlLmNvbS9ndWkveC94bGliL2Rpc3BsYXkvb3BlbmluZy5odG1s">Opening the Display<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly91bml4LnN0YWNrZXhjaGFuZ2UuY29tL3F1ZXN0aW9ucy8yMTE2MzcvaG93LWRvLWktZ2V0LXgtdG8tc3RhcnQtd2l0aG91dC1hLW1vbml0b3ItYXR0YWNoZWQtd2hpbGUtdXNpbmctbnZpZGlhLWRyaXZlcnM=">How do I get X to start without a monitor attached while using NVIDIA drivers?<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly91bml4LnN0YWNrZXhjaGFuZ2UuY29tL3F1ZXN0aW9ucy8yOTU3ODQvaG93LXRvLXRlbGwtaW50ZWwtZ3JhcGhpY3MtdG8tdXNlLW15LWN1c3RvbS1lZGlkLWZpbGU=">How to tell intel graphics to use my custom EDID file?<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>系统服务</category>
        <category>Xorg</category>
      </categories>
      <tags>
        <tag>x11</tag>
        <tag>xorg</tag>
      </tags>
  </entry>
  <entry>
    <title>RDMA网络简介</title>
    <url>/post/f4fa9e36.html</url>
    <content><![CDATA[<p><code>RDMA</code>(Remote Direct Memory Access)全称<code>远程直接数据存取</code>，就是为了解决网络传输中服务器端数据处理的延迟而产生的。RDMA通过网络把资料直接传入计算机的存储区，将数据从一个系统快速移动到远程系统存储器中，而不对操作系统造成任何影响，这样就不需要用到多少计算机的处理功能。它消除了外部存储器复制和上下文切换的开销，因而能解放内存带宽和CPU周期用于改进应用系统性能。</p>
<span id="more"></span>

<h2 id="驱动下载"><a href="#驱动下载" class="headerlink" title="驱动下载"></a>驱动下载</h2><blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cubWVsbGFub3guY29tL3Byb2R1Y3RzL2luZmluaWJhbmQtZHJpdmVycy9saW51eC9tbG54X29mZWQ=">https://www.mellanox.com/products/infiniband-drivers/linux/mlnx_ofed<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<p>判断驱动是否安装成功：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ibdev2netdev</span></span><br><span class="line">mlx5_0 port 1 ==&gt; ens2f0 (Up)   #表示该网口插了网线</span><br><span class="line">mlx5_1 port 1 ==&gt; ens2f1 (Down) #表示该网口没有插网线</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>ibdev2netdev</code>命令输出以上类似信息表明网卡驱动安装成功</p>
</blockquote>
<h3 id="CentOS7开源驱动安装与卸载"><a href="#CentOS7开源驱动安装与卸载" class="headerlink" title="CentOS7开源驱动安装与卸载"></a>CentOS7开源驱动安装与卸载</h3><blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cucmRtYW1vam8uY29tLzIwMTQvMTAvMTEvd29ya2luZy1yZG1hLXJlZGhhdGNlbnRvcy03LyM6fjp0ZXh0PXl1bSUyMGFsbG93cyUyMGluc3RhbGxhdGlvbiUyMG9mJTIwbXVsdGlwbGUlMjBwYWNrYWdlcyUyMGFjY29yZGluZyUyMHRvLHBhY2thZ2VzJTIwYXJlJTIwcGFydCUyMG9mJTIwdGhlJTIwZ3JvdXAlMjAlMjJJbmZpbmliYW5kJTIwU3VwcG9ydCUyMiUzQQ==">Working with RDMA in RedHat&#x2F;CentOS 7.*<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<ul>
<li>安装：<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum groupinfo &quot;Infiniband Support&quot;</span><br><span class="line">yum groupinstall &quot;Infiniband Support&quot;</span><br><span class="line">yum --setopt=group_package_types=optional groupinstall &quot;Infiniband Support&quot;</span><br></pre></td></tr></table></figure></li>
<li>卸载：<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum -y groupremove &quot;Infiniband Support&quot;</span><br></pre></td></tr></table></figure></li>
<li>开启RDMA服务<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl start rdma</span><br><span class="line">systemctl enable rdma</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="吞吐量测试"><a href="#吞吐量测试" class="headerlink" title="吞吐量测试"></a>吞吐量测试</h2><h3 id="写吞吐量"><a href="#写吞吐量" class="headerlink" title="写吞吐量"></a>写吞吐量</h3><p>在RDMA驱动安装时会安装一些RDMA工具，可以使用<code>ib_send_bw</code>测试写吞吐量</p>
<p>服务器A（server）：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ib_write_bw -a -d mlx5_0</span><br></pre></td></tr></table></figure>

<p>服务器B（client）：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ib_write_bw -a -d mlx5_0 192.168.2.1(server端ip)</span><br></pre></td></tr></table></figure>

<h3 id="读吞吐量"><a href="#读吞吐量" class="headerlink" title="读吞吐量"></a>读吞吐量</h3><p>读吞吐量的测试与写吞吐量测试相同，只是使用命令换为<code>ib_read_bw</code></p>
<h2 id="延时测试"><a href="#延时测试" class="headerlink" title="延时测试"></a>延时测试</h2><p>测试同样分为读写，测试工具为<code>ib_read_lat</code>、<code>ib_write_lat</code></p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9jb21tdW5pdHkubWVsbGFub3guY29tL3MvYXJ0aWNsZS9wZXJmb3JtYW5jZS10dW5pbmctZm9yLW1lbGxhbm94LWFkYXB0ZXJz">Performance Tuning for Mellanox Adapters<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<h2 id="带宽统计"><a href="#带宽统计" class="headerlink" title="带宽统计"></a>带宽统计</h2><p>在使用RDMA时，发送和接收的数据带宽可以在app中自己进行收集，这样我们的程序发送和接收的数据量会很清楚。<br>如果想知道当前RDMA网卡所发送和接收的带宽可以通过sysfs下的相关节点获取。</p>
<ul>
<li>发送数据量（byte）：<code>/sys/class/infiniband/mlx5_0/ports/1/counters/port_xmit_data</code></li>
<li>接收数据量（byte）：<code>/sys/class/infiniband/mlx5_0/ports/1/counters/port_rcv_data</code></li>
</ul>
<p><strong>注</strong>：<code>port_xmit_data</code>和<code>port_rcv_data</code>的数值是实际的1&#x2F;4,因此实际的带宽是在其基础之上乘以<code>4</code>，应该是为了防止数据溢出</p>
<blockquote>
<p>port_xmit_data: (RO) Total number of data octets, divided by 4 (lanes), transmitted on all VLs. This is 64 bit counter<br>port_rcv_data: (RO) Total number of data octets, divided by 4 (lanes), received on all VLs. This is 64 bit counter.</p>
<blockquote>
<p>来自： <code>Documentation/ABI/stable/sysfs-class-infiniband</code></p>
</blockquote>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">pma_cnt_ext-&gt;port_xmit_data =</span><br><span class="line">    cpu_to_be64(MLX5_SUM_CNT(out, transmitted_ib_unicast.octets,</span><br><span class="line">                 transmitted_ib_multicast.octets) &gt;&gt; <span class="number">2</span>);</span><br><span class="line">pma_cnt_ext-&gt;port_rcv_data =</span><br><span class="line">    cpu_to_be64(MLX5_SUM_CNT(out, received_ib_unicast.octets,</span><br><span class="line">                 received_ib_multicast.octets) &gt;&gt; <span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>file: drivers&#x2F;infiniband&#x2F;hw&#x2F;mlx5&#x2F;mad.c</p>
</blockquote>
<h2 id="网络联通性测试"><a href="#网络联通性测试" class="headerlink" title="网络联通性测试"></a>网络联通性测试</h2><p>由于当前网卡只支持<code>Ethernet</code>模式，因此只能使用<code>ibv_rc_pingpong</code>进行ping测试。</p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9jb21tdW5pdHkubWVsbGFub3guY29tL3MvYXJ0aWNsZS9Sb0NFLURlYnVnLUZsb3ctZm9yLUxpbnV4">https://community.mellanox.com/s/article/RoCE-Debug-Flow-for-Linux<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<h3 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ibdev2netdev</span></span><br><span class="line">mlx4_0 port 1 ==&gt; enp1s0 (Down)</span><br><span class="line">mlx5_0 port 1 ==&gt; ens2f0 (Up)</span><br><span class="line">mlx5_1 port 1 ==&gt; ens2f1 (Up)</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ibv_rc_pingpong -d mlx5_0 -g 0</span></span><br><span class="line">  local address:  LID 0x0000, QPN 0x00011a, PSN 0xd775ee, GID fe80::e42:a1ff:fe41:2d36</span><br><span class="line">  remote address: LID 0x0000, QPN 0x0009df, PSN 0xa7f02f, GID fe80::1e34:daff:fe79:c0d</span><br><span class="line">8192000 bytes in 0.01 seconds = 5126.01 Mbit/sec</span><br><span class="line">1000 iters in 0.01 seconds = 12.78 usec/iter</span><br></pre></td></tr></table></figure>

<h3 id="Client"><a href="#Client" class="headerlink" title="Client"></a>Client</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ibdev2netdev</span></span><br><span class="line">mlx5_0 port 1 ==&gt; p5p1 (Down)</span><br><span class="line">mlx5_1 port 1 ==&gt; p5p2 (Up)</span><br><span class="line">mlx5_2 port 1 ==&gt; p4p1 (Down)</span><br><span class="line">mlx5_3 port 1 ==&gt; p4p2 (Down)</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ibv_rc_pingpong -d mlx5_1 -g 0 192.168.2.4</span></span><br><span class="line">  local address:  LID 0x0000, QPN 0x0009df, PSN 0xa7f02f, GID fe80::1e34:daff:fe79:c0d</span><br><span class="line">  remote address: LID 0x0000, QPN 0x00011a, PSN 0xd775ee, GID fe80::e42:a1ff:fe41:2d36</span><br><span class="line">8192000 bytes in 0.01 seconds = 5376.21 Mbit/sec</span><br><span class="line">1000 iters in 0.01 seconds = 12.19 usec/iter</span><br></pre></td></tr></table></figure>

<h2 id="ibping"><a href="#ibping" class="headerlink" title="ibping"></a>ibping</h2><p>测试ib模式下网络的连通性。</p>
<h2 id="mlx5计数器和状态参数"><a href="#mlx5计数器和状态参数" class="headerlink" title="mlx5计数器和状态参数"></a>mlx5计数器和状态参数</h2><p>在sysfs文件系统可以查看<code>/sys/class/infiniband/</code></p>
<blockquote>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9jb21tdW5pdHkubWVsbGFub3guY29tL3MvYXJ0aWNsZS91bmRlcnN0YW5kaW5nLW1seDUtbGludXgtY291bnRlcnMtYW5kLXN0YXR1cy1wYXJhbWV0ZXJz">Understanding mlx5 Linux Counters and Status Parameters<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9teW1lbGxhbm94LmZvcmNlLmNvbS9tZWxsYW5veGNvbW11bml0eS9zL2FydGljbGUvaW5maW5pYmFuZC1wb3J0LWNvdW50ZXJz">InfiniBand Port Counters<i class="fa fa-external-link-alt"></i></span></li>
</ul>
</blockquote>
<p>Linux内核说明文档：<span class="exturl" data-url="aHR0cHM6Ly93d3cua2VybmVsLm9yZy9kb2MvaHRtbC9sYXRlc3QvYWRtaW4tZ3VpZGUvYWJpLXN0YWJsZS5odG1sI2FiaS1maWxlLXN0YWJsZS1zeXNmcy1jbGFzcy1pbmZpbmliYW5k">https://www.kernel.org/doc/html/latest/admin-guide/abi-stable.html#abi-file-stable-sysfs-class-infiniband<i class="fa fa-external-link-alt"></i></span></p>
<h3 id="counters"><a href="#counters" class="headerlink" title="counters"></a>counters</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">ls</span> -lsh /sys/class/infiniband/mlx5_0/ports/1/counters/</span></span><br><span class="line">total 0</span><br><span class="line">0 -r--r--r-- 1 root root 4.0K 5月  24 15:28 excessive_buffer_overrun_errors</span><br><span class="line">0 -r--r--r-- 1 root root 4.0K 5月  24 15:28 link_downed</span><br><span class="line">0 -r--r--r-- 1 root root 4.0K 5月  24 15:28 link_error_recovery</span><br><span class="line">0 -r--r--r-- 1 root root 4.0K 5月  24 15:28 local_link_integrity_errors</span><br><span class="line">0 -r--r--r-- 1 root root 4.0K 5月  24 15:28 multicast_rcv_packets</span><br><span class="line">0 -r--r--r-- 1 root root 4.0K 5月  24 15:28 multicast_xmit_packets</span><br><span class="line">0 -r--r--r-- 1 root root 4.0K 5月  24 15:28 port_rcv_constraint_errors</span><br><span class="line">0 -r--r--r-- 1 root root 4.0K 5月  24 15:28 port_rcv_data</span><br><span class="line">0 -r--r--r-- 1 root root 4.0K 5月  24 15:28 port_rcv_errors</span><br><span class="line">0 -r--r--r-- 1 root root 4.0K 5月  24 15:28 port_rcv_packets</span><br><span class="line">0 -r--r--r-- 1 root root 4.0K 5月  24 15:28 port_rcv_remote_physical_errors</span><br><span class="line">0 -r--r--r-- 1 root root 4.0K 5月  24 15:28 port_rcv_switch_relay_errors</span><br><span class="line">0 -r--r--r-- 1 root root 4.0K 5月  24 15:28 port_xmit_constraint_errors</span><br><span class="line">0 -r--r--r-- 1 root root 4.0K 5月  24 15:28 port_xmit_data</span><br><span class="line">0 -r--r--r-- 1 root root 4.0K 5月  24 15:28 port_xmit_discards</span><br><span class="line">0 -r--r--r-- 1 root root 4.0K 5月  24 15:28 port_xmit_packets</span><br><span class="line">0 -r--r--r-- 1 root root 4.0K 5月  24 15:28 port_xmit_wait</span><br><span class="line">0 -r--r--r-- 1 root root 4.0K 5月  24 15:28 symbol_error</span><br><span class="line">0 -r--r--r-- 1 root root 4.0K 5月  24 15:28 unicast_rcv_packets</span><br><span class="line">0 -r--r--r-- 1 root root 4.0K 5月  24 15:28 unicast_xmit_packets</span><br><span class="line">0 -r--r--r-- 1 root root 4.0K 5月  24 15:28 VL15_dropped</span><br></pre></td></tr></table></figure>
<p>Counter Description:</p>
<table>
<thead>
<tr>
<th align="left"><strong>Counter</strong></th>
<th align="left"><strong>Description</strong></th>
<th align="left"><strong>InfiniBand Spec Name</strong></th>
<th align="left"><strong>Group</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">port_rcv_data</td>
<td align="left">The total number of data octets, divided by 4, (counting in double words, 32 bits), received on all VLs from the port.</td>
<td align="left">PortRcvData</td>
<td align="left">Informative</td>
</tr>
<tr>
<td align="left">port_rcv_packets</td>
<td align="left">Total number of packets (this may include packets containing Errors. This is 64 bit counter.</td>
<td align="left">PortRcvPkts</td>
<td align="left">Informative</td>
</tr>
<tr>
<td align="left">port_multicast_rcv_packets</td>
<td align="left">Total number of multicast packets, including multicast packets containing errors.</td>
<td align="left">PortMultiCastRcvPkts</td>
<td align="left">Informative</td>
</tr>
<tr>
<td align="left">port_unicast_rcv_packets</td>
<td align="left">Total number of unicast packets, including unicast packets containing errors.</td>
<td align="left">PortUnicastRcvPkts</td>
<td align="left">Informative</td>
</tr>
<tr>
<td align="left">port_xmit_data</td>
<td align="left">The total number of data octets, divided by 4, (counting in double words, 32 bits), transmitted on all VLs from the port.</td>
<td align="left">PortXmitData</td>
<td align="left">Informative</td>
</tr>
<tr>
<td align="left">port_xmit_packetsport_xmit_packets_64</td>
<td align="left">Total number of packets transmitted on all VLs from this port. This may include packets with errors.This is 64 bit counter.</td>
<td align="left">PortXmitPkts</td>
<td align="left">Informative</td>
</tr>
<tr>
<td align="left">port_rcv_switch_relay_errors</td>
<td align="left">Total number of packets received on the port that were discarded because they could not be forwarded by the switch relay.</td>
<td align="left">PortRcvSwitchRelayErrors</td>
<td align="left">Error</td>
</tr>
<tr>
<td align="left">port_rcv_errors</td>
<td align="left">Total number of packets containing an error that were received on the port.</td>
<td align="left">PortRcvErrors</td>
<td align="left">Informative</td>
</tr>
<tr>
<td align="left">port_rcv_constraint_errors</td>
<td align="left">Total number of packets received on the switch physical port that are discarded.</td>
<td align="left">PortRcvConstraintErrors</td>
<td align="left">Error</td>
</tr>
<tr>
<td align="left">local_link_integrity_errors</td>
<td align="left">The number of times that the count of local physical errors exceeded the threshold specified by LocalPhyErrors.</td>
<td align="left">LocalLinkIntegrityErrors</td>
<td align="left">Error</td>
</tr>
<tr>
<td align="left">port_xmit_wait</td>
<td align="left">The number of ticks during which the port had data to transmit but no data was sent during the entire tick (either because of insufficient credits or because of lack of arbitration).</td>
<td align="left">PortXmitWait</td>
<td align="left">Informative</td>
</tr>
<tr>
<td align="left">port_multicast_xmit_packets</td>
<td align="left">Total number of multicast packets transmitted on all VLs from the port. This may include multicast packets with errors.</td>
<td align="left">PortMultiCastXmitPkts</td>
<td align="left">Informative</td>
</tr>
<tr>
<td align="left">port_unicast_xmit_packets</td>
<td align="left">Total number of unicast packets transmitted on all VLs from the port. This may include unicast packets with errors.</td>
<td align="left">PortUnicastXmitPkts</td>
<td align="left">Informative</td>
</tr>
<tr>
<td align="left">port_xmit_discards</td>
<td align="left">Total number of outbound packets discarded by the port because the port is down or congested.</td>
<td align="left">PortXmitDiscards</td>
<td align="left">Error</td>
</tr>
<tr>
<td align="left">port_xmit_constraint_errors</td>
<td align="left">Total number of packets not transmitted from the switch physical port.</td>
<td align="left">PortXmitConstraintErrors</td>
<td align="left">Error</td>
</tr>
<tr>
<td align="left">port_rcv_remote_physical_errors</td>
<td align="left">Total number of packets marked with the EBP delimiter received on the port.</td>
<td align="left">PortRcvRemotePhysicalErrors</td>
<td align="left">Error</td>
</tr>
<tr>
<td align="left">symbol_error</td>
<td align="left">Total number of minor link errors detected on one or more physical lanes.</td>
<td align="left">SymbolErrorCounter</td>
<td align="left">Error</td>
</tr>
<tr>
<td align="left">VL15_dropped</td>
<td align="left">Number of incoming VL15 packets dropped due to resource limitations (e.g., lack of buffers) of the port.</td>
<td align="left">VL15Dropped</td>
<td align="left">Error</td>
</tr>
<tr>
<td align="left">link_error_recovery</td>
<td align="left">Total number of times the Port Training state machine has successfully completed the link error recovery process.</td>
<td align="left">LinkErrorRecoveryCounter</td>
<td align="left">Error</td>
</tr>
<tr>
<td align="left">link_downed</td>
<td align="left">Total number of times the Port Training state machine has failed the link error recovery process and downed the link.</td>
<td align="left">LinkDownedCounter</td>
<td align="left">Error</td>
</tr>
</tbody></table>
<h3 id="hw-counters"><a href="#hw-counters" class="headerlink" title="hw_counters"></a>hw_counters</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">ls</span> -lsh /sys/class/infiniband/mlx5_0/ports/1/hw_counters/</span></span><br><span class="line">total 0</span><br><span class="line">0 -r--r--r-- 1 root root 4.0K 5月  24 15:28 duplicate_request</span><br><span class="line">0 -r--r--r-- 1 root root 4.0K 5月  24 15:28 implied_nak_seq_err</span><br><span class="line">0 -rw-r--r-- 1 root root 4.0K 5月  28 16:42 lifespan</span><br><span class="line">0 -r--r--r-- 1 root root 4.0K 5月  24 15:28 local_ack_timeout_err</span><br><span class="line">0 -r--r--r-- 1 root root 4.0K 5月  24 15:28 np_cnp_sent</span><br><span class="line">0 -r--r--r-- 1 root root 4.0K 5月  24 15:28 np_ecn_marked_roce_packets</span><br><span class="line">0 -r--r--r-- 1 root root 4.0K 5月  24 15:28 out_of_buffer</span><br><span class="line">0 -r--r--r-- 1 root root 4.0K 5月  24 15:28 out_of_sequence</span><br><span class="line">0 -r--r--r-- 1 root root 4.0K 5月  24 15:28 packet_seq_err</span><br><span class="line">0 -r--r--r-- 1 root root 4.0K 5月  24 15:28 req_cqe_error</span><br><span class="line">0 -r--r--r-- 1 root root 4.0K 5月  24 15:28 req_cqe_flush_error</span><br><span class="line">0 -r--r--r-- 1 root root 4.0K 5月  24 15:28 req_remote_access_errors</span><br><span class="line">0 -r--r--r-- 1 root root 4.0K 5月  24 15:28 req_remote_invalid_request</span><br><span class="line">0 -r--r--r-- 1 root root 4.0K 5月  24 15:28 resp_cqe_error</span><br><span class="line">0 -r--r--r-- 1 root root 4.0K 5月  24 15:28 resp_cqe_flush_error</span><br><span class="line">0 -r--r--r-- 1 root root 4.0K 5月  24 15:28 resp_local_length_error</span><br><span class="line">0 -r--r--r-- 1 root root 4.0K 5月  24 15:28 resp_remote_access_errors</span><br><span class="line">0 -r--r--r-- 1 root root 4.0K 5月  24 15:28 rnr_nak_retry_err</span><br><span class="line">0 -r--r--r-- 1 root root 4.0K 5月  24 15:28 rp_cnp_handled</span><br><span class="line">0 -r--r--r-- 1 root root 4.0K 5月  24 15:28 rp_cnp_ignored</span><br><span class="line">0 -r--r--r-- 1 root root 4.0K 5月  24 15:28 rx_atomic_requests</span><br><span class="line">0 -r--r--r-- 1 root root 4.0K 5月  24 15:28 rx_icrc_encapsulated</span><br><span class="line">0 -r--r--r-- 1 root root 4.0K 5月  24 15:28 rx_read_requests</span><br><span class="line">0 -r--r--r-- 1 root root 4.0K 5月  24 15:28 rx_write_requests</span><br></pre></td></tr></table></figure>

<p>HW Counters Description:</p>
<table>
<thead>
<tr>
<th align="left"><strong>Counter</strong></th>
<th align="left"><strong>Description</strong></th>
<th align="left"><strong>Group</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">duplicate_request</td>
<td align="left">Number of received packets. A duplicate request is a request that had been previously executed.</td>
<td align="left">Error</td>
</tr>
<tr>
<td align="left">implied_nak_seq_err</td>
<td align="left">Number of time the requested decided an ACK. with a PSN larger than the expected PSN for an RDMA read or response.</td>
<td align="left">Error</td>
</tr>
<tr>
<td align="left">lifespan</td>
<td align="left">The maximum period in ms which defines the aging of the counter reads. Two consecutive reads within this period might return the same values</td>
<td align="left">Informative</td>
</tr>
<tr>
<td align="left">local_ack_timeout_err</td>
<td align="left">The number of times QP’s ack timer expired for RC, XRC, DCT QPs at the sender side.The QP retry limit was not exceed, therefore it is still recoverable error.</td>
<td align="left">Error</td>
</tr>
<tr>
<td align="left">np_cnp_sent</td>
<td align="left">The number of CNP packets sent by the Notification Point when it noticed congestion experienced in the RoCEv2 IP header (ECN bits).The counters was added in MLNX_OFED 4.1</td>
<td align="left">Informative</td>
</tr>
<tr>
<td align="left">np_ecn_marked_roce_packets</td>
<td align="left">The number of RoCEv2 packets received by the notification point which were marked for experiencing the congestion (ECN bits where ‘11’ on the ingress RoCE traffic) .The counters was added in MLNX_OFED 4.1</td>
<td align="left">Informative</td>
</tr>
<tr>
<td align="left">out_of_buffer</td>
<td align="left">The number of drops occurred due to lack of WQE for the associated QPs.</td>
<td align="left">Error</td>
</tr>
<tr>
<td align="left">out_of_sequence</td>
<td align="left">The number of out of sequence packets received.</td>
<td align="left">Error</td>
</tr>
<tr>
<td align="left">packet_seq_err</td>
<td align="left">The number of received NAK sequence error packets. The QP retry limit was not exceeded.</td>
<td align="left">Error</td>
</tr>
<tr>
<td align="left">req_cqe_error</td>
<td align="left">The number of times requester detected CQEs completed with errors.The counters was added in MLNX_OFED 4.1</td>
<td align="left">Error</td>
</tr>
<tr>
<td align="left">req_cqe_flush_error</td>
<td align="left">The number of times requester detected CQEs completed with flushed errors.The counters was added in MLNX_OFED 4.1</td>
<td align="left">Error</td>
</tr>
<tr>
<td align="left">req_remote_access_errors</td>
<td align="left">The number of times requester detected remote access errors.The counters was added in MLNX_OFED 4.1</td>
<td align="left">Error</td>
</tr>
<tr>
<td align="left">req_remote_invalid_request</td>
<td align="left">The number of times requester detected remote invalid request errors.The counters was added in MLNX_OFED 4.1</td>
<td align="left">Error</td>
</tr>
<tr>
<td align="left">resp_cqe_error</td>
<td align="left">The number of times responder detected CQEs completed with errors.The counters was added in MLNX_OFED 4.1</td>
<td align="left">Error</td>
</tr>
<tr>
<td align="left">resp_cqe_flush_error</td>
<td align="left">The number of times responder detected CQEs completed with flushed errors.The counters was added in MLNX_OFED 4.1</td>
<td align="left">Error</td>
</tr>
<tr>
<td align="left">resp_local_length_error</td>
<td align="left">The number of times responder detected local length errors.The counters was added in MLNX_OFED 4.1</td>
<td align="left">Error</td>
</tr>
<tr>
<td align="left">resp_remote_access_errors</td>
<td align="left">The number of times responder detected remote access errors.The counters was added in MLNX_OFED 4.1</td>
<td align="left">Error</td>
</tr>
<tr>
<td align="left">rnr_nak_retry_err</td>
<td align="left">The number of received RNR NAK packets. The QP retry limit was not exceeded.</td>
<td align="left">Error</td>
</tr>
<tr>
<td align="left">rp_cnp_handled</td>
<td align="left">The number of CNP packets handled by the Reaction Point HCA to throttle the transmission rate.The counters was added in MLNX_OFED 4.1</td>
<td align="left">Informative</td>
</tr>
<tr>
<td align="left">rp_cnp_ignored</td>
<td align="left">The number of CNP packets received and ignored by the Reaction Point HCA. This counter should not raise if RoCE Congestion Control was enabled in the network. If this counter raise, verify that ECN was enabled on the adapter. See <span class="exturl" data-url="aHR0cHM6Ly9jb21tdW5pdHkubWVsbGFub3guY29tL3MvYXJ0aWNsZS9ob3d0by1jb25maWd1cmUtZGNxY24tLXJvY2UtY2MtLXZhbHVlcy1mb3ItY29ubmVjdHgtNC0tbGludXgteA==">HowTo Configure DCQCN (RoCE CC) values for ConnectX-4 (Linux)<i class="fa fa-external-link-alt"></i></span>.The counters was added in MLNX_OFED 4.1</td>
<td align="left">Error</td>
</tr>
<tr>
<td align="left">rx_atomic_requests</td>
<td align="left">The number of received ATOMIC request for the associated QPs.</td>
<td align="left">Informative</td>
</tr>
<tr>
<td align="left">rx_dct_connect</td>
<td align="left">The number of received connection request for the associated DCTs.</td>
<td align="left">Informative</td>
</tr>
<tr>
<td align="left">rx_read_requests</td>
<td align="left">The number of received READ requests for the associated QPs.</td>
<td align="left">Informative</td>
</tr>
<tr>
<td align="left">rx_write_requests</td>
<td align="left">The number of received WRITE requests for the associated QPs.</td>
<td align="left">Informative</td>
</tr>
<tr>
<td align="left">rx_icrc_encapsulated</td>
<td align="left">The number of RoCE packets with ICRC errors.This counter was added in MLNX_OFED 4.4 and kernel 4.19</td>
<td align="left">Error</td>
</tr>
<tr>
<td align="left">roce_adp_retrans</td>
<td align="left">Counts the number of adaptive retransmissions for RoCE trafficThe counter was added in MLNX_OFED rev 5.0-1.0.0.0 and kernel v5.6.0</td>
<td align="left">Informative</td>
</tr>
<tr>
<td align="left">roce_adp_retrans_to</td>
<td align="left">Counts the number of times RoCE traffic reached timeout due to adaptive retransmissionThe counter was added in MLNX_OFED rev 5.0-1.0.0.0 and kernel v5.6.0</td>
<td align="left">Informative</td>
</tr>
<tr>
<td align="left">roce_slow_restart</td>
<td align="left">Counts the number of times RoCE slow restart was usedThe counter was added in MLNX_OFED rev 5.0-1.0.0.0 and kernel v5.6.0</td>
<td align="left">Informative</td>
</tr>
<tr>
<td align="left">roce_slow_restart_cnps</td>
<td align="left">Counts the number of times RoCE slow restart generated CNP packetsThe counter was added in MLNX_OFED rev 5.0-1.0.0.0 and kernel v5.6.0</td>
<td align="left">Informative</td>
</tr>
<tr>
<td align="left">roce_slow_restart_trans</td>
<td align="left">Counts the number of times RoCE slow restart changed state to slow restartThe counter was added in MLNX_OFED rev 5.0-1.0.0.0 and kernel v5.6.0</td>
<td align="left">Informative</td>
</tr>
</tbody></table>
<ul>
<li><code>duplicate_request</code>:（Duplicated packets）接收报文数，重复请求是先前已执行的请求。</li>
<li><code>out_of_sequence</code>:（Drop out of sequence）接收到的乱序包的数量，说明此时已经产生了丢包</li>
<li><code>packet_seq_err</code>：（NAK sequence rcvd）接收到的NAK序列错误数据包的数量，未超过QP重试限制。</li>
</ul>
<h2 id="带宽监测工具——netdata"><a href="#带宽监测工具——netdata" class="headerlink" title="带宽监测工具——netdata"></a>带宽监测工具——netdata</h2><p><code>netdata</code>可以查看RDMA网卡的带宽，但是展示的发送和接收的数据是通过<code>/sys/class/infiniband</code>下的节点获取的，因此实际带宽数据是其展示数据的<code>4倍</code></p>
<p><img data-src="/images/2021/05/netdata_rdma_ib.png" alt="netdata_rdma_ib"></p>
<blockquote>
<p>插件源码：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL25ldGRhdGEvbmV0ZGF0YS9ibG9iL21hc3Rlci9jb2xsZWN0b3JzL3Byb2MucGx1Z2luL3N5c19jbGFzc19pbmZpbmliYW5kLmM=">https://github.com/netdata/netdata/blob/master/collectors/proc.plugin/sys_class_infiniband.c<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<h2 id="网卡工作模式"><a href="#网卡工作模式" class="headerlink" title="网卡工作模式"></a>网卡工作模式</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ibstatus</span></span><br><span class="line">Infiniband device &#x27;mlx5_0&#x27; port 1 status:</span><br><span class="line">	default gid:	 fe80:0000:0000:0000:0e42:a1ff:fe41:2d36</span><br><span class="line">	base lid:	 0x0</span><br><span class="line">	sm lid:		 0x0</span><br><span class="line">	state:		 4: ACTIVE</span><br><span class="line">	phys state:	 5: LinkUp</span><br><span class="line">	rate:		 25 Gb/sec (1X EDR)</span><br><span class="line">	link_layer:	 Ethernet</span><br><span class="line"></span><br><span class="line">Infiniband device &#x27;mlx5_1&#x27; port 1 status:</span><br><span class="line">	default gid:	 fe80:0000:0000:0000:0e42:a1ff:fe41:2d37</span><br><span class="line">	base lid:	 0x0</span><br><span class="line">	sm lid:		 0x0</span><br><span class="line">	state:		 4: ACTIVE</span><br><span class="line">	phys state:	 5: LinkUp</span><br><span class="line">	rate:		 25 Gb/sec (1X EDR)</span><br><span class="line">	link_layer:	 Ethernet</span><br></pre></td></tr></table></figure>
<ul>
<li><code>link_layer</code>： 工作模式，Ethernet为IP模式，还有IB（infiniband）模式。</li>
<li>工作模式切换：<span class="exturl" data-url="aHR0cHM6Ly9jb21tdW5pdHkubWVsbGFub3guY29tL3MvYXJ0aWNsZS9ob3d0by1jaGFuZ2UtcG9ydC10eXBlLWluLW1lbGxhbm94LWNvbm5lY3R4LTMtYWRhcHRlcg==">HowTo Change Port Type in Mellanox ConnectX-3 Adapter<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><ul>
<li><code>ibstat</code>: 查询InfiniBand设备的基本状态</li>
<li><code>ibstatus</code>： 网卡信息</li>
<li><code>ibv_devinfo</code>：网卡设备信息（ibv_devinfo -d mlx5_0 -v）</li>
<li><code>ibv_devices</code>：查看本主机的infiniband设备</li>
<li><code>ibnodes</code>：查看网络中的infiniband设备</li>
<li><code>show_gids</code>：看看网卡支持的roce版本</li>
<li><code>show_counters</code>:网卡端口统计数据，比如发送接受数据大小</li>
<li><code>mlxconfig</code>: 网卡配置（mlxconfig -d mlx5_1 q查询网卡配置信息）</li>
</ul>
<h2 id="双网口作用"><a href="#双网口作用" class="headerlink" title="双网口作用"></a>双网口作用</h2><p><code>双网口</code>：指一个物理网卡上的两个网络接口</p>
<ol>
<li>可以捆绑，比单口效率高多了。同时上两个不同的网络网，有一个不同时，另一个也在同时工作实现网络备份。</li>
<li>服务器必备2个或2个以上的网口，一个用于网路接入，另一个作为输入。</li>
<li>家用PC机用2个的网口的网卡，可以实现服务器的初级功能，接入网络然后输入，并管理输入端的网路和数据。</li>
<li>双口的可以做负载均衡，单口的无此功能。</li>
<li>双口的可以连接两个网络，可以做网关，单口的直接无法做到此点。当然，如果用两个单口网卡，也可以实现某些双口网卡的同样效果，但在转换速度上还是和双口网卡略有差异。</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9hY2Nlc3MucmVkaGF0LmNvbS9zb2x1dGlvbnMvMzAxNjQz">How to install support for Mellanox Infiniband hardware on RHEL6<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cubWVsbGFub3guY29tL3N1cHBvcnQvbWxueC1vZmVkLXB1YmxpYy1yZXBvc2l0b3J5">Mellanox Technologies Ltd. Public Repository<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3h6dGpocy9hcnRpY2xlL2RldGFpbHMvNTE0ODc0Njc=">infiniband带宽测试方法1 ib_read&#x2F;write_bw&#x2F;lat<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xqbGZhdGhlci9hcnRpY2xlL2RldGFpbHMvMTAyOTI1OTU0">ib_write_bw 和 ib_read_bw 测试 RDMA 的读写处理确定带宽<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1FpYW5nTGlfc3Ryb25nL2FydGljbGUvZGV0YWlscy84MTAyMTE5Mw==">ibverbs文档翻译<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9pbnN1amFuZy5naXRodWIuaW8vMjAyMC0wMi0wOS9pbnRyb2R1Y3Rpb24tdG8tcHJvZ3JhbW1pbmctaW5maW5pYmFuZC8=">Introduction to Programming Infiniband RDMA<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvaHRtbC9kcmFmdC10YWxwZXktbmZzdjQtcmRtYS1zZXNzLTAw">NFSv4 RDMA and Session Extensions<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cubWVsbGFub3guY29tL3JlbGF0ZWQtZG9jcy9wcm9kX3NvZnR3YXJlL1JETUFfQXdhcmVfUHJvZ3JhbW1pbmdfdXNlcl9tYW51YWwucGRm">RDMA_Aware_Programming_user_manual.pdf<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vc2N0Yi9wLzEzMTc5NTQyLmh0bWw=">infiniband网卡安装、使用总结<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLm1lbGxhbm94LmNvbS9kaXNwbGF5L1ZNQXY4ODMvUG9ydCtUeXBlK01hbmFnZW1lbnQ=">Port Type Management<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>网络</category>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
        <tag>rdma</tag>
      </tags>
  </entry>
  <entry>
    <title>「译」Linux DRM开发人员指南</title>
    <url>/post/3ac13ea3.html</url>
    <content><![CDATA[<p>最近在看DRM驱动相关的代码，但是总有一种盲人摸象的感觉，今天看到<span class="exturl" data-url="aHR0cDovL3d3dy5sYW5kbGV5Lm5ldC9rZG9jcy9odG1sZG9jcy9kcm0uaHRtbA==">Linux DRM Developer’s Guide<i class="fa fa-external-link-alt"></i></span>文档，在这里简单翻译一下,可以对DRM驱动有一个整体的认识。</p>
<span id="more"></span>


<h1 id="第1章-简介"><a href="#第1章-简介" class="headerlink" title="第1章 简介"></a>第1章 简介</h1><p>Linux DRM层包含旨在满足复杂图形设备需求的代码，通常包含非常适合3D图形加速的可编程管线。 内核中的图形驱动程序可以利用DRM功能来简化诸如内存管理，中断处理和DMA之类的任务，并为应用程序提供统一的接口。</p>
<p>版本说明：本指南涵盖了DRM树中的功能，包括TTM内存管理器，输出配置和模式设置以及新的vblank内部，以及当前内核中的所有常规功能。</p>
<h1 id="第2章-DRM内部"><a href="#第2章-DRM内部" class="headerlink" title="第2章 DRM内部"></a>第2章 DRM内部</h1><p>本章介绍了与驱动程序作者和开发人员有关的DRM内部，这些工作人员和开发人员致力于为现有驱动程序添加对最新功能的支持。</p>
<p>首先，我们讨论一些典型的驱动程序初始化要求，例如设置命令缓冲区，创建初始输出配置以及初始化核心服务。 后续部分将更详细地介绍核心内部结构，并提供实施说明和示例。</p>
<p>DRM层为图形驱动程序提供了多种服务，其中许多服务是由它通过libdrm提供的应用程序接口驱动的，libdrm是包装大多数DRM ioctl的库。 其中包括vblank事件处理，内存管理，输出管理，帧缓冲区管理，命令提交和防护，挂起&#x2F;恢复支持以及DMA服务。</p>
<h2 id="驱动程序初始化"><a href="#驱动程序初始化" class="headerlink" title="驱动程序初始化"></a>驱动程序初始化</h2><p>每个DRM驱动程序的核心是<code>drm_driver</code>结构。 驱动程序通常会静态初始化<code>drm_driver</code>结构，然后将其传递给<code>drm_*_init()</code>函数之一，以将其注册到DRM子系统。</p>
<p><code>drm_driver</code>结构包含描述驱动程序及其支持的功能的静态信息，以及指向DRM核心将调用以实现DRM API的方法的指针。 我们将首先浏览drm_driver静态信息字段，然后在以后的部分中详细描述各个操作。</p>
<h3 id="驱动信息"><a href="#驱动信息" class="headerlink" title="驱动信息"></a>驱动信息</h3><h4 id="驱动功能"><a href="#驱动功能" class="headerlink" title="驱动功能"></a>驱动功能</h4><p>驱动程序通过在<code>driver_features</code>字段中设置适当的标志来告知DRM核心其要求和支持的功能。 由于自注册以来，这些标志会影响DRM核心行为，因此必须将大多数标志设置为注册<code>drm_driver</code>实例。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">u32 driver_features;</span><br></pre></td></tr></table></figure>
<p>驱动程序功能标志：</p>
<ul>
<li><code>DRIVER_USE_AGP</code>： 驱动程序使用AGP接口，DRM核心将管理AGP资源。</li>
<li><code>DRIVER_REQUIRE_AGP</code>： 驱动程序需要AGP接口才能运行。 AGP初始化失败将成为致命错误。</li>
<li><code>DRIVER_PCI_DMA</code>：驱动程序具有PCI DMA的功能，将启用PCI DMA缓冲区到用户空间的映射。 不推荐使用。</li>
<li><code>DRIVER_SG</code>： 驱动程序可以执行scatter&#x2F;gather DMA，将启用catter&#x2F;gather缓冲区的分配和映射。 不推荐使用。</li>
<li><code>DRIVER_HAVE_DMA</code>： 驱动程序支持DMA，将支持用户空间DMA API。 不推荐使用。</li>
<li><code>DRIVER_HAVE_IRQ</code>： DRIVER_HAVE_IRQ指示驱动程序是否具有由DRM Core管理的IRQ处理程序。 设置该标志后，内核将支持简单的IRQ处理程序安装。 安装过程在“<span class="exturl" data-url="aHR0cDovL3d3dy5sYW5kbGV5Lm5ldC9rZG9jcy9odG1sZG9jcy9kcm0uaHRtbCNkcm0taXJxLXJlZ2lzdHJhdGlvbg==">IRQ注册<i class="fa fa-external-link-alt"></i></span>”一节中介绍。</li>
<li><code>DRIVER_IRQ_SHARED</code>：DRIVER_IRQ_SHARED指示设备和处理程序是否支持共享的IRQ（请注意，这是PCI驱动程序所必需的）。</li>
<li><code>DRIVER_GEM</code>: 驱动程序使用GEM内存管理器。</li>
<li><code>DRIVER_MODESET</code>: 驱动程序支持模式设置界面（KMS）。</li>
<li><code>DRIVER_PRIME</code>: 驱动程序实现DRM PRIME缓冲区共享。</li>
<li><code>DRIVER_RENDER</code>: 驱动程序支持专用渲染节点。</li>
</ul>
<h4 id="Major-Minor-and-Patchlevel"><a href="#Major-Minor-and-Patchlevel" class="headerlink" title="Major, Minor and Patchlevel"></a>Major, Minor and Patchlevel</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *name;</span><br><span class="line"><span class="type">char</span> *desc;</span><br><span class="line"><span class="type">char</span> *date;</span><br></pre></td></tr></table></figure>
<p>驱动程序名称在初始化时被打印到内核日志中，用于IRQ注册，并通过DRM_IOCTL_VERSION传递给用户空间。<br>驱动程序描述是通过DRM_IOCTL_VERSION ioctl传递给用户空间的纯信息字符串，否则由内核未使用。<br>格式为YYYYMMDD的驱动程序日期旨在标识对驱动程序的最新修改日期。 但是，由于大多数驱动程序无法更新它，因此它的值几乎没有用。 DRM内核在初始化时将其打印到内核日志，并通过DRM_IOCTL_VERSION ioctl将其传递到用户空间。</p>
<h3 id="驱动加载"><a href="#驱动加载" class="headerlink" title="驱动加载"></a>驱动加载</h3><p>加载方法是驱动程序和设备初始化的入口点。 该方法负责分配和初始化驱动程序私有数据，指定支持的性能计数器，执行资源分配和映射（例如，获取时钟，映射寄存器或分配命令缓冲区），初始化内存管理器（称为“内存管理”的部分），安装 IRQ处理程序（称为“ IRQ注册”的部分），设置垂直消隐处理（称为“垂直消隐”的部分），模式设置（称为“模式设置”的部分）和初始输出配置（称为“ KMS初始化”的部分） 和清理”）。</p>
<blockquote>
<p><strong>注</strong>:</p>
<p>如果需要考虑兼容性（例如将驱动程序从用户模式设置转换为内核模式设置），则必须小心以防止设备初始化和与当前活动的用户空间驱动程序不兼容的控制。 例如，如果正在使用用户级别模式设置驱动程序，则在加载时执行输出发现和配置会很成问题。 同样，如果使用了不了解内存管理的用户级驱动程序，则可能需要省略内存管理和命令缓冲区设置。 这些要求是特定于驱动程序的，因此必须注意使新旧应用程序和库均能正常工作。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> (*load) (<span class="keyword">struct</span> drm_device *, <span class="type">unsigned</span> <span class="type">long</span> flags);</span><br></pre></td></tr></table></figure>
<p>该方法有两个参数，一个指向新创建的<code>drm_device</code>的指针和标志。 这些标志用于传递与传递给<code>drm_*_init()</code>的设备相对应的设备ID的<code>driver_data</code>字段。 当前只有PCI设备使用此功能，USB和平台DRM驱动程序的加载方法称为标志0。</p>
<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><p>现代Linux系统需要大量的图形内存来存储帧缓冲区，纹理，顶点和其他与图形相关的数据。考虑到许多数据的动态特性，因此有效管理图形内存对于图形堆栈至关重要，并且在DRM基础架构中发挥着核心作用。<br>DRM核心包括两个<code>内存管理器</code>，即<code>转换表映射（TTM）</code>和<code>图形执行管理器（GEM）</code>。 TTM是第一个开发的DRM内存管理器，并试图成为一种“千篇一律”的解决方案。它提供了一个单一的用户空间API，可满足所有硬件的需求，同时支持统一内存体系结构（UMA）设备和具有专用视频RAM的设备（即大多数离散视频卡）。这导致了一个庞大，复杂的代码片段，结果证明这些代码难以用于驱动程序开发。<br>GEM最初是由英特尔赞助的项目，以应对TTM的复杂性。它的设计理念是完全不同的：GEM没有为每个与图形内存相关的问题提供解决方案，而是确定了驱动程序之间的通用代码，并创建了一个共享它的支持库。与TTM相比，GEM的初始化和执行要求更简单，但它没有视频RAM管理功能，因此仅限于UMA设备。</p>
<h3 id="转换表管理器（TTM）"><a href="#转换表管理器（TTM）" class="headerlink" title="转换表管理器（TTM）"></a>转换表管理器（TTM）</h3><blockquote>
<p><strong>警告</strong></p>
<p>本节已过时。</p>
</blockquote>
<h3 id="图形执行管理器（GEM）"><a href="#图形执行管理器（GEM）" class="headerlink" title="图形执行管理器（GEM）"></a>图形执行管理器（GEM）</h3><p>GEM设计方法导致内存管理器无法在其用户空间或内核API中提供所有（甚至所有常见）用例的完整覆盖。 GEM向用户空间公开了一组与内存相关的标准操作，并向驱动程序提供了一组帮助程序功能，并允许驱动程序使用自己的私有API来实现特定于硬件的操作。<br>GEM-LWN上的<span class="exturl" data-url="aHR0cHM6Ly9sd24ubmV0L0FydGljbGVzLzI4Mzc5OC8=">Graphics Execution Manager<i class="fa fa-external-link-alt"></i></span>文章中介绍了GEM用户空间API。尽管有些过时，但该文档很好地概述了GEM API原则。目前，使用特定于驱动程序的ioctl来实现缓冲区分配以及读写操作（作为通用GEM API的一部分进行描述）。<br>GEM与数据无关。它管理抽象缓冲区对象，而无需知道各个缓冲区包含哪些内容。因此，需要了解缓冲区内容或用途（例如缓冲区分配或同步原语）的API不在GEM的范围内，必须使用特定于驱动程序的ioctl来实现。</p>
<p>从根本上讲，GEM涉及以下几种操作：</p>
<ul>
<li>内存分配和释放</li>
<li>命令执行</li>
<li>执行命令时的光圈管理</li>
</ul>
<p>缓冲区对象分配相对简单，并且主要由Linux的shmem层提供，后者提供了用于备份每个对象的内存。</p>
<p>特定于设备的操作，例如命令执行，固定，缓冲区读写，映射和域所有权转移，留给特定于驱动程序的ioctl。</p>
<h4 id="GEM初始化"><a href="#GEM初始化" class="headerlink" title="GEM初始化"></a>GEM初始化</h4><p>使用GEM的驱动程序必须在<code>struct drm_driver</code> <code>driver_features</code>字段中设置<code>DRIVER_GEM</code>位。 然后，DRM内核将在调用装入操作之前自动初始化GEM内核。 在后台，这将创建DRM内存管理器对象，该对象提供用于对象分配的地址空间池。<br>在KMS配置中，如果硬件需要，驱动程序需要在核心GEM初始化之后分配和初始化<code>命令环缓冲区</code>。 UMA设备通常具有所谓的“被盗”存储区，该存储区为初始帧缓冲区和设备所需的大而连续的存储区提供了空间。 该空间通常不由GEM管理，必须单独初始化为它自己的DRM MM对象。</p>
<h4 id="GEM对象创建"><a href="#GEM对象创建" class="headerlink" title="GEM对象创建"></a>GEM对象创建</h4><p>GEM将GEM对象的创建和支持它们的内存分配分为两个不同的操作。</p>
<p>GEM对象由<code>struct drm_gem_object</code>的实例表示。 驱动程序通常需要使用私有信息来扩展GEM对象，从而创建特定于驱动程序的GEM对象结构类型，以嵌入<code>struct drm_gem_object</code>的实例。<br>要创建GEM对象，驱动程序会为其特定GEM对象类型的实例分配内存，并通过调用<code>drm_gem_object_init</code>初始化嵌入式结构<code>drm_gem_object</code>。 该函数获取指向DRM设备的指针，指向GEM对象的指针和缓冲区对象的大小（以字节为单位）。</p>
<p>GEM使用<code>shmem</code>分配匿名可分页内存。 <code>drm_gem_object_init</code>将创建所需大小的shmfs文件，并将其存储在<code>struct drm_gem_object filp</code>字段中。 当图形硬件直接使用系统内存时，该内存既可以用作对象的主要存储，也可以用作后备存储。<br>驱动程序负责通过为每个页面调用<code>shmem_read_mapping_page_gfp</code>来分配实际的物理页面。 请注意，它们可以在初始化GEM对象时决定分配页面，或延迟分配直到需要内存（例如，由于用户空间内存访问而导致页面错误，或者驱动程序需要启动涉及到DMA的传输时）。</p>
<p>例如，当硬件需要物理上连续的系统内存时（例如嵌入式设备中的常见情况），并不总是需要匿名的可分页内存分配。 驱动程序可以通过调用<code>drm_gem_private_object_init</code>而不是<code>drm_gem_object_init</code>来初始化没有shmfs支持的GEM对象（称为专用GEM对象）。 专用GEM对象的存储必须由驱动程序管理。</p>
<p>不需要使用私有信息扩展GEM对象的驱动程序可以调用<code>drm_gem_object_alloc</code>函数来分配和初始化结构<code>drm_gem_object</code>实例。 在使用<code>drm_gem_object_init</code>初始化GEM对象之后，GEM内核将调用可选的驱动程序<code>gem_init_object</code>操作。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> (*gem_init_object) (<span class="keyword">struct</span> drm_gem_object *obj);</span><br></pre></td></tr></table></figure>

<p>私有GEM对象不存在alloc-and-init函数。</p>
<h4 id="GEM对象生命周期"><a href="#GEM对象生命周期" class="headerlink" title="GEM对象生命周期"></a>GEM对象生命周期</h4><p>所有GEM对象均由GEM内核<code>引用计数</code>。 可以通过分别调用<code>drm_gem_object_reference</code>和<code>drm_gem_object_unreference</code>来获取和释放引用。 调用者必须持有<code>drm_device struct_mutex</code>锁。 为了方便起见，GEM提供了可以在不持有锁的情况下调用的<code>drm_gem_object_reference_unlocked</code>和<code>drm_gem_object_unreference_unlocked</code>函数。</p>
<p>当释放对GEM对象的最后一个引用时，GEM内核将调用<code>drm_driver gem_free_object</code>操作。 该操作对于启用了GEM的驱动程序是必需的，并且必须释放GEM对象和所有关联的资源。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> (*gem_free_object) (<span class="keyword">struct</span> drm_gem_object *obj);</span><br></pre></td></tr></table></figure>

<p>驱动程序负责释放所有GEM对象资源，包括GEM核心创建的资源。 如果已经为对象创建了<code>mmap</code>偏移量（在这种情况下，drm_gem_object::map_list::map不为NULL），则必须通过调用<code>drm_gem_free_mmap_offset</code>来释放它。 必须通过调用<code>drm_gem_object_release</code>释放shmfs后备存储（如果未创建任何shmfs后备存储，则可以安全地调用该函数）。</p>
<h4 id="GEM对象命名"><a href="#GEM对象命名" class="headerlink" title="GEM对象命名"></a>GEM对象命名</h4><p>用户空间和内核之间的通信使用本地句柄，全局名称或最近使用的文件描述符来引用GEM对象。 所有这些都是32位整数值。 通常的Linux内核限制适用于文件描述符。<br>GEM句柄是DRM文件本地的。 应用程序通过特定于驱动程序的ioctl获取GEM对象的句柄，并且可以使用该句柄引用其他标准或特定于驱动程序的ioctl中的GEM对象。 关闭DRM文件句柄将释放其所有GEM句柄并取消引用关联的GEM对象。</p>
<h5 id="DRM-PRIME辅助功能参考"><a href="#DRM-PRIME辅助功能参考" class="headerlink" title="DRM PRIME辅助功能参考"></a>DRM PRIME辅助功能参考</h5><h4 id="GEM对象映射"><a href="#GEM对象映射" class="headerlink" title="GEM对象映射"></a>GEM对象映射</h4><p>因为映射操作相当繁重，所以与通过将缓冲区映射到用户空间相比，GEM支持通过特定于驱动程序的ioctl实现对缓冲区的类似于读&#x2F;写的访问。 但是，当需要随机访问缓冲区（例如执行软件渲染）时，直接访问对象可能会更有效率。<br>mmap系统调用不能直接用于映射GEM对象，因为它们没有自己的文件句柄。 当前共存在两种方法来将GEM对象映射到用户空间。 第一种方法使用特定于驱动程序的ioctl来执行映射操作，并在后台调用do_mmap。 这通常被认为是可疑的，似乎不建议使用支持GEM的新驱动程序，因此在此不再赘述。</p>
<h4 id="Dumb-GEM对象"><a href="#Dumb-GEM对象" class="headerlink" title="Dumb GEM对象"></a>Dumb GEM对象</h4><p>GEM API并未将GEM对象创建标准化，而是将其留给特定于驱动程序的ioctl。 对于包含特定于设备的用户空间组件（例如，在libdrm中）的完整图形堆栈来说，这不是一个问题，但此限制使基于DRM的早期启动图形不必要地复杂。<br><code>Dumb GEM</code>对象通过提供标准API来创建适合于扫描的哑缓冲区，从而部分缓解了该问题，然后可以将其用于创建KMS帧缓冲区。</p>
<h4 id="内存一致性-——-Memory-Coherency"><a href="#内存一致性-——-Memory-Coherency" class="headerlink" title="内存一致性 —— Memory Coherency"></a>内存一致性 —— Memory Coherency</h4><h4 id="命令执行-——-Command-Execution"><a href="#命令执行-——-Command-Execution" class="headerlink" title="命令执行 —— Command Execution"></a>命令执行 —— Command Execution</h4><h2 id="模式设置（Mode-Setting）"><a href="#模式设置（Mode-Setting）" class="headerlink" title="模式设置（Mode Setting）"></a>模式设置（Mode Setting）</h2><p>驱动程序必须通过在DRM设备上调用<code>drm_mode_config_init</code>来初始化模式设置核心。 该函数初始化<code>drm_device mode_config</code>字段，并且永不失败。 完成后，必须通过初始化以下字段来设置模式配置。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> min_width, min_height;</span><br><span class="line"><span class="type">int</span> max_width, max_height;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>帧缓冲区的最小和最大宽度和高度，以像素为单位。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">drm_mode_config_funcs</span> *<span class="title">funcs</span>;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>模式设定函数</p>
</blockquote>
<h3 id="帧缓冲区创建"><a href="#帧缓冲区创建" class="headerlink" title="帧缓冲区创建"></a>帧缓冲区创建</h3><h3 id="输出轮询——Output-Polling"><a href="#输出轮询——Output-Polling" class="headerlink" title="输出轮询——Output Polling"></a>输出轮询——Output Polling</h3><h3 id="锁定——Locking"><a href="#锁定——Locking" class="headerlink" title="锁定——Locking"></a>锁定——Locking</h3><p>除了某些具有自己的锁定的查找结构（隐藏在接口功能后面）之外，大多数模式集状态还受<code>dev-&gt;mode_config.lock</code>互斥锁以及逐个<code>crtc锁</code>的保护，以允许进行<code>光标更新</code>，<code>页面翻转</code>和后台任务（例如输出检测）同时发生的类似操作。 跨域的操作（例如完整模式集）始终会抓住所有锁。 那里的驱动程序需要通过额外的锁定来保护crtcs之间共享的资源。 如果modset功能碰到crtc状态，例如，如果他们碰到crtc状态，他们还需要小心以始终抓住相关的crtc锁。 用于负载检测（仅抓取<code>mode_config.lock</code>以允许实时crtcs上的并发屏幕更新）。</p>
<h2 id="KMS初始化和清理"><a href="#KMS初始化和清理" class="headerlink" title="KMS初始化和清理"></a>KMS初始化和清理</h2><p>KMS设备被抽象并作为一组平面，<code>CRTC</code>，<code>encoders</code>和<code>connectors</code>。 因此，KMS驱动程序必须在初始化模式设置后的加载时创建并初始化所有这些对象。</p>
<h3 id="CRTCs-struct-drm-crtc"><a href="#CRTCs-struct-drm-crtc" class="headerlink" title="CRTCs (struct drm_crtc)"></a>CRTCs (struct drm_crtc)</h3><p><code>CRTC</code>是代表芯片一部分的抽象，其中包含指向扫描缓冲区的指针。 因此，可用的CRTC数量决定了在任何给定时间可以激活多少个独立的扫描缓冲区。 CRTC结构包含几个字段来支持此操作：指向某些视频内存的指针（抽象为帧缓冲区对象），显示模式以及视频内存中的（x，y）偏移量以支持平移或配置，其中一个 视频存储器跨越多个CRTC。</p>
<h4 id="CRTC初始化"><a href="#CRTC初始化" class="headerlink" title="CRTC初始化"></a>CRTC初始化</h4><p>KMS设备必须创建并注册至少一个<code>struct drm_crtc</code>实例。 该实例可能由驱动程序分配并归零（可能是较大结构的一部分），并使用指向CRTC函数的指针通过调用<code>drm_crtc_init</code>进行注册。</p>
<h4 id="CRTC运作"><a href="#CRTC运作" class="headerlink" title="CRTC运作"></a>CRTC运作</h4><h5 id="Set-Configuration"><a href="#Set-Configuration" class="headerlink" title="Set Configuration"></a>Set Configuration</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> (*set_config)(<span class="keyword">struct</span> drm_mode_set *<span class="built_in">set</span>);</span><br></pre></td></tr></table></figure>
<p>将新的CRTC配置应用于设备。 该配置指定了CRTC，要从中扫描出的帧缓冲区，帧缓冲区中的（x，y）位置，显示模式以及连接器阵列（如果可能）以CRTC驱动。<br>如果配置中指定的帧缓冲区为NULL，则驱动程序必须分离所有连接到CRTC的编码器和所有连接到这些编码器的连接器，并禁用它们。<br>在保持模式配置锁定的情况下调用此操作。</p>
<blockquote>
<p><strong>注</strong>:</p>
<p>FIXME：set_config应该如何与DPMS交互？ 如果CRTC被暂停，是否应该恢复？</p>
</blockquote>
<h5 id="Page-Flipping"><a href="#Page-Flipping" class="headerlink" title="Page Flipping"></a>Page Flipping</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> (*page_flip)(<span class="keyword">struct</span> drm_crtc *crtc, <span class="keyword">struct</span> drm_framebuffer *fb,</span><br><span class="line">                   <span class="keyword">struct</span> drm_pending_vblank_event *event);</span><br></pre></td></tr></table></figure>

<p>将<code>页面翻转</code>到CRTC的给定<code>帧缓冲区</code>。在保持模式配置互斥锁的情况下调用此操作。<br><code>页面翻转</code>是一种<code>同步机制</code>，可以在<code>垂直消隐期</code>(vblank)间将CRTC扫描出的帧缓冲区替换为新的帧缓冲区，从而避免撕裂。当应用程序请求页面翻转时，DRM内核将验证新的帧缓冲区是否足够大，以供CRTC在当前配置的模式下进行扫描，然后使用指向新帧缓冲区的指针调用CRTC page_flip操作。<br><code>page_flip</code>操作安排页面翻转。一旦完成了针对新帧缓冲区的任何暂挂渲染，CRTC将重新编程为在下一次垂直刷新后显示该帧缓冲区。该操作必须立即返回，而不必等待渲染或页面翻转完成，并且必须阻止任何新的渲染到帧缓冲区，直到页面翻转完成。<br>如果可以成功调度页面翻转，则驱动程序必须将<code>drm_crtc-&gt;fb</code>字段设置为fb指向的新帧缓冲区。这一点很重要，这样可以使基于帧缓冲区的引用计数保持平衡。<br>如果页面翻转已经挂起，则page_flip操作必须返回-EBUSY。</p>
<p>为了将页面翻转同步到<code>垂直消隐</code>，驱动程序可能需要启用<code>垂直消隐</code>中断。 为此，它应该调用<code>drm_vblank_get</code>，并在页面翻转完成后调用<code>drm_vblank_put</code>。<br>如果在翻页完成时请求通知应用程序，则将使用指向<code>drm_pending_vblank_event</code>实例的非NULL事件参数来调用<code>page_flip</code>操作。 翻页完成后，驱动程序必须调用<code>drm_send_vblank_event</code>填写事件并发送以唤醒所有等待的进程。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">spin_lock_irqsave(&amp;dev-&gt;event_lock, flags);</span><br><span class="line">...</span><br><span class="line">drm_send_vblank_event(dev, pipe, event);</span><br><span class="line">spin_unlock_irqrestore(&amp;dev-&gt;event_lock, flags);</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注</strong>:</p>
<p>FIXME：不需要等待渲染完成的驱动程序是否可以将事件添加到dev-&gt; vblank_event_list并让DRM内核处理所有事情，例如“常规”垂直消隐事件？</p>
</blockquote>
<p>在等待页面翻转完成时，驱动程序可以自由使用<code>event-&gt;base.link</code>列表头，以将未决事件存储在特定于驱动程序的列表中。<br>如果在发出事件信号之前关闭了文件句柄，则驱动程序必须注意在其预关闭操作中销毁该事件（如果需要，请调用<code>drm_vblank_put</code>）。</p>
<h5 id="Miscellaneous（其他）"><a href="#Miscellaneous（其他）" class="headerlink" title="Miscellaneous（其他）"></a>Miscellaneous（其他）</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> (*set_property)(<span class="keyword">struct</span> drm_crtc *crtc,</span><br><span class="line">                     <span class="keyword">struct</span> drm_property *property, <span class="type">uint64_t</span> value);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>将给定的CRTC属性的值设置为value。 有关属性的更多信息，请参见“ KMS属性”一节。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> (*gamma_set)(<span class="keyword">struct</span> drm_crtc *crtc, u16 *r, u16 *g, u16 *b,</span><br><span class="line">                        <span class="type">uint32_t</span> start, <span class="type">uint32_t</span> size);</span><br><span class="line">&gt; 将灰度系数应用于设备。 该操作是可选的。</span><br><span class="line"></span><br><span class="line">``` C</span><br><span class="line"><span class="title function_">void</span> <span class="params">(*destroy)</span><span class="params">(<span class="keyword">struct</span> drm_crtc *crtc)</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>不再需要时销毁CRTC。 请参阅“ KMS初始化和清理”部分。</p>
</blockquote>
<h3 id="Planes-struct-drm-plane"><a href="#Planes-struct-drm-plane" class="headerlink" title="Planes (struct drm_plane)"></a>Planes (struct drm_plane)</h3><p>平面(plane)表示可以在扫描过程中与CRTC<code>混合</code>或<code>叠加</code>在CRTC顶部的图像源。 平面与帧缓冲区关联，以裁剪图像存储器（源）的一部分，并可以选择将其缩放到目标大小。 然后将结果与CRTC混合或叠加在CRTC之上。</p>
<h4 id="Plane-Initialization"><a href="#Plane-Initialization" class="headerlink" title="Plane Initialization"></a>Plane Initialization</h4><p>平面是可选的。 要创建平面，KMS驱动程序会分配<code>struct drm_plane</code>实例（可能是较大结构的一部分）的实例并将其清零，并通过调用<code>drm_plane_init</code>对其进行注册。 该函数采用可与平面关联的CRTC的位掩码，指向平面函数的指针以及格式支持的格式的列表。</p>
<h4 id="Plane-Operations"><a href="#Plane-Operations" class="headerlink" title="Plane Operations"></a>Plane Operations</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> (*update_plane)(<span class="keyword">struct</span> drm_plane *plane, <span class="keyword">struct</span> drm_crtc *crtc,</span><br><span class="line">                        <span class="keyword">struct</span> drm_framebuffer *fb, <span class="type">int</span> crtc_x, <span class="type">int</span> crtc_y,</span><br><span class="line">                        <span class="type">unsigned</span> <span class="type">int</span> crtc_w, <span class="type">unsigned</span> <span class="type">int</span> crtc_h,</span><br><span class="line">                        <span class="type">uint32_t</span> src_x, <span class="type">uint32_t</span> src_y,</span><br><span class="line">                        <span class="type">uint32_t</span> src_w, <span class="type">uint32_t</span> src_h);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>启用并配置平面以使用给定的CRTC和帧缓冲区。</p>
</blockquote>
<p>帧缓冲存储器坐标中的源矩形由<code>src_x</code>，<code>src_y</code>，<code>src_w</code>和<code>src_h</code>参数（作为16.16定点值）给出。 不支持亚像素平面坐标的设备可以忽略小数部分。<br>CRTC坐标中的目标矩形由<code>crtc_x</code>，<code>crtc_y</code>，<code>crtc_w</code>和<code>crtc_h</code>参数（作为整数值）给出。 设备将源矩形缩放为目标矩形。 如果不支持缩放，并且源矩形大小与目标矩形大小不匹配，则驱动程序必须返回-EINVAL错误。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> (*disable_plane)(<span class="keyword">struct</span> drm_plane *plane);</span><br></pre></td></tr></table></figure>
<p>禁用平面。 DRM内核会调用此方法，以响应将帧缓冲区ID设置为0，<code>DRM_IOCTL_MODE_SETPLANE</code> ioctl调用。CRTC不能处理禁用的平面。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> (*destroy)(<span class="keyword">struct</span> drm_plane *plane);</span><br></pre></td></tr></table></figure>
<p>不再需要时销毁平面。 请参阅“ KMS初始化和清理”部分。</p>
<h3 id="Encoders-struct-drm-encoder"><a href="#Encoders-struct-drm-encoder" class="headerlink" title="Encoders (struct drm_encoder)"></a>Encoders (struct drm_encoder)</h3><p><code>编码器</code>从CRTC提取像素数据，并将其转换为适合任何连接的<code>连接器</code>的格式。 在某些设备上，CRTC可能会向多个编码器发送数据。 在那种情况下，两个编码器都将从同一个扫描缓冲区接收数据，从而导致跨连接到每个编码器的连接器的“克隆”显示配置。</p>
<h4 id="Encoder-Initialization"><a href="#Encoder-Initialization" class="headerlink" title="Encoder Initialization"></a>Encoder Initialization</h4><p>对于CRTC，KMS驱动程序必须创建，初始化和注册至少一个<code>struct drm_encoder</code>实例。 该实例由驱动程序分配并归零，可能是较大结构的一部分。<br>驱动程序必须在注册编码器之前初始化<code>struct drm_encoder</code>可能的<code>_crtcs</code>和可能的克隆字段。 这两个字段分别是编码器可以连接到的CRTC的位掩码，并且是用于克隆的同级编码器。<br>初始化之后，必须使用对<code>drm_encoder_init</code>的调用来注册编码器。 该函数获取指向编码器功能和编码器类型的指针。 支持的类型是</p>
<ul>
<li>DRM_MODE_ENCODER_DAC用于VGA和DVI-I &#x2F; DVI-A上的模拟</li>
<li>DRM_MODE_ENCODER_TMDS用于DVI，HDMI和（嵌入式）DisplayPort</li>
<li>DRM_MODE_ENCODER_LVDS用于显示面板</li>
<li>用于电视输出的DRM_MODE_ENCODER_TVDAC（复合，S视频，分量，SCART）</li>
<li>DRM_MODE_ENCODER_VIRTUAL用于虚拟机显示</li>
</ul>
<p><code>编码器</code>必须连接到<code>CRTC</code>才能使用。 DRM驱动程序在初始化时不附加编码器。 应用程序（或实现时的fbdev兼容性层）负责将要使用的编码器附加到CRTC。</p>
<h4 id="Encoder-Operations"><a href="#Encoder-Operations" class="headerlink" title="Encoder Operations"></a>Encoder Operations</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> (*destroy)(<span class="keyword">struct</span> drm_encoder *encoder);</span><br></pre></td></tr></table></figure>
<p>在不再需要时调用以销毁编码器。 请参阅“ KMS初始化和清理”部分。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> (*set_property)(<span class="keyword">struct</span> drm_plane *plane,</span><br><span class="line">                     <span class="keyword">struct</span> drm_property *property, <span class="type">uint64_t</span> value);</span><br></pre></td></tr></table></figure>
<p>将给定平面属性的值设置为value。 有关属性的更多信息，请参见“ KMS属性”一节。</p>
<h3 id="Connectors-struct-drm-connector"><a href="#Connectors-struct-drm-connector" class="headerlink" title="Connectors (struct drm_connector)"></a>Connectors (struct drm_connector)</h3><p><code>连接器</code>是设备上像素数据的最终目标，并且通常直接连接到外部显示设备，例如监视器或笔记本电脑面板。 一次只能将一个连接器连接到一个编码器。 连接器也是保留有关附加显示器信息的结构，因此它包含显示数据，EDID数据，DPMS和连接状态以及有关附加显示器支持的模式的信息的字段。</p>
<h4 id="Connector-Initialization"><a href="#Connector-Initialization" class="headerlink" title="Connector Initialization"></a>Connector Initialization</h4><p>最后，KMS驱动程序必须创建，初始化，注册并附加至少一个<code>struct drm_connector</code>实例。 该实例将与其他KMS对象一起创建，并通过设置以下字段进行初始化。</p>
<ul>
<li><code>interlace_allowed</code>： 连接器是否可以处理隔行模式。</li>
<li><code>doublescan_allowed</code>：连接器是否可以处理双重扫描。</li>
<li><code>display_info</code>：当检测到显示时，显示信息由<code>EDID</code>信息填充。 对于嵌入式系统中的非热插拔显示器（如平板显示器），驱动程序应使用显示器的物理尺寸初始化<code>display_info.width_mm</code>和<code>display_info.height_mm</code>字段。</li>
<li><code>polled</code>： 连接器轮询模式，组合<ul>
<li><code>DRM_CONNECTOR_POLL_HPD</code>：连接器会生成热插拔事件，不需要定期进行轮询。 不能将<code>CONNECT和DISCONNECT</code>标志与<code>HPD</code>标志一起设置。</li>
<li><code>DRM_CONNECTOR_POLL_CONNECT</code>：定期轮询连接器以进行连接。</li>
<li><code>DRM_CONNECTOR_POLL_DISCONNECT</code>：定期轮询连接器是否断开连接。</li>
</ul>
</li>
</ul>
<p>对于不支持连接状态发现的连接器，设置为0。</p>
<p>然后，使用指向连接器功能和连接器类型的指针，调用<code>drm_connector_init</code>来注册连接器，并通过调用<code>drm_sysfs_connector_add</code>通过sysfs公开连接器。</p>
<p>支持的连接器类型为：</p>
<ul>
<li>DRM_MODE_CONNECTOR_VGA</li>
<li>DRM_MODE_CONNECTOR_DVII</li>
<li>DRM_MODE_CONNECTOR_DVID</li>
<li>DRM_MODE_CONNECTOR_DVIA</li>
<li>DRM_MODE_CONNECTOR_Composite</li>
<li>DRM_MODE_CONNECTOR_SVIDEO</li>
<li>DRM_MODE_CONNECTOR_LVDS</li>
<li>DRM_MODE_CONNECTOR_Component</li>
<li>DRM_MODE_CONNECTOR_9PinDIN</li>
<li>DRM_MODE_CONNECTOR_DisplayPort</li>
<li>DRM_MODE_CONNECTOR_HDMIA</li>
<li>DRM_MODE_CONNECTOR_HDMIB</li>
<li>DRM_MODE_CONNECTOR_TV</li>
<li>DRM_MODE_CONNECTOR_eDP</li>
<li>DRM_MODE_CONNECTOR_VIRTUAL</li>
</ul>
<p>必须将<code>connector</code>连接到<code>encoder</code>上才能使用。 对于将连接器映射到编码器1：1的设备，应在初始化时通过调用<code>drm_mode_connector_attach_encoder</code>来连接连接器。 驱动程序还必须将<code>drm_connector</code>编码器字段设置为指向附加的编码器。</p>
<p>最后，驱动程序必须通过调用<code>drm_kms_helper_poll_init</code>来初始化连接器状态更改检测。 如果至少一个连接器是可轮询的，但不能生成热插拔中断（由<code>DRM_CONNECTOR_POLL_CONNECT</code>和<code>DRM_CONNECTOR_POLL_DISCONNECT</code>连接器标志指示），则延迟的工作将自动排队，以定期轮询更改。 可以生成热插拔中断的连接器必须改用<code>DRM_CONNECTOR_POLL_HPD</code>标志进行标记，并且它们的中断处理程序必须调用<code>drm_helper_hpd_irq_event</code>。 该功能将使延迟的工作排队等待检查所有连接器的状态，但是不会进行定期轮询。</p>
<h4 id="Connector-Operations"><a href="#Connector-Operations" class="headerlink" title="Connector Operations"></a>Connector Operations</h4><blockquote>
<p><strong>注</strong>:</p>
<p>除非另有说明，否则所有操作都是强制性的。</p>
</blockquote>
<h5 id="DPMS-Display-Power-Management-Signaling"><a href="#DPMS-Display-Power-Management-Signaling" class="headerlink" title="DPMS(Display Power Management Signaling)"></a>DPMS(Display Power Management Signaling)</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> (*dpms)(<span class="keyword">struct</span> drm_connector *connector, <span class="type">int</span> mode);</span><br></pre></td></tr></table></figure>
<p>DPMS操作设置连接器的电源状态。 模式参数是以下之一</p>
<ul>
<li>DRM_MODE_DPMS_ON</li>
<li>DRM_MODE_DPMS_STANDBY</li>
<li>DRM_MODE_DPMS_SUSPEND</li>
<li>DRM_MODE_DPMS_OFF</li>
</ul>
<p>在除DPMS_ON模式以外的所有模式下，连接器所连接的编码器均应通过适当地驱动其信号，将显示器置于低功耗模式。 如果编码器上连接了多个连接器，则应注意不要改变其他显示器的电源状态。 当所有相关的连接器都置于低功耗模式时，应将低功耗模式传播到编码器和CRTC。</p>
<h5 id="Modes"><a href="#Modes" class="headerlink" title="Modes"></a>Modes</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> (*fill_modes)(<span class="keyword">struct</span> drm_connector *connector, <span class="type">uint32_t</span> max_width,</span><br><span class="line">                      <span class="type">uint32_t</span> max_height);</span><br></pre></td></tr></table></figure>
<p>用连接器所有受支持的模式填充模式列表。 如果<code>max_width</code>和<code>max_height</code>参数不为零，则实现必须忽略所有大于<code>max_width</code>或大于<code>max_height</code>的模式。</p>
<p>连接器还必须使用连接的显示器物理尺寸（以毫米为单位）填写此操作的<code>display_info width_mm</code>和<code>height_mm</code>字段。 如果该值未知或不适用（例如，对于投影仪设备），则应将字段设置为0。</p>
<h5 id="Connection-Status"><a href="#Connection-Status" class="headerlink" title="Connection Status"></a>Connection Status</h5><p>如果支持，则通过轮询或热插拔事件更新连接状态（请参阅<a href="">polled</a>）。 状态值通过ioctls报告给用户空间，并且不能在驱动程序内部使用，因为状态值只能通过从用户空间调用drm_mode_getconnector进行初始化。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title function_">drm_connector_status</span> <span class="params">(*detect)</span><span class="params">(<span class="keyword">struct</span> drm_connector *connector,</span></span><br><span class="line"><span class="params">                                        <span class="type">bool</span> force)</span>;</span><br></pre></td></tr></table></figure>
<p>检查是否有任何东西连接到连接器。 由于用户请求，在轮询时将<code>force</code>参数设置为false，或者在检查连接器时将<code>force</code>参数设置为true。 驾驶员可以使用这种力来避免自动探测过程中昂贵的破坏性操作。<br>如果连接器已连接某些东西，则返回<code>connector_status_connected</code>；如果未连接任何东西，则返回<code>connector_status_disconnected</code>；如果连接状态未知，则返回<code>connector_status_unknown</code>。<br>如果确实已将连接状态探测为已连接，则驱动程序仅应返回connector_status_connected。 无法检测到连接状态的连接器或失败的连接状态探测，应返回connector_status_unknown。</p>
<h5 id="Miscellaneous"><a href="#Miscellaneous" class="headerlink" title="Miscellaneous"></a>Miscellaneous</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> (*set_property)(<span class="keyword">struct</span> drm_connector *connector,</span><br><span class="line">                     <span class="keyword">struct</span> drm_property *property, <span class="type">uint64_t</span> value);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>将给定的连接器属性的值设置为value。 有关属性的更多信息，请参见“ KMS属性”一节。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> (*destroy)(<span class="keyword">struct</span> drm_connector *connector);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>不再需要时销毁连接器。 请参阅“ KMS初始化和清理”部分。</p>
</blockquote>
<h3 id="Cleanup"><a href="#Cleanup" class="headerlink" title="Cleanup"></a>Cleanup</h3><p>DRM核心管理其对象的生存期。 当不再需要某个对象时，内核调用其destroy函数，该函数必须清除并释放为该对象分配的所有资源。 每个<code>drm_*_init</code>调用必须与相应的<code>drm_*_cleanup</code>调用匹配，以清理CRTC（drm_crtc_cleanup），平面（drm_plane_cleanup），编码器（drm_encoder_cleanup）和连接器（drm_connector_cleanup）。 此外，在调用<code>drm_connector_cleanup</code>之前，必须通过调用<code>drm_sysfs_connector_remove</code>来删除已添加到sysfs的连接器。</p>
<p>必须通过调用<code>drm_kms_helper_poll_fini</code>清除连接器状态更改检测。</p>
<h3 id="Output-discovery-and-initialization-example"><a href="#Output-discovery-and-initialization-example" class="headerlink" title="Output discovery and initialization example"></a>Output discovery and initialization example</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">intel_crt_init</span><span class="params">(<span class="keyword">struct</span> drm_device *dev)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">drm_connector</span> *<span class="title">connector</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">intel_output</span> *<span class="title">intel_output</span>;</span></span><br><span class="line"></span><br><span class="line">	intel_output = kzalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> intel_output), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!intel_output)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	connector = &amp;intel_output-&gt;base;</span><br><span class="line">	drm_connector_init(dev, &amp;intel_output-&gt;base,</span><br><span class="line">			   &amp;intel_crt_connector_funcs, DRM_MODE_CONNECTOR_VGA);</span><br><span class="line"></span><br><span class="line">	drm_encoder_init(dev, &amp;intel_output-&gt;enc, &amp;intel_crt_enc_funcs,</span><br><span class="line">			 DRM_MODE_ENCODER_DAC);</span><br><span class="line"></span><br><span class="line">	drm_mode_connector_attach_encoder(&amp;intel_output-&gt;base,</span><br><span class="line">					  &amp;intel_output-&gt;enc);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Set up the DDC bus. */</span></span><br><span class="line">	intel_output-&gt;ddc_bus = intel_i2c_create(dev, GPIOA, <span class="string">&quot;CRTDDC_A&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (!intel_output-&gt;ddc_bus) &#123;</span><br><span class="line">		dev_printk(KERN_ERR, &amp;dev-&gt;pdev-&gt;dev, <span class="string">&quot;DDC bus registration &quot;</span></span><br><span class="line">			   <span class="string">&quot;failed.\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	intel_output-&gt;type = INTEL_OUTPUT_ANALOG;</span><br><span class="line">	connector-&gt;interlace_allowed = <span class="number">0</span>;</span><br><span class="line">	connector-&gt;doublescan_allowed = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	drm_encoder_helper_add(&amp;intel_output-&gt;enc, &amp;intel_crt_helper_funcs);</span><br><span class="line">	drm_connector_helper_add(connector, &amp;intel_crt_connector_helper_funcs);</span><br><span class="line"></span><br><span class="line">	drm_sysfs_connector_add(connector);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例（取自i915驱动程序）中，创建了CRTC，连接器和编码器组合。 还创建了特定于设备的i2c总线，以获取EDID数据并执行监视器检测。 该过程完成后，将向sysfs注册新的连接器，以使其属性可用于应用程序。</p>
<h3 id="KMS-API-Functions"><a href="#KMS-API-Functions" class="headerlink" title="KMS API Functions"></a><span class="exturl" data-url="aHR0cDovL3d3dy5sYW5kbGV5Lm5ldC9rZG9jcy9odG1sZG9jcy9kcm0uaHRtbCNpZHA1MTMyMzIw">KMS API Functions<i class="fa fa-external-link-alt"></i></span></h3><h2 id="Mode-Setting-Helper-Functions"><a href="#Mode-Setting-Helper-Functions" class="headerlink" title="Mode Setting Helper Functions"></a>Mode Setting Helper Functions</h2><p>驱动程序提供的<code>CRTC</code>，<code>编码器</code>和<code>连接器</code>功能实现DRM API。它们由DRM核心和ioctl处理程序调用以处理设备状态更改和配置请求。由于实现这些功能通常需要特定于驱动程序的逻辑，因此可以使用中间层帮助程序功能来避免重复样板代码。</p>
<p>DRM核心包含一个<code>中间层(mid-layer)</code>实现。中间层提供了几种<code>CRTC</code>，<code>编码器</code>和<code>连接器</code>功能的实现（从中间层的顶部调用），这些功能可预处理请求并调用驱动程序提供的较低级功能（在中间层的底部） 。例如，<code>drm_crtc_helper_set_config</code>函数可用于填充结构<code>drm_crtc_funcs set_config</code>字段。调用时，它将<code>set_config</code>操作拆分为更小，更简单的操作，并调用驱动程序进行处理。</p>
<p>要使用中间层，驱动程序调用<code>drm_crtc_helper_add</code>，<code>drm_encoder_helper_add</code>和<code>drm_connector_helper_add</code>函数以安装其中间层底层操作处理程序，并使用指向中间层顶层API的指针填充drm_crtc_funcs，drm_encoder_funcs和drm_connector_funcs结构。最好在注册相应的KMS对象之后立即完成中间层底部操作处理程序的安装。</p>
<p><code>mid-layer</code>未在<code>CRTC</code>，<code>encoder</code>和<code>connector</code>操作之间划分。要使用它，驱动程序必须为所有三个KMS实体提供底层功能。</p>
<h3 id="Helper-Functions"><a href="#Helper-Functions" class="headerlink" title="Helper Functions"></a>Helper Functions</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">drm_crtc_helper_set_config</span><span class="params">(<span class="keyword">struct</span> drm_mode_set *<span class="built_in">set</span>)</span>;</span><br></pre></td></tr></table></figure>
<p><code>drm_crtc_helper_set_config</code>帮助器函数是CRTC <code>set_config</code>实现。它首先尝试通过调用连接器<code>best_encoder</code>帮助程序操作来找到每个连接器的最佳编码器。</p>
<p>找到合适的编码器后，帮助器函数将调用<code>mode_fixup</code>编码器和CRTC帮助器操作来调整请求的模式，或者完全拒绝该模式，在这种情况下，错误将返回给应用程序。如果模式调整后的新配置与当前配置相同，则辅助功能将返回而无需执行任何其他操作。</p>
<p>如果调整后的模式与当前模式相同，但是需要对帧缓冲区进行更改，则<code>drm_crtc_helper_set_config</code>函数将调用CRTC <code>mode_set_base</code>帮助程序操作。如果调整后的模式不同于当前模式，或者如果未提供<code>mode_set_base</code>辅助操作，则辅助功能通过按此顺序调用prepare，mode_set以及commit CRTC和编码器辅助操作来执行完整模式设置序列。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">drm_helper_connector_dpms</span><span class="params">(<span class="keyword">struct</span> drm_connector *connector, <span class="type">int</span> mode)</span>;</span><br></pre></td></tr></table></figure>
<p><code>drm_helper_connector_dpms</code>帮助器函数是一个连接器dpms实现，可跟踪连接器的电源状态。 要使用该功能，驱动程序必须为CRTC和编码器提供dpms帮助程序操作，以将DPMS状态应用于设备。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">drm_helper_probe_single_connector_modes</span><span class="params">(<span class="keyword">struct</span> drm_connector *connector,</span></span><br><span class="line"><span class="params">                                            <span class="type">uint32_t</span> maxX, <span class="type">uint32_t</span> maxY)</span>;</span><br></pre></td></tr></table></figure>
<p><code>drm_helper_probe_single_connector_modes</code>帮助器函数是连接器<code>fill_modes</code>实现，该实现更新连接器的连接状态，然后通过调用连接器<code>get_modes</code>帮助器操作来检索模式列表。</p>
<p>如果指定，该函数将滤除大于max_width和max_height的模式。 然后，它为所探测列表中的每个模式调用连接器mode_valid helper操作，以检查该模式是否对连接器有效。</p>
<h3 id="CRTC-Helper-Operations"><a href="#CRTC-Helper-Operations" class="headerlink" title="CRTC Helper Operations"></a>CRTC Helper Operations</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> (*mode_fixup)(<span class="keyword">struct</span> drm_crtc *crtc,</span><br><span class="line">                       <span class="type">const</span> <span class="keyword">struct</span> drm_display_mode *mode,</span><br><span class="line">                       <span class="keyword">struct</span> drm_display_mode *adjusted_mode);</span><br></pre></td></tr></table></figure>
<p>让CRTC调整请求的模式或完全拒绝它。 如果模式被接受（可能在调整之后），则此操作返回true；如果模式被拒绝，则返回false。</p>
<p>如果无法合理使用<code>mode_fixup</code>操作，则应拒绝该模式。 在这种情况下，“合理”的定义目前是模糊的。 一种可能的行为是，当将固定模式面板与能够缩放的硬件一起使用时，将调整后的模式设置为面板定时。 另一行为是接受任何输入模式并将其调整为硬件支持的最接近模式（FIXME：这需要澄清）。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> (*mode_set_base)(<span class="keyword">struct</span> drm_crtc *crtc, <span class="type">int</span> x, <span class="type">int</span> y,</span><br><span class="line">                     <span class="keyword">struct</span> drm_framebuffer *old_fb)</span><br></pre></td></tr></table></figure>
<p>将当前帧缓冲区（存储在crtc-&gt; fb中）上的CRTC移到位置（x，y）。 帧缓冲区，x位置或y位置中的任何一个都可能已被修改。<br>此帮助程序操作是可选的。 如果未提供，则<code>drm_crtc_helper_set_config</code>函数将退回到<code>mode_set</code>帮助程序操作。</p>
<blockquote>
<p><strong>注意</strong></p>
<p>FIXME：为什么将x和y作为参数传递，因为可以通过<code>crtc-&gt;x</code>和<code>crtc-&gt;y</code>来访问它们？</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> (*prepare)(<span class="keyword">struct</span> drm_crtc *crtc);</span><br></pre></td></tr></table></figure>
<p>准备CRTC以进行模式设置。 验证请求的模式后，将调用此操作。 驱动程序使用它来执行设置新模式之前所需的设备特定操作。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> (*mode_set)(<span class="keyword">struct</span> drm_crtc *crtc, <span class="keyword">struct</span> drm_display_mode *mode,</span><br><span class="line">                <span class="keyword">struct</span> drm_display_mode *adjusted_mode, <span class="type">int</span> x, <span class="type">int</span> y,</span><br><span class="line">                <span class="keyword">struct</span> drm_framebuffer *old_fb);</span><br></pre></td></tr></table></figure>
<p>设置新的模式，位置和帧缓冲区。 取决于设备要求，该模式可以由驱动程序在内部存储，并在<code>commit</code>操作中应用，或立即编程到硬件。<br>成功时，<code>mode_set</code>操作将返回0，如果发生错误，则返回负错误代码。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> (*commit)(<span class="keyword">struct</span> drm_crtc *crtc);</span><br></pre></td></tr></table></figure>
<p>提交模式。 设置新模式后将调用此操作。 返回时，设备必须使用新模式并可以完全操作。</p>
<h3 id="Encoder-Helper-Operations"><a href="#Encoder-Helper-Operations" class="headerlink" title="Encoder Helper Operations"></a>Encoder Helper Operations</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> (*mode_fixup)(<span class="keyword">struct</span> drm_encoder *encoder,</span><br><span class="line">                       <span class="type">const</span> <span class="keyword">struct</span> drm_display_mode *mode,</span><br><span class="line">                       <span class="keyword">struct</span> drm_display_mode *adjusted_mode);</span><br></pre></td></tr></table></figure>
<p>让编码器调整请求的模式或完全拒绝它。 如果模式被接受（可能在调整之后），则此操作返回true；如果模式被拒绝，则返回false。 有关允许的调整的说明，请参见mode_fixup CRTC帮助器操作。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> (*prepare)(<span class="keyword">struct</span> drm_encoder *encoder);</span><br></pre></td></tr></table></figure>
<p>准备编码器以进行模式设置。 验证请求的模式后，将调用此操作。 驱动程序使用它来执行设置新模式之前所需的设备特定操作。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> (*mode_set)(<span class="keyword">struct</span> drm_encoder *encoder,</span><br><span class="line">                 <span class="keyword">struct</span> drm_display_mode *mode,</span><br><span class="line">                 <span class="keyword">struct</span> drm_display_mode *adjusted_mode);</span><br></pre></td></tr></table></figure>
<p>设置新模式。 取决于设备要求，该模式可以由驱动程序在内部存储，并在<code>commit</code>操作中应用，或立即编程到硬件。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> (*commit)(<span class="keyword">struct</span> drm_encoder *encoder);</span><br></pre></td></tr></table></figure>
<p>提交模式。 设置新模式后将调用此操作。 返回时，设备必须使用新模式并可以完全操作。</p>
<h3 id="Connector-Helper-Operations"><a href="#Connector-Helper-Operations" class="headerlink" title="Connector Helper Operations"></a>Connector Helper Operations</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">drm_encoder</span> *(*<span class="title">best_encoder</span>)(<span class="keyword">struct</span> <span class="title">drm_connector</span> *<span class="title">connector</span>);</span></span><br></pre></td></tr></table></figure>
<p>将指针返回到连接器的最佳编码器。 将连接器映射到编码器1：1的设备只需将指针返回到关联的编码器即可。 此操作是强制性的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">drm_encoder</span> *(*<span class="title">best_encoder</span>)(<span class="keyword">struct</span> <span class="title">drm_connector</span> *<span class="title">connector</span>);</span></span><br></pre></td></tr></table></figure>
<p>通过使用<code>drm_add_edid_modes</code>解析EDID数据或直接为每种受支持的模式调用<code>drm_mode_probed_add</code>来填充连接器的<code>probed_modes</code>列表，并返回其检测到的模式数。 此操作是强制性的。</p>
<p>手动添加模式时，驱动程序通过调用<code>drm_mode_create</code>来创建每种模式，并且必须填写以下字段。</p>
<ul>
<li><code>__u32 type;</code><ul>
<li><code>DRM_MODE_TYPE_PREFERRED</code> —— 连接器的首选模式（一般设置该值）</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> (*mode_valid)(<span class="keyword">struct</span> drm_connector *connector,</span><br><span class="line">		  <span class="keyword">struct</span> drm_display_mode *mode);</span><br></pre></td></tr></table></figure>
<p>验证模式对于连接器是否有效。 对于支持的模式，返回<code>MODE_OK</code>；对于不支持的模式，返回枚举<code>drm_mode_status</code>值（MODE_ *）之一。 此操作是强制性的。</p>
<p>由于当前不使用模式拒绝原因来立即删除不受支持的模式，因此无论该模式无效的确切原因如何，实现都可以返回MODE_BAD。</p>
<blockquote>
<p><strong>注意:</strong></p>
<p>请注意，仅针对设备检测到的模式调用<code>mode_valid helper</code>操作，而不针对用户通过CRTC <code>set_config</code>操作设置的模式。</p>
</blockquote>
<h3 id="Modeset-Helper-Functions-Reference"><a href="#Modeset-Helper-Functions-Reference" class="headerlink" title="Modeset Helper Functions Reference"></a><span class="exturl" data-url="aHR0cDovL3d3dy5sYW5kbGV5Lm5ldC9rZG9jcy9odG1sZG9jcy9kcm0uaHRtbCNpZHA1NzMyMjQw">Modeset Helper Functions Reference<i class="fa fa-external-link-alt"></i></span></h3><h3 id="fbdev-Helper-Functions-Reference"><a href="#fbdev-Helper-Functions-Reference" class="headerlink" title="fbdev Helper Functions Reference"></a><span class="exturl" data-url="aHR0cDovL3d3dy5sYW5kbGV5Lm5ldC9rZG9jcy9odG1sZG9jcy9kcm0uaHRtbCNpZHA1ODc2ODk2">fbdev Helper Functions Reference<i class="fa fa-external-link-alt"></i></span></h3><h3 id="Display-Port-Helper-Functions-Reference"><a href="#Display-Port-Helper-Functions-Reference" class="headerlink" title="Display Port Helper Functions Reference"></a><span class="exturl" data-url="aHR0cDovL3d3dy5sYW5kbGV5Lm5ldC9rZG9jcy9odG1sZG9jcy9kcm0uaHRtbCNpZHA2MTE5NjMy">Display Port Helper Functions Reference<i class="fa fa-external-link-alt"></i></span></h3><h3 id="EDID-Helper-Functions-Reference"><a href="#EDID-Helper-Functions-Reference" class="headerlink" title="EDID Helper Functions Reference"></a><span class="exturl" data-url="aHR0cDovL3d3dy5sYW5kbGV5Lm5ldC9rZG9jcy9odG1sZG9jcy9kcm0uaHRtbCNpZHA2MTQ5Mzky">EDID Helper Functions Reference<i class="fa fa-external-link-alt"></i></span></h3><h3 id="Rectangle-Utilities-Reference"><a href="#Rectangle-Utilities-Reference" class="headerlink" title="Rectangle Utilities Reference"></a><span class="exturl" data-url="aHR0cDovL3d3dy5sYW5kbGV5Lm5ldC9rZG9jcy9odG1sZG9jcy9kcm0uaHRtbCNpZHA2MzkxNzc2">Rectangle Utilities Reference<i class="fa fa-external-link-alt"></i></span></h3><h3 id="Flip-work-Helper-Reference"><a href="#Flip-work-Helper-Reference" class="headerlink" title="Flip-work Helper Reference"></a><span class="exturl" data-url="aHR0cDovL3d3dy5sYW5kbGV5Lm5ldC9rZG9jcy9odG1sZG9jcy9kcm0uaHRtbCNpZHA2NzA2NjA4">Flip-work Helper Reference<i class="fa fa-external-link-alt"></i></span></h3><h3 id="VMA-Offset-Manager"><a href="#VMA-Offset-Manager" class="headerlink" title="VMA Offset Manager"></a><span class="exturl" data-url="aHR0cDovL3d3dy5sYW5kbGV5Lm5ldC9rZG9jcy9odG1sZG9jcy9kcm0uaHRtbCNpZHA2Nzk4NTQ0">VMA Offset Manager<i class="fa fa-external-link-alt"></i></span></h3><h2 id="KMS-Properties"><a href="#KMS-Properties" class="headerlink" title="KMS Properties"></a><span class="exturl" data-url="aHR0cDovL3d3dy5sYW5kbGV5Lm5ldC9rZG9jcy9odG1sZG9jcy9kcm0uaHRtbCNkcm0ta21zLXByb3BlcnRpZXM=">KMS Properties<i class="fa fa-external-link-alt"></i></span></h2><h2 id="Vertical-Blanking"><a href="#Vertical-Blanking" class="headerlink" title="Vertical Blanking"></a><span class="exturl" data-url="aHR0cDovL3d3dy5sYW5kbGV5Lm5ldC9rZG9jcy9odG1sZG9jcy9kcm0uaHRtbCNkcm0tdmVydGljYWwtYmxhbms=">Vertical Blanking<i class="fa fa-external-link-alt"></i></span></h2><h2 id="Open-x2F-Close-File-Operations-and-IOCTLs"><a href="#Open-x2F-Close-File-Operations-and-IOCTLs" class="headerlink" title="Open&#x2F;Close, File Operations and IOCTLs"></a><span class="exturl" data-url="aHR0cDovL3d3dy5sYW5kbGV5Lm5ldC9rZG9jcy9odG1sZG9jcy9kcm0uaHRtbCNpZHA3MjE3NDA4">Open&#x2F;Close, File Operations and IOCTLs<i class="fa fa-external-link-alt"></i></span></h2><h3 id="Open-and-Close"><a href="#Open-and-Close" class="headerlink" title="Open and Close"></a><span class="exturl" data-url="aHR0cDovL3d3dy5sYW5kbGV5Lm5ldC9rZG9jcy9odG1sZG9jcy9kcm0uaHRtbCNpZHA3MjE4MDk2">Open and Close<i class="fa fa-external-link-alt"></i></span></h3><h3 id="File-Operations"><a href="#File-Operations" class="headerlink" title="File Operations"></a><span class="exturl" data-url="aHR0cDovL3d3dy5sYW5kbGV5Lm5ldC9rZG9jcy9odG1sZG9jcy9kcm0uaHRtbCNpZHA3MjMyMzY4">File Operations<i class="fa fa-external-link-alt"></i></span></h3><h3 id="IOCTLs"><a href="#IOCTLs" class="headerlink" title="IOCTLs"></a><span class="exturl" data-url="aHR0cDovL3d3dy5sYW5kbGV5Lm5ldC9rZG9jcy9odG1sZG9jcy9kcm0uaHRtbCNpZHA3MjQ0ODMy">IOCTLs<i class="fa fa-external-link-alt"></i></span></h3><h1 id="第3章-用户态接口"><a href="#第3章-用户态接口" class="headerlink" title="第3章 用户态接口"></a>第3章 用户态接口</h1><h2 id="VBlank事件处理"><a href="#VBlank事件处理" class="headerlink" title="VBlank事件处理"></a>VBlank事件处理</h2><p>DRM核心公开了两个垂直的空白相关的ioctl：</p>
<ul>
<li><code>DRM_IOCTL_WAIT_VBLANK</code>: 它以struct drm_wait_vblank结构作为其参数，并在发生指定的vblank事件时用于阻止或请求信号。</li>
<li><code>DRM_IOCTL_MODESET_CTL</code>: 在模式设置之前和之后，应由应用程序级别的驱动程序调用此方法，因为在许多设备上，垂直空白计数器会在那时重置。 在内部，当使用_DRM_PRE_MODESET命令调用ioctl时，DRM会对最后的vblank计数进行快照，以使计数器不会向后移动（使用_DRM_POST_MODESET时将进行处理）。</li>
</ul>
]]></content>
      <categories>
        <category>设备驱动</category>
      </categories>
      <tags>
        <tag>gpu</tag>
        <tag>drm</tag>
      </tags>
  </entry>
  <entry>
    <title>wpa_supplicant源码分析--conf配置文件</title>
    <url>/post/50085.html</url>
    <content><![CDATA[<p>解析wpa_supplicant的配置文件，一般叫做 <code>wpa_supplicant.conf</code></p>
<p>在wpa_supplicant的源码中都有配置文件的示例<span class="exturl" data-url="aHR0cDovL3cxLmZpL2NnaXQvaG9zdGFwL3BsYWluL3dwYV9zdXBwbGljYW50L3dwYV9zdXBwbGljYW50LmNvbmY=">wpa_supplicant.conf<i class="fa fa-external-link-alt"></i></span></p>
<span id="more"></span>

<h2 id="wpa-supplicant-conf"><a href="#wpa-supplicant-conf" class="headerlink" title="wpa_supplicant.conf"></a>wpa_supplicant.conf</h2><p>当前项目中使用到的一个配置文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ctrl_interface=/var/run/sockets</span><br><span class="line">driver_param=use_p2p_group_interface=1p2p_device=1</span><br><span class="line">update_config=1</span><br><span class="line">device_name=V_9ca2</span><br><span class="line">device_type=10-0050F204-5</span><br><span class="line">config_methods=virtual_push_button physical_display keypad</span><br><span class="line">p2p_go_intent=15</span><br><span class="line">p2p_ssid_postfix=-V_9ca2</span><br><span class="line">persistent_reconnect=1</span><br><span class="line"></span><br><span class="line">network=&#123;</span><br><span class="line">  ssid=&quot;D-H-V_9ca2&quot;</span><br><span class="line">  bssid=ae:83:f3:b4:9c:a2</span><br><span class="line">  psk=&quot;00000000&quot;</span><br><span class="line">  proto=RSN</span><br><span class="line">  key_mgmt=WPA-PSK</span><br><span class="line">  pairwise=CCMP</span><br><span class="line">  auth_alg=OPEN</span><br><span class="line">  mode=3</span><br><span class="line">  disabled=2</span><br><span class="line">  p2p_client_list=1a:f0:e4:87:fb:74 ac:83:f3:b3:72:24 04:e6:76:c3:37:84</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>该配置文件用于p2p</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wpa_supplicant -iwlan0 -s -Dnl80211 -O/var/run/sockets -c/etc/wifi/p2p_supplicant.conf</span><br></pre></td></tr></table></figure>
<ul>
<li><code>-D</code>: 指定使用的wifi驱动, nl80211 &#x3D; Linux nl80211&#x2F;cfg80211</li>
<li><code>-i</code>: 指定端口</li>
<li><code>-C</code>: 指定配置文件</li>
<li><code>-O</code>: 覆盖新接口的ctrl_interface参数</li>
</ul>
<h2 id="配置文件解析"><a href="#配置文件解析" class="headerlink" title="配置文件解析"></a>配置文件解析</h2><p>以下的数据结构都是从<code>wpa_supplicant_8</code>中的源码获取.</p>
<blockquote>
<p><code>8</code>支持建立热点(hostapd)</p>
</blockquote>
<h3 id="可配置参数"><a href="#可配置参数" class="headerlink" title="可配置参数"></a>可配置参数</h3><p>wpa_supplicant的所有参数都定义在struct wpa_config中</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct wpa_config - wpa_supplicant configuration data</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This data structure is presents the per-interface (radio) configuration</span></span><br><span class="line"><span class="comment"> * data. In many cases, there is only one struct wpa_config instance, but if</span></span><br><span class="line"><span class="comment"> * more than one network interface is being controlled, one instance is used</span></span><br><span class="line"><span class="comment"> * for each.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">wpa_config</span> &#123;</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * ssid - Head of the global network list</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * This is the head for the list of all the configured networks.</span></span><br><span class="line"><span class="comment">	 * config文件中，存储所有network节点的链表</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">wpa_ssid</span> *<span class="title">ssid</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * pssid - Per-priority network lists (in priority order)</span></span><br><span class="line"><span class="comment">	 * 按照priority排列的network节点</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">wpa_ssid</span> **<span class="title">pssid</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * num_prio - Number of different priorities used in the pssid lists</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * This indicates how many per-priority network lists are included in</span></span><br><span class="line"><span class="comment">	 * pssid.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">int</span> num_prio;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * cred - Head of the credential list</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * This is the head for the list of all the configured credentials.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">wpa_cred</span> *<span class="title">cred</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * eapol_version - IEEE 802.1X/EAPOL version number</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * wpa_supplicant is implemented based on IEEE Std 802.1X-2004 which</span></span><br><span class="line"><span class="comment">	 * defines EAPOL version 2. However, there are many APs that do not</span></span><br><span class="line"><span class="comment">	 * handle the new version number correctly (they seem to drop the</span></span><br><span class="line"><span class="comment">	 * frames completely). In order to make wpa_supplicant interoperate</span></span><br><span class="line"><span class="comment">	 * with these APs, the version number is set to 1 by default. This</span></span><br><span class="line"><span class="comment">	 * configuration value can be used to set it to the new version (2).</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">int</span> eapol_version;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * ap_scan - AP scanning/selection</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * By default, wpa_supplicant requests driver to perform AP</span></span><br><span class="line"><span class="comment">	 * scanning and then uses the scan results to select a</span></span><br><span class="line"><span class="comment">	 * suitable AP. Another alternative is to allow the driver to</span></span><br><span class="line"><span class="comment">	 * take care of AP scanning and selection and use</span></span><br><span class="line"><span class="comment">	 * wpa_supplicant just to process EAPOL frames based on IEEE</span></span><br><span class="line"><span class="comment">	 * 802.11 association information from the driver.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * 1: wpa_supplicant initiates scanning and AP selection (default).</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * 0: Driver takes care of scanning, AP selection, and IEEE 802.11</span></span><br><span class="line"><span class="comment">	 * association parameters (e.g., WPA IE generation); this mode can</span></span><br><span class="line"><span class="comment">	 * also be used with non-WPA drivers when using IEEE 802.1X mode;</span></span><br><span class="line"><span class="comment">	 * do not try to associate with APs (i.e., external program needs</span></span><br><span class="line"><span class="comment">	 * to control association). This mode must also be used when using</span></span><br><span class="line"><span class="comment">	 * wired Ethernet drivers.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * 2: like 0, but associate with APs using security policy and SSID</span></span><br><span class="line"><span class="comment">	 * (but not BSSID); this can be used, e.g., with ndiswrapper and NDIS</span></span><br><span class="line"><span class="comment">	 * drivers to enable operation with hidden SSIDs and optimized roaming;</span></span><br><span class="line"><span class="comment">	 * in this mode, the network blocks in the configuration are tried</span></span><br><span class="line"><span class="comment">	 * one by one until the driver reports successful association; each</span></span><br><span class="line"><span class="comment">	 * network block should have explicit security policy (i.e., only one</span></span><br><span class="line"><span class="comment">	 * option in the lists) for key_mgmt, pairwise, group, proto variables.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">int</span> ap_scan;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * disable_scan_offload - Disable automatic offloading of scan requests</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * By default, %wpa_supplicant tries to offload scanning if the driver</span></span><br><span class="line"><span class="comment">	 * indicates support for this (sched_scan). This configuration</span></span><br><span class="line"><span class="comment">	 * parameter can be used to disable this offloading mechanism.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">int</span> disable_scan_offload;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * ctrl_interface - Parameters for the control interface</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * If this is specified, %wpa_supplicant will open a control interface</span></span><br><span class="line"><span class="comment">	 * that is available for external programs to manage %wpa_supplicant.</span></span><br><span class="line"><span class="comment">	 * The meaning of this string depends on which control interface</span></span><br><span class="line"><span class="comment">	 * mechanism is used. For all cases, the existence of this parameter</span></span><br><span class="line"><span class="comment">	 * in configuration is used to determine whether the control interface</span></span><br><span class="line"><span class="comment">	 * is enabled.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * For UNIX domain sockets (default on Linux and BSD): This is a</span></span><br><span class="line"><span class="comment">	 * directory that will be created for UNIX domain sockets for listening</span></span><br><span class="line"><span class="comment">	 * to requests from external programs (CLI/GUI, etc.) for status</span></span><br><span class="line"><span class="comment">	 * information and configuration. The socket file will be named based</span></span><br><span class="line"><span class="comment">	 * on the interface name, so multiple %wpa_supplicant processes can be</span></span><br><span class="line"><span class="comment">	 * run at the same time if more than one interface is used.</span></span><br><span class="line"><span class="comment">	 * /var/run/wpa_supplicant is the recommended directory for sockets and</span></span><br><span class="line"><span class="comment">	 * by default, wpa_cli will use it when trying to connect with</span></span><br><span class="line"><span class="comment">	 * %wpa_supplicant.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Access control for the control interface can be configured</span></span><br><span class="line"><span class="comment">	 * by setting the directory to allow only members of a group</span></span><br><span class="line"><span class="comment">	 * to use sockets. This way, it is possible to run</span></span><br><span class="line"><span class="comment">	 * %wpa_supplicant as root (since it needs to change network</span></span><br><span class="line"><span class="comment">	 * configuration and open raw sockets) and still allow GUI/CLI</span></span><br><span class="line"><span class="comment">	 * components to be run as non-root users. However, since the</span></span><br><span class="line"><span class="comment">	 * control interface can be used to change the network</span></span><br><span class="line"><span class="comment">	 * configuration, this access needs to be protected in many</span></span><br><span class="line"><span class="comment">	 * cases. By default, %wpa_supplicant is configured to use gid</span></span><br><span class="line"><span class="comment">	 * 0 (root). If you want to allow non-root users to use the</span></span><br><span class="line"><span class="comment">	 * control interface, add a new group and change this value to</span></span><br><span class="line"><span class="comment">	 * match with that group. Add users that should have control</span></span><br><span class="line"><span class="comment">	 * interface access to this group.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * When configuring both the directory and group, use following format:</span></span><br><span class="line"><span class="comment">	 * DIR=/var/run/wpa_supplicant GROUP=wheel</span></span><br><span class="line"><span class="comment">	 * DIR=/var/run/wpa_supplicant GROUP=0</span></span><br><span class="line"><span class="comment">	 * (group can be either group name or gid)</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * For UDP connections (default on Windows): The value will be ignored.</span></span><br><span class="line"><span class="comment">	 * This variable is just used to select that the control interface is</span></span><br><span class="line"><span class="comment">	 * to be created. The value can be set to, e.g., udp</span></span><br><span class="line"><span class="comment">	 * (ctrl_interface=udp).</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * For Windows Named Pipe: This value can be used to set the security</span></span><br><span class="line"><span class="comment">	 * descriptor for controlling access to the control interface. Security</span></span><br><span class="line"><span class="comment">	 * descriptor can be set using Security Descriptor String Format (see</span></span><br><span class="line"><span class="comment">	 * http://msdn.microsoft.com/library/default.asp?url=/library/en-us/secauthz/security/security_descriptor_string_format.asp).</span></span><br><span class="line"><span class="comment">	 * The descriptor string needs to be prefixed with SDDL=. For example,</span></span><br><span class="line"><span class="comment">	 * ctrl_interface=SDDL=D: would set an empty DACL (which will reject</span></span><br><span class="line"><span class="comment">	 * all connections).</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">char</span> *ctrl_interface;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * ctrl_interface_group - Control interface group (DEPRECATED)</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * This variable is only used for backwards compatibility. Group for</span></span><br><span class="line"><span class="comment">	 * UNIX domain sockets should now be specified using GROUP=group in</span></span><br><span class="line"><span class="comment">	 * ctrl_interface variable.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">char</span> *ctrl_interface_group;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * fast_reauth - EAP fast re-authentication (session resumption)</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * By default, fast re-authentication is enabled for all EAP methods</span></span><br><span class="line"><span class="comment">	 * that support it. This variable can be used to disable fast</span></span><br><span class="line"><span class="comment">	 * re-authentication (by setting fast_reauth=0). Normally, there is no</span></span><br><span class="line"><span class="comment">	 * need to disable fast re-authentication.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">int</span> fast_reauth;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * opensc_engine_path - Path to the OpenSSL engine for opensc</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * This is an OpenSSL specific configuration option for loading OpenSC</span></span><br><span class="line"><span class="comment">	 * engine (engine_opensc.so); if %NULL, this engine is not loaded.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">char</span> *opensc_engine_path;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * pkcs11_engine_path - Path to the OpenSSL engine for PKCS#11</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * This is an OpenSSL specific configuration option for loading PKCS#11</span></span><br><span class="line"><span class="comment">	 * engine (engine_pkcs11.so); if %NULL, this engine is not loaded.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">char</span> *pkcs11_engine_path;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * pkcs11_module_path - Path to the OpenSSL OpenSC/PKCS#11 module</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * This is an OpenSSL specific configuration option for configuring</span></span><br><span class="line"><span class="comment">	 * path to OpenSC/PKCS#11 engine (opensc-pkcs11.so); if %NULL, this</span></span><br><span class="line"><span class="comment">	 * module is not loaded.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">char</span> *pkcs11_module_path;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * pcsc_reader - PC/SC reader name prefix</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * If not %NULL, PC/SC reader with a name that matches this prefix is</span></span><br><span class="line"><span class="comment">	 * initialized for SIM/USIM access. Empty string can be used to match</span></span><br><span class="line"><span class="comment">	 * the first available reader.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">char</span> *pcsc_reader;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * pcsc_pin - PIN for USIM, GSM SIM, and smartcards</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * This field is used to configure PIN for SIM/USIM for EAP-SIM and</span></span><br><span class="line"><span class="comment">	 * EAP-AKA. If left out, this will be asked through control interface.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">char</span> *pcsc_pin;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * driver_param - Driver interface parameters</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * This text string is passed to the selected driver interface with the</span></span><br><span class="line"><span class="comment">	 * optional struct wpa_driver_ops::set_param() handler. This can be</span></span><br><span class="line"><span class="comment">	 * used to configure driver specific options without having to add new</span></span><br><span class="line"><span class="comment">	 * driver interface functionality.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">char</span> *driver_param;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * dot11RSNAConfigPMKLifetime - Maximum lifetime of a PMK</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * dot11 MIB variable for the maximum lifetime of a PMK in the PMK</span></span><br><span class="line"><span class="comment">	 * cache (unit: seconds).</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> dot11RSNAConfigPMKLifetime;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * dot11RSNAConfigPMKReauthThreshold - PMK re-authentication threshold</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * dot11 MIB variable for the percentage of the PMK lifetime</span></span><br><span class="line"><span class="comment">	 * that should expire before an IEEE 802.1X reauthentication occurs.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> dot11RSNAConfigPMKReauthThreshold;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * dot11RSNAConfigSATimeout - Security association timeout</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * dot11 MIB variable for the maximum time a security association</span></span><br><span class="line"><span class="comment">	 * shall take to set up (unit: seconds).</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> dot11RSNAConfigSATimeout;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * update_config - Is wpa_supplicant allowed to update configuration</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * This variable control whether wpa_supplicant is allow to re-write</span></span><br><span class="line"><span class="comment">	 * its configuration with wpa_config_write(). If this is zero,</span></span><br><span class="line"><span class="comment">	 * configuration data is only changed in memory and the external data</span></span><br><span class="line"><span class="comment">	 * is not overriden. If this is non-zero, wpa_supplicant will update</span></span><br><span class="line"><span class="comment">	 * the configuration data (e.g., a file) whenever configuration is</span></span><br><span class="line"><span class="comment">	 * changed. This update may replace the old configuration which can</span></span><br><span class="line"><span class="comment">	 * remove comments from it in case of a text file configuration.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">int</span> update_config;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * blobs - Configuration blobs</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">wpa_config_blob</span> *<span class="title">blobs</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * uuid - Universally Unique IDentifier (UUID; see RFC 4122) for WPS</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	u8 uuid[<span class="number">16</span>];</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * device_name - Device Name (WPS)</span></span><br><span class="line"><span class="comment">	 * User-friendly description of device; up to 32 octets encoded in</span></span><br><span class="line"><span class="comment">	 * UTF-8</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">char</span> *device_name;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * manufacturer - Manufacturer (WPS)</span></span><br><span class="line"><span class="comment">	 * The manufacturer of the device (up to 64 ASCII characters)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">char</span> *manufacturer;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * model_name - Model Name (WPS)</span></span><br><span class="line"><span class="comment">	 * Model of the device (up to 32 ASCII characters)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">char</span> *model_name;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * model_number - Model Number (WPS)</span></span><br><span class="line"><span class="comment">	 * Additional device description (up to 32 ASCII characters)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">char</span> *model_number;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * serial_number - Serial Number (WPS)</span></span><br><span class="line"><span class="comment">	 * Serial number of the device (up to 32 characters)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">char</span> *serial_number;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * device_type - Primary Device Type (WPS)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	u8 device_type[WPS_DEV_TYPE_LEN];</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * config_methods - Config Methods</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * This is a space-separated list of supported WPS configuration</span></span><br><span class="line"><span class="comment">	 * methods. For example, &quot;label virtual_display virtual_push_button</span></span><br><span class="line"><span class="comment">	 * keypad&quot;.</span></span><br><span class="line"><span class="comment">	 * Available methods: usba ethernet label display ext_nfc_token</span></span><br><span class="line"><span class="comment">	 * int_nfc_token nfc_interface push_button keypad</span></span><br><span class="line"><span class="comment">	 * virtual_display physical_display</span></span><br><span class="line"><span class="comment">	 * virtual_push_button physical_push_button.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">char</span> *config_methods;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * os_version - OS Version (WPS)</span></span><br><span class="line"><span class="comment">	 * 4-octet operating system version number</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	u8 os_version[<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * country - Country code</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * This is the ISO/IEC alpha2 country code for which we are operating</span></span><br><span class="line"><span class="comment">	 * in</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">char</span> country[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * wps_cred_processing - Credential processing</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 *   0 = process received credentials internally</span></span><br><span class="line"><span class="comment">	 *   1 = do not process received credentials; just pass them over</span></span><br><span class="line"><span class="comment">	 *	ctrl_iface to external program(s)</span></span><br><span class="line"><span class="comment">	 *   2 = process received credentials internally and pass them over</span></span><br><span class="line"><span class="comment">	 *	ctrl_iface to external program(s)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">int</span> wps_cred_processing;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_SEC_DEVICE_TYPES 5</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * sec_device_types - Secondary Device Types (P2P)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	u8 sec_device_type[MAX_SEC_DEVICE_TYPES][WPS_DEV_TYPE_LEN];</span><br><span class="line">	<span class="type">int</span> num_sec_device_types;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> p2p_listen_reg_class;</span><br><span class="line">	<span class="type">int</span> p2p_listen_channel;</span><br><span class="line">	<span class="type">int</span> p2p_oper_reg_class;</span><br><span class="line">	<span class="type">int</span> p2p_oper_channel;</span><br><span class="line">	<span class="type">int</span> p2p_go_intent;</span><br><span class="line">	<span class="type">char</span> *p2p_ssid_postfix;</span><br><span class="line">	<span class="type">int</span> persistent_reconnect;</span><br><span class="line">	<span class="type">int</span> p2p_intra_bss;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> num_p2p_pref_chan;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">p2p_channel</span> *<span class="title">p2p_pref_chan</span>;</span></span><br><span class="line">	<span class="type">int</span> p2p_ignore_shared_freq;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">wpabuf</span> *<span class="title">wps_vendor_ext_m1</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_WPS_VENDOR_EXT 10</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * wps_vendor_ext - Vendor extension attributes in WPS</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">wpabuf</span> *<span class="title">wps_vendor_ext</span>[<span class="title">MAX_WPS_VENDOR_EXT</span>];</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * p2p_group_idle - Maximum idle time in seconds for P2P group</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * This value controls how long a P2P group is maintained after there</span></span><br><span class="line"><span class="comment">	 * is no other members in the group. As a GO, this means no associated</span></span><br><span class="line"><span class="comment">	 * stations in the group. As a P2P client, this means no GO seen in</span></span><br><span class="line"><span class="comment">	 * scan results. The maximum idle time is specified in seconds with 0</span></span><br><span class="line"><span class="comment">	 * indicating no time limit, i.e., the P2P group remains in active</span></span><br><span class="line"><span class="comment">	 * state indefinitely until explicitly removed. As a P2P client, the</span></span><br><span class="line"><span class="comment">	 * maximum idle time of P2P_MAX_CLIENT_IDLE seconds is enforced, i.e.,</span></span><br><span class="line"><span class="comment">	 * this parameter is mainly meant for GO use and for P2P client, it can</span></span><br><span class="line"><span class="comment">	 * only be used to reduce the default timeout to smaller value. A</span></span><br><span class="line"><span class="comment">	 * special value -1 can be used to configure immediate removal of the</span></span><br><span class="line"><span class="comment">	 * group for P2P client role on any disconnection after the data</span></span><br><span class="line"><span class="comment">	 * connection has been established.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">int</span> p2p_group_idle;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * bss_max_count - Maximum number of BSS entries to keep in memory</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> bss_max_count;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * bss_expiration_age - BSS entry age after which it can be expired</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * This value controls the time in seconds after which a BSS entry</span></span><br><span class="line"><span class="comment">	 * gets removed if it has not been updated or is not in use.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> bss_expiration_age;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * bss_expiration_scan_count - Expire BSS after number of scans</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * If the BSS entry has not been seen in this many scans, it will be</span></span><br><span class="line"><span class="comment">	 * removed. A value of 1 means that entry is removed after the first</span></span><br><span class="line"><span class="comment">	 * scan in which the BSSID is not seen. Larger values can be used</span></span><br><span class="line"><span class="comment">	 * to avoid BSS entries disappearing if they are not visible in</span></span><br><span class="line"><span class="comment">	 * every scan (e.g., low signal quality or interference).</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> bss_expiration_scan_count;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * filter_ssids - SSID-based scan result filtering</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 *   0 = do not filter scan results</span></span><br><span class="line"><span class="comment">	 *   1 = only include configured SSIDs in scan results/BSS table</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">int</span> filter_ssids;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * filter_rssi - RSSI-based scan result filtering</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * 0 = do not filter scan results</span></span><br><span class="line"><span class="comment">	 * -n = filter scan results below -n dBm</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">int</span> filter_rssi;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * max_num_sta - Maximum number of STAs in an AP/P2P GO</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> max_num_sta;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * freq_list - Array of allowed scan frequencies or %NULL for all</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * This is an optional zero-terminated array of frequencies in</span></span><br><span class="line"><span class="comment">	 * megahertz (MHz) to allow for narrowing scanning range.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">int</span> *freq_list;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * scan_cur_freq - Whether to scan only the current channel</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * If true, attempt to scan only the current channel if any other</span></span><br><span class="line"><span class="comment">	 * VIFs on this radio are already associated on a particular channel.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">int</span> scan_cur_freq;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * changed_parameters - Bitmap of changed parameters since last update</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> changed_parameters;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * disassoc_low_ack - Disassocicate stations with massive packet loss</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">int</span> disassoc_low_ack;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * interworking - Whether Interworking (IEEE 802.11u) is enabled</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">int</span> interworking;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * access_network_type - Access Network Type</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * When Interworking is enabled, scans will be limited to APs that</span></span><br><span class="line"><span class="comment">	 * advertise the specified Access Network Type (0..15; with 15</span></span><br><span class="line"><span class="comment">	 * indicating wildcard match).</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">int</span> access_network_type;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * hessid - Homogenous ESS identifier</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * If this is set (any octet is non-zero), scans will be used to</span></span><br><span class="line"><span class="comment">	 * request response only from BSSes belonging to the specified</span></span><br><span class="line"><span class="comment">	 * Homogeneous ESS. This is used only if interworking is enabled.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	u8 hessid[ETH_ALEN];</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * hs20 - Hotspot 2.0</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">int</span> hs20;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * pbc_in_m1 - AP mode WPS probing workaround for PBC with Windows 7</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Windows 7 uses incorrect way of figuring out AP&#x27;s WPS capabilities</span></span><br><span class="line"><span class="comment">	 * by acting as a Registrar and using M1 from the AP. The config</span></span><br><span class="line"><span class="comment">	 * methods attribute in that message is supposed to indicate only the</span></span><br><span class="line"><span class="comment">	 * configuration method supported by the AP in Enrollee role, i.e., to</span></span><br><span class="line"><span class="comment">	 * add an external Registrar. For that case, PBC shall not be used and</span></span><br><span class="line"><span class="comment">	 * as such, the PushButton config method is removed from M1 by default.</span></span><br><span class="line"><span class="comment">	 * If pbc_in_m1=1 is included in the configuration file, the PushButton</span></span><br><span class="line"><span class="comment">	 * config method is left in M1 (if included in config_methods</span></span><br><span class="line"><span class="comment">	 * parameter) to allow Windows 7 to use PBC instead of PIN (e.g., from</span></span><br><span class="line"><span class="comment">	 * a label in the AP).</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">int</span> pbc_in_m1;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * autoscan - Automatic scan parameters or %NULL if none</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * This is an optional set of parameters for automatic scanning</span></span><br><span class="line"><span class="comment">	 * within an interface in following format:</span></span><br><span class="line"><span class="comment">	 * &lt;autoscan module name&gt;:&lt;module parameters&gt;</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">char</span> *autoscan;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * wps_nfc_pw_from_config - NFC Device Password was read from config</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * This parameter can be determined whether the NFC Device Password was</span></span><br><span class="line"><span class="comment">	 * included in the configuration (1) or generated dynamically (0). Only</span></span><br><span class="line"><span class="comment">	 * the former case is re-written back to the configuration file.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">int</span> wps_nfc_pw_from_config;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * wps_nfc_dev_pw_id - NFC Device Password ID for password token</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">int</span> wps_nfc_dev_pw_id;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * wps_nfc_dh_pubkey - NFC DH Public Key for password token</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">wpabuf</span> *<span class="title">wps_nfc_dh_pubkey</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * wps_nfc_dh_privkey - NFC DH Private Key for password token</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">wpabuf</span> *<span class="title">wps_nfc_dh_privkey</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * wps_nfc_dev_pw - NFC Device Password for password token</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">wpabuf</span> *<span class="title">wps_nfc_dev_pw</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * ext_password_backend - External password backend or %NULL if none</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * format: &lt;backend name&gt;[:&lt;optional backend parameters&gt;]</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">char</span> *ext_password_backend;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * p2p_go_max_inactivity - Timeout in seconds to detect STA inactivity</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * This timeout value is used in P2P GO mode to clean up</span></span><br><span class="line"><span class="comment">	 * inactive stations.</span></span><br><span class="line"><span class="comment">	 * By default: 300 seconds.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">int</span> p2p_go_max_inactivity;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">hostapd_wmm_ac_params</span> <span class="title">wmm_ac_params</span>[4];</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * auto_interworking - Whether to use network selection automatically</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * 0 = do not automatically go through Interworking network selection</span></span><br><span class="line"><span class="comment">	 *     (i.e., require explicit interworking_select command for this)</span></span><br><span class="line"><span class="comment">	 * 1 = perform Interworking network selection if one or more</span></span><br><span class="line"><span class="comment">	 *     credentials have been configured and scan did not find a</span></span><br><span class="line"><span class="comment">	 *     matching network block</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">int</span> auto_interworking;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * p2p_go_ht40 - Default mode for HT40 enable when operating as GO.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * This will take effect for p2p_group_add, p2p_connect, and p2p_invite.</span></span><br><span class="line"><span class="comment">	 * Note that regulatory constraints and driver capabilities are</span></span><br><span class="line"><span class="comment">	 * consulted anyway, so setting it to 1 can&#x27;t do real harm.</span></span><br><span class="line"><span class="comment">	 * By default: 0 (disabled)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">int</span> p2p_go_ht40;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * p2p_disabled - Whether P2P operations are disabled for this interface</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">int</span> p2p_disabled;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * p2p_no_group_iface - Whether group interfaces can be used</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * By default, wpa_supplicant will create a separate interface for P2P</span></span><br><span class="line"><span class="comment">	 * group operations if the driver supports this. This functionality can</span></span><br><span class="line"><span class="comment">	 * be disabled by setting this parameter to 1. In that case, the same</span></span><br><span class="line"><span class="comment">	 * interface that was used for the P2P management operations is used</span></span><br><span class="line"><span class="comment">	 * also for the group operation.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">int</span> p2p_no_group_iface;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * okc - Whether to enable opportunistic key caching by default</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * By default, OKC is disabled unless enabled by the per-network</span></span><br><span class="line"><span class="comment">	 * proactive_key_caching=1 parameter. okc=1 can be used to change this</span></span><br><span class="line"><span class="comment">	 * default behavior.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">int</span> okc;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * pmf - Whether to enable/require PMF by default</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * By default, PMF is disabled unless enabled by the per-network</span></span><br><span class="line"><span class="comment">	 * ieee80211w=1 or ieee80211w=2 parameter. pmf=1/2 can be used to change</span></span><br><span class="line"><span class="comment">	 * this default behavior.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">mfp_options</span> <span class="title">pmf</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * sae_groups - Preference list of enabled groups for SAE</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * By default (if this parameter is not set), the mandatory group 19</span></span><br><span class="line"><span class="comment">	 * (ECC group defined over a 256-bit prime order field) is preferred,</span></span><br><span class="line"><span class="comment">	 * but other groups are also enabled. If this parameter is set, the</span></span><br><span class="line"><span class="comment">	 * groups will be tried in the indicated order.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">int</span> *sae_groups;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * dtim_period - Default DTIM period in Beacon intervals</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * This parameter can be used to set the default value for network</span></span><br><span class="line"><span class="comment">	 * blocks that do not specify dtim_period.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">int</span> dtim_period;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * beacon_int - Default Beacon interval in TU</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * This parameter can be used to set the default value for network</span></span><br><span class="line"><span class="comment">	 * blocks that do not specify beacon_int.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">int</span> beacon_int;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * ap_vendor_elements: Vendor specific elements for Beacon/ProbeResp</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * This parameter can be used to define additional vendor specific</span></span><br><span class="line"><span class="comment">	 * elements for Beacon and Probe Response frames in AP/P2P GO mode. The</span></span><br><span class="line"><span class="comment">	 * format for these element(s) is a hexdump of the raw information</span></span><br><span class="line"><span class="comment">	 * elements (id+len+payload for one or more elements).</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">wpabuf</span> *<span class="title">ap_vendor_elements</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * ignore_old_scan_res - Ignore scan results older than request</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * The driver may have a cache of scan results that makes it return</span></span><br><span class="line"><span class="comment">	 * information that is older than our scan trigger. This parameter can</span></span><br><span class="line"><span class="comment">	 * be used to configure such old information to be ignored instead of</span></span><br><span class="line"><span class="comment">	 * allowing it to update the internal BSS table.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">int</span> ignore_old_scan_res;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * sched_scan_interval -  schedule scan interval</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> sched_scan_interval;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * tdls_external_control - External control for TDLS setup requests</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Enable TDLS mode where external programs are given the control</span></span><br><span class="line"><span class="comment">	 * to specify the TDLS link to get established to the driver. The</span></span><br><span class="line"><span class="comment">	 * driver requests the TDLS setup to the supplicant only for the</span></span><br><span class="line"><span class="comment">	 * specified TDLS peers.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">int</span> tdls_external_control;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="network节点"><a href="#network节点" class="headerlink" title="network节点"></a>network节点</h3><p>wpa_supplicant.conf文件中每个network节点都是一个保存的网络, 存储了网络的名称（ssid），密码（psk），加密方式（WPA_PSK），优先级（priority）</p>
<p>WIFI网络有多种加密方式，每种加密方式（wpa_psk，wep，open，wapi，各种eap等）的节点书写方式都不同，具体可以参考源代码中<span class="exturl" data-url="aHR0cDovL3cxLmZpL2NnaXQvaG9zdGFwL3BsYWluL3dwYV9zdXBwbGljYW50L3dwYV9zdXBwbGljYW50LmNvbmY=">wpa_supplicant.conf<i class="fa fa-external-link-alt"></i></span>文件</p>
<p>network节点的结构体<code>struct wpa_ssid</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct wpa_ssid - Network configuration data</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This structure includes all the configuration variables for a network. This</span></span><br><span class="line"><span class="comment"> * data is included in the per-interface configuration data as an element of</span></span><br><span class="line"><span class="comment"> * the network list, struct wpa_config::ssid. Each network block in the</span></span><br><span class="line"><span class="comment"> * configuration is mapped to a struct wpa_ssid instance.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">wpa_ssid</span> &#123;</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * next - Next network in global list</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * This pointer can be used to iterate over all networks. The head of</span></span><br><span class="line"><span class="comment">	 * this list is stored in the ssid field of struct wpa_config.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">wpa_ssid</span> *<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * pnext - Next network in per-priority list</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * This pointer can be used to iterate over all networks in the same</span></span><br><span class="line"><span class="comment">	 * priority class. The heads of these list are stored in the pssid</span></span><br><span class="line"><span class="comment">	 * fields of struct wpa_config.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">wpa_ssid</span> *<span class="title">pnext</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * id - Unique id for the network</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * This identifier is used as a unique identifier for each network</span></span><br><span class="line"><span class="comment">	 * block when using the control interface. Each network is allocated an</span></span><br><span class="line"><span class="comment">	 * id when it is being created, either when reading the configuration</span></span><br><span class="line"><span class="comment">	 * file or when a new network is added through the control interface.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">int</span> id;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * priority - Priority group</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * By default, all networks will get same priority group (0). If some</span></span><br><span class="line"><span class="comment">	 * of the networks are more desirable, this field can be used to change</span></span><br><span class="line"><span class="comment">	 * the order in which wpa_supplicant goes through the networks when</span></span><br><span class="line"><span class="comment">	 * selecting a BSS. The priority groups will be iterated in decreasing</span></span><br><span class="line"><span class="comment">	 * priority (i.e., the larger the priority value, the sooner the</span></span><br><span class="line"><span class="comment">	 * network is matched against the scan results). Within each priority</span></span><br><span class="line"><span class="comment">	 * group, networks will be selected based on security policy, signal</span></span><br><span class="line"><span class="comment">	 * strength, etc.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Please note that AP scanning with scan_ssid=1 and ap_scan=2 mode are</span></span><br><span class="line"><span class="comment">	 * not using this priority to select the order for scanning. Instead,</span></span><br><span class="line"><span class="comment">	 * they try the networks in the order that used in the configuration</span></span><br><span class="line"><span class="comment">	 * file.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">int</span> priority;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * ssid - Service set identifier (network name)</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * This is the SSID for the network. For wireless interfaces, this is</span></span><br><span class="line"><span class="comment">	 * used to select which network will be used. If set to %NULL (or</span></span><br><span class="line"><span class="comment">	 * ssid_len=0), any SSID can be used. For wired interfaces, this must</span></span><br><span class="line"><span class="comment">	 * be set to %NULL. Note: SSID may contain any characters, even nul</span></span><br><span class="line"><span class="comment">	 * (ASCII 0) and as such, this should not be assumed to be a nul</span></span><br><span class="line"><span class="comment">	 * terminated string. ssid_len defines how many characters are valid</span></span><br><span class="line"><span class="comment">	 * and the ssid field is not guaranteed to be nul terminated.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	u8 *ssid;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * ssid_len - Length of the SSID</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">size_t</span> ssid_len;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * bssid - BSSID</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * If set, this network block is used only when associating with the AP</span></span><br><span class="line"><span class="comment">	 * using the configured BSSID</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * If this is a persistent P2P group (disabled == 2), this is the GO</span></span><br><span class="line"><span class="comment">	 * Device Address.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	u8 bssid[ETH_ALEN];</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * bssid_set - Whether BSSID is configured for this network</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">int</span> bssid_set;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * psk - WPA pre-shared key (256 bits)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	u8 psk[<span class="number">32</span>];</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * psk_set - Whether PSK field is configured</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">int</span> psk_set;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * passphrase - WPA ASCII passphrase</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * If this is set, psk will be generated using the SSID and passphrase</span></span><br><span class="line"><span class="comment">	 * configured for the network. ASCII passphrase must be between 8 and</span></span><br><span class="line"><span class="comment">	 * 63 characters (inclusive).</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">char</span> *passphrase;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * ext_psk - PSK/passphrase name in external storage</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * If this is set, PSK/passphrase will be fetched from external storage</span></span><br><span class="line"><span class="comment">	 * when requesting association with the network.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">char</span> *ext_psk;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * pairwise_cipher - Bitfield of allowed pairwise ciphers, WPA_CIPHER_*</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">int</span> pairwise_cipher;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * group_cipher - Bitfield of allowed group ciphers, WPA_CIPHER_*</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">int</span> group_cipher;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * key_mgmt - Bitfield of allowed key management protocols</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * WPA_KEY_MGMT_*</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">int</span> key_mgmt;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * bg_scan_period - Background scan period in seconds, 0 to disable, or</span></span><br><span class="line"><span class="comment">	 * -1 to indicate no change to default driver configuration</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">int</span> bg_scan_period;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * proto - Bitfield of allowed protocols, WPA_PROTO_*</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">int</span> proto;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * auth_alg -  Bitfield of allowed authentication algorithms</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * WPA_AUTH_ALG_*</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">int</span> auth_alg;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * scan_ssid - Scan this SSID with Probe Requests</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * scan_ssid can be used to scan for APs using hidden SSIDs.</span></span><br><span class="line"><span class="comment">	 * Note: Many drivers do not support this. ap_mode=2 can be used with</span></span><br><span class="line"><span class="comment">	 * such drivers to use hidden SSIDs.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">int</span> scan_ssid;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> IEEE8021X_EAPOL</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EAPOL_FLAG_REQUIRE_KEY_UNICAST BIT(0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EAPOL_FLAG_REQUIRE_KEY_BROADCAST BIT(1)</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * eapol_flags - Bit field of IEEE 802.1X/EAPOL options (EAPOL_FLAG_*)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">int</span> eapol_flags;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * eap - EAP peer configuration for this network</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">eap_peer_config</span> <span class="title">eap</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* IEEE8021X_EAPOL */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NUM_WEP_KEYS 4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_WEP_KEY_LEN 16</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * wep_key - WEP keys</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	u8 wep_key[NUM_WEP_KEYS][MAX_WEP_KEY_LEN];</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * wep_key_len - WEP key lengths</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">size_t</span> wep_key_len[NUM_WEP_KEYS];</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * wep_tx_keyidx - Default key index for TX frames using WEP</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">int</span> wep_tx_keyidx;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * proactive_key_caching - Enable proactive key caching</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * This field can be used to enable proactive key caching which is also</span></span><br><span class="line"><span class="comment">	 * known as opportunistic PMKSA caching for WPA2. This is disabled (0)</span></span><br><span class="line"><span class="comment">	 * by default unless default value is changed with the global okc=1</span></span><br><span class="line"><span class="comment">	 * parameter. Enable by setting this to 1.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Proactive key caching is used to make supplicant assume that the APs</span></span><br><span class="line"><span class="comment">	 * are using the same PMK and generate PMKSA cache entries without</span></span><br><span class="line"><span class="comment">	 * doing RSN pre-authentication. This requires support from the AP side</span></span><br><span class="line"><span class="comment">	 * and is normally used with wireless switches that co-locate the</span></span><br><span class="line"><span class="comment">	 * authenticator.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Internally, special value -1 is used to indicate that the parameter</span></span><br><span class="line"><span class="comment">	 * was not specified in the configuration (i.e., default behavior is</span></span><br><span class="line"><span class="comment">	 * followed).</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">int</span> proactive_key_caching;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * mixed_cell - Whether mixed cells are allowed</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * This option can be used to configure whether so called mixed cells,</span></span><br><span class="line"><span class="comment">	 * i.e., networks that use both plaintext and encryption in the same</span></span><br><span class="line"><span class="comment">	 * SSID, are allowed. This is disabled (0) by default. Enable by</span></span><br><span class="line"><span class="comment">	 * setting this to 1.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">int</span> mixed_cell;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> IEEE8021X_EAPOL</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * leap - Number of EAP methods using LEAP</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * This field should be set to 1 if LEAP is enabled. This is used to</span></span><br><span class="line"><span class="comment">	 * select IEEE 802.11 authentication algorithm.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">int</span> leap;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * non_leap - Number of EAP methods not using LEAP</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * This field should be set to &gt;0 if any EAP method other than LEAP is</span></span><br><span class="line"><span class="comment">	 * enabled. This is used to select IEEE 802.11 authentication</span></span><br><span class="line"><span class="comment">	 * algorithm.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">int</span> non_leap;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * eap_workaround - EAP workarounds enabled</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * wpa_supplicant supports number of &quot;EAP workarounds&quot; to work around</span></span><br><span class="line"><span class="comment">	 * interoperability issues with incorrectly behaving authentication</span></span><br><span class="line"><span class="comment">	 * servers. This is recommended to be enabled by default because some</span></span><br><span class="line"><span class="comment">	 * of the issues are present in large number of authentication servers.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Strict EAP conformance mode can be configured by disabling</span></span><br><span class="line"><span class="comment">	 * workarounds with eap_workaround = 0.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> eap_workaround;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* IEEE8021X_EAPOL */</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * mode - IEEE 802.11 operation mode (Infrastucture/IBSS)</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * 0 = infrastructure (Managed) mode, i.e., associate with an AP.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * 1 = IBSS (ad-hoc, peer-to-peer)</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * 2 = AP (access point)</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * 3 = P2P Group Owner (can be set in the configuration file)</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * 4 = P2P Group Formation (used internally; not in configuration</span></span><br><span class="line"><span class="comment">	 * files)</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Note: IBSS can only be used with key_mgmt NONE (plaintext and</span></span><br><span class="line"><span class="comment">	 * static WEP) and key_mgmt=WPA-NONE (fixed group key TKIP/CCMP). In</span></span><br><span class="line"><span class="comment">	 * addition, ap_scan has to be set to 2 for IBSS. WPA-None requires</span></span><br><span class="line"><span class="comment">	 * following network block options: proto=WPA, key_mgmt=WPA-NONE,</span></span><br><span class="line"><span class="comment">	 * pairwise=NONE, group=TKIP (or CCMP, but not both), and psk must also</span></span><br><span class="line"><span class="comment">	 * be set (either directly or using ASCII passphrase).</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">wpas_mode</span> &#123;</span></span><br><span class="line">		WPAS_MODE_INFRA = <span class="number">0</span>,</span><br><span class="line">		WPAS_MODE_IBSS = <span class="number">1</span>,</span><br><span class="line">		WPAS_MODE_AP = <span class="number">2</span>,</span><br><span class="line">		WPAS_MODE_P2P_GO = <span class="number">3</span>,</span><br><span class="line">		WPAS_MODE_P2P_GROUP_FORMATION = <span class="number">4</span>,</span><br><span class="line">	&#125; mode;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * disabled - Whether this network is currently disabled</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * 0 = this network can be used (default).</span></span><br><span class="line"><span class="comment">	 * 1 = this network block is disabled (can be enabled through</span></span><br><span class="line"><span class="comment">	 * ctrl_iface, e.g., with wpa_cli or wpa_gui).</span></span><br><span class="line"><span class="comment">	 * 2 = this network block includes parameters for a persistent P2P</span></span><br><span class="line"><span class="comment">	 * group (can be used with P2P ctrl_iface commands)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">int</span> disabled;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * disabled_for_connect - Whether this network was temporarily disabled</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * This flag is used to reenable all the temporarily disabled networks</span></span><br><span class="line"><span class="comment">	 * after either the success or failure of a WPS connection.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">int</span> disabled_for_connect;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * peerkey -  Whether PeerKey handshake for direct links is allowed</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * This is only used when both RSN/WPA2 and IEEE 802.11e (QoS) are</span></span><br><span class="line"><span class="comment">	 * enabled.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * 0 = disabled (default)</span></span><br><span class="line"><span class="comment">	 * 1 = enabled</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">int</span> peerkey;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * id_str - Network identifier string for external scripts</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * This value is passed to external ctrl_iface monitors in</span></span><br><span class="line"><span class="comment">	 * WPA_EVENT_CONNECTED event and wpa_cli sets this as WPA_ID_STR</span></span><br><span class="line"><span class="comment">	 * environment variable for action scripts.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">char</span> *id_str;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_IEEE80211W</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * ieee80211w - Whether management frame protection is enabled</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * This value is used to configure policy for management frame</span></span><br><span class="line"><span class="comment">	 * protection (IEEE 802.11w). 0 = disabled, 1 = optional, 2 = required.</span></span><br><span class="line"><span class="comment">	 * This is disabled by default unless the default value has been changed</span></span><br><span class="line"><span class="comment">	 * with the global pmf=1/2 parameter.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Internally, special value 3 is used to indicate that the parameter</span></span><br><span class="line"><span class="comment">	 * was not specified in the configuration (i.e., default behavior is</span></span><br><span class="line"><span class="comment">	 * followed).</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">mfp_options</span> <span class="title">ieee80211w</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* CONFIG_IEEE80211W */</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * frequency - Channel frequency in megahertz (MHz) for IBSS</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * This value is used to configure the initial channel for IBSS (adhoc)</span></span><br><span class="line"><span class="comment">	 * networks, e.g., 2412 = IEEE 802.11b/g channel 1. It is ignored in</span></span><br><span class="line"><span class="comment">	 * the infrastructure mode. In addition, this value is only used by the</span></span><br><span class="line"><span class="comment">	 * station that creates the IBSS. If an IBSS network with the</span></span><br><span class="line"><span class="comment">	 * configured SSID is already present, the frequency of the network</span></span><br><span class="line"><span class="comment">	 * will be used instead of this configured value.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">int</span> frequency;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> ht40;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * wpa_ptk_rekey - Maximum lifetime for PTK in seconds</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * This value can be used to enforce rekeying of PTK to mitigate some</span></span><br><span class="line"><span class="comment">	 * attacks against TKIP deficiencies.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">int</span> wpa_ptk_rekey;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * scan_freq - Array of frequencies to scan or %NULL for all</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * This is an optional zero-terminated array of frequencies in</span></span><br><span class="line"><span class="comment">	 * megahertz (MHz) to include in scan requests when searching for this</span></span><br><span class="line"><span class="comment">	 * network. This can be used to speed up scanning when the network is</span></span><br><span class="line"><span class="comment">	 * known to not use all possible channels.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">int</span> *scan_freq;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * bgscan - Background scan and roaming parameters or %NULL if none</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * This is an optional set of parameters for background scanning and</span></span><br><span class="line"><span class="comment">	 * roaming within a network (ESS) in following format:</span></span><br><span class="line"><span class="comment">	 * &lt;bgscan module name&gt;:&lt;module parameters&gt;</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">char</span> *bgscan;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * ignore_broadcast_ssid - Hide SSID in AP mode</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Send empty SSID in beacons and ignore probe request frames that do</span></span><br><span class="line"><span class="comment">	 * not specify full SSID, i.e., require stations to know SSID.</span></span><br><span class="line"><span class="comment">	 * default: disabled (0)</span></span><br><span class="line"><span class="comment">	 * 1 = send empty (length=0) SSID in beacon and ignore probe request</span></span><br><span class="line"><span class="comment">	 * for broadcast SSID</span></span><br><span class="line"><span class="comment">	 * 2 = clear SSID (ASCII 0), but keep the original length (this may be</span></span><br><span class="line"><span class="comment">	 * required with some clients that do not support empty SSID) and</span></span><br><span class="line"><span class="comment">	 * ignore probe requests for broadcast SSID</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">int</span> ignore_broadcast_ssid;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * freq_list - Array of allowed frequencies or %NULL for all</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * This is an optional zero-terminated array of frequencies in</span></span><br><span class="line"><span class="comment">	 * megahertz (MHz) to allow for selecting the BSS. If set, scan results</span></span><br><span class="line"><span class="comment">	 * that do not match any of the specified frequencies are not</span></span><br><span class="line"><span class="comment">	 * considered when selecting a BSS.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">int</span> *freq_list;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * p2p_client_list - List of P2P Clients in a persistent group (GO)</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * This is a list of P2P Clients (P2P Device Address) that have joined</span></span><br><span class="line"><span class="comment">	 * the persistent group. This is maintained on the GO for persistent</span></span><br><span class="line"><span class="comment">	 * group entries (disabled == 2).</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	u8 *p2p_client_list;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * num_p2p_clients - Number of entries in p2p_client_list</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">size_t</span> num_p2p_clients;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> P2P_MAX_STORED_CLIENTS</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> P2P_MAX_STORED_CLIENTS 100</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* P2P_MAX_STORED_CLIENTS */</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * psk_list - Per-client PSKs (struct psk_list_entry)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dl_list</span> <span class="title">psk_list</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * p2p_group - Network generated as a P2P group (used internally)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">int</span> p2p_group;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * p2p_persistent_group - Whether this is a persistent group</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">int</span> p2p_persistent_group;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * temporary - Whether this network is temporary and not to be saved</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">int</span> temporary;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * export_keys - Whether keys may be exported</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * This attribute will be set when keys are determined through</span></span><br><span class="line"><span class="comment">	 * WPS or similar so that they may be exported.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">int</span> export_keys;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> ANDROID_P2P</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * assoc_retry - Number of times association should be retried.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">int</span> assoc_retry;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_HT_OVERRIDES</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * disable_ht - Disable HT (IEEE 802.11n) for this network</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * By default, use it if it is available, but this can be configured</span></span><br><span class="line"><span class="comment">	 * to 1 to have it disabled.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">int</span> disable_ht;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * disable_ht40 - Disable HT40 for this network</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * By default, use it if it is available, but this can be configured</span></span><br><span class="line"><span class="comment">	 * to 1 to have it disabled.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">int</span> disable_ht40;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * disable_sgi - Disable SGI (Short Guard Interval) for this network</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * By default, use it if it is available, but this can be configured</span></span><br><span class="line"><span class="comment">	 * to 1 to have it disabled.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">int</span> disable_sgi;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * disable_max_amsdu - Disable MAX A-MSDU</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * A-MDSU will be 3839 bytes when disabled, or 7935</span></span><br><span class="line"><span class="comment">	 * when enabled (assuming it is otherwise supported)</span></span><br><span class="line"><span class="comment">	 * -1 (default) means do not apply any settings to the kernel.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">int</span> disable_max_amsdu;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * ampdu_factor - Maximum A-MPDU Length Exponent</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Value: 0-3, see 7.3.2.56.3 in IEEE Std 802.11n-2009.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">int</span> ampdu_factor;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * ampdu_density - Minimum A-MPDU Start Spacing</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Value: 0-7, see 7.3.2.56.3 in IEEE Std 802.11n-2009.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">int</span> ampdu_density;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * ht_mcs - Allowed HT-MCS rates, in ASCII hex: ffff0000...</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * By default (empty string): Use whatever the OS has configured.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">char</span> *ht_mcs;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* CONFIG_HT_OVERRIDES */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_VHT_OVERRIDES</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * disable_vht - Disable VHT (IEEE 802.11ac) for this network</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * By default, use it if it is available, but this can be configured</span></span><br><span class="line"><span class="comment">	 * to 1 to have it disabled.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">int</span> disable_vht;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * vht_capa - VHT capabilities to use</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> vht_capa;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * vht_capa_mask - mask for VHT capabilities</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> vht_capa_mask;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> vht_rx_mcs_nss_1, vht_rx_mcs_nss_2,</span><br><span class="line">	    vht_rx_mcs_nss_3, vht_rx_mcs_nss_4,</span><br><span class="line">	    vht_rx_mcs_nss_5, vht_rx_mcs_nss_6,</span><br><span class="line">	    vht_rx_mcs_nss_7, vht_rx_mcs_nss_8;</span><br><span class="line">	<span class="type">int</span> vht_tx_mcs_nss_1, vht_tx_mcs_nss_2,</span><br><span class="line">	    vht_tx_mcs_nss_3, vht_tx_mcs_nss_4,</span><br><span class="line">	    vht_tx_mcs_nss_5, vht_tx_mcs_nss_6,</span><br><span class="line">	    vht_tx_mcs_nss_7, vht_tx_mcs_nss_8;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* CONFIG_VHT_OVERRIDES */</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * ap_max_inactivity - Timeout in seconds to detect STA&#x27;s inactivity</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * This timeout value is used in AP mode to clean up inactive stations.</span></span><br><span class="line"><span class="comment">	 * By default: 300 seconds.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">int</span> ap_max_inactivity;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * dtim_period - DTIM period in Beacon intervals</span></span><br><span class="line"><span class="comment">	 * By default: 2</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">int</span> dtim_period;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * beacon_int - Beacon interval (default: 100 TU)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">int</span> beacon_int;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * auth_failures - Number of consecutive authentication failures</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> auth_failures;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * disabled_until - Network block disabled until this time if non-zero</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">os_time</span> <span class="title">disabled_until</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * parent_cred - Pointer to parent wpa_cred entry</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * This pointer can be used to delete temporary networks when a wpa_cred</span></span><br><span class="line"><span class="comment">	 * that was used to create them is removed. This pointer should not be</span></span><br><span class="line"><span class="comment">	 * dereferences since it may not be updated in all cases.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">void</span> *parent_cred;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>网络</category>
        <category>wifi</category>
      </categories>
      <tags>
        <tag>wifi</tag>
      </tags>
  </entry>
  <entry>
    <title>Audio驱动总结--ALSA</title>
    <url>/post/50356.html</url>
    <content><![CDATA[<p>接触Audio的这几个月,对控制的理解和对alsa框架的理解其中学习的进行总结</p>
<span id="more"></span>

<h2 id="音频参数"><a href="#音频参数" class="headerlink" title="音频参数"></a>音频参数</h2><ul>
<li>Sample：样本长度(位宽)，音频数据最基本的单位，常见的有8位和16位。</li>
<li>Channel：声道数，分为单声道mono和立体声stereo。</li>
<li>Frame：帧，构成一个声音单元，Frame &#x3D; Sample * channel, sample*channel&#x2F;8 Byte。</li>
<li>Rate：又称Sample rate，采样率，即每秒的采样次数，针对帧而言。</li>
<li>Interleaved：交错模式，一种音频数据的记录方式，在交错模式下，数据以连续桢的形式存放，即首先记录完桢1的左声道样本和右声道样本（假设为立体声），再开始桢2的记录。而在非交错模式下，首先记录的是一个周期内所有桢的左声道样本，再记录右声道样本，数据是以连续通道的方式存储。多数情况下使用交错模式。</li>
<li>Period size：周期，每次硬件中断处理音频数据的帧数，对于音频设备的数据读写，以frame为单位。</li>
<li>Buffer size：数据缓冲区大小，这里特指runtime的buffer size，而不是snd_pcm_hardware定义的buffer_bytes_max。一般来说Buffer size &#x3D; period_size * period_count，period_count相当于处理完一个buffer数据所需的硬件中断次数。单位也是frame</li>
<li>码率: (编码速率), 码率 &#x3D; 采样频率 * 位宽 * 声道个数</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">│                                                                   │</span><br><span class="line">├────────────────────────────── Buffer  ────────────────────────────┤</span><br><span class="line">│                                                                   │</span><br><span class="line">├───────────┬──────────┬───────────┬──────────┬──────────┬──────────┤</span><br><span class="line">│           │          │           │          │          │          │</span><br><span class="line">│   perid   │  perid   │  perid    │  perid   │  perid   │  perid   │   6 perids</span><br><span class="line">│           │          │           │          │          │          │</span><br><span class="line">└───────────┴──────────┼───────────┼──────────┴──────────┴──────────┘</span><br><span class="line">                       │           │</span><br><span class="line">            ┌──────────┘           └────────────────────┐</span><br><span class="line">            │                                           │</span><br><span class="line">            ├───────┬────────┬────────┬────────┬────────┤</span><br><span class="line">            │ frame │ frame  │ frame  │ frame  │ frame  │  perid = 5 frames</span><br><span class="line">            └───────┴────────┼────────┼────────┴────────┘</span><br><span class="line">                             │        │</span><br><span class="line">                          ┌──┘        └──┐</span><br><span class="line">                          │              │</span><br><span class="line">                          ├──────┬───────┤</span><br><span class="line">                          │ left │ right │  frame = 2 sample (2channel)</span><br><span class="line">                          └──────┴───────┘</span><br></pre></td></tr></table></figure>
<blockquote>
<p>一个buffer由若干个period组成, 一个period由若干个frame组成</p>
</blockquote>
<p>这个buffer中有6个period，每当DMA搬运完一个period的数据就会产生一次中断，因此搬运这个buffer中的数据将产生6次中断。<br>ALSA为什么这样做？因为数据缓存区可能很大，一次传输可能会导致不可接受的延迟；为了解决这个问题，alsa把缓存区拆分成多个周期，以周期为单元传输数据</p>
<p><em><strong>采样率和实际的分频误差在5%左右</strong></em></p>
<blockquote>
<p><strong>Period</strong></p>
<p>The interval between interrupts from the hardware. This defines the input latency, since the CPU will not have any idea that there is data waiting until the audio interface interrupts it.</p>
<p>The audio interface has a “pointer” that marks the current position for read&#x2F;write in its h&#x2F;w buffer. The pointer circles around the buffer as long as the interface is running.</p>
<p>Typically, there are an integral number of periods per traversal of the h&#x2F;w buffer, but not always. There is at least one card (ymfpci)<br>that generates interrupts at a fixed rate indepedent of the buffer size (which can be changed), resulting in some “odd” effects compared to more traditional designs.</p>
<p>Note: h&#x2F;w generally defines the interrupt in frames, though not always.</p>
<p>Alsa’s period size setting will affect how much work the CPU does. if you set the period size low, there will be more interrupts and the work that is done every interrupt will be done more often. So, if you don’t care about low latency,<br>set the period size large as possible and you’ll have more CPU cycles for other things. The defaults that ALSA provides are in the middle of the range, typically.</p>
<p>(from an old AlsaDevel thread[1], quoting Paul Davis)</p>
<p>Retrieved from “<span class="exturl" data-url="aHR0cDovL2Fsc2Eub3BlbnNyYy5vcmcvUGVyaW9kIg==">http://alsa.opensrc.org/Period&quot;<i class="fa fa-external-link-alt"></i></span></p>
<p>来自：<span class="exturl" data-url="aHR0cDovL2Fsc2Eub3BlbnNyYy5vcmcvUGVyaW9k">http://alsa.opensrc.org/Period<i class="fa fa-external-link-alt"></i></span></p>
<p><strong>FramesPeriods</strong></p>
<p>A frame is equivalent of one sample being played, irrespective of the number of channels or the number of bits. e.g.</p>
<ul>
<li>1 frame of a Stereo 48khz 16bit PCM stream is 4 bytes.</li>
<li>1 frame of a 5.1 48khz 16bit PCM stream is 12 bytes.<br><code>A period is the number of frames in between each hardware interrupt</code>. The poll() will return once a period.<br>The buffer is a ring buffer. The buffer size always has to be greater than one period size. Commonly this is 2*period size, but some hardware can do 8 periods per buffer. It is also possible for the buffer size to not be an integer multiple of the period size.<br>Now, if the hardware has been set to 48000Hz , 2 periods, of 1024 frames each, making a buffer size of 2048 frames. The hardware will interrupt 2 times per buffer. ALSA will endeavor to keep the buffer as full as possible. Once the first period of samples has<br>been played, the third period of samples is transfered into the space the first one occupied while the second period of samples is being played. (normal ring buffer behaviour).</li>
</ul>
<p>Additional example</p>
<p>Here is an alternative example for the above discussion.<br>Say we want to work with a stereo, 16-bit, 44.1 KHz stream, one-way (meaning, either in playback or in capture direction). Then we have:</p>
<ul>
<li>‘stereo’ &#x3D; number of channels: 2</li>
<li><code>1 analog sample</code> is represented with 16 bits &#x3D; 2 bytes</li>
<li><code>1 frame</code> represents 1 analog sample from all channels; here we have 2 channels, and so:<ul>
<li><code>1 frame</code> &#x3D; (num_channels) * (1 sample in bytes) &#x3D; (2 channels) * (2 bytes (16 bits) per sample) &#x3D; 4 bytes (32 bits)</li>
</ul>
</li>
<li>To sustain 2x 44.1 KHz <code>analog rate</code> - the system must be capable of <code>data transfer rate</code>, in Bytes&#x2F;sec:<ul>
<li><code>Bps_rate</code> &#x3D; (num_channels) * (1 sample in bytes) * (analog_rate) &#x3D; (1 frame) * (analog_rate) &#x3D; ( 2 channels ) * (2 bytes&#x2F;sample) * (44100 samples&#x2F;sec) &#x3D; 2<em>2</em>44100 &#x3D; 176400 Bytes&#x2F;sec<br><img data-src="/images/2021/11/audio_pcm_bps_rate.png" alt="audio_pcm_bps_rate"><br>Now, if ALSA would interrupt each second, asking for bytes - we’d need to have 176400 bytes ready for it (at end of each second), in order to sustain analog 16-bit stereo @ 44.1Khz.</li>
</ul>
</li>
<li>If it would interrupt each half a second, correspondingly for the same stream we’d need 176400&#x2F;2 &#x3D; 88200 bytes ready, at each interrupt;</li>
<li>if the interrupt hits each 100 ms, we’d need to have 176400*(0.1&#x2F;1) &#x3D; 17640 bytes ready, at each interrupt.<br>We can control when this PCM interrupt is generated, by setting a period size, which is set in frames.</li>
<li>Thus, if we set 16-bit stereo @ 44.1Khz, and the period_size to 4410 frames &#x3D;&gt; (for 16-bit stereo @ 44.1Khz, 1 frame equals 4 bytes - so 4410 frames equal 4410*4 &#x3D; 17640 bytes) &#x3D;&gt; an interrupt will be generated each 17640 bytes - that is, each 100 ms.</li>
<li>Correspondingly, buffer_size should be at least 2<em>period_size &#x3D; 2</em>4410 &#x3D; 8820 frames (or 8820*4 &#x3D; 35280 bytes).<br>It seems (writing-an-alsa-driver.pdf), however, that it is the ALSA runtime that decides on the actual buffer_size and period_size, depending on: the requested number of channels, and their respective properties (rate and sampling resolution) - as well as the<br>parameters set in the snd_pcm_hardware structure (in the driver).<br>Also, the following quote may be relevant, from <span class="exturl" data-url="aHR0cDovL21haWxtYW4uYWxzYS1wcm9qZWN0Lm9yZy9waXBlcm1haWwvYWxzYS1kZXZlbC8yMDA3LUFwcmlsLzAwMDQ3NC5odG1s">http://mailman.alsa-project.org/pipermail/alsa-devel/2007-April/000474.html<i class="fa fa-external-link-alt"></i></span>:</li>
</ul>
<blockquote>
<blockquote>
<p>The “frame” represents the unit, 1 frame &#x3D; # channels x sample_bytes.<br>In your case, 1 frame corresponds to 2 channels x 16 bits &#x3D; 4 bytes.</p>
<p>The periods is the number of periods in a ring-buffer.  In OSS, called<br>as “fragments”.</p>
<p>So,</p>
<ul>
<li>buffer_size &#x3D; period_size * periods</li>
<li>period_bytes &#x3D; period_size * bytes_per_frame</li>
<li>bytes_per_frame &#x3D; channels * bytes_per_sample</li>
</ul>
</blockquote>
<p>I still don’t understand what ‘period_size’ and a ‘period’ is?</p>
</blockquote>
<p>The “period” defines the frequency to update the status, usually viathe invokation of interrupts.  The “period_size” defines the frame sizes corresponding to the “period time”.  This term corresponds to the “fragment size” on OSS.  On major sound hardwares,<br>a ring-buffer is divided to several parts and an irq is issued on each boundary. The period_size defines the size of this chunk.</p>
<p>On some hardwares, the irq is controlled on the basis of a timer.  In this case, the period is defined as the timer frequency to invoke an irq.</p>
<p>来自：<span class="exturl" data-url="aHR0cDovL2Fsc2EtcHJvamVjdC5vcmcvbWFpbi9pbmRleC5waHAvRnJhbWVzUGVyaW9kcw==">http://alsa-project.org/main/index.php/FramesPeriods<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9tYWlsbWFuLmFsc2EtcHJvamVjdC5vcmcvcGlwZXJtYWlsL2Fsc2EtZGV2ZWwvMjAwNy1BcHJpbC8wMDA0NzQuaHRtbA==">[alsa-devel] Questions about writing a new ALSA driver for a very limitted device<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<h3 id="snd-pcm-lib-buffer-bytes-substream-与snd-pcm-lib-period-bytes-substream"><a href="#snd-pcm-lib-buffer-bytes-substream-与snd-pcm-lib-period-bytes-substream" class="headerlink" title="snd_pcm_lib_buffer_bytes(substream)与snd_pcm_lib_period_bytes(substream)"></a>snd_pcm_lib_buffer_bytes(substream)与snd_pcm_lib_period_bytes(substream)</h3><p>在驱动中进行dma数据传输时，需要通过<code>snd_pcm_lib_buffer_bytes(substream)</code>获取传输数据的buffer大小和<code>snd_pcm_lib_period_bytes(substream)</code>每次dma传输的数据大小</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * snd_pcm_lib_buffer_bytes - Get the buffer size of the current PCM in bytes</span></span><br><span class="line"><span class="comment"> * @substream: PCM substream</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">size_t</span> <span class="title function_">snd_pcm_lib_buffer_bytes</span><span class="params">(<span class="keyword">struct</span> snd_pcm_substream *substream)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">snd_pcm_runtime</span> *<span class="title">runtime</span> =</span> substream-&gt;runtime;</span><br><span class="line">    <span class="keyword">return</span> frames_to_bytes(runtime, runtime-&gt;buffer_size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * snd_pcm_lib_period_bytes - Get the period size of the current PCM in bytes</span></span><br><span class="line"><span class="comment"> * @substream: PCM substream</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">size_t</span> <span class="title function_">snd_pcm_lib_period_bytes</span><span class="params">(<span class="keyword">struct</span> snd_pcm_substream *substream)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">snd_pcm_runtime</span> *<span class="title">runtime</span> =</span> substream-&gt;runtime;</span><br><span class="line">    <span class="keyword">return</span> frames_to_bytes(runtime, runtime-&gt;period_size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>period_size可以控制pcm中断的产生，也就是period_size大小的数据传输完需要一个dma中断。</li>
<li>buffer_size,period_size的计算？</li>
</ul>
<p>在驱动里，我们会设置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">period_bytes_min = 1024 * 4 = 4096,</span><br><span class="line">period_bytes_max = 1024 *16,</span><br></pre></td></tr></table></figure>
<p>alsa会根据上面的最大最小值算出一个合适的值作为runtime-&gt;period_size。</p>
<p>在<code>sound/core/pcm_native.c</code>中的<code>snd_pcm_hw_constraints_init</code>函数实现了计算各种alsa定义的一些参数规则，其中包含了<code>buffer_size</code>， <code>period_size</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">err = snd_pcm_hw_rule_add(runtime, <span class="number">0</span>, SNDRV_PCM_HW_PARAM_PERIOD_SIZE,</span><br><span class="line">              snd_pcm_hw_rule_div, <span class="literal">NULL</span>,</span><br><span class="line">              SNDRV_PCM_HW_PARAM_BUFFER_SIZE, SNDRV_PCM_HW_PARAM_PERIODS, <span class="number">-1</span>);</span><br><span class="line"><span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">err = snd_pcm_hw_rule_add(runtime, <span class="number">0</span>, SNDRV_PCM_HW_PARAM_PERIOD_SIZE,</span><br><span class="line">              snd_pcm_hw_rule_mulkdiv, (<span class="type">void</span>*) <span class="number">8</span>,</span><br><span class="line">              SNDRV_PCM_HW_PARAM_PERIOD_BYTES, SNDRV_PCM_HW_PARAM_FRAME_BITS, <span class="number">-1</span>);</span><br><span class="line"><span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">err = snd_pcm_hw_rule_add(runtime, <span class="number">0</span>, SNDRV_PCM_HW_PARAM_PERIOD_SIZE,</span><br><span class="line">              snd_pcm_hw_rule_muldivk, (<span class="type">void</span>*) <span class="number">1000000</span>,</span><br><span class="line">              SNDRV_PCM_HW_PARAM_PERIOD_TIME, SNDRV_PCM_HW_PARAM_RATE, <span class="number">-1</span>);</span><br><span class="line"><span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> err;</span><br></pre></td></tr></table></figure>

<p>参考： <span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTI3Njk2OTEvYXJ0aWNsZS9kZXRhaWxzLzQ2NzI3NTQz">Alsa period_size&#x2F;periods&#x2F;buffer_size计算逻辑<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="音频处理软件"><a href="#音频处理软件" class="headerlink" title="音频处理软件"></a>音频处理软件</h2><blockquote>
<p> Audacity 2.0.5</p>
</blockquote>
<h2 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h2><p>主要由音频总线(I2S,PCM)和控制总线(I2C或SPI)组成。</p>
<p><img data-src="/images/audio/alsa/alsa-hardware-link.png" alt="alsa-hardware-link"></p>
<p><img data-src="/images/audio/alsa/audio-hardware.png" alt="audio-hardware"></p>
<h2 id="alsa-ASOC"><a href="#alsa-ASOC" class="headerlink" title="alsa - ASOC"></a>alsa - ASOC</h2><p>在内核设备驱动层，ALSA提供了alsa-driver，同时在应用层，ALSA为我们提供了alsa-lib，应用程序只要调用alsa-lib提供的API，即可以完成对底层音频硬件的控制。</p>
<p><img data-src="/images/audio/alsa/alsa-struct.png" alt="alsa-struct"></p>
<p>ASoC被分为<code>Machine</code>、<code>Platform</code>和<code>Codec</code>三大部分。其中的Machine驱动负责Platform和Codec之间的耦合和设备或板子特定的代码。Platform驱动的主要作用是完成音频数据的管理，最终通过CPU的数字音频接口（DAI）把音频数据传送给Codec进行处理，最终由Codec输出驱动耳机或者是喇叭的音信信号。</p>
<ul>
<li>machine<br>用于描述设备组件信息和特定的控制如耳机&#x2F;外放等。</li>
</ul>
<blockquote>
<p>是指某一款机器，可以是某款设备，某款开发板，又或者是某款智能手机，由此可以看出Machine几乎是不可重用的，每个Machine上的硬件实现可能都不一样，CPU不一样，Codec不一样，音频的输入、输出设备也不一样，Machine为CPU、Codec、输入输出设备提供了一个<code>载体</code>。</p>
</blockquote>
<p>这一部分将平台驱动和Codec驱动绑定在一起，描述了板级的硬件特征。主要负责Platform和Codec之间的耦合以及部分和设备或板子特定的代码。Machine驱动负责处理机器特有的一些控件和音频事件（例如，当播放音频时，需要先行打开一个放大器）；单独的Platform和Codec驱动是不能工作的，它必须由Machine驱动把它们结合在一起才能完成整个设备的音频处理工作。ASoC的一切都从Machine驱动开始，包括声卡的注册，绑定Platform和Codec驱动等等</p>
<ul>
<li>Platform<br>用于实现平台相关的DMA驱动和音频接口等。</li>
</ul>
<blockquote>
<p>一般是指某一个SoC平台，比如pxaxxx,s3cxxxx,omapxxx等等，与音频相关的通常包含该SoC中的时钟、DMA、I2S、PCM等等，只要指定了SoC，那么我们可以认为它会有一个对应的Platform，它只与SoC相关，与Machine无关，这样我们就可以把Platform抽象出来，使得同一款SoC不用做任何的改动，就可以用在不同的Machine中。实际上，把Platform认为是某个SoC更好理解。</p>
</blockquote>
<p>这一部分只关心CPU本身，不关心Codec。主要处理两个问题：<code>DMA引擎</code>和<code>SoC集成的PCM、I2S或AC &#39;97数字接口控制</code>。主要作用是完成音频数据的管理，最终通过CPU的数字音频接口（DAI）把音频数据传送给Codec进行处理，最终由Codec输出驱动耳机或者是喇叭的音信信号。在具体实现上，ASoC有把Platform驱动分为两个部分：<code>snd_soc_platform_driver</code>和<code>snd_soc_dai_driver</code>。其中，platform_driver负责管理音频数据，把音频数据通过dma或其他操作传送至cpu dai中，dai_driver则主要完成cpu一侧的dai的参数配置，同时也会通过一定的途径把必要的dma等参数与snd_soc_platform_driver进行交互。</p>
<ul>
<li>Codec<br>用于实现平台无关的功能，如寄存器读写接口，音频接口，各widgets的控制接口和DAPM的实现等</li>
</ul>
<blockquote>
<p>字面上的意思就是编解码器，Codec里面包含了I2S接口、D&#x2F;A、A&#x2F;D、Mixer、PA（功放），通常包含多种输入（Mic、Line-in、I2S、PCM）和多个输出（耳机、喇叭、听筒，Line-out），Codec和Platform一样，是可重用的部件，同一个Codec可以被不同的Machine使用。嵌入式Codec通常通过I2C对内部的寄存器进行控制。</p>
</blockquote>
<p>这一部分只关心Codec本身，与CPU平台相关的特性不由此部分操作。在移动设备中，Codec的作用可以归结为4种，分别是：</p>
<ol>
<li>对PCM等信号进行D&#x2F;A转换，把数字的音频信号转换为模拟信号。</li>
<li>对Mic、Linein或者其他输入源的模拟信号进行A&#x2F;D转换，把模拟的声音信号转变CPU能够处理的数字信号。</li>
<li>对音频通路进行控制，比如播放音乐，收听调频收音机，又或者接听电话时，音频信号在codec内的流通路线是不一样的。</li>
<li>对音频信号做出相应的处理，例如音量控制，功率放大，EQ控制等等。</li>
</ol>
<p>ASoC对Codec的这些功能都定义好了一些列相应的接口，以方便地对Codec进行控制。ASoC对Codec驱动的一个基本要求是：<code>驱动程序的代码必须要做到平台无关性，以方便同一个Codec的代码不经修改即可用在不同的平台上</code>。</p>
<p><img data-src="/images/audio/alsa/alas-asoc-arch.png" alt="alsa-asoc-arch"></p>
<p>ASoC对于Alsa来说，就是分别注册PCM&#x2F;CONTROL类型的snd_device设备，并实现相应的操作方法集。图中DAI是数字音频接口，用于配置音频数据格式等。</p>
<ul>
<li>Codec驱动向ASoC注册<code>snd_soc_codec</code>和<code>snd_soc_dai</code>设备。</li>
<li>Platform驱动向ASoC注册<code>snd_soc_platform</code>和<code>snd_soc_dai</code>设备。</li>
<li>Machine驱动通过<code>snd_soc_dai_link</code>绑定codec&#x2F;dai&#x2F;platform.</li>
</ul>
<p>Widget是各个组件内部的小单元。处在活动通路上电，不在活动通路下电。ASoC的DAPM正是通过控制这些Widget的上下电达到动态电源管理的效果。</p>
<ul>
<li>path描述与其它widget的连接关系。</li>
<li>event用于通知该widget的上下电状态。</li>
<li>power指示当前的上电状态。</li>
<li>control实现空间用户接口用于控制widget的音量&#x2F;通路切换等。</li>
</ul>
<p>对驱动开者来说，就可以很好的解耦了：</p>
<ul>
<li>codec驱动的开发者，实现codec的IO读写方法，描述DAI支持的数据格式&#x2F;操作方法和Widget的连接关系就可以了;</li>
<li>soc芯片的驱动开发者，Platform实现snd_pcm的操作方法集和DAI的配置如操作 DMA，I2S&#x2F;AC97&#x2F;PCM的设定等;</li>
<li>板级的开发者，描述Machine上codec与platform之间的总线连接， earphone&#x2F;Speaker的布线情况就可以了。</li>
</ul>
<h3 id="DAPM"><a href="#DAPM" class="headerlink" title="DAPM"></a>DAPM</h3><h3 id="DPCM"><a href="#DPCM" class="headerlink" title="DPCM"></a>DPCM</h3><blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9naXQua2VybmVsLm9yZy9wdWIvc2NtL2xpbnV4L2tlcm5lbC9naXQvdG9ydmFsZHMvbGludXguZ2l0L3BsYWluL0RvY3VtZW50YXRpb24vc291bmQvc29jL2RwY20ucnN0P2g9djQuMTYtcmM1">Dynamic PCM<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<h2 id="PCM设备"><a href="#PCM设备" class="headerlink" title="PCM设备"></a>PCM设备</h2><h3 id="放音-–-应用"><a href="#放音-–-应用" class="headerlink" title="放音 – 应用"></a>放音 – 应用</h3><blockquote>
<p><code>tinyplay</code>播放音乐</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># strace  tinyplay  pcmrec.wav</span></span><br><span class="line">execve(<span class="string">&quot;/usr/bin/tinyplay&quot;</span>, [<span class="string">&quot;tinyplay&quot;</span>, <span class="string">&quot;pcmrec.wav&quot;</span>], [<span class="comment">/* 16 vars */</span>]) = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">open(<span class="string">&quot;pcmrec.wav&quot;</span>, O_RDONLY)            = <span class="number">3</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">//读取wav格式的音频文件的头数据</span></span><br><span class="line">read(<span class="number">3</span>, <span class="string">&quot;RIFF$\342\4\0WAVEfmt \20\0\0\0\1\0\2\0@\37\0\0\0&#125;\0\0&quot;</span>..., <span class="number">4096</span>) = <span class="number">4096</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第一次打开`pcmC0D0p`设备节点, 重新设置硬件参数</span></span><br><span class="line">open(<span class="string">&quot;/dev/snd/pcmC0D0p&quot;</span>, O_RDWR)       = <span class="number">4</span></span><br><span class="line"><span class="comment">//ioctl - cmd=SNDRV_PCM_IOCTL_HW_REFINE</span></span><br><span class="line">ioctl(<span class="number">4</span>, <span class="number">0xc25c4110</span>, <span class="number">0x412178</span>)          = <span class="number">0</span></span><br><span class="line">close(<span class="number">4</span>)                                = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第二次打开`pcmC0D0p`设备节点, 进行音频播放的准备工作和播放</span></span><br><span class="line">open(<span class="string">&quot;/dev/snd/pcmC0D0p&quot;</span>, O_RDWR)       = <span class="number">4</span></span><br><span class="line"><span class="comment">//ioctl - cmd=`SNDRV_PCM_IOCTL_INFO`</span></span><br><span class="line">ioctl(<span class="number">4</span>, AGPIOC_ACQUIRE or APM_IOC_STANDBY, <span class="number">0x7f83f3cc</span>) = <span class="number">0</span></span><br><span class="line"><span class="comment">//ioctl - cmd=`SNDRV_PCM_IOCTL_HW_PARAMS`</span></span><br><span class="line">ioctl(<span class="number">4</span>, <span class="number">0xc25c4111</span>, <span class="number">0x7f83f170</span>)        = <span class="number">0</span></span><br><span class="line"><span class="comment">//ioctl - cmd=`SNDRV_PCM_IOCTL_SW_PARAMS`</span></span><br><span class="line">ioctl(<span class="number">4</span>, <span class="number">0xc0684113</span>, <span class="number">0x7f83f5ec</span>)        = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//在播放期间响应Ctrl+C的中断信号</span></span><br><span class="line">rt_sigaction(SIGINT, &#123;<span class="number">0x10000000</span>, [RT_65 RT_67], <span class="number">0x401240</span> <span class="comment">/* SA_??? */</span>&#125;, &#123;SIG_DFL, [RT_67 RT_68 RT_72 RT_74 RT_75 RT_77 RT_81 RT_89 RT_90 RT_91 RT_93 RT_94], <span class="number">0</span>&#125;, <span class="number">16</span>) = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// mmap</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ioctl - cmd=`SNDRV_PCM_IOCTL_SYNC_PTR`</span></span><br><span class="line"></span><br><span class="line">read(<span class="number">3</span>, <span class="string">&quot;\320\367\200\367\370\370`\370\220\370\330\370@\372h\371\240\371\320\374\230\373\240\374\341\5\301\1\241\5\221\25&quot;</span>..., <span class="number">12288</span>) = <span class="number">12288</span></span><br><span class="line">read(<span class="number">3</span>, <span class="string">&quot;a\0361\36\241\f\10\376\300\374\320\375\30\375\360\375\340\375\0\377\320\377(\377\370\376p\375p\374\321\0&quot;</span>..., <span class="number">4096</span>) = <span class="number">4096</span></span><br><span class="line"><span class="comment">//ioctl - cmd=`SNDRV_PCM_IOCTL_PREPARE`</span></span><br><span class="line">ioctl(<span class="number">4</span>, <span class="number">0x20004140</span>, <span class="number">0x7f83f648</span>)        = <span class="number">0</span></span><br><span class="line"><span class="comment">//ioctl - cmd=`SNDRV_PCM_IOCTL_WRITEI_FRAMES`</span></span><br><span class="line">ioctl(<span class="number">4</span>, <span class="number">0x800c4150</span>, <span class="number">0x7f83f648</span>)        = <span class="number">0</span></span><br><span class="line">read(<span class="number">3</span>, <span class="string">&quot;\201\21\301\27q\30\261\25\301\20Q\6x\375h\373\370\373\230\374\210\374x\374p\374\220\374\30\375 \375&quot;</span>..., <span class="number">12288</span>) = <span class="number">12288</span></span><br><span class="line">read(<span class="number">3</span>, <span class="string">&quot;\201\35\1%\241&#x27;\301\32\341\t@\377\250\374\220\372\20\373\30\374\340\373X\374H\374X\376\201\v\321\32&quot;</span>..., <span class="number">4096</span>) = <span class="number">4096</span></span><br><span class="line">ioctl(<span class="number">4</span>, <span class="number">0x800c4150</span>, <span class="number">0x7f83f648</span>)        = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">... <span class="comment">//while()&#123; 循环读取播放 &#125;</span></span><br><span class="line"></span><br><span class="line">read(<span class="number">3</span>, <span class="string">&quot;\370\375\10\376 \376\210\376X\376x\376\250\376\350\376\360\376\260\376(\377H\377q\0\301\5\1\vq\21&quot;</span>..., <span class="number">12288</span>) = <span class="number">12288</span></span><br><span class="line">read(<span class="number">3</span>, <span class="string">&quot;\221\0021\n\21\f\241\5x\376\30\377\300\377(\377\1\1!\3q\4Q\3\301\4\240\377h\376\210\377&quot;</span>..., <span class="number">4096</span>) = <span class="number">4096</span></span><br><span class="line">ioctl(<span class="number">4</span>, <span class="number">0x800c4150</span>, <span class="number">0x7f83f648</span>)        = <span class="number">0</span></span><br><span class="line">read(<span class="number">3</span>, <span class="string">&quot;P\377\0\377!\0\361\6Q\t\230\377@\376\250\377X\377\361\3\1\16\241\n!\0!\6A\16\241\v&quot;</span>..., <span class="number">12288</span>) = <span class="number">4652</span></span><br><span class="line">read(<span class="number">3</span>, <span class="string">&quot;&quot;</span>, <span class="number">4096</span>)                       = <span class="number">0</span></span><br><span class="line">ioctl(<span class="number">4</span>, <span class="number">0x800c4150</span>, <span class="number">0x7f83f648</span>)        = <span class="number">0</span></span><br><span class="line">read(<span class="number">3</span>, <span class="string">&quot;&quot;</span>, <span class="number">16384</span>)                      = <span class="number">0</span></span><br><span class="line">ioctl(<span class="number">4</span>, <span class="number">0x800c4150</span>, <span class="number">0x7f83f648</span>)        = <span class="number">0</span></span><br><span class="line">close(<span class="number">4</span>)                                = <span class="number">0</span></span><br><span class="line">close(<span class="number">3</span>)                                = <span class="number">0</span></span><br><span class="line">munmap(<span class="number">0x76fe9000</span>, <span class="number">65536</span>)               = <span class="number">0</span></span><br><span class="line">write(<span class="number">1</span>, <span class="string">&quot;Playing sample: 2 ch, 8000 hz, 1&quot;</span>..., <span class="number">38</span>) = <span class="number">38</span>  <span class="comment">//printf</span></span><br><span class="line">exit_group(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<h4 id="为什么open两次pcmC0D0p设备节点"><a href="#为什么open两次pcmC0D0p设备节点" class="headerlink" title="为什么open两次pcmC0D0p设备节点"></a>为什么open两次pcmC0D0p设备节点</h4><ol>
<li>第一次打开<code>pcmC0D0p</code>,主要为了重新规范硬件<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">snd_pcm_hw_params</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> flags;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">snd_mask</span> <span class="title">masks</span>[<span class="title">SNDRV_PCM_HW_PARAM_LAST_MASK</span> -</span></span><br><span class="line"><span class="class">                   <span class="title">SNDRV_PCM_HW_PARAM_FIRST_MASK</span> + 1];</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">snd_mask</span> <span class="title">mres</span>[5];</span>    <span class="comment">/* reserved masks */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">snd_interval</span> <span class="title">intervals</span>[<span class="title">SNDRV_PCM_HW_PARAM_LAST_INTERVAL</span> -</span></span><br><span class="line"><span class="class">                        <span class="title">SNDRV_PCM_HW_PARAM_FIRST_INTERVAL</span> + 1];</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">snd_interval</span> <span class="title">ires</span>[9];</span>    <span class="comment">/* reserved intervals */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> rmask;     <span class="comment">/* W: requested masks */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> cmask;     <span class="comment">/* R: changed masks */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> info;      <span class="comment">/* R: Info flags for returned setup */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> msbits;        <span class="comment">/* R: used most significant bits */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> rate_num;      <span class="comment">/* R: rate numerator */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> rate_den;      <span class="comment">/* R: rate denominator */</span></span><br><span class="line">    <span class="type">snd_pcm_uframes_t</span> fifo_size;    <span class="comment">/* R: chip FIFO size in frames */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> reserved[<span class="number">64</span>]; <span class="comment">/* reserved for future */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>file: include&#x2F;uapi&#x2F;sound&#x2F;asound.h</p>
</blockquote>
</li>
</ol>
<p>主要是将用户空间的snd_pcm_hw_params信息和内核空间的进行对比和规范化</p>
<ol start="2">
<li>第二次打开<code>pcmC0D0p</code>,主要为了进行音频播放的准备和播放音频信号</li>
</ol>
<h4 id="为什么read音频文件两次-并且读的数据大小不一致"><a href="#为什么read音频文件两次-并且读的数据大小不一致" class="headerlink" title="为什么read音频文件两次,并且读的数据大小不一致"></a>为什么read音频文件两次,并且读的数据大小不一致</h4><p>tinyplay中播放时,每次只读取一部分(16KB)的音频文件进行播放</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">size = pcm_frames_to_bytes(pcm, pcm_get_buffer_size(pcm)); <span class="comment">//size=16384Byte=16KB</span></span><br><span class="line">buffer = <span class="built_in">malloc</span>(size);</span><br><span class="line">...</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">	<span class="comment">//buffer 临时存放音频文件的数据的buf</span></span><br><span class="line">	<span class="comment">//size   一次读取的大小(16384Byte)</span></span><br><span class="line">	<span class="comment">//file   打开的音频文件描述符</span></span><br><span class="line">    num_read = fread(buffer, <span class="number">1</span>, size, file);</span><br><span class="line">    <span class="keyword">if</span> (num_read &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pcm_write(pcm, buffer, num_read)) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Error playing sample\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(num_read == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(buffer, <span class="number">0</span>, size);</span><br><span class="line">        <span class="keyword">if</span>(pcm_write(pcm, buffer, size))&#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Error playing sample\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">while</span> (!close &amp;&amp; num_read &gt; <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>在进行strace时,一次播放进行了两次的read系统调用,将每一次read数据的大小相加(12288+4096&#x3D;16384Byte),正好与malloc的buffer大小一致.因此两次的read是由用户空间的函数进行数据分割的.</p>
<h4 id="用户空间申请buffer大小的依据"><a href="#用户空间申请buffer大小的依据" class="headerlink" title="用户空间申请buffer大小的依据"></a>用户空间申请buffer大小的依据</h4><p>在播放当前歌曲时,所申请的buffer大小为16KB,为什么申请16K?</p>
<p>音频信息:</p>
<table>
<thead>
<tr>
<th align="center">采样率</th>
<th align="center">通道</th>
<th align="center">位宽(format)</th>
</tr>
</thead>
<tbody><tr>
<td align="center">44100Hz</td>
<td align="center">2</td>
<td align="center">16bit</td>
</tr>
</tbody></table>
<blockquote>
<p>4KB的buffer大小为<code>tinyplay</code>默认大小,<code>period_size = 1024</code>, <code>period_count = 4</code>决定了buffer大小,而<code>period_size</code>可以进行修改默认大小.</p>
</blockquote>
<p>需要申请buffer的大小: 1024 * 4 * 2 * (16 &#x2F; 8) &#x3D; 16384</p>
<h3 id="放音-–-内核"><a href="#放音-–-内核" class="headerlink" title="放音 – 内核"></a>放音 – 内核</h3><h4 id="ASOC接口"><a href="#ASOC接口" class="headerlink" title="ASOC接口"></a>ASOC接口</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* create a new pcm */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">soc_new_pcm</span><span class="params">(<span class="keyword">struct</span> snd_soc_pcm_runtime *rtd, <span class="type">int</span> num)</span></span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">/* ASoC PCM operations */</span></span><br><span class="line">	<span class="keyword">if</span> (rtd-&gt;dai_link-&gt;dynamic) &#123;</span><br><span class="line">		rtd-&gt;ops.open       = dpcm_fe_dai_open;</span><br><span class="line">		rtd-&gt;ops.hw_params  = dpcm_fe_dai_hw_params;</span><br><span class="line">		rtd-&gt;ops.prepare    = dpcm_fe_dai_prepare;</span><br><span class="line">		rtd-&gt;ops.trigger    = dpcm_fe_dai_trigger;</span><br><span class="line">		rtd-&gt;ops.hw_free    = dpcm_fe_dai_hw_free;</span><br><span class="line">		rtd-&gt;ops.close      = dpcm_fe_dai_close;</span><br><span class="line">		rtd-&gt;ops.pointer    = soc_pcm_pointer;</span><br><span class="line">		rtd-&gt;ops.ioctl      = soc_pcm_ioctl;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">//回调函数</span></span><br><span class="line">		rtd-&gt;ops.open       = soc_pcm_open;</span><br><span class="line">		rtd-&gt;ops.hw_params  = soc_pcm_hw_params;</span><br><span class="line">		rtd-&gt;ops.prepare    = soc_pcm_prepare;</span><br><span class="line">		rtd-&gt;ops.trigger    = soc_pcm_trigger;</span><br><span class="line">		rtd-&gt;ops.hw_free    = soc_pcm_hw_free;</span><br><span class="line">		rtd-&gt;ops.close      = soc_pcm_close;</span><br><span class="line">		rtd-&gt;ops.pointer    = soc_pcm_pointer;</span><br><span class="line">		rtd-&gt;ops.ioctl      = soc_pcm_ioctl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (platform-&gt;driver-&gt;ops) &#123;</span><br><span class="line">		rtd-&gt;ops.ack        = platform-&gt;driver-&gt;ops-&gt;ack;</span><br><span class="line">		rtd-&gt;ops.copy       = platform-&gt;driver-&gt;ops-&gt;copy;</span><br><span class="line">		rtd-&gt;ops.silence    = platform-&gt;driver-&gt;ops-&gt;silence;</span><br><span class="line">		rtd-&gt;ops.page       = platform-&gt;driver-&gt;ops-&gt;page;</span><br><span class="line">		rtd-&gt;ops.mmap       = platform-&gt;driver-&gt;ops-&gt;mmap;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (playback)</span><br><span class="line">		snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &amp;rtd-&gt;ops);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (capture)</span><br><span class="line">		snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &amp;rtd-&gt;ops);</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>file: sound&#x2F;soc&#x2F;soc-pcm.c</p>
</blockquote>
<h5 id="soc-pcm-open"><a href="#soc-pcm-open" class="headerlink" title="soc_pcm_open"></a>soc_pcm_open</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static int soc_pcm_open(struct snd_pcm_substream *substream)</span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">	// CPU &lt;I2S&gt; : jz_i2s_startup</span><br><span class="line">	if (cpu_dai-&gt;driver-&gt;ops-&gt;startup) &#123;</span><br><span class="line">		 ret = cpu_dai-&gt;driver-&gt;ops-&gt;startup(substream, cpu_dai);</span><br><span class="line">	&#125;</span><br><span class="line">	// Platform &lt;DMA&gt; : jz_pcm_open</span><br><span class="line">	if (platform-&gt;driver-&gt;ops &amp;&amp; platform-&gt;driver-&gt;ops-&gt;open) &#123;</span><br><span class="line">		 ret = platform-&gt;driver-&gt;ops-&gt;open(substream);</span><br><span class="line">	&#125;</span><br><span class="line">	// Codec &lt;idec_d3&gt; : jz_icdc_startup</span><br><span class="line">	if (codec_dai-&gt;driver-&gt;ops-&gt;startup) &#123;</span><br><span class="line">		 ret = codec_dai-&gt;driver-&gt;ops-&gt;startup(substream, codec_dai);</span><br><span class="line">	&#125;</span><br><span class="line"> 	// Machine &lt;link&gt; : phoenix_spk_sup  file:sound/soc/ingenic/asoc-board/phoenix_icdc.c</span><br><span class="line">	if (rtd-&gt;dai_link-&gt;ops &amp;&amp; rtd-&gt;dai_link-&gt;ops-&gt;startup) &#123;</span><br><span class="line">		 ret = rtd-&gt;dai_link-&gt;ops-&gt;startup(substream);</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="soc-pcm-hw-params"><a href="#soc-pcm-hw-params" class="headerlink" title="soc_pcm_hw_params"></a>soc_pcm_hw_params</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">soc_pcm_hw_params</span><span class="params">(<span class="keyword">struct</span> snd_pcm_substream *substream,</span></span><br><span class="line"><span class="params">                <span class="keyword">struct</span> snd_pcm_hw_params *params)</span></span><br><span class="line">&#123;</span><br><span class="line">	 ...</span><br><span class="line">	 <span class="comment">// Machine &lt;link&gt; : phoenix_i2s_hw_params</span></span><br><span class="line">	 <span class="keyword">if</span> (rtd-&gt;dai_link-&gt;ops &amp;&amp; rtd-&gt;dai_link-&gt;ops-&gt;hw_params) &#123;</span><br><span class="line">		 ret = rtd-&gt;dai_link-&gt;ops-&gt;hw_params(substream, params);</span><br><span class="line">	 &#125;</span><br><span class="line">	 <span class="comment">// Codec &lt;idec_d3&gt; : icdc_d3_hw_params</span></span><br><span class="line">	 <span class="keyword">if</span> (codec_dai-&gt;driver-&gt;ops-&gt;hw_params) &#123;</span><br><span class="line">		 ret = codec_dai-&gt;driver-&gt;ops-&gt;hw_params(substream, params, codec_dai);</span><br><span class="line">	 &#125;</span><br><span class="line">	 <span class="comment">// CPU &lt;I2S&gt; : jz_i2s_hw_params</span></span><br><span class="line">	 <span class="keyword">if</span> (cpu_dai-&gt;driver-&gt;ops-&gt;hw_params) &#123;</span><br><span class="line">		 ret = cpu_dai-&gt;driver-&gt;ops-&gt;hw_params(substream, params, cpu_dai);</span><br><span class="line">	 &#125;</span><br><span class="line">	 <span class="comment">// Platform &lt;DMA&gt; : jz_pcm_hw_params</span></span><br><span class="line">	 <span class="keyword">if</span> (platform-&gt;driver-&gt;ops &amp;&amp; platform-&gt;driver-&gt;ops-&gt;hw_params) &#123;</span><br><span class="line">		 ret = platform-&gt;driver-&gt;ops-&gt;hw_params(substream, params);</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="soc-pcm-prepare"><a href="#soc-pcm-prepare" class="headerlink" title="soc_pcm_prepare"></a>soc_pcm_prepare</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">soc_pcm_prepare</span><span class="params">(<span class="keyword">struct</span> snd_pcm_substream *substream)</span></span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// Machine &lt;link&gt; : phoenix_i2s_hw_params</span></span><br><span class="line">	<span class="keyword">if</span> (rtd-&gt;dai_link-&gt;ops &amp;&amp; rtd-&gt;dai_link-&gt;ops-&gt;prepare) &#123;</span><br><span class="line">		ret = rtd-&gt;dai_link-&gt;ops-&gt;prepare(substream);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Platform &lt;DMA&gt; :	jz_pcm_prepare</span></span><br><span class="line">	<span class="keyword">if</span> (platform-&gt;driver-&gt;ops &amp;&amp; platform-&gt;driver-&gt;ops-&gt;prepare) &#123;</span><br><span class="line">		ret = platform-&gt;driver-&gt;ops-&gt;prepare(substream);</span><br><span class="line">	&#125;</span><br><span class="line">   	<span class="comment">// Codec &lt;idec_d3&gt; : 默认函数</span></span><br><span class="line">	<span class="keyword">if</span> (codec_dai-&gt;driver-&gt;ops-&gt;prepare) &#123;</span><br><span class="line">		ret = codec_dai-&gt;driver-&gt;ops-&gt;prepare(substream, codec_dai);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// CPU &lt;I2S&gt; : 默认函数</span></span><br><span class="line">	<span class="keyword">if</span> (cpu_dai-&gt;driver-&gt;ops-&gt;prepare) &#123;</span><br><span class="line">		ret = cpu_dai-&gt;driver-&gt;ops-&gt;prepare(substream, cpu_dai);</span><br><span class="line">	&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="soc-pcm-trigger"><a href="#soc-pcm-trigger" class="headerlink" title="soc_pcm_trigger"></a>soc_pcm_trigger</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">soc_pcm_trigger</span><span class="params">(<span class="keyword">struct</span> snd_pcm_substream *substream, <span class="type">int</span> cmd)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// Codec &lt;idec_d3&gt; : icdc_d3_trigger</span></span><br><span class="line">	<span class="keyword">if</span> (codec_dai-&gt;driver-&gt;ops-&gt;trigger) &#123;</span><br><span class="line">		ret = codec_dai-&gt;driver-&gt;ops-&gt;trigger(substream, cmd, codec_dai);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Platform &lt;DMA&gt; :	jz_pcm_trigger</span></span><br><span class="line">	<span class="keyword">if</span> (platform-&gt;driver-&gt;ops &amp;&amp; platform-&gt;driver-&gt;ops-&gt;trigger) &#123;</span><br><span class="line">		ret = platform-&gt;driver-&gt;ops-&gt;trigger(substream, cmd);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// CPU &lt;I2S&gt; : jz_i2s_trigger</span></span><br><span class="line">	<span class="keyword">if</span> (cpu_dai-&gt;driver-&gt;ops-&gt;trigger) &#123;</span><br><span class="line">		ret = cpu_dai-&gt;driver-&gt;ops-&gt;trigger(substream, cmd, cpu_dai);</span><br><span class="line">	&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="soc-pcm-hw-free"><a href="#soc-pcm-hw-free" class="headerlink" title="soc_pcm_hw_free"></a>soc_pcm_hw_free</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">soc_pcm_hw_free</span><span class="params">(<span class="keyword">struct</span> snd_pcm_substream *substream)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* free any machine hw params */</span></span><br><span class="line">	<span class="comment">// Machine &lt;link&gt; : phoenix_i2s_hw_free</span></span><br><span class="line">	<span class="keyword">if</span> (rtd-&gt;dai_link-&gt;ops &amp;&amp; rtd-&gt;dai_link-&gt;ops-&gt;hw_free)</span><br><span class="line">		rtd-&gt;dai_link-&gt;ops-&gt;hw_free(substream);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* free any DMA resources */</span></span><br><span class="line">	<span class="comment">// Platform &lt;DMA&gt; : snd_pcm_lib_free_pages</span></span><br><span class="line">	<span class="keyword">if</span> (platform-&gt;driver-&gt;ops &amp;&amp; platform-&gt;driver-&gt;ops-&gt;hw_free)</span><br><span class="line">		platform-&gt;driver-&gt;ops-&gt;hw_free(substream);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* now free hw params for the DAIs  */</span></span><br><span class="line">	<span class="comment">// Codec &lt;idec_d3&gt; : 默认函数</span></span><br><span class="line">	<span class="keyword">if</span> (codec_dai-&gt;driver-&gt;ops-&gt;hw_free)</span><br><span class="line">		codec_dai-&gt;driver-&gt;ops-&gt;hw_free(substream, codec_dai);</span><br><span class="line">	<span class="comment">// CPU &lt;I2S&gt; : 默认函数</span></span><br><span class="line">	<span class="keyword">if</span> (cpu_dai-&gt;driver-&gt;ops-&gt;hw_free)</span><br><span class="line">		cpu_dai-&gt;driver-&gt;ops-&gt;hw_free(substream, cpu_dai);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="soc-pcm-pointer"><a href="#soc-pcm-pointer" class="headerlink" title="soc_pcm_pointer"></a>soc_pcm_pointer</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">snd_pcm_uframes_t</span> <span class="title function_">soc_pcm_pointer</span><span class="params">(<span class="keyword">struct</span> snd_pcm_substream *substream)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Platform &lt;DMA&gt; :</span></span><br><span class="line">    <span class="keyword">if</span> (platform-&gt;driver-&gt;ops &amp;&amp; platform-&gt;driver-&gt;ops-&gt;pointer)</span><br><span class="line">        offset = platform-&gt;driver-&gt;ops-&gt;pointer(substream);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cpu_dai-&gt;driver-&gt;ops-&gt;delay)</span><br><span class="line">        delay += cpu_dai-&gt;driver-&gt;ops-&gt;delay(substream, cpu_dai);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (codec_dai-&gt;driver-&gt;ops-&gt;delay)</span><br><span class="line">        delay += codec_dai-&gt;driver-&gt;ops-&gt;delay(substream, codec_dai);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (platform-&gt;driver-&gt;delay)</span><br><span class="line">        delay += platform-&gt;driver-&gt;delay(substream, codec_dai);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="soc-pcm-close"><a href="#soc-pcm-close" class="headerlink" title="soc_pcm_close"></a>soc_pcm_close</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">soc_pcm_close</span><span class="params">(<span class="keyword">struct</span> snd_pcm_substream *substream)</span></span><br><span class="line">&#123;</span><br><span class="line">	 <span class="comment">// CPU &lt;I2S&gt; : jz_i2s_shutdown</span></span><br><span class="line">	<span class="keyword">if</span> (cpu_dai-&gt;driver-&gt;ops-&gt;shutdown)</span><br><span class="line">		cpu_dai-&gt;driver-&gt;ops-&gt;shutdown(substream, cpu_dai);</span><br><span class="line">	<span class="comment">// Codec &lt;idec_d3&gt; : jz_icdc_shutdown</span></span><br><span class="line">	<span class="keyword">if</span> (codec_dai-&gt;driver-&gt;ops-&gt;shutdown)</span><br><span class="line">		codec_dai-&gt;driver-&gt;ops-&gt;shutdown(substream, codec_dai);</span><br><span class="line">	<span class="comment">// Machine &lt;link&gt; : phoenix_spk_sdown</span></span><br><span class="line">	<span class="keyword">if</span> (rtd-&gt;dai_link-&gt;ops &amp;&amp; rtd-&gt;dai_link-&gt;ops-&gt;shutdown)</span><br><span class="line">		rtd-&gt;dai_link-&gt;ops-&gt;shutdown(substream);</span><br><span class="line">	<span class="comment">// Platform &lt;DMA&gt; :	jz_pcm_close</span></span><br><span class="line">	<span class="keyword">if</span> (platform-&gt;driver-&gt;ops &amp;&amp; platform-&gt;driver-&gt;ops-&gt;close)</span><br><span class="line">		platform-&gt;driver-&gt;ops-&gt;close(substream);</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="open"><a href="#open" class="headerlink" title="open"></a>open</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">|(sound/core/pcm_native.c )</span><br><span class="line">|-&gt; snd_pcm_playback_open</span><br><span class="line">  \</span><br><span class="line">  |-&gt; snd_pcm_open(file, pcm, SNDRV_PCM_STREAM_PLAYBACK);</span><br><span class="line">    \</span><br><span class="line">    |-&gt; <span class="keyword">while</span>(<span class="number">1</span>)&#123; snd_pcm_open_file(file, pcm, stream); schedule(); &#125;</span><br><span class="line">      \</span><br><span class="line">      |-&gt; snd_pcm_open_substream</span><br><span class="line">		\</span><br><span class="line">		|-&gt; substream-&gt;ops-&gt;open(substream)</span><br><span class="line">		  |(sound/soc/soc-pcm.c)</span><br><span class="line">		  |-&gt; soc_pcm_open</span><br><span class="line">			\</span><br><span class="line">			|-&gt; cpu_dai-&gt;driver-&gt;ops-&gt;startup(substream, cpu_dai);</span><br><span class="line">			  \_**snd_soc_register_component** -&gt; snd_soc_dai_driver -&gt; snd_soc_dai_ops (.startup = jz_i2s_startup)</span><br><span class="line">			|-&gt; codec_dai-&gt;driver-&gt;ops-&gt;startup(substream, codec_dai);</span><br><span class="line">			  \_**snd_soc_register_codec** -&gt; snd_soc_dai_driver -&gt; snd_soc_dai_ops (.startup = jz_icdc_startup)</span><br><span class="line">			|-&gt; rtd-&gt;dai_link-&gt;ops-&gt;startup(substream);</span><br><span class="line">			  \_ **snd_soc_register_card** -&gt; snd_soc_dai_link -&gt; snd_soc_ops (.startup = phoenix_spk_sup)</span><br></pre></td></tr></table></figure>

<h4 id="ioctl"><a href="#ioctl" class="headerlink" title="ioctl"></a>ioctl</h4><blockquote>
<p>ioctl幻数</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取声卡信息返回给用户空间</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SNDRV_PCM_IOCTL_INFO _IOR(<span class="string">&#x27;A&#x27;</span>, 0x01, struct snd_pcm_info)</span></span><br><span class="line"><span class="comment">//硬件参数重新规范</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SNDRV_PCM_IOCTL_HW_REFINE _IOWR(<span class="string">&#x27;A&#x27;</span>, 0x10, struct snd_pcm_hw_params)</span></span><br><span class="line"><span class="comment">//设置硬件参数</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SNDRV_PCM_IOCTL_HW_PARAMS _IOWR(<span class="string">&#x27;A&#x27;</span>, 0x11, struct snd_pcm_hw_params)</span></span><br><span class="line"><span class="comment">//设置软件参数</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SNDRV_PCM_IOCTL_SW_PARAMS _IOWR(<span class="string">&#x27;A&#x27;</span>, 0x13, struct snd_pcm_sw_params)</span></span><br><span class="line"><span class="comment">//准备操作</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SNDRV_PCM_IOCTL_PREPARE _IO(<span class="string">&#x27;A&#x27;</span>, 0x40)</span></span><br><span class="line"><span class="comment">//从用户空间把音频数据拿过来，从wav文件中读出数据</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SNDRV_PCM_IOCTL_WRITEI_FRAMES _IOW(<span class="string">&#x27;A&#x27;</span>, 0x50, struct snd_xferi)</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(`sound/core/pcm_native.c`)</span><br><span class="line">|-&gt;	snd_pcm_playback_ioctl</span><br><span class="line">|</span><br><span class="line">|-&gt; snd_pcm_playback_ioctl1 --&gt; 判断cmd &lt;SNDRV_PCM_IOCTL_WRITEI_FRAMES&gt;</span><br><span class="line">|(`sound/core/pcm_lib.c`)</span><br><span class="line">|-&gt; snd_pcm_lib_write --- &gt; struct snd_pcm_substream *substream</span><br><span class="line">|</span><br><span class="line">|-&gt; snd_pcm_lib_write1</span><br><span class="line">		|_call_back--&gt;snd_pcm_lib_write_transfer(数据传输:copy和map)</span><br><span class="line">			|_.(内存和DMA之间的数据传递, 循环搬送直到播放完毕)</span><br><span class="line">					char *hwbuf = runtime-&gt;dma_area + frames_to_bytes(runtime, hwoff);</span><br><span class="line">					if (copy_from_user(hwbuf, buf, frames_to_bytes(runtime, frames)))</span><br><span class="line">		|</span><br><span class="line">		|-&gt; snd_pcm_start(substream) //**启动传输(只是在开始时,调用一次)**</span><br><span class="line">			|</span><br><span class="line">			|-&gt; snd_pcm_action</span><br><span class="line">				|</span><br><span class="line">				|-&gt; snd_pcm_action_single</span><br><span class="line">					|</span><br><span class="line">					|-&gt; &#123;</span><br><span class="line">							res = ops-&gt;pre_action(substream, state);</span><br><span class="line">							if (res &lt; 0)</span><br><span class="line"> 						   		return res;</span><br><span class="line">							res = ops-&gt;do_action(substream, state);</span><br><span class="line">							if (res == 0)</span><br><span class="line"> 						   		ops-&gt;post_action(substream, state);</span><br><span class="line">							else if (ops-&gt;undo_action)</span><br><span class="line">						    	ops-&gt;undo_action(substream, state);</span><br><span class="line">						&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>file: sound&#x2F;core&#x2F;pcm_native.c</p>
</blockquote>
<h4 id="close"><a href="#close" class="headerlink" title="close"></a>close</h4><p>通过系统调用close, 到release进行关闭</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.release =      snd_pcm_release</span><br><span class="line"></span><br><span class="line">snd_pcm_release</span><br><span class="line">  |</span><br><span class="line">  |-&gt; snd_pcm_release_substream</span><br><span class="line">	|</span><br><span class="line">	|-&gt; snd_pcm_drop</span><br><span class="line">	  |</span><br><span class="line">	  |-&gt; snd_pcm_stop</span><br><span class="line">		|</span><br><span class="line">		|-&gt; snd_pcm_action(&amp;snd_pcm_action_stop, substream, state)</span><br><span class="line">	|</span><br><span class="line">	|-&gt; substream-&gt;ops-&gt;hw_free(substream)</span><br><span class="line">	|-&gt; substream-&gt;ops-&gt;close(substream)</span><br></pre></td></tr></table></figure>

<h2 id="control设备"><a href="#control设备" class="headerlink" title="control设备"></a>control设备</h2><h2 id="codec"><a href="#codec" class="headerlink" title="codec"></a>codec</h2><h2 id="数据路由"><a href="#数据路由" class="headerlink" title="数据路由"></a>数据路由</h2><h2 id="amixer的设置"><a href="#amixer的设置" class="headerlink" title="amixer的设置"></a>amixer的设置</h2><h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><p>ASoC添加了debugfs和ftrace的调试支持。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mount -t debugfs none /mnt/</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">cat</span> available_events | grep <span class="string">&quot;asoc&quot;</span></span></span><br><span class="line">asoc:snd_soc_cache_sync</span><br><span class="line">asoc:snd_soc_jack_notify</span><br><span class="line">asoc:snd_soc_jack_report</span><br><span class="line">asoc:snd_soc_jack_irq</span><br><span class="line">asoc:snd_soc_dapm_connected</span><br><span class="line">asoc:snd_soc_dapm_input_path</span><br><span class="line">asoc:snd_soc_dapm_output_path</span><br><span class="line">asoc:snd_soc_dapm_walk_done</span><br><span class="line">asoc:snd_soc_dapm_widget_event_done</span><br><span class="line">asoc:snd_soc_dapm_widget_event_start</span><br><span class="line">asoc:snd_soc_dapm_widget_power</span><br><span class="line">asoc:snd_soc_dapm_done</span><br><span class="line">asoc:snd_soc_dapm_start</span><br><span class="line">asoc:snd_soc_bias_level_done</span><br><span class="line">asoc:snd_soc_bias_level_start</span><br><span class="line">asoc:snd_soc_preg_read</span><br><span class="line">asoc:snd_soc_preg_write</span><br><span class="line">asoc:snd_soc_reg_read</span><br><span class="line">asoc:snd_soc_reg_write</span><br></pre></td></tr></table></figure>

<ul>
<li>在DEBUGFS下，可以查看一个各个组件及widgets的状态。</li>
<li>在FTRACE下，<code>echo asoc &gt; tracing/set_event</code>打开调试，就可以<code>cat /mnt/tracing/trace</code>查看widget的上下电顺序， 通路的切换等。</li>
</ul>
<h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><h3 id="频响"><a href="#频响" class="headerlink" title="频响"></a>频响</h3><blockquote>
<p>频率响应 简称频响，英文名称是<code>Frequency Response</code>，在电子学上用来描述一台仪器对于不同频率的信号的处理能力的差异。</p>
</blockquote>
<h3 id="扫频"><a href="#扫频" class="headerlink" title="扫频"></a>扫频</h3><blockquote>
<p>利用正弦波信号的频率随时间在一定范围内反复扫描</p>
</blockquote>
]]></content>
      <categories>
        <category>设备驱动</category>
        <category>音频</category>
      </categories>
      <tags>
        <tag>驱动</tag>
        <tag>alsa</tag>
        <tag>audio</tag>
      </tags>
  </entry>
</search>
