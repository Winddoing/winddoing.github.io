<!DOCTYPE html><html lang=zh-CN><head><meta charset=UTF-8><meta name=viewport content="width=device-width"><meta name=theme-color content=#222 media="(prefers-color-scheme: light)"><meta name=theme-color content=#222 media="(prefers-color-scheme: dark)"><meta name=generator content="Hexo 6.2.0"><link rel=preconnect href=https://fonts.googleapis.com crossorigin><link rel=preconnect href=https://cdnjs.cloudflare.com crossorigin><link rel=apple-touch-icon sizes=180x180 href=/images/apple-touch-icon-next.png><link rel=icon type=image/png sizes=32x32 href=/favicon.ico><link rel=icon type=image/png sizes=16x16 href=/favicon.ico><link rel=mask-icon href=/images/logo.svg color=#222><meta name=baidu-site-verification content=WIIeufYjj6><link rel=stylesheet href=/css/main.css><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Microsoft+YaHei:300,300italic,400,400italic,700,700italic%7Ccmmi10:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin=anonymous><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin=anonymous><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin=anonymous><script class=next-config data-name=main type=application/json>{"hostname":"winddoing.github.io","root":"/","images":"/images","scheme":"Mist","darkmode":true,"version":"8.12.1","exturl":true,"sidebar":{"position":"right","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"default"},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":"utterances","storage":true,"lazyload":false,"nav":null,"activeClass":"utterances"},"stickytabs":false,"motion":{"enable":true,"async":true,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src=/js/config.js></script><meta name=description content=通过OpenGL使用GPU进行色彩空间的转换可以加速转换时间，提高效率。><meta property=og:type content=article><meta property=og:title content=OpenGL进行RGBA转NV12><meta property=og:url content=https://winddoing.github.io/post/ab7c39de.html><meta property=og:site_name content="Winddoing&#39;s Notes"><meta property=og:description content=通过OpenGL使用GPU进行色彩空间的转换可以加速转换时间，提高效率。><meta property=og:locale content=zh_CN><meta property=og:image content=https://winddoing.github.io/images/2022/09/opengl_rgba_to_yuv.png><meta property=article:published_time content=2022-09-23T03:28:00.000Z><meta property=article:modified_time content=2023-12-16T04:58:17.925Z><meta property=article:author content=winddoing><meta property=article:tag content=opengl><meta property=article:tag content=rgba><meta property=article:tag content=yuv><meta name=twitter:card content=summary><meta name=twitter:image content=https://winddoing.github.io/images/2022/09/opengl_rgba_to_yuv.png><link rel=canonical href=https://winddoing.github.io/post/ab7c39de.html><script class=next-config data-name=page type=application/json>{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://winddoing.github.io/post/ab7c39de.html","path":"post/ab7c39de.html","title":"OpenGL进行RGBA转NV12"}</script><script class=next-config data-name=calendar type=application/json>""</script><title>OpenGL进行RGBA转NV12 | Winddoing's Notes</title><script src=/js/third-party/analytics/baidu-analytics.js></script><script async src=https://hm.baidu.com/hm.js?b96a560ce0a6bfbeaaddc59dc5888b75></script><noscript><link rel=stylesheet href=/css/noscript.css></noscript></head><body itemscope itemtype=http://schema.org/WebPage class=use-motion><div class=headband></div><main class=main><header class=header itemscope itemtype=http://schema.org/WPHeader><div class=header-inner><div class=site-brand-container><div class=site-nav-toggle><div class=toggle aria-label=切换导航栏 role=button><span class=toggle-line></span> <span class=toggle-line></span> <span class=toggle-line></span></div></div><div class=site-meta><a href="/" class=brand rel=start><i class=logo-line></i><p class=site-title>Winddoing's Notes</p><i class=logo-line></i></a><p class=site-subtitle itemprop=description>Follow Excellent, Success will Chase you</p></div><div class=site-nav-right><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class=site-nav><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel=section><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel=section><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel=section><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel=section><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-search"><a role=button class=popup-trigger><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class=search-pop-overlay><div class="popup search-popup"><div class=search-header><span class=search-icon><i class="fa fa-search"></i></span><div class=search-input-container><input autocomplete=off autocapitalize=off maxlength=80 placeholder=搜索... spellcheck=false type=search class=search-input></div><span class=popup-btn-close role=button><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class=search-result-icon><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></div><div class="toggle sidebar-toggle" role=button><span class=toggle-line></span> <span class=toggle-line></span> <span class=toggle-line></span></div><aside class=sidebar><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class=sidebar-nav><li class=sidebar-nav-toc>文章目录</li><li class=sidebar-nav-overview>站点概览</li></ul><div class=sidebar-panel-container><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class=nav><li class="nav-item nav-level-2"><a class=nav-link href=#RGBA><span class=nav-number>1.</span> <span class=nav-text>RGBA</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%83%8F%E7%B4%A0%E5%AD%98%E5%82%A8%E6%A0%BC%E5%BC%8F><span class=nav-number>1.1.</span> <span class=nav-text>像素存储格式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class=nav-link href=#NV12><span class=nav-number>2.</span> <span class=nav-text>NV12</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%83%8F%E7%B4%A0%E5%AD%98%E5%82%A8%E6%A0%BC%E5%BC%8F-1><span class=nav-number>2.1.</span> <span class=nav-text>像素存储格式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class=nav-link href=#RGBA%E8%BD%ACNV12-%E8%AE%A1%E7%AE%97%E5%85%AC%E5%BC%8F><span class=nav-number>3.</span> <span class=nav-text>RGBA转NV12-计算公式</span></a></li><li class="nav-item nav-level-2"><a class=nav-link href=#shader%E8%BD%AC%E6%8D%A2><span class=nav-number>4.</span> <span class=nav-text>shader转换</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#%E7%89%87%E6%AE%B5%E7%9D%80%E8%89%B2%E5%99%A8%E5%A4%84%E7%90%86><span class=nav-number>4.1.</span> <span class=nav-text>片段着色器处理</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#%E4%B8%BA%E4%BB%80%E4%B9%88UV%E5%88%86%E9%87%8F%E8%A6%81%E5%8A%A00-5><span class=nav-number>4.1.1.</span> <span class=nav-text>为什么UV分量要加0.5</span></a></li></ol></li><li class="nav-item nav-level-3"><a class=nav-link href=#%E8%AE%A1%E7%AE%97%E7%9D%80%E8%89%B2%E5%99%A8%E5%A4%84%E7%90%86><span class=nav-number>4.2.</span> <span class=nav-text>计算着色器处理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class=nav-link href=#%E5%8F%A6%E4%B8%80%E7%A7%8D%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F%E2%80%94%E8%BE%93%E5%87%BAy%E5%92%8Cuv%E4%B8%A4%E4%B8%AA%E7%BA%B9%E7%90%86><span class=nav-number>5.</span> <span class=nav-text>另一种处理方式—输出y和uv两个纹理</span></a></li><li class="nav-item nav-level-2"><a class=nav-link href=#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E2%80%94%E2%80%94%E5%8F%82%E8%80%83%EF%BC%88%E6%9C%AA%E6%B5%8B%E8%AF%95%EF%BC%89><span class=nav-number>6.</span> <span class=nav-text>代码实现——参考（未测试）</span></a></li><li class="nav-item nav-level-2"><a class=nav-link href=#%E5%8F%82%E8%80%83><span class=nav-number>7.</span> <span class=nav-text>参考</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author site-overview-item animated" itemprop=author itemscope itemtype=http://schema.org/Person><img class=site-author-image itemprop=image alt=winddoing src=/images/Winddoing.jpg><p class=site-author-name itemprop=name>winddoing</p><div class=site-description itemprop=description>失败缘于忽视细处，成功始于重视小事</div></div><div class="site-state-wrap site-overview-item animated"><nav class=site-state><div class="site-state-item site-state-posts"><a href="/archives/"><span class=site-state-item-count>358</span> <span class=site-state-item-name>日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class=site-state-item-count>112</span> <span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class=site-state-item-count>284</span> <span class=site-state-item-name>标签</span></a></div></nav></div><div class="links-of-author site-overview-item animated"><span class=links-of-author-item><span class=exturl data-url="aHR0cHM6Ly9naXRodWIuY29tL1dpbmRkb2luZw==" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Winddoing"><i class="fab fa-github fa-fw"></i>GitHub</span></span> <span class=links-of-author-item><span class=exturl data-url=aHR0cHM6Ly9naXRlZS5jb20vd2luZGRvaW5n title="Gitee → https:&#x2F;&#x2F;gitee.com&#x2F;winddoing"><i class="fab fa-codiepie fa-fw"></i>Gitee</span></span> <span class=links-of-author-item><span class=exturl data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS91c2Vycy85NTY3MzYxL3dpbmRkb2luZw==" title="StackOverflow → https:&#x2F;&#x2F;stackoverflow.com&#x2F;users&#x2F;9567361&#x2F;winddoing"><i class="fab fa-stack-overflow fa-fw"></i>StackOverflow</span></span> <span class=links-of-author-item><span class=exturl data-url="aHR0cHM6Ly9hcHAudHJhdmlzLWNpLmNvbS9naXRodWIvV2luZGRvaW5nL3dpbmRkb2luZy5naXRodWIuaW8=" title="Travis CI → https:&#x2F;&#x2F;app.travis-ci.com&#x2F;github&#x2F;Winddoing&#x2F;winddoing.github.io"><i class="fas fa-terminal fa-fw"></i>Travis CI</span></span></div><div class="cc-license site-overview-item animated" itemprop=license><span class="exturl cc-opacity" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC8="><img src=https://cdnjs.cloudflare.com/ajax/libs/creativecommons-vocabulary/2020.11.3/assets/license_badges/small/by_nc_sa.svg alt="Creative Commons"></span></div><div class="links-of-blogroll site-overview-item animated"><div class=links-of-blogroll-title><i class="link fa-fw"></i> Links</div><ul class=links-of-blogroll-list><li class=links-of-blogroll-item><span class=exturl data-url="aHR0cHM6Ly93aW5kZG9pbmcuZ2l0Ym9vay5pby9lbWJlZGRlZF9saW51eF9ub3Rlcy8=" title=https:&#x2F;&#x2F;winddoing.gitbook.io&#x2F;embedded_linux_notes&#x2F;>嵌入式相关</span></li><li class=links-of-blogroll-item><span class=exturl data-url="aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2RyZWFtcQ==" title=http:&#x2F;&#x2F;blog.csdn.net&#x2F;sdreamq>CSDN</span></li><li class=links-of-blogroll-item><span class=exturl data-url=aHR0cDovL3d3dy53b3dvdGVjaC5uZXQv title=http:&#x2F;&#x2F;www.wowotech.net&#x2F;>蜗窝科技</span></li><li class=links-of-blogroll-item><span class=exturl data-url=aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpb25neGlhbnpl title=https:&#x2F;&#x2F;blog.csdn.net&#x2F;xiongxianze>xiongxianze</span></li></ul></div><div id=days></div><script>
function show_date_time(){
    window.setTimeout("show_date_time()", 1000);
    BirthDay=new Date("02/26/2014 15:00:00");
    today=new Date();
    timeold=(today.getTime()-BirthDay.getTime());
    sectimeold=timeold/1000
        secondsold=Math.floor(sectimeold);
    msPerDay=24*60*60*1000
        e_daysold=timeold/msPerDay
        daysold=Math.floor(e_daysold);
    e_hrsold=(e_daysold-daysold)*24;
    hrsold=setzero(Math.floor(e_hrsold));
    e_minsold=(e_hrsold-hrsold)*60;
    minsold=setzero(Math.floor((e_hrsold-hrsold)*60));
    seconds=setzero(Math.floor((e_minsold-minsold)*60));
    document.getElementById('days').innerHTML="已运行"+daysold+"天"+hrsold+"小时"+minsold+"分"+seconds+"秒";
}
function setzero(i){
    if (i<10)
    {i="0" + i};
    return i;
}
show_date_time();
</script></div></div></div></aside><div class=sidebar-dimmer></div></header><div class=back-to-top role=button aria-label=返回顶部><i class="fa fa-arrow-up"></i> <span>0%</span></div><div class=reading-progress-bar></div><noscript><div class=noscript-warning>Theme NexT works best with JavaScript enabled</div></noscript><div class="main-inner post posts-expand"><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang=zh-CN><link itemprop=mainEntityOfPage href=https://winddoing.github.io/post/ab7c39de.html><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content=/images/Winddoing.jpg><meta itemprop=name content=winddoing></span> <span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Winddoing's Notes"><meta itemprop=description content=失败缘于忽视细处，成功始于重视小事></span> <span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="OpenGL进行RGBA转NV12 | Winddoing's Notes"><meta itemprop=description></span><header class=post-header><h1 class=post-title itemprop="name headline">OpenGL进行RGBA转NV12</h1><div class=post-meta-container><div class=post-meta><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-calendar"></i></span> <span class=post-meta-item-text>发表于</span><time title="创建时间：2022-09-23 11:28:00" itemprop="dateCreated datePublished" datetime=2022-09-23T11:28:00+08:00>2022-09-23</time></span> <span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-folder"></i></span> <span class=post-meta-item-text>分类于</span> <span itemprop=about itemscope itemtype=http://schema.org/Thing><a href="/categories/%E5%A4%9A%E5%AA%92%E4%BD%93/" itemprop=url rel=index><span itemprop=name>多媒体</span></a></span> ， <span itemprop=about itemscope itemtype=http://schema.org/Thing><a href="/categories/%E5%A4%9A%E5%AA%92%E4%BD%93/OpenGL/" itemprop=url rel=index><span itemprop=name>OpenGL</span></a></span></span> <span id=/post/ab7c39de.html class="post-meta-item leancloud_visitors" data-flag-title=OpenGL进行RGBA转NV12 title=阅读次数><span class=post-meta-item-icon><i class="far fa-eye"></i></span> <span class=post-meta-item-text>阅读次数：</span> <span class=leancloud-visitors-count></span></span> <span class=post-meta-item title=阅读次数 id=busuanzi_container_page_pv><span class=post-meta-item-icon><i class="far fa-eye"></i></span> <span class=post-meta-item-text>阅读次数：</span> <span id=busuanzi_value_page_pv></span></span> <span class=post-meta-break></span> <span class=post-meta-item title=本文字数><span class=post-meta-item-icon><i class="far fa-file-word"></i></span> <span class=post-meta-item-text>本文字数：</span> <span>12k</span></span> <span class=post-meta-item title=阅读时长><span class=post-meta-item-icon><i class="far fa-clock"></i></span> <span class=post-meta-item-text>阅读时长 &asymp;</span> <span>11 分钟</span></span></div></div></header><div class=post-body itemprop=articleBody><p>通过OpenGL使用GPU进行色彩空间的转换可以加速转换时间，提高效率。</p><span id=more></span><h2 id=RGBA><a href=#RGBA class=headerlink title=RGBA></a>RGBA</h2><p>RGB图像具有三个通道 R、G、B，分别对应红、绿、蓝三个分量，由三个分量的值决定颜色；通常，会给RGB图像加一个通道alpha，即透明度，于是共有四个分量共同控制颜色。</p><h3 id=像素存储格式><a href=#像素存储格式 class=headerlink title=像素存储格式></a>像素存储格式</h3><p>一个<code>6x4</code>的图像，示例：</p><figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre></td><td class=code><pre><span class=line>RGBA RGBA RGBA RGBA RGBA RGBA</span><br><span class=line>RGBA RGBA RGBA RGBA RGBA RGBA</span><br><span class=line>RGBA RGBA RGBA RGBA RGBA RGBA</span><br><span class=line>RGBA RGBA RGBA RGBA RGBA RGBA</span><br><span class=line>          - RGBA -</span><br></pre></td></tr></table></figure><p>内存空间大小：6x4x(8x4)&#x3D;768bit</p><h2 id=NV12><a href=#NV12 class=headerlink title=NV12></a>NV12</h2><h3 id=像素存储格式-1><a href=#像素存储格式-1 class=headerlink title=像素存储格式></a>像素存储格式</h3><p>一个<code>6x4</code>的图像，示例：</p><figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre></td><td class=code><pre><span class=line>Y Y Y Y Y Y</span><br><span class=line>Y Y Y Y Y Y</span><br><span class=line>Y Y Y Y Y Y</span><br><span class=line>Y Y Y Y Y Y</span><br><span class=line>U V U V U V</span><br><span class=line>U V U V U V</span><br><span class=line> - NV12 -</span><br></pre></td></tr></table></figure><p>内存空间大小：6x(4+4&#x2F;2)x8&#x3D;288bit</p><h2 id=RGBA转NV12-计算公式><a href=#RGBA转NV12-计算公式 class=headerlink title=RGBA转NV12-计算公式></a>RGBA转NV12-计算公式</h2>$$ \begin{bmatrix} Y \\ U \\ V \\ \end{bmatrix} = \begin{bmatrix} 0.299 & 0.587 & 0.114 \\ -0.169 & -0.331 & 0.5 \\ 0.5 & 0.419 & -0.081 \\ \end{bmatrix} \begin{bmatrix} R \\ G \\ B \\ \end{bmatrix} + \begin{bmatrix} 0 \\ 128 \\ 128 \\ \end{bmatrix} \tag{RGB to YUV} $$ $$ \begin{bmatrix} R \\ G \\ B \end{bmatrix} = \begin{bmatrix} 1 & -0.00093 & 1.401687 \\ 1 & -0.3437 & -0.71417 \\ 1 & 1.77216 & 0.00099 \end{bmatrix} \begin{bmatrix} Y \\ U - 128 \\ V -128 \end{bmatrix} \tag{ YUV to RGB} $$<p>根据上面公式单个像素点的RGB转YUV计算方式：</p><figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre></td><td class=code><pre><span class=line>Y =  0.299R + 0.587G + 0.114B</span><br><span class=line>U = -0.169R - 0.331G + 0.500B</span><br><span class=line>V =  0.500R - 0.419G - 0.081B</span><br></pre></td></tr></table></figure><h2 id=shader转换><a href=#shader转换 class=headerlink title=shader转换></a>shader转换</h2><p>需求：在实际业务中渲染后的最终结果将输出一张RGBA格式的纹理，但是编码器的输入格式为NV12,因此需要将一个RGBA的纹理转换为一个NV12格式的纹理，并且可以一次性读取NV12格式的数据（glReadPixels）.</p><p>shader实现RGB转YUV原理图：</p><h3 id=片段着色器处理><a href=#片段着色器处理 class=headerlink title=片段着色器处理></a>片段着色器处理</h3><p>参考实现代码：<span class=exturl data-url="aHR0cHM6Ly9naXRodWIuY29tL2dpdGh1Ymhhb2hhby9OREtfT3BlbkdMRVNfM18wL2FwcC9zcmMvbWFpbi9jcHAvc2FtcGxlL1JHQjJOVjIxU2FtcGxlLmNwcA==">https://github.com/githubhaohao/NDK_OpenGLES_3_0/app/src/main/cpp/sample/RGB2NV21Sample.cpp<i class="fa fa-external-link-alt"></i></span></p><p>RGBA转成YUYV<br><img data-src=/images/2022/09/opengl_rgba_to_yuv.png alt="opengl rgba to yuv"></p><figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br></pre></td><td class=code><pre><span class=line>#version 300 es</span><br><span class=line>precision mediump float;</span><br><span class=line>in vec2 v_texCoord;</span><br><span class=line>layout(location = 0) out vec4 outColor;</span><br><span class=line>uniform sampler2D s_TextureMap;//RGBA纹理, 输入纹理参数</span><br><span class=line>uniform float u_Offset;//采样偏移</span><br><span class=line></span><br><span class=line>//RGB to YUV</span><br><span class=line>//Y =  0.299R + 0.587G + 0.114B</span><br><span class=line>//U = -0.147R - 0.289G + 0.436B</span><br><span class=line>//V =  0.615R - 0.515G - 0.100B</span><br><span class=line></span><br><span class=line>const vec3 COEF_Y = vec3( 0.299,  0.587,  0.114);</span><br><span class=line>const vec3 COEF_U = vec3(-0.147, -0.289,  0.436);</span><br><span class=line>const vec3 COEF_V = vec3( 0.615, -0.515, -0.100);</span><br><span class=line></span><br><span class=line>void main()</span><br><span class=line>&#123;</span><br><span class=line>    vec2 texelOffset = vec2(u_Offset, 0.0);</span><br><span class=line>    vec4 color0 = texture(s_TextureMap, v_texCoord);</span><br><span class=line>    //偏移 offset 采样</span><br><span class=line>    vec4 color1 = texture(s_TextureMap, v_texCoord + texelOffset);</span><br><span class=line></span><br><span class=line>    float y0 = dot(color0.rgb, COEF_Y);</span><br><span class=line>    float u0 = dot(color0.rgb, COEF_U) + 0.5;</span><br><span class=line>    float v0 = dot(color0.rgb, COEF_V) + 0.5;</span><br><span class=line>    float y1 = dot(color1.rgb, COEF_Y);</span><br><span class=line></span><br><span class=line>    outColor = vec4(y0, u0, y1, v0);</span><br><span class=line>&#125;</span><br></pre></td></tr></table></figure><h4 id=为什么UV分量要加0-5><a href=#为什么UV分量要加0-5 class=headerlink title=为什么UV分量要加0.5></a>为什么UV分量要加<code>0.5</code></h4><p>因为<code>归一化</code></p><p>YUV格式图像<code>UV分量</code>的默认值分别是<code>127</code>，<code>Y分量</code>默认值是<code>0</code> ，8个bit位的取值范围是<code>0 ~ 255</code>，由于在shader中纹理采样值需要进行归一化，所以<code>UV分量</code>的采样值需要分别加<code>0.5</code>，确保RGB到YUV正确转换</p><blockquote><p><code>归一化</code>的目的就是使得预处理的数据被限定在一定的范围内（比如[0,1]或者[-1,1]），从而消除奇异样本数据导致的不良影响</p></blockquote><blockquote><p>纹理格式:</p><p>OpenGL默认以无符号<code>归一化</code>格式存储纹理；当数据以无符号归一化格式存储时，<strong>纹素的值在内存中以整数存储，整数在读进着色器时转化为浮点数，并且用整数对应的最大值来除，最后生成[0.0, 1.0]的数据传给着色器</strong>。如果提供的是_SNORM修改符（例如GL_RGBA8_SNORM），数据是有符号的归一化；此时在内存中的数据是有符号整数，并且在它返回给着色器前，转换为浮点数，并被对应的最大有符号整数除，生成范围在[-1.0, 1.0]的浮点数值并传给着色器</p></blockquote><p>YUV默认值<code>[0, 127, 127]</code>的情况下，着色器读取数据时进行归一化(每个分量除以最大值255)，将变为<code>[0, 0.5, 0.5]</code>；而RGB默认值<code>[0, 0, 0]</code>, 进行归一化，后依然为<code>[0, 0, 0]</code>，因此在shader中进行转换时需要考虑归一化后的参数，RGB转YUV时，UV分量需要加<code>0.5</code>，而YUV转RGB时，UV分量需要减<code>0.5</code>。</p><h3 id=计算着色器处理><a href=#计算着色器处理 class=headerlink title=计算着色器处理></a>计算着色器处理</h3><figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br><span class=line>52</span><br><span class=line>53</span><br><span class=line>54</span><br><span class=line>55</span><br><span class=line>56</span><br><span class=line>57</span><br><span class=line>58</span><br><span class=line>59</span><br><span class=line>60</span><br><span class=line>61</span><br><span class=line>62</span><br><span class=line>63</span><br><span class=line>64</span><br><span class=line>65</span><br><span class=line>66</span><br><span class=line>67</span><br><span class=line>68</span><br><span class=line>69</span><br><span class=line>70</span><br><span class=line>71</span><br><span class=line>72</span><br><span class=line>73</span><br><span class=line>74</span><br><span class=line>75</span><br><span class=line>76</span><br><span class=line>77</span><br><span class=line>78</span><br></pre></td><td class=code><pre><span class=line>#extension GL_NV_image_formats : enable</span><br><span class=line>layout (rgba8, binding = 0) readonly uniform lowp image2D rgbaImage;  //输入纹理ID</span><br><span class=line>layout (r8, binding = 1) writeonly uniform lowp image2D yImage;       //输出纹理ID</span><br><span class=line>layout (local_size_x = 16, local_size_y = 16) in;   //以16x16像素块为处理单元</span><br><span class=line>layout(location = 2) uniform int height;            //输入参数纹理高度</span><br><span class=line>void main()</span><br><span class=line>&#123;</span><br><span class=line>    ivec2 storePos = ivec2(gl_GlobalInvocationID.xy);</span><br><span class=line>    ivec2 nvPos;</span><br><span class=line>    ivec2 ypos;</span><br><span class=line>    vec4 vr;  //right</span><br><span class=line>    vec4 vl;  //left</span><br><span class=line>    vec4 vld;</span><br><span class=line>    vec4 vrd;</span><br><span class=line>    vec4 sumUV;</span><br><span class=line>    vec4 yvec;</span><br><span class=line>    float y0,u0,v0,y1,u1,v1,y2,u2,v2,y3,u3,v3;</span><br><span class=line>    if(storePos.y &gt;= height)</span><br><span class=line>    &#123;</span><br><span class=line>        return;</span><br><span class=line>    &#125;</span><br><span class=line>    if(storePos.x % 2 == 0 &amp;&amp; storePos.y % 2 == 0)</span><br><span class=line>    &#123;</span><br><span class=line>        nvPos = storePos;</span><br><span class=line>        ypos = storePos;</span><br><span class=line>        vl = imageLoad(rgbaImage, storePos);</span><br><span class=line>        storePos.x+=1;</span><br><span class=line>        vr = imageLoad(rgbaImage, storePos);</span><br><span class=line>        storePos.y+=1;</span><br><span class=line>        vrd = imageLoad(rgbaImage, storePos);</span><br><span class=line>        storePos.x-=1;</span><br><span class=line>        vld = imageLoad(rgbaImage, storePos);</span><br><span class=line></span><br><span class=line>        y0 = 0.299*vl.r + 0.587 *vl.g + 0.114*vl.b;</span><br><span class=line>        u0 = (-0.169*vl.r - 0.331*vl.g + 0.500*vl.b) + 0.5;</span><br><span class=line>        v0 = ( 0.500*vl.r - 0.419*vl.g - 0.081*vl.b) + 0.5;</span><br><span class=line></span><br><span class=line>        y1 = 0.299*vr.r + 0.587 *vr.g + 0.114*vr.b;</span><br><span class=line>        u1 = (-0.169*vr.r - 0.331*vr.g + 0.500*vr.b) + 0.5;</span><br><span class=line>        v1 = ( 0.500*vr.r - 0.419*vr.g - 0.081*vr.b) + 0.5;</span><br><span class=line></span><br><span class=line>        y2 = 0.299*vrd.r + 0.587 *vrd.g + 0.114*vrd.b;</span><br><span class=line>        u2 = (-0.169*vrd.r - 0.331*vrd.g + 0.500*vrd.b) + 0.5;</span><br><span class=line>        v2 = ( 0.500*vrd.r - 0.419*vrd.g - 0.081*vrd.b) + 0.5;</span><br><span class=line></span><br><span class=line>        y3 = 0.299*vld.r + 0.587 *vld.g + 0.114*vld.b;</span><br><span class=line>        u3 = (-0.169*vld.r - 0.331*vld.g + 0.500*vld.b) + 0.5;</span><br><span class=line>        v3 = ( 0.500*vld.r - 0.419*vld.g - 0.081*vld.b) + 0.5;</span><br><span class=line></span><br><span class=line>        sumUV.x = (u0+u1+u2+u3)/4.0;</span><br><span class=line>        sumUV.y = (v0+v1+v2+v3)/4.0;</span><br><span class=line></span><br><span class=line>        // calculate position of NV components</span><br><span class=line>        nvPos.x = nvPos.x;</span><br><span class=line>        nvPos.y = nvPos.y/2;</span><br><span class=line></span><br><span class=line>        // update start position of NV buffer</span><br><span class=line>        nvPos.y += height;</span><br><span class=line></span><br><span class=line>        imageStore(yImage, nvPos, sumUV);</span><br><span class=line>        sumUV.x = sumUV.y;</span><br><span class=line>        nvPos.x += 1;</span><br><span class=line>        imageStore(yImage, nvPos, sumUV);</span><br><span class=line></span><br><span class=line>        yvec.x = y0;</span><br><span class=line>        imageStore(yImage, ypos, yvec);</span><br><span class=line>        ypos.x = ypos.x+1;</span><br><span class=line>        yvec.x = y1;</span><br><span class=line>        imageStore(yImage, ypos, yvec);</span><br><span class=line>        ypos.y = ypos.y+1;</span><br><span class=line>        yvec.x = y2;</span><br><span class=line>        imageStore(yImage, ypos, yvec);</span><br><span class=line>        ypos.x = ypos.x-1;</span><br><span class=line>        yvec.x = y3;</span><br><span class=line>        imageStore(yImage, ypos, yvec);</span><br><span class=line></span><br><span class=line>    &#125;</span><br><span class=line>&#125;</span><br></pre></td></tr></table></figure><p>输入输出纹理传入shader需要<code>glGetTextureImage</code>进行绑定。</p><p>片段着色器和计算着色器在同一个OpenGL上下文中无法使用，会导致渲染后的生成的像素点变为白色。</p><p>因此实际操作中需要以渲染上下文为基础，创建一个共享上下文进行转换（转换上下文），这样也可以实现渲染与转换的异步操作，提供部分性能。</p><h2 id=另一种处理方式—输出y和uv两个纹理><a href=#另一种处理方式—输出y和uv两个纹理 class=headerlink title=另一种处理方式—输出y和uv两个纹理></a>另一种处理方式—输出y和uv两个纹理</h2><p>参考：<span class=exturl data-url="aHR0cHM6Ly9zdGFja29vbS5jb20vY25fZW4vcXVlc3Rpb24vM2tBZHU=">https://stackoom.com/cn_en/question/3kAdu<i class="fa fa-external-link-alt"></i></span></p><p>着色器代码：</p><figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre></td><td class=code><pre><span class=line>#version 450 core</span><br><span class=line>layout(local_size_x = 32, local_size_y = 32) in;</span><br><span class=line>layout(binding = 0) uniform sampler2D src;</span><br><span class=line>layout(binding = 0) uniform writeonly image2D dst_y;</span><br><span class=line>layout(binding = 1) uniform writeonly image2D dst_uv;</span><br><span class=line>void main() &#123;</span><br><span class=line>    ivec2 id = ivec2(gl_GlobalInvocationID.xy);</span><br><span class=line>    vec3 yuv = rgb_to_yuv(texelFetch(src, id).rgb);</span><br><span class=line>    imageStore(dst_y, id, vec4(yuv.x,0,0,0));</span><br><span class=line>    imageStore(dst_uv, id, vec4(yuv.yz,0,0));</span><br><span class=line>&#125;</span><br></pre></td></tr></table></figure><p>有很多不同的YUV约定，我不知道您的编码器应该使用哪种约定(上面的转换公式)。因此，将上面的rgb_to_yuv替换为YUV-&gt; RGB转换的倒数。</p><figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br></pre></td><td class=code><pre><span class=line>GLuint in_rgb = ...; // rgb(a) input texture</span><br><span class=line>int width = ..., height = ...; // the size of in_rgb</span><br><span class=line></span><br><span class=line>GLuint tex[2]; // output textures (Y plane, UV plane)</span><br><span class=line></span><br><span class=line>glCreateTextures(GL_TEXTURE_2D, tex, 2);</span><br><span class=line>glTextureStorage2D(tex[0], 1, GL_R8, width, height); // Y plane</span><br><span class=line></span><br><span class=line>// UV plane -- TWO mipmap levels</span><br><span class=line>glTextureStorage2D(tex[1], 2, GL_RG8, width, height);</span><br><span class=line></span><br><span class=line>// use this instead if you need signed UV planes:</span><br><span class=line>//glTextureStorage2D(tex[1], 2, GL_RG8_SNORM, width, height);</span><br><span class=line></span><br><span class=line>glBindTextures(0, 1, &amp;in_rgb);</span><br><span class=line>glBindImageTextures(0, 2, tex);</span><br><span class=line>glUseProgram(compute); // the above compute shader</span><br><span class=line></span><br><span class=line>int wgs[3];</span><br><span class=line>glGetProgramiv(compute, GL_COMPUTE_WORK_GROUP_SIZE, wgs);</span><br><span class=line>glDispatchCompute(width/wgs[0], height/wgs[1], 1);</span><br><span class=line></span><br><span class=line>glUseProgram(0);</span><br><span class=line>glGenerateTextureMipmap(tex[1]); // downsamples tex[1]</span><br><span class=line></span><br><span class=line>// copy data to the CPU memory:</span><br><span class=line>uint8_t *data = (uint8_t*)malloc(width*height*3/2);</span><br><span class=line>glGetTextureImage(tex[0], 0, GL_RED, GL_UNSIGNED_BYTE, width*height, data);</span><br><span class=line>glGetTextureImage(tex[1], 1, GL_RG, GL_UNSIGNED_BYTE, width*height/2,</span><br><span class=line>    data + width*height);</span><br></pre></td></tr></table></figure><ul><li>此代码未经测试。</li><li>假定宽度和高度可以被32整除。</li><li>它可能在某处缺少内存障碍。</li><li>这不是从GPU中读取数据的最有效方法-您可能需要至少在读取下一帧的同时计算下一帧。</li></ul><h2 id=代码实现——参考（未测试）><a href=#代码实现——参考（未测试） class=headerlink title=代码实现——参考（未测试）></a>代码实现——参考（未测试）</h2><p>参考代码来自：<span class=exturl data-url=aHR0cHM6Ly9naXRodWIuY29tL2NvaGVucm90ZW0vUmdiMk5WMTIv>https://github.com/cohenrotem/Rgb2NV12/<i class="fa fa-external-link-alt"></i></span></p><figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br><span class=line>52</span><br><span class=line>53</span><br><span class=line>54</span><br><span class=line>55</span><br><span class=line>56</span><br><span class=line>57</span><br><span class=line>58</span><br><span class=line>59</span><br><span class=line>60</span><br><span class=line>61</span><br><span class=line>62</span><br><span class=line>63</span><br><span class=line>64</span><br><span class=line>65</span><br><span class=line>66</span><br><span class=line>67</span><br><span class=line>68</span><br><span class=line>69</span><br><span class=line>70</span><br><span class=line>71</span><br><span class=line>72</span><br><span class=line>73</span><br><span class=line>74</span><br><span class=line>75</span><br><span class=line>76</span><br><span class=line>77</span><br><span class=line>78</span><br><span class=line>79</span><br><span class=line>80</span><br><span class=line>81</span><br><span class=line>82</span><br><span class=line>83</span><br><span class=line>84</span><br><span class=line>85</span><br><span class=line>86</span><br><span class=line>87</span><br><span class=line>88</span><br><span class=line>89</span><br><span class=line>90</span><br><span class=line>91</span><br><span class=line>92</span><br><span class=line>93</span><br><span class=line>94</span><br><span class=line>95</span><br><span class=line>96</span><br><span class=line>97</span><br><span class=line>98</span><br><span class=line>99</span><br><span class=line>100</span><br><span class=line>101</span><br><span class=line>102</span><br><span class=line>103</span><br><span class=line>104</span><br><span class=line>105</span><br><span class=line>106</span><br><span class=line>107</span><br><span class=line>108</span><br><span class=line>109</span><br><span class=line>110</span><br><span class=line>111</span><br><span class=line>112</span><br><span class=line>113</span><br><span class=line>114</span><br><span class=line>115</span><br><span class=line>116</span><br><span class=line>117</span><br><span class=line>118</span><br><span class=line>119</span><br><span class=line>120</span><br><span class=line>121</span><br><span class=line>122</span><br><span class=line>123</span><br><span class=line>124</span><br><span class=line>125</span><br><span class=line>126</span><br><span class=line>127</span><br><span class=line>128</span><br><span class=line>129</span><br><span class=line>130</span><br><span class=line>131</span><br><span class=line>132</span><br><span class=line>133</span><br><span class=line>134</span><br><span class=line>135</span><br><span class=line>136</span><br><span class=line>137</span><br><span class=line>138</span><br><span class=line>139</span><br><span class=line>140</span><br><span class=line>141</span><br><span class=line>142</span><br><span class=line>143</span><br><span class=line>144</span><br><span class=line>145</span><br><span class=line>146</span><br><span class=line>147</span><br><span class=line>148</span><br><span class=line>149</span><br><span class=line>150</span><br><span class=line>151</span><br><span class=line>152</span><br><span class=line>153</span><br><span class=line>154</span><br><span class=line>155</span><br><span class=line>156</span><br><span class=line>157</span><br><span class=line>158</span><br><span class=line>159</span><br><span class=line>160</span><br><span class=line>161</span><br><span class=line>162</span><br><span class=line>163</span><br><span class=line>164</span><br><span class=line>165</span><br><span class=line>166</span><br><span class=line>167</span><br><span class=line>168</span><br><span class=line>169</span><br><span class=line>170</span><br><span class=line>171</span><br><span class=line>172</span><br><span class=line>173</span><br><span class=line>174</span><br><span class=line>175</span><br><span class=line>176</span><br><span class=line>177</span><br><span class=line>178</span><br></pre></td><td class=code><pre><span class=line>//https://software.intel.com/en-us/node/503873</span><br><span class=line>//YCbCr Color Model:</span><br><span class=line>//    The YCbCr color space is used for component digital video and was developed as part of the ITU-R BT.601 Recommendation. YCbCr is a scaled and offset version of the YUV color space.</span><br><span class=line>//    The Intel IPP functions use the following basic equations [Jack01] to convert between R&#x27;G&#x27;B&#x27; in the range 0-255 and Y&#x27;Cb&#x27;Cr&#x27; (this notation means that all components are derived from gamma-corrected R&#x27;G&#x27;B&#x27;):</span><br><span class=line>//    Y&#x27; = 0.257*R&#x27; + 0.504*G&#x27; + 0.098*B&#x27; + 16</span><br><span class=line>//    Cb&#x27; = -0.148*R&#x27; - 0.291*G&#x27; + 0.439*B&#x27; + 128</span><br><span class=line>//    Cr&#x27; = 0.439*R&#x27; - 0.368*G&#x27; - 0.071*B&#x27; + 128</span><br><span class=line></span><br><span class=line></span><br><span class=line>//Y&#x27; = 0.257*R&#x27; + 0.504*G&#x27; + 0.098*B&#x27; + 16</span><br><span class=line>static float Rgb2Y(float r0, float g0, float b0)</span><br><span class=line>&#123;</span><br><span class=line>    float y0 = 0.257f*r0 + 0.504f*g0 + 0.098f*b0 + 16.0f;</span><br><span class=line>    return y0;</span><br><span class=line>&#125;</span><br><span class=line></span><br><span class=line>//U equals Cb&#x27;</span><br><span class=line>//Cb&#x27; = -0.148*R&#x27; - 0.291*G&#x27; + 0.439*B&#x27; + 128</span><br><span class=line>static float Rgb2U(float r0, float g0, float b0)</span><br><span class=line>&#123;</span><br><span class=line>    float u0 = -0.148f*r0 - 0.291f*g0 + 0.439f*b0 + 128.0f;</span><br><span class=line>    return u0;</span><br><span class=line>&#125;</span><br><span class=line></span><br><span class=line>//V equals Cr&#x27;</span><br><span class=line>//Cr&#x27; = 0.439*R&#x27; - 0.368*G&#x27; - 0.071*B&#x27; + 128</span><br><span class=line>static float Rgb2V(float r0, float g0, float b0)</span><br><span class=line>&#123;</span><br><span class=line>    float v0 = 0.439f*r0 - 0.368f*g0 - 0.071f*b0 + 128.0f;</span><br><span class=line>    return v0;</span><br><span class=line>&#125;</span><br><span class=line></span><br><span class=line>//Convert two rows from RGB to two Y rows, and one row of interleaved U,V.</span><br><span class=line>//I0 and I1 points two sequential source rows.</span><br><span class=line>//I0 -&gt; rgbrgbrgbrgbrgbrgb...</span><br><span class=line>//I1 -&gt; rgbrgbrgbrgbrgbrgb...</span><br><span class=line>//Y0 and Y1 points two sequential destination rows of Y plane.</span><br><span class=line>//Y0 -&gt; yyyyyy</span><br><span class=line>//Y1 -&gt; yyyyyy</span><br><span class=line>//UV0 points destination rows of interleaved UV plane.</span><br><span class=line>//UV0 -&gt; uvuvuv</span><br><span class=line>static void Rgb2NV12TwoRows(const unsigned char I0[],</span><br><span class=line>                            const unsigned char I1[],</span><br><span class=line>                            int step,</span><br><span class=line>                            const int image_width,</span><br><span class=line>                            unsigned char Y0[],</span><br><span class=line>                            unsigned char Y1[],</span><br><span class=line>                            unsigned char UV0[])</span><br><span class=line>&#123;</span><br><span class=line>    int x;  //Column index</span><br><span class=line></span><br><span class=line>    //Process 4 source pixels per iteration (2 pixels of row I0 and 2 pixels of row I1).</span><br><span class=line>    for (x = 0; x &lt; image_width; x += 2)</span><br><span class=line>    &#123;</span><br><span class=line>        //Load R,G,B elements from first row (and convert to float).</span><br><span class=line>        float r00 = (float)I0[x*step + 0];</span><br><span class=line>        float g00 = (float)I0[x*step + 1];</span><br><span class=line>        float b00 = (float)I0[x*step + 2];</span><br><span class=line></span><br><span class=line>        //Load next R,G,B elements from first row (and convert to float).</span><br><span class=line>        float r01 = (float)I0[x*step + step+0];</span><br><span class=line>        float g01 = (float)I0[x*step + step+1];</span><br><span class=line>        float b01 = (float)I0[x*step + step+2];</span><br><span class=line></span><br><span class=line>        //Load R,G,B elements from second row (and convert to float).</span><br><span class=line>        float r10 = (float)I1[x*step + 0];</span><br><span class=line>        float g10 = (float)I1[x*step + 1];</span><br><span class=line>        float b10 = (float)I1[x*step + 2];</span><br><span class=line></span><br><span class=line>        //Load next R,G,B elements from second row (and convert to float).</span><br><span class=line>        float r11 = (float)I1[x*step + step+0];</span><br><span class=line>        float g11 = (float)I1[x*step + step+1];</span><br><span class=line>        float b11 = (float)I1[x*step + step+2];</span><br><span class=line></span><br><span class=line>        //Calculate 4 Y elements.</span><br><span class=line>        float y00 = Rgb2Y(r00, g00, b00);</span><br><span class=line>        float y01 = Rgb2Y(r01, g01, b01);</span><br><span class=line>        float y10 = Rgb2Y(r10, g10, b10);</span><br><span class=line>        float y11 = Rgb2Y(r11, g11, b11);</span><br><span class=line></span><br><span class=line>        //Calculate 4 U elements.</span><br><span class=line>        float u00 = Rgb2U(r00, g00, b00);</span><br><span class=line>        float u01 = Rgb2U(r01, g01, b01);</span><br><span class=line>        float u10 = Rgb2U(r10, g10, b10);</span><br><span class=line>        float u11 = Rgb2U(r11, g11, b11);</span><br><span class=line></span><br><span class=line>        //Calculate 4 V elements.</span><br><span class=line>        float v00 = Rgb2V(r00, g00, b00);</span><br><span class=line>        float v01 = Rgb2V(r01, g01, b01);</span><br><span class=line>        float v10 = Rgb2V(r10, g10, b10);</span><br><span class=line>        float v11 = Rgb2V(r11, g11, b11);</span><br><span class=line></span><br><span class=line>        //Calculate destination U element: average of 2x2 &quot;original&quot; U elements.</span><br><span class=line>        float u0 = (u00 + u01 + u10 + u11)*0.25f;</span><br><span class=line></span><br><span class=line>        //Calculate destination V element: average of 2x2 &quot;original&quot; V elements.</span><br><span class=line>        float v0 = (v00 + v01 + v10 + v11)*0.25f;</span><br><span class=line></span><br><span class=line>        //Store 4 Y elements (two in first row and two in second row).</span><br><span class=line>        Y0[x + 0]    = (unsigned char)(y00 + 0.5f);</span><br><span class=line>        Y0[x + 1]    = (unsigned char)(y01 + 0.5f);</span><br><span class=line>        Y1[x + 0]    = (unsigned char)(y10 + 0.5f);</span><br><span class=line>        Y1[x + 1]    = (unsigned char)(y11 + 0.5f);</span><br><span class=line></span><br><span class=line>        //Store destination U element.</span><br><span class=line>        UV0[x + 0]    = (unsigned char)(u0 + 0.5f);</span><br><span class=line></span><br><span class=line>        //Store destination V element (next to stored U element).</span><br><span class=line>        UV0[x + 1]    = (unsigned char)(v0 + 0.5f);</span><br><span class=line>    &#125;</span><br><span class=line>&#125;</span><br><span class=line></span><br><span class=line></span><br><span class=line>//Convert image I from pixel ordered RGB to NV12 format.</span><br><span class=line>//I - Input image in pixel ordered RGB format</span><br><span class=line>//image_width - Number of columns of I</span><br><span class=line>//image_height - Number of rows of I</span><br><span class=line>//J - Destination &quot;image&quot; in NV12 format.</span><br><span class=line></span><br><span class=line>//I is pixel ordered RGB color format (size in bytes is image_width*image_height*3):</span><br><span class=line>//RGBRGBRGBRGBRGBRGB</span><br><span class=line>//RGBRGBRGBRGBRGBRGB</span><br><span class=line>//RGBRGBRGBRGBRGBRGB</span><br><span class=line>//RGBRGBRGBRGBRGBRGB</span><br><span class=line>//</span><br><span class=line>//J is in NV12 format (size in bytes is image_width*image_height*3/2):</span><br><span class=line>//YYYYYY</span><br><span class=line>//YYYYYY</span><br><span class=line>//UVUVUV</span><br><span class=line>//Each element of destination U is average of 2x2 &quot;original&quot; U elements</span><br><span class=line>//Each element of destination V is average of 2x2 &quot;original&quot; V elements</span><br><span class=line>//</span><br><span class=line>//Limitations:</span><br><span class=line>//1. image_width must be a multiple of 2.</span><br><span class=line>//2. image_height must be a multiple of 2.</span><br><span class=line>//3. I and J must be two separate arrays (in place computation is not supported).</span><br><span class=line>void Rgb2NV12(const unsigned char I[], int step,</span><br><span class=line>              const int image_width,</span><br><span class=line>              const int image_height,</span><br><span class=line>              unsigned char J[])</span><br><span class=line>&#123;</span><br><span class=line>    //In NV12 format, UV plane starts below Y plane.</span><br><span class=line>    unsigned char *UV = &amp;J[image_width*image_height];</span><br><span class=line></span><br><span class=line>    //I0 and I1 points two sequential source rows.</span><br><span class=line>    const unsigned char *I0;  //I0 -&gt; rgbrgbrgbrgbrgbrgb...</span><br><span class=line>    const unsigned char *I1;  //I1 -&gt; rgbrgbrgbrgbrgbrgb...</span><br><span class=line></span><br><span class=line>    //Y0 and Y1 points two sequential destination rows of Y plane.</span><br><span class=line>    unsigned char *Y0;    //Y0 -&gt; yyyyyy</span><br><span class=line>    unsigned char *Y1;    //Y1 -&gt; yyyyyy</span><br><span class=line></span><br><span class=line>    //UV0 points destination rows of interleaved UV plane.</span><br><span class=line>    unsigned char *UV0; //UV0 -&gt; uvuvuv</span><br><span class=line></span><br><span class=line>    int y;  //Row index</span><br><span class=line></span><br><span class=line>    //In each iteration: process two rows of Y plane, and one row of interleaved UV plane.</span><br><span class=line>    for (y = 0; y &lt; image_height; y += 2)</span><br><span class=line>    &#123;</span><br><span class=line>        I0 = &amp;I[y*image_width*step];        //Input row width is image_width*3 bytes (each pixel is R,G,B).</span><br><span class=line>        I1 = &amp;I[(y+1)*image_width*step];</span><br><span class=line></span><br><span class=line>        Y0 = &amp;J[y*image_width];            //Output Y row width is image_width bytes (one Y element per pixel).</span><br><span class=line>        Y1 = &amp;J[(y+1)*image_width];</span><br><span class=line></span><br><span class=line>        UV0 = &amp;UV[(y/2)*image_width];    //Output UV row - width is same as Y row width.</span><br><span class=line></span><br><span class=line>        //Process two source rows into: Two Y destination row, and one destination interleaved U,V row.</span><br><span class=line>        Rgb2NV12TwoRows(I0,</span><br><span class=line>                        I1,</span><br><span class=line>                        step,</span><br><span class=line>                        image_width,</span><br><span class=line>                        Y0,</span><br><span class=line>                        Y1,</span><br><span class=line>                        UV0);</span><br><span class=line>    &#125;</span><br><span class=line>&#125;</span><br></pre></td></tr></table></figure><h2 id=参考><a href=#参考 class=headerlink title=参考></a>参考</h2><ul><li><span class=exturl data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC9kYTJhNjgyYWU5NjQ=">RGB YUV420sp 互相转换 nv21<i class="fa fa-external-link-alt"></i></span></li><li><span class=exturl data-url=aHR0cHM6Ly9qdWVqaW4uY24vcG9zdC82OTY2NjA4MDgyMDQyMzU1NzI1>OpenGL ES 将 RGB 图像转换为 YUV 格式。<i class="fa fa-external-link-alt"></i></span></li><li><span class=exturl data-url="aHR0cHM6Ly9zdGFja29vbS5jb20vY25fZW4vcXVlc3Rpb24vM2tBZHU=">如何使用OpenGL将RGBA转换为NV12？<i class="fa fa-external-link-alt"></i></span></li><li><span class=exturl data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vbWF6aGVueXUvcC83MjQwNDA3Lmh0bWw=">【OpenGL】用OpenGL shader实现将YUV(YUV420,YV12)转RGB-(直接调用GPU实现，纯硬件方式，效率高) <i class="fa fa-external-link-alt"></i></span> —— 多个纹理处理</li><li><span class=exturl data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC8xOTczMTliMGIwMDc=">OpenGL ES：rgb转换yuv<i class="fa fa-external-link-alt"></i></span></li></ul></div><footer class=post-footer><div class=post-copyright><ul><li class=post-copyright-author><strong>本文作者：</strong>winddoing</li><li class=post-copyright-link><strong>本文链接：</strong> <a href=https://winddoing.github.io/post/ab7c39de.html title=OpenGL进行RGBA转NV12>https://winddoing.github.io/post/ab7c39de.html</a></li><li class=post-copyright-license><strong>版权声明：</strong>本博客所有文章除特别声明外，均采用 <span class=exturl data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC8="><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div><div class=post-tags><a href="/tags/opengl/" rel=tag><i class="fa fa-tag"></i> opengl</a> <a href="/tags/rgba/" rel=tag><i class="fa fa-tag"></i> rgba</a> <a href="/tags/yuv/" rel=tag><i class="fa fa-tag"></i> yuv</a></div><div class=post-nav><div class=post-nav-item><a href=/post/4a8fdf27.html rel=prev title="[译] H.264和H.265的区别"><i class="fa fa-chevron-left"></i> [译] H.264和H.265的区别</a></div><div class=post-nav-item><a href=/post/9a5cc3eb.html rel=next title=加密解密>加密解密 <i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><div class="comments utterances-container"></div></div></main><footer class=footer><div class=footer-inner><div class=copyright>&copy; 2014 – <span itemprop=copyrightYear>2023</span> <span class=with-love><i class="fa fa-heart"></i></span> <span class=author itemprop=copyrightHolder>winddoing</span></div><div class=wordcount><span class=post-meta-item><span class=post-meta-item-icon><i class="fa fa-chart-line"></i></span> <span title=站点总字数>1.1m</span></span> <span class=post-meta-item><span class=post-meta-item-icon><i class="fa fa-coffee"></i></span> <span title=站点阅读时长>16:21</span></span></div><div class=busuanzi-count><span class=post-meta-item id=busuanzi_container_site_uv><span class=post-meta-item-icon><i class="fa fa-users"></i></span> <span class=site-uv title=总访客量><span id=busuanzi_value_site_uv></span></span></span> <span class=post-meta-item id=busuanzi_container_site_pv><span class=post-meta-item-icon><i class="fa fa-eye"></i></span> <span class=site-pv title=总访问量><span id=busuanzi_value_site_pv></span></span></span></div><div class=powered-by>由 <span class=exturl data-url=aHR0cHM6Ly9oZXhvLmlv>Hexo</span> & <span class=exturl data-url="aHR0cHM6Ly90aGVtZS1uZXh0LmpzLm9yZy9taXN0Lw==">NexT.Mist</span> 强力驱动</div></div></footer><script src=https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin=anonymous></script><script src=https://cdnjs.cloudflare.com/ajax/libs/next-theme-pjax/0.5.0/pjax.min.js integrity="sha256-3NkoLDrmHLTYj7csHIZSr0MHAFTXth7Ua/DDt4MRUAg=" crossorigin=anonymous></script><script src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin=anonymous></script><script src=https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin=anonymous></script><script src=https://cdnjs.cloudflare.com/ajax/libs/lozad.js/1.16.0/lozad.min.js integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin=anonymous></script><script src=https://cdnjs.cloudflare.com/ajax/libs/pangu/4.0.7/pangu.min.js integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin=anonymous></script><script src=/js/comments.js></script><script src=/js/utils.js></script><script src=/js/motion.js></script><script src=/js/schemes/muse.js></script><script src=/js/next-boot.js></script><script src=/js/pjax.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.0/search.js integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin=anonymous></script><script src=/js/third-party/search/local-search.js></script><script class=next-config data-name=pdf type=application/json>{"object_url":{"url":"https://cdnjs.cloudflare.com/ajax/libs/pdfobject/2.2.8/pdfobject.min.js","integrity":"sha256-tu9j5pBilBQrWSDePOOajCUdz6hWsid/lBNzK4KgEPM="},"url":"/lib/pdf/web/viewer.html"}</script><script src=/js/third-party/tags/pdf.js></script><script class=next-config data-name=mermaid type=application/json>{"enable":true,"theme":{"light":"default","dark":"dark"},"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mermaid/9.1.1/mermaid.min.js","integrity":"sha256-8L3O8tirFUa8Va4NSTAyIbHJeLd6OnlcxgupV9F77e0="}}</script><script src=/js/third-party/tags/mermaid.js></script><script src=/js/third-party/fancybox.js></script><script data-pjax async src=https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script><script class=next-config data-name=leancloud_visitors type=application/json>{"enable":true,"app_id":"Q8qpjA3fOO7FEUBqcmcQFptF-gzGzoHsz","app_key":"tgUTq5bX3fVmn916EMRe65eJ","server_url":null,"security":false}</script><script src=/js/third-party/statistics/lean-analytics.js></script><script class=next-config data-name=enableMath type=application/json>true</script><script class=next-config data-name=mathjax type=application/json>{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.1/es5/tex-mml-chtml.js","integrity":"sha256-hlC2uSQYTmPsrzGZTEQEg9PZ1a/+SV6VBCTclohf2og="}}</script><script src=/js/third-party/math/mathjax.js></script><script class=next-config data-name=utterances type=application/json>{"enable":true,"repo":"Winddoing/winddoing.github.io","issue_term":"title","theme":"github-light"}</script><script src=/js/third-party/comments/utterances.js></script></body></html>