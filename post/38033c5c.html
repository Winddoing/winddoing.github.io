<!DOCTYPE html><html lang=zh-CN><head><meta charset=UTF-8><meta name=viewport content="width=device-width"><meta name=theme-color content=#222 media="(prefers-color-scheme: light)"><meta name=theme-color content=#222 media="(prefers-color-scheme: dark)"><meta name=generator content="Hexo 6.2.0"><link rel=preconnect href=https://fonts.googleapis.com crossorigin><link rel=preconnect href=https://cdnjs.cloudflare.com crossorigin><link rel=apple-touch-icon sizes=180x180 href=/images/apple-touch-icon-next.png><link rel=icon type=image/png sizes=32x32 href=/favicon.ico><link rel=icon type=image/png sizes=16x16 href=/favicon.ico><link rel=mask-icon href=/images/logo.svg color=#222><meta name=baidu-site-verification content=WIIeufYjj6><link rel=stylesheet href=/css/main.css><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Microsoft+YaHei:300,300italic,400,400italic,700,700italic%7Ccmmi10:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin=anonymous><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin=anonymous><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin=anonymous><script class=next-config data-name=main type=application/json>{"hostname":"winddoing.github.io","root":"/","images":"/images","scheme":"Mist","darkmode":true,"version":"8.12.1","exturl":true,"sidebar":{"position":"right","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"default"},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":"utterances","storage":true,"lazyload":false,"nav":null,"activeClass":"utterances"},"stickytabs":false,"motion":{"enable":true,"async":true,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src=/js/config.js></script><meta name=description content="CMA，Contiguous Memory Allocator，是内存管理子系统中的一个模块，预留内存的配置解析和管理内存配置。一般系统会在启动过程中，从整个memory中配置一段连续内存用于CMA，然后内核其他的模块可以通过CMA的接口API进行连续内存的分配。CMA的核心并不是设计精巧的算法来管理地址连续的内存块，实际上它的底层还是依赖内核伙伴系统这样的内存管理机制，或者说CMA是处于需要连续"><meta property=og:type content=article><meta property=og:title content=LInux内核——CMA><meta property=og:url content=https://winddoing.github.io/post/38033c5c.html><meta property=og:site_name content="Winddoing&#39;s Notes"><meta property=og:description content="CMA，Contiguous Memory Allocator，是内存管理子系统中的一个模块，预留内存的配置解析和管理内存配置。一般系统会在启动过程中，从整个memory中配置一段连续内存用于CMA，然后内核其他的模块可以通过CMA的接口API进行连续内存的分配。CMA的核心并不是设计精巧的算法来管理地址连续的内存块，实际上它的底层还是依赖内核伙伴系统这样的内存管理机制，或者说CMA是处于需要连续"><meta property=og:locale content=zh_CN><meta property=article:published_time content=2022-10-17T09:27:00.000Z><meta property=article:modified_time content=2023-12-16T04:58:17.921Z><meta property=article:author content=winddoing><meta property=article:tag content=linux><meta property=article:tag content=内存管理><meta name=twitter:card content=summary><link rel=canonical href=https://winddoing.github.io/post/38033c5c.html><script class=next-config data-name=page type=application/json>{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://winddoing.github.io/post/38033c5c.html","path":"post/38033c5c.html","title":"LInux内核——CMA"}</script><script class=next-config data-name=calendar type=application/json>""</script><title>LInux内核——CMA | Winddoing's Notes</title><script src=/js/third-party/analytics/baidu-analytics.js></script><script async src=https://hm.baidu.com/hm.js?b96a560ce0a6bfbeaaddc59dc5888b75></script><noscript><link rel=stylesheet href=/css/noscript.css></noscript></head><body itemscope itemtype=http://schema.org/WebPage class=use-motion><div class=headband></div><main class=main><header class=header itemscope itemtype=http://schema.org/WPHeader><div class=header-inner><div class=site-brand-container><div class=site-nav-toggle><div class=toggle aria-label=切换导航栏 role=button><span class=toggle-line></span> <span class=toggle-line></span> <span class=toggle-line></span></div></div><div class=site-meta><a href="/" class=brand rel=start><i class=logo-line></i><p class=site-title>Winddoing's Notes</p><i class=logo-line></i></a><p class=site-subtitle itemprop=description>Follow Excellent, Success will Chase you</p></div><div class=site-nav-right><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class=site-nav><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel=section><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel=section><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel=section><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel=section><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-search"><a role=button class=popup-trigger><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class=search-pop-overlay><div class="popup search-popup"><div class=search-header><span class=search-icon><i class="fa fa-search"></i></span><div class=search-input-container><input autocomplete=off autocapitalize=off maxlength=80 placeholder=搜索... spellcheck=false type=search class=search-input></div><span class=popup-btn-close role=button><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class=search-result-icon><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></div><div class="toggle sidebar-toggle" role=button><span class=toggle-line></span> <span class=toggle-line></span> <span class=toggle-line></span></div><aside class=sidebar><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class=sidebar-nav><li class=sidebar-nav-toc>文章目录</li><li class=sidebar-nav-overview>站点概览</li></ul><div class=sidebar-panel-container><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class=nav><li class="nav-item nav-level-2"><a class=nav-link href=#CMA%E6%9C%80%E5%88%9D%E7%9A%84%E7%9B%AE%E7%9A%84><span class=nav-number>1.</span> <span class=nav-text>CMA最初的目的</span></a></li><li class="nav-item nav-level-2"><a class=nav-link href=#CMA%E4%BD%BF%E7%94%A8><span class=nav-number>2.</span> <span class=nav-text>CMA使用</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#%E8%AE%BE%E5%A4%87%E6%A0%91%E6%8C%87%E5%AE%9A><span class=nav-number>2.1.</span> <span class=nav-text>设备树指定</span></a></li><li class="nav-item nav-level-3"><a class=nav-link href=#cmdline%E6%8C%87%E5%AE%9A><span class=nav-number>2.2.</span> <span class=nav-text>cmdline指定</span></a></li><li class="nav-item nav-level-3"><a class=nav-link href=#menuconfig%E6%8C%87%E5%AE%9A><span class=nav-number>2.3.</span> <span class=nav-text>menuconfig指定</span></a></li></ol></li><li class="nav-item nav-level-2"><a class=nav-link href=#%E5%8E%9F%E7%90%86><span class=nav-number>3.</span> <span class=nav-text>原理</span></a></li><li class="nav-item nav-level-2"><a class=nav-link href=#%E4%B8%BB%E8%A6%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84><span class=nav-number>4.</span> <span class=nav-text>主要数据结构</span></a></li><li class="nav-item nav-level-2"><a class=nav-link href=#%E7%B3%BB%E7%BB%9FCMA%E8%B0%83%E8%AF%95%E4%BF%A1%E6%81%AF><span class=nav-number>5.</span> <span class=nav-text>系统CMA调试信息</span></a></li><li class="nav-item nav-level-2"><a class=nav-link href=#%E5%BA%94%E7%94%A8%E2%80%94%E2%80%94memuconfig%E6%8C%87%E5%AE%9A><span class=nav-number>6.</span> <span class=nav-text>应用——memuconfig指定</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#CMA%E9%A2%84%E7%95%99%E5%A4%A7%E5%B0%8F><span class=nav-number>6.1.</span> <span class=nav-text>CMA预留大小</span></a></li><li class="nav-item nav-level-3"><a class=nav-link href=#%E7%B3%BB%E7%BB%9Ffree%E6%98%AF%E5%90%A6%E7%BB%9F%E8%AE%A1CMA%E5%86%85%E5%AD%98><span class=nav-number>6.2.</span> <span class=nav-text>系统free是否统计CMA内存</span></a></li><li class="nav-item nav-level-3"><a class=nav-link href=#CMA%E9%A2%84%E7%95%99%E5%86%85%E5%AD%98%E4%B8%8E%E7%B3%BB%E7%BB%9F%E5%86%85%E5%AD%98%E5%85%B3%E7%B3%BB><span class=nav-number>6.3.</span> <span class=nav-text>CMA预留内存与系统内存关系</span></a></li></ol></li><li class="nav-item nav-level-2"><a class=nav-link href=#%E9%97%AE%E9%A2%98%E2%80%94%E2%80%94PFNs-busy><span class=nav-number>7.</span> <span class=nav-text>问题——PFNs busy</span></a></li><li class="nav-item nav-level-2"><a class=nav-link href=#%E5%8F%82%E8%80%83><span class=nav-number>8.</span> <span class=nav-text>参考</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author site-overview-item animated" itemprop=author itemscope itemtype=http://schema.org/Person><img class=site-author-image itemprop=image alt=winddoing src=/images/Winddoing.jpg><p class=site-author-name itemprop=name>winddoing</p><div class=site-description itemprop=description>失败缘于忽视细处，成功始于重视小事</div></div><div class="site-state-wrap site-overview-item animated"><nav class=site-state><div class="site-state-item site-state-posts"><a href="/archives/"><span class=site-state-item-count>358</span> <span class=site-state-item-name>日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class=site-state-item-count>112</span> <span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class=site-state-item-count>284</span> <span class=site-state-item-name>标签</span></a></div></nav></div><div class="links-of-author site-overview-item animated"><span class=links-of-author-item><span class=exturl data-url="aHR0cHM6Ly9naXRodWIuY29tL1dpbmRkb2luZw==" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Winddoing"><i class="fab fa-github fa-fw"></i>GitHub</span></span> <span class=links-of-author-item><span class=exturl data-url=aHR0cHM6Ly9naXRlZS5jb20vd2luZGRvaW5n title="Gitee → https:&#x2F;&#x2F;gitee.com&#x2F;winddoing"><i class="fab fa-codiepie fa-fw"></i>Gitee</span></span> <span class=links-of-author-item><span class=exturl data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS91c2Vycy85NTY3MzYxL3dpbmRkb2luZw==" title="StackOverflow → https:&#x2F;&#x2F;stackoverflow.com&#x2F;users&#x2F;9567361&#x2F;winddoing"><i class="fab fa-stack-overflow fa-fw"></i>StackOverflow</span></span> <span class=links-of-author-item><span class=exturl data-url="aHR0cHM6Ly9hcHAudHJhdmlzLWNpLmNvbS9naXRodWIvV2luZGRvaW5nL3dpbmRkb2luZy5naXRodWIuaW8=" title="Travis CI → https:&#x2F;&#x2F;app.travis-ci.com&#x2F;github&#x2F;Winddoing&#x2F;winddoing.github.io"><i class="fas fa-terminal fa-fw"></i>Travis CI</span></span></div><div class="cc-license site-overview-item animated" itemprop=license><span class="exturl cc-opacity" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC8="><img src=https://cdnjs.cloudflare.com/ajax/libs/creativecommons-vocabulary/2020.11.3/assets/license_badges/small/by_nc_sa.svg alt="Creative Commons"></span></div><div class="links-of-blogroll site-overview-item animated"><div class=links-of-blogroll-title><i class="link fa-fw"></i> Links</div><ul class=links-of-blogroll-list><li class=links-of-blogroll-item><span class=exturl data-url="aHR0cHM6Ly93aW5kZG9pbmcuZ2l0Ym9vay5pby9lbWJlZGRlZF9saW51eF9ub3Rlcy8=" title=https:&#x2F;&#x2F;winddoing.gitbook.io&#x2F;embedded_linux_notes&#x2F;>嵌入式相关</span></li><li class=links-of-blogroll-item><span class=exturl data-url="aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2RyZWFtcQ==" title=http:&#x2F;&#x2F;blog.csdn.net&#x2F;sdreamq>CSDN</span></li><li class=links-of-blogroll-item><span class=exturl data-url=aHR0cDovL3d3dy53b3dvdGVjaC5uZXQv title=http:&#x2F;&#x2F;www.wowotech.net&#x2F;>蜗窝科技</span></li><li class=links-of-blogroll-item><span class=exturl data-url=aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpb25neGlhbnpl title=https:&#x2F;&#x2F;blog.csdn.net&#x2F;xiongxianze>xiongxianze</span></li></ul></div><div id=days></div><script>
function show_date_time(){
    window.setTimeout("show_date_time()", 1000);
    BirthDay=new Date("02/26/2014 15:00:00");
    today=new Date();
    timeold=(today.getTime()-BirthDay.getTime());
    sectimeold=timeold/1000
        secondsold=Math.floor(sectimeold);
    msPerDay=24*60*60*1000
        e_daysold=timeold/msPerDay
        daysold=Math.floor(e_daysold);
    e_hrsold=(e_daysold-daysold)*24;
    hrsold=setzero(Math.floor(e_hrsold));
    e_minsold=(e_hrsold-hrsold)*60;
    minsold=setzero(Math.floor((e_hrsold-hrsold)*60));
    seconds=setzero(Math.floor((e_minsold-minsold)*60));
    document.getElementById('days').innerHTML="已运行"+daysold+"天"+hrsold+"小时"+minsold+"分"+seconds+"秒";
}
function setzero(i){
    if (i<10)
    {i="0" + i};
    return i;
}
show_date_time();
</script></div></div></div></aside><div class=sidebar-dimmer></div></header><div class=back-to-top role=button aria-label=返回顶部><i class="fa fa-arrow-up"></i> <span>0%</span></div><div class=reading-progress-bar></div><noscript><div class=noscript-warning>Theme NexT works best with JavaScript enabled</div></noscript><div class="main-inner post posts-expand"><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang=zh-CN><link itemprop=mainEntityOfPage href=https://winddoing.github.io/post/38033c5c.html><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content=/images/Winddoing.jpg><meta itemprop=name content=winddoing></span> <span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Winddoing's Notes"><meta itemprop=description content=失败缘于忽视细处，成功始于重视小事></span> <span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="LInux内核——CMA | Winddoing's Notes"><meta itemprop=description></span><header class=post-header><h1 class=post-title itemprop="name headline">LInux内核——CMA</h1><div class=post-meta-container><div class=post-meta><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-calendar"></i></span> <span class=post-meta-item-text>发表于</span><time title="创建时间：2022-10-17 17:27:00" itemprop="dateCreated datePublished" datetime=2022-10-17T17:27:00+08:00>2022-10-17</time></span> <span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-folder"></i></span> <span class=post-meta-item-text>分类于</span> <span itemprop=about itemscope itemtype=http://schema.org/Thing><a href="/categories/Linux%E5%86%85%E6%A0%B8/" itemprop=url rel=index><span itemprop=name>Linux内核</span></a></span></span> <span id=/post/38033c5c.html class="post-meta-item leancloud_visitors" data-flag-title=LInux内核——CMA title=阅读次数><span class=post-meta-item-icon><i class="far fa-eye"></i></span> <span class=post-meta-item-text>阅读次数：</span> <span class=leancloud-visitors-count></span></span> <span class=post-meta-item title=阅读次数 id=busuanzi_container_page_pv><span class=post-meta-item-icon><i class="far fa-eye"></i></span> <span class=post-meta-item-text>阅读次数：</span> <span id=busuanzi_value_page_pv></span></span> <span class=post-meta-break></span> <span class=post-meta-item title=本文字数><span class=post-meta-item-icon><i class="far fa-file-word"></i></span> <span class=post-meta-item-text>本文字数：</span> <span>17k</span></span> <span class=post-meta-item title=阅读时长><span class=post-meta-item-icon><i class="far fa-clock"></i></span> <span class=post-meta-item-text>阅读时长 &asymp;</span> <span>16 分钟</span></span></div></div></header><div class=post-body itemprop=articleBody><p><code>CMA</code>，Contiguous Memory Allocator，是内存管理子系统中的一个模块，<strong>预留内存的配置解析和管理内存配置</strong>。一般系统会在启动过程中，从整个memory中配置一段连续内存用于CMA，然后内核其他的模块可以通过CMA的接口API进行连续内存的分配。CMA的核心并不是设计精巧的算法来管理地址连续的内存块，实际上它的底层还是依赖内核伙伴系统这样的内存管理机制，或者说CMA是处于需要连续内存块的其他内核模块（例如DMA mapping framework）和内存管理模块之间的一个中间层模块，主要功能包括：</p><ul><li>解析DTS或者命令行中的参数，确定CMA内存的区域，这样的区域我们定义为CMA area。</li><li>提供cma_alloc和cma_release两个接口函数用于分配和释放CMA pages</li><li>记录和跟踪CMA area中各个pages的状态</li><li>调用伙伴系统接口，进行真正的内存分配。</li></ul><span id=more></span><h2 id=CMA最初的目的><a href=#CMA最初的目的 class=headerlink title=CMA最初的目的></a>CMA最初的目的</h2><blockquote><p><span class=exturl data-url="aHR0cHM6Ly9sd24ubmV0L0FydGljbGVzLzM5NjY1Ny8=">https://lwn.net/Articles/396657/<i class="fa fa-external-link-alt"></i></span></p></blockquote><p>连续内存分配器(CMA)是一个框架，它允许为物理连续内存管理设置特定于计算机的配置。然后根据该配置为设备分配内存。<br>该框架的主要作用<strong>不是分配内存，而是解析和管理内存配置，以及充当设备驱动程序和可插入分配器之间的中介</strong>。因此，它不依赖于任何内存分配方法或策略。</p><h2 id=CMA使用><a href=#CMA使用 class=headerlink title=CMA使用></a>CMA使用</h2><p>cma区域可以通过<code>设备树</code>、<code>cmdline</code>和<code>menuconfig</code>指定，并且可以通过设备树的phandle机制和单独的设备绑定，具体的实现和原理说明如下:</p><h3 id=设备树指定><a href=#设备树指定 class=headerlink title=设备树指定></a>设备树指定</h3><p>在设备树中添加<code>reserved-memory</code>节点，并且compatible属性指定为shared-dma-pool，并在设备节点中通过memory-region引用该节点，</p><figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br></pre></td><td class=code><pre><span class=line>reserved-memory &#123;</span><br><span class=line>    #address-cells = &lt;2&gt;;</span><br><span class=line>    #size-cells = &lt;2&gt;;</span><br><span class=line>    ranges;</span><br><span class=line></span><br><span class=line>    /* Chipselect 2,00000000 is physically at 0x18000000 */</span><br><span class=line>    vram: vram@18000000 &#123;</span><br><span class=line>        /* 8 MB of designated video RAM */</span><br><span class=line>        compatible = &quot;shared-dma-pool&quot;;</span><br><span class=line>        reg = &lt;0x00000000 0x18000000 0 0x00800000&gt;;</span><br><span class=line>        no-map;</span><br><span class=line>    &#125;;</span><br><span class=line>&#125;;</span><br></pre></td></tr></table></figure><p>节点配置属性：</p><ul><li>compatible (optional) ——standard definition<ul><li><code>shared-dma-pool</code>： 表示一个内存区域，用于一组设备的DMA缓冲区共享池。操作系统可以使用它在必要时实例化必要的池管理子系统。</li><li>vendor specific, 特定于供应商的字符串，形式为，<vendor>,[<device>-]<usage></usage></device></vendor></li></ul></li><li>no-map (optional) —— empty property<ul><li>指示操作系统不能创建该区域的虚拟映射作为其系统内存的标准映射的一部分，也不允许在使用该区域的设备驱动程序控制之外的任何情况下对其进行投机性访问。</li></ul></li><li>reusable (optional) —— empty property<ul><li>操作系统可以使用该区域的内存，但该区域的设备驱动程序需要能够回收它。通常，这意味着操作系统可以使用该区域存储易失性数据或缓存数据，这些数据可以重新生成或迁移到其他地方。</li></ul></li></ul><p>详细参考文档：<code>Documentation/devicetree/bindings/reserved-memory/reserved-memory.txt</code></p><h3 id=cmdline指定><a href=#cmdline指定 class=headerlink title=cmdline指定></a>cmdline指定</h3><p>在uboot的<code>bootargs</code>可以添加cma属性指定cma区域</p><figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre></td><td class=code><pre><span class=line>cma=nn[MG]@[start[MG][-end[MG]]]</span><br><span class=line>        [ARM,X86,KNL]</span><br><span class=line>        Sets the size of kernel global memory area for</span><br><span class=line>        contiguous memory allocations and optionally the</span><br><span class=line>        placement constraint by the physical address range of</span><br><span class=line>        memory allocations. A value of 0 disables CMA</span><br><span class=line>        altogether. For more information, see</span><br><span class=line>        include/linux/dma-contiguous.h</span><br></pre></td></tr></table></figure><blockquote><p>Documentation&#x2F;admin-guide&#x2F;kernel-parameters.txt</p></blockquote><figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre></td><td class=code><pre><span class=line>cma=256M</span><br><span class=line>或</span><br><span class=line>cma=64M@0x0-0xb0000000</span><br></pre></td></tr></table></figure><h3 id=menuconfig指定><a href=#menuconfig指定 class=headerlink title=menuconfig指定></a>menuconfig指定</h3><p>CMA相关的menuconfig分别在<code>memory management options</code>和<code>library routines</code>里面</p><figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br></pre></td><td class=code><pre><span class=line>Memory Management options  ---&gt;</span><br><span class=line>  [*] Contiguous Memory Allocator</span><br><span class=line>  [ ]   CMA debug messages (DEVELOPMENT)</span><br><span class=line>  [*]   CMA debugfs interface</span><br><span class=line>  (7)   Maximum count of the CMA areas</span><br><span class=line></span><br><span class=line>Library routines  ---&gt;</span><br><span class=line>  [*] DMA Contiguous Memory Allocator</span><br><span class=line>        *** Default contiguous memory area size: ***</span><br><span class=line>  (1280) Size in Mega Bytes</span><br><span class=line>        Selected region size (Use mega bytes value only)  ---&gt;</span><br><span class=line>  (8)   Maximum PAGE_SIZE order of alignment for contiguous buffers</span><br></pre></td></tr></table></figure><h2 id=原理><a href=#原理 class=headerlink title=原理></a>原理</h2><p>CMA通过在启动阶段预先保留内存。这些内存叫做CMA区域，稍后返回给伙伴系统从而可以被用作正常申请。如果要保留内存，则需要恰好在底层<code>MEMBLOCK</code>分配器初始化之后，及大量内存被占用之前调用，并在伙伴系统建立之前调用。</p><ul><li>页迁移：</li></ul><p>当从伙伴系统申请内存的时候，需要提供一个gfp_mask参数。不管其他事情，这个参数指定了要申请内存的迁移类型。迁移类型是MIGRATE_MOVABLE，它背后的意思是在可移动页面上的数据可以被迁移（或者移动，因此而命名），这对于磁盘缓存或者进程页面来说很有效。为了使相同迁移类型的页面在一起，伙伴系统把页面组成 “页面块 (pageblock)”，每组都有一个指定的迁移类型。分配器根据请求的类型在不同的页面块上分配页。如果尝试失败，分配器会在其它页面块上分配并甚至修改页面块的迁移类型。这意味着一个不可移动的页可能分配自一个MIGRATE_MOVABLE页面块，并导致该页面块的迁移类型改变。这不是CMA想要的，所以它引入了一个MIGRATE_CMA类型，该类型又一个重要的属性: <strong>只有可移动页可以从MIGRATE_CMA页面块种分配</strong>。那么，在启动期间，当dma_congiguous_reserve()和dma_declare_contiguous()方法被调用的时候，CMA在memblock中预留一部分RAM，并在随后将其返还给伙伴系统，仅将其页面块的迁移类型置为MIGRATE_CMA. 最终的结果是所有预留的页都在伙伴系统里，所以它们都可以用于可移动页的分配。</p><ul><li>CMA分配与释放<figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre></td><td class=code><pre><span class=line>int alloc_contig_range(unsigned long start, unsigned long end, unsigned migratetype, gfp_t gfp_mask)</span><br><span class=line>void free_contig_range(unsigned long pfn, unsigned nr_pages);</span><br></pre></td></tr></table></figure>CMA分配，<code>dma_alloc_from_contiguous()</code>选择一个页范围，start和end参数指定了目标内存的页框个数（或PFN范围)。参数migratetype指定了潜在的迁移类型; 在CMA的情况下，这个参数就是MIGRATE_CMA。这个函数所做的第一件事是将包含 (start, end) 范围内的页面块标记为 MIGRATE_ISOLATE。伙伴系统不会去触动这种类型的页面块。改变迁移类型不会魔 法般地释放页面，因此接下来需要调用 __alloc_conting_migrate_range()。它扫 描PFN范围并寻找可以迁移的页面。迁移是将页面复制到系统其它内存部分并更新相 关引用的过程。迁移部份很直接，后面的部分需要内存管理子系统来完成。当数据迁 移完成，旧的页面被释放并回归伙伴系统。这就是为什么之前那些需要包含的页面块 一定要标记为 MIGRATE_ISOLATE 的原因。如果指定了其它的迁移类型，伙伴系统会 毫不犹豫地将它们用于其它类型的申请。</li></ul><p>现在所有 alloc_contig_range 关心的页都是空闲的了。该方法将从伙伴系统中取 出它们，并将这些页面块的类型改为 MIGRATE_CMA。然后将这些页返回给调用者。</p><p>CMA释放：调用free_contig_range函数迭代所有的页面并将其返还给伙伴系统。</p><blockquote><ul><li>当设备驱动不用时，内存管理系统将该区域用于分配和管理可移动类型页面；</li><li>当设备驱动使用时，此时已经分配的页面需要进行迁移，又用于连续内存分配；</li></ul></blockquote><h2 id=主要数据结构><a href=#主要数据结构 class=headerlink title=主要数据结构></a>主要数据结构</h2><figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br></pre></td><td class=code><pre><span class=line><span class=class><span class=keyword>struct</span> <span class=title>cma</span> &#123;</span></span><br><span class=line>    <span class=comment>//起始物理地址对应的页帧号，相当于起始地址</span></span><br><span class=line>    <span class=type>unsigned</span> <span class=type>long</span>   base_pfn;</span><br><span class=line>    <span class=comment>//当前CMA区域页的个数，也就内存总容量，页的默认大小4K</span></span><br><span class=line>    <span class=type>unsigned</span> <span class=type>long</span>   count;</span><br><span class=line>    <span class=comment>//使用bitmap机制维护当前CMA区域内存的物理页，每个bit代表一定数量的物理页，至于代表多少物理页与order_per_bit有关</span></span><br><span class=line>    <span class=type>unsigned</span> <span class=type>long</span>   *bitmap;</span><br><span class=line>    <span class=comment>//指明该CMA区域的bitmap中，每个bit代表的页数量为2^order值</span></span><br><span class=line>    <span class=type>unsigned</span> <span class=type>int</span> order_per_bit; <span class=comment>/* Order of pages represented by one bit */</span></span><br><span class=line>    <span class=class><span class=keyword>struct</span> <span class=title>mutex</span>    <span class=title>lock</span>;</span></span><br><span class=line><span class=meta>#<span class=keyword>ifdef</span> CONFIG_CMA_DEBUGFS</span></span><br><span class=line>    <span class=class><span class=keyword>struct</span> <span class=title>hlist_head</span> <span class=title>mem_head</span>;</span></span><br><span class=line>    <span class=type>spinlock_t</span> mem_head_lock;</span><br><span class=line><span class=meta>#<span class=keyword>endif</span></span></span><br><span class=line>    <span class=comment>//当前CMA区域的描述名</span></span><br><span class=line>    <span class=type>const</span> <span class=type>char</span> *name;</span><br><span class=line>&#125;;</span><br><span class=line></span><br><span class=line><span class=comment>//存放各个CMA区域的cma信息的数组</span></span><br><span class=line><span class=keyword>extern</span> <span class=class><span class=keyword>struct</span> <span class=title>cma</span> <span class=title>cma_areas</span>[<span class=title>MAX_CMA_AREAS</span>];</span></span><br><span class=line><span class=comment>//统计当前系统初始化的最大可用的cma区域数量</span></span><br><span class=line><span class=keyword>extern</span> <span class=type>unsigned</span> cma_area_count;</span><br></pre></td></tr></table></figure><h2 id=系统CMA调试信息><a href=#系统CMA调试信息 class=headerlink title=系统CMA调试信息></a>系统CMA调试信息</h2><ul><li>CMA区域内存统计<figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre></td><td class=code><pre><span class=line># cat /proc/meminfo | grep cma -i</span><br><span class=line>CmaTotal:        1310720 kB</span><br><span class=line>CmaFree:         1309472 kB</span><br></pre></td></tr></table></figure></li><li>各个CMA区域详细信息<figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre></td><td class=code><pre><span class=line># ls /sys/kernel/debug/cma/cma-reserved/</span><br><span class=line>alloc          bitmap         free           order_per_bit</span><br><span class=line>base_pfn       count          maxchunk       used</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre></td><td class=code><pre><span class=line># cat /sys/kernel/debug/cma/cma-reserved/count</span><br><span class=line>327680</span><br><span class=line></span><br><span class=line># cat /sys/kernel/debug/cma/cma-reserved/bitmap</span><br><span class=line>4294967295 4294967295 4294967295 4294967295 16777215 0 0 0 4294967295 4294967295 65535 0 4294967295 4294967295 65535 0 0 0 0 0 0 0</span><br><span class=line></span><br><span class=line># cat /sys/kernel/debug/cma/cma-reserved/order_per_bit</span><br><span class=line>0</span><br></pre></td></tr></table></figure></li><li><code>order_per_bit</code>,为0,表示bitmap中的每一位bit代表一个1（2^0）个物理页。</li><li><code>bitmap</code>： 其中的每一项占32bit，而每一bit代表的一个物理页的状态，<code>0</code>表示free，<code>1</code>表示已经分配。（bitmap的总数为count&#x2F;32, 327680&#x2F;32&#x3D;10240）</li></ul><blockquote><p>查看bitmap中的特殊数字</p><ul><li>4294967295 -&gt; 0xFFFFFFFF: 32位全1</li><li>16777215 -&gt; 0xFFFFFF: 24位全1</li><li>65535 -&gt; 0xFFFF: 16为全1</li></ul></blockquote><h2 id=应用——memuconfig指定><a href=#应用——memuconfig指定 class=headerlink title=应用——memuconfig指定></a>应用——memuconfig指定</h2><p>内核版本： <code>5.4.217</code></p><figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre></td><td class=code><pre><span class=line># dmesg | grep cma</span><br><span class=line>[    0.000000] cma: Reserved 1280 MiB at 0x0000000020000000</span><br><span class=line>[    0.000000] Memory: 553676K/1966080K available (9982K kernel code, 1174K rwdata, 3328K rodata, 896K init, 497K bss, 101684K reserved, 1310720K cma-reserved)</span><br></pre></td></tr></table></figure><blockquote><ul><li>当前系统内存2G，而cma预留了1280MB，这1280MB内存预留有谁决定？？</li><li>除去CMA预留的1280MB，内存剩余768MB，如果系统占用内存超过768MB事，如何处理？？？</li><li>2G系统内存，预留1280MB，为啥free看到的可用内存依然是1866MB，是不是CMA预留内存也可以被系统应用所使用？？？</li><li>如果CMA预留内存也可以被系统使用，那么后期内存碎片化严重时，在CMA中无法分配大内存区域时怎么办？？？</li></ul></blockquote><figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre></td><td class=code><pre><span class=line>0.000000] Call trace:</span><br><span class=line>[    0.000000]  dump_backtrace+0x0/0x19c</span><br><span class=line>[    0.000000]  show_stack+0x28/0x34</span><br><span class=line>[    0.000000]  dump_stack+0xa4/0xe4</span><br><span class=line>[    0.000000]  cma_declare_contiguous+0x2f4/0x330</span><br><span class=line>[    0.000000]  dma_contiguous_reserve_area+0x5c/0x8c</span><br><span class=line>[    0.000000]  dma_contiguous_reserve+0xe4/0x110</span><br><span class=line>[    0.000000]  arm64_memblock_init+0x200/0x270</span><br><span class=line>[    0.000000]  setup_arch+0x240/0x5c0</span><br><span class=line>[    0.000000]  start_kernel+0x90/0x468</span><br><span class=line>[    0.000000] cma: Reserved 1280 MiB at 0x0000000020000000</span><br></pre></td></tr></table></figure><p>函数调用栈：</p><figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre></td><td class=code><pre><span class=line>start_kernel</span><br><span class=line>  \-&gt; setup_arch</span><br><span class=line>    \-&gt; arm64_memblock_init</span><br><span class=line>      \-&gt; dma_contiguous_reserve</span><br><span class=line>        \-&gt; dma_contiguous_reserve_area</span><br><span class=line>          \-&gt; cma_declare_contiguous</span><br></pre></td></tr></table></figure><p>物理内存范围：</p><figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre></td><td class=code><pre><span class=line>                               总大小1920 MB</span><br><span class=line>    +-----------------------------------------------------------------------------+</span><br><span class=line>    |                                                                             |</span><br><span class=line>    |                                                                             |</span><br><span class=line>    +-----------------------------------------------------------------------------+</span><br><span class=line>0x7800 0000                                                                       0</span><br></pre></td></tr></table></figure><h3 id=CMA预留大小><a href=#CMA预留大小 class=headerlink title=CMA预留大小></a>CMA预留大小</h3><p>首先，确定<code>Reserved 1280 MiB</code>日志输出的位置，再找到其调用关系及cma预留大小的定义。</p><figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre></td><td class=code><pre><span class=line><span class=type>int</span> __init <span class="title function_">cma_declare_contiguous</span><span class=params>(<span class=type>phys_addr_t</span> base,</span></span><br><span class=line><span class=params>            <span class=type>phys_addr_t</span> size, <span class=type>phys_addr_t</span> limit,</span></span><br><span class=line><span class=params>            <span class=type>phys_addr_t</span> alignment, <span class=type>unsigned</span> <span class=type>int</span> order_per_bit,</span></span><br><span class=line><span class=params>            <span class=type>bool</span> fixed, <span class=type>const</span> <span class=type>char</span> *name, <span class=keyword>struct</span> cma **res_cma)</span></span><br><span class=line>&#123;</span><br><span class=line>  ...</span><br><span class=line>  pr_info(<span class=string>&quot;Reserved %ld MiB at %pa\n&quot;</span>, (<span class=type>unsigned</span> <span class=type>long</span>)size / SZ_1M,</span><br><span class=line>    &amp;base);</span><br><span class=line>  <span class=keyword>return</span> <span class=number>0</span></span><br><span class=line>&#125;</span><br></pre></td></tr></table></figure><blockquote><p>mm&#x2F;cma.c</p></blockquote><p>在<code>dma_contiguous_reserve</code>接口中指定需要预留的内存大小</p><figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br></pre></td><td class=code><pre><span class=line><span class=type>void</span> __init <span class="title function_">dma_contiguous_reserve</span><span class=params>(<span class=type>phys_addr_t</span> limit)</span></span><br><span class=line>&#123;</span><br><span class=line>    ...</span><br><span class=line>    &#125; <span class=keyword>else</span> &#123;</span><br><span class=line><span class=meta>#<span class=keyword>ifdef</span> CONFIG_CMA_SIZE_SEL_MBYTES</span></span><br><span class=line>        selected_size = size_bytes;</span><br><span class=line><span class=meta>#<span class=keyword>elif</span> defined(CONFIG_CMA_SIZE_SEL_PERCENTAGE)</span></span><br><span class=line>        selected_size = cma_early_percent_memory();</span><br><span class=line><span class=meta>#<span class=keyword>elif</span> defined(CONFIG_CMA_SIZE_SEL_MIN)</span></span><br><span class=line>        selected_size = min(size_bytes, cma_early_percent_memory());</span><br><span class=line><span class=meta>#<span class=keyword>elif</span> defined(CONFIG_CMA_SIZE_SEL_MAX)</span></span><br><span class=line>        selected_size = max(size_bytes, cma_early_percent_memory());</span><br><span class=line><span class=meta>#<span class=keyword>endif</span></span></span><br><span class=line>    &#125;</span><br><span class=line></span><br><span class=line>    <span class=keyword>if</span> (selected_size &amp;&amp; !dma_contiguous_default_area) &#123;</span><br><span class=line>        pr_debug(<span class=string>&quot;%s: reserving %ld MiB for global area\n&quot;</span>, __func__,</span><br><span class=line>             (<span class=type>unsigned</span> <span class=type>long</span>)selected_size / SZ_1M);</span><br><span class=line></span><br><span class=line>        dma_contiguous_reserve_area(selected_size, selected_base,</span><br><span class=line>                        selected_limit,</span><br><span class=line>                        &amp;dma_contiguous_default_area,</span><br><span class=line>                        fixed);</span><br><span class=line>    &#125;</span><br><span class=line>&#125;</span><br></pre></td></tr></table></figure><p>menuconfig中指定了<code>CONFIG_CMA_SIZE_SEL_MBYTES</code>，因此CMA预留内存大小为<code>size_bytes</code></p><figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br></pre></td><td class=code><pre><span class=line><span class=meta>#<span class=keyword>ifdef</span> CONFIG_CMA_SIZE_MBYTES</span></span><br><span class=line><span class=meta>#<span class=keyword>define</span> CMA_SIZE_MBYTES CONFIG_CMA_SIZE_MBYTES</span></span><br><span class=line><span class=meta>#<span class=keyword>else</span></span></span><br><span class=line><span class=meta>#<span class=keyword>define</span> CMA_SIZE_MBYTES 0</span></span><br><span class=line><span class=meta>#<span class=keyword>endif</span></span></span><br><span class=line></span><br><span class=line><span class=comment>/*</span></span><br><span class=line><span class=comment> * Default global CMA area size can be defined in kernel&#x27;s .config.</span></span><br><span class=line><span class=comment> * This is useful mainly for distro maintainers to create a kernel</span></span><br><span class=line><span class=comment> * that works correctly for most supported systems.</span></span><br><span class=line><span class=comment> * The size can be set in bytes or as a percentage of the total memory</span></span><br><span class=line><span class=comment> * in the system.</span></span><br><span class=line><span class=comment> *</span></span><br><span class=line><span class=comment> * Users, who want to set the size of global CMA area for their system</span></span><br><span class=line><span class=comment> * should use cma= kernel parameter.</span></span><br><span class=line><span class=comment> */</span></span><br><span class=line><span class=type>static</span> <span class=type>const</span> <span class=type>phys_addr_t</span> size_bytes = (<span class=type>phys_addr_t</span>)CMA_SIZE_MBYTES * SZ_1M;</span><br></pre></td></tr></table></figure><p>实际预留大小在menuconfig中进行配置：</p><figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre></td><td class=code><pre><span class=line>#</span><br><span class=line># Default contiguous memory area size:</span><br><span class=line>#</span><br><span class=line>CONFIG_CMA_SIZE_MBYTES=1280</span><br><span class=line>CONFIG_CMA_SIZE_SEL_MBYTES=y</span><br><span class=line># CONFIG_CMA_SIZE_SEL_PERCENTAGE is not set</span><br><span class=line># CONFIG_CMA_SIZE_SEL_MIN is not set</span><br><span class=line># CONFIG_CMA_SIZE_SEL_MAX is not set</span><br><span class=line>CONFIG_CMA_ALIGNMENT=8</span><br></pre></td></tr></table></figure><p>在<code>cma_declare_contiguous</code>函数中的memblock_phys_alloc_range接口申请了CMA内存区域。</p><figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre></td><td class=code><pre><span class=line>         + &lt;--------------------------+ 物理内存总大小1920MB +-------------------------&gt; +</span><br><span class=line>         |        + &lt;----------+ CMA区域大小1280MB +---------&gt; +                        |</span><br><span class=line>         |        |                                           |                        |</span><br><span class=line>         +-----------------------------------------------------------------------------+</span><br><span class=line>         |        |                CMA area                   |                        |</span><br><span class=line>         +--------+-------------------------------------------+------------------------+</span><br><span class=line>0x7800 0000    0x7000 0000                                0x2000 0000                  0</span><br><span class=line>                                                           cma base</span><br></pre></td></tr></table></figure><p>CMA base地址如何确定：随机还是指定？</p><ul><li>cmdline方式中可以指定CMA区域的base地址和大小</li><li>menuconfig方式中指定指定CMA区域的大小，base地址随机指定符合要求的区域。</li></ul><p>在<code>cma_declare_contiguous</code>函数中，通过<code>memblock_phys_alloc_range</code>接口申请完了CMA区域的内存后，紧接着使用<code>cma_init_reserved_mem</code>接口将其进行初始化。</p><p>初始化的目的指定CMA相应区域的参数，比如基址、大小等</p><p>CMA区域的个数可以进行配置，内核默认最多<code>8</code>个，因为<code>CONFIG_CMA_AREAS</code>默认值为7</p><figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre></td><td class=code><pre><span class=line><span class=class><span class=keyword>struct</span> <span class=title>cma</span> <span class=title>cma_areas</span>[<span class=title>MAX_CMA_AREAS</span>];</span></span><br><span class=line><span class=type>unsigned</span> cma_area_count;</span><br><span class=line></span><br><span class=line><span class=comment>//MAX_CMA_AREAS定义：</span></span><br><span class=line></span><br><span class=line><span class=comment>/*</span></span><br><span class=line><span class=comment> * There is always at least global CMA area and a few optional</span></span><br><span class=line><span class=comment> * areas configured in kernel .config.</span></span><br><span class=line><span class=comment> */</span></span><br><span class=line><span class=meta>#<span class=keyword>ifdef</span> CONFIG_CMA_AREAS</span></span><br><span class=line><span class=meta>#<span class=keyword>define</span> MAX_CMA_AREAS   (1 + CONFIG_CMA_AREAS)</span></span><br></pre></td></tr></table></figure><p>每个CMA区域将一定大小的内存申请后将通过<code>cma_init_reserved_mem</code>进行初始化，并将参数信息保存到<code>cma_areas</code>数组中。</p><p>使用memconfig进行CMA预留区域的指定，只会使用一个<code>cma_areas</code>数组项，而设计多个的目的是在设备树中可以指定多个不同的CMA预留区域。</p><figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br></pre></td><td class=code><pre><span class=line><span class=comment>/**</span></span><br><span class=line><span class=comment> * cma_init_reserved_mem() - create custom contiguous area from reserved memory</span></span><br><span class=line><span class=comment> * @base: Base address of the reserved area</span></span><br><span class=line><span class=comment> * @size: Size of the reserved area (in bytes),</span></span><br><span class=line><span class=comment> * @order_per_bit: Order of pages represented by one bit on bitmap.</span></span><br><span class=line><span class=comment> * @name: The name of the area. If this parameter is NULL, the name of</span></span><br><span class=line><span class=comment> *        the area will be set to &quot;cmaN&quot;, where N is a running counter of</span></span><br><span class=line><span class=comment> *        used areas.</span></span><br><span class=line><span class=comment> * @res_cma: Pointer to store the created cma region.</span></span><br><span class=line><span class=comment> *</span></span><br><span class=line><span class=comment> * This function creates custom contiguous area from already reserved memory.</span></span><br><span class=line><span class=comment> */</span></span><br><span class=line><span class=type>int</span> __init <span class="title function_">cma_init_reserved_mem</span><span class=params>(<span class=type>phys_addr_t</span> base, <span class=type>phys_addr_t</span> size,</span></span><br><span class=line><span class=params>                 <span class=type>unsigned</span> <span class=type>int</span> order_per_bit,</span></span><br><span class=line><span class=params>                 <span class=type>const</span> <span class=type>char</span> *name,</span></span><br><span class=line><span class=params>                 <span class=keyword>struct</span> cma **res_cma)</span></span><br><span class=line>&#123;</span><br><span class=line>  ...</span><br><span class=line>  cma = &amp;cma_areas[cma_area_count];</span><br><span class=line>  <span class=keyword>if</span> (name) &#123;</span><br><span class=line>      cma-&gt;name = name;</span><br><span class=line>  &#125; <span class=keyword>else</span> &#123;</span><br><span class=line>      cma-&gt;name = kasprintf(GFP_KERNEL, <span class=string>&quot;cma%d\n&quot;</span>, cma_area_count);</span><br><span class=line>      <span class=keyword>if</span> (!cma-&gt;name)</span><br><span class=line>          <span class=keyword>return</span> -ENOMEM;</span><br><span class=line>  &#125;</span><br><span class=line>  cma-&gt;base_pfn = PFN_DOWN(base);</span><br><span class=line>  cma-&gt;count = size &gt;&gt; PAGE_SHIFT;</span><br><span class=line>  cma-&gt;order_per_bit = order_per_bit;</span><br><span class=line>  *res_cma = cma;</span><br><span class=line>  cma_area_count++;</span><br><span class=line>  totalcma_pages += (size / PAGE_SIZE);</span><br><span class=line></span><br><span class=line>  <span class=keyword>return</span> <span class=number>0</span>;</span><br><span class=line>&#125;</span><br></pre></td></tr></table></figure><p>各个CMA预留区域的内存页初始化：</p><p>系统启动初期根据各种参数，预留CMA区域的物理内存，将其基地址和大小进行确认，并检查其合法性；系统启动过程中，调用<code>cma_init_reserved_areas</code>接口对个CMA区域内存进行初始化后， CMA就可用供其他模块、设备和子系统使用。</p><figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre></td><td class=code><pre><span class=line>core_initcall(cma_init_reserved_areas)</span><br><span class=line>  cma_init_reserved_areas</span><br><span class=line>    \-&gt; 遍历cma_areas数组进行初始化</span><br><span class=line>    |-&gt; cma_activate_area</span><br><span class=line>      \-&gt; cma-&gt;bitmap = bitmap_zalloc(cma_bitmap_maxno(cma), GFP_KERNEL)</span><br><span class=line>      |-&gt; init_cma_reserved_pageblock</span><br><span class=line>        \-&gt; set_pageblock_migratetype(page, MIGRATE_CMA);</span><br><span class=line>        |-&gt; __free_pages</span><br><span class=line>        |-&gt; adjust_managed_page_count</span><br></pre></td></tr></table></figure><p><code>init_cma_reserved_pageblock</code>接口将释放整个页面块并将其迁移类型设置为<code>MIGRATE_CMA</code>。</p><p>内核初始化过程中，通过core_initcall()函数将该 section 内的初始化 函数遍历执行，其中包括 CMA 的激活入口 cma_init_reserved_areas() 函数， 该函数遍历 CMA 分配的所有 CMA 分区并激活每一个 CMA 分区。在该函数中， 函数首先调用kzalloc()函数为CMA分区的bitmap所需的内存，然后调用<code>init_cma_reserved_pageblock()</code>函数，在该函数中，内核将CMA区块内的<strong>所有物理页都清除RESERVED标志，引用计数设置为0</strong>，接着按pageblock的方式设置区域内的页组迁移类型都是<code>MIGRATE_CMA</code>。函数继续调用set_page_refcounted()函数将引用计数设置为1以及调用<code>__free_pages()</code>函数将所有的页从CMA分配器中释放并归还给buddy管理器。最后调用<code>adjust_managed_page_count()</code>更新系统可用物理页总数。至此系统的其他部分可以开始使用CMA分配器分配的连续物理内存。</p><h3 id=系统free是否统计CMA内存><a href=#系统free是否统计CMA内存 class=headerlink title=系统free是否统计CMA内存></a>系统free是否统计CMA内存</h3><blockquote><p>结论：free会统计CMA区域内存。</p></blockquote><p>因为CMA区域中的page被设置为<code>MIGRATE_CMA</code>,然后放入<code>伙伴系统</code>中，等待用户使用（NOTE：MIGRATE_CMA是伙伴系统中页属性的概念,所以CMA区也只是伙伴系统中的一个概念，不是一个ZONE）,这样进行初始化后，free统计时也会将CMA区域的内存统计进去。</p><h3 id=CMA预留内存与系统内存关系><a href=#CMA预留内存与系统内存关系 class=headerlink title=CMA预留内存与系统内存关系></a>CMA预留内存与系统内存关系</h3><blockquote><p>结论：CMA区域的内存即是预留内存（reserved），也是系统内存（memory）；也就是说CMA区域这部分内存除了设备驱动申请DMA内存使用外，在系统内存不足时可以使用，</p></blockquote><p>系统中何时使用CMA区域内存：</p><ul><li>设备驱动中主动申请DMA内存时使用，这个每个驱动实现不同由驱动工程师自主控制。</li><li>系统应用程序的使用，也就是申请内存时如何使用MIGRATE_CMA page？</li></ul><h2 id=问题——PFNs-busy><a href=#问题——PFNs-busy class=headerlink title="问题——PFNs busy"></a>问题——PFNs busy</h2><figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre></td><td class=code><pre><span class=line>[  136.103382] alloc_contig_range: [22200, 22ef4) PFNs busy</span><br><span class=line>[  136.110892] alloc_contig_range: [22400, 22ff4) PFNs busy</span><br><span class=line>[  136.118504] alloc_contig_range: [22400, 230f4) PFNs busy</span><br><span class=line>[  136.126102] alloc_contig_range: [22400, 231f4) PFNs busy</span><br><span class=line>[  136.133735] alloc_contig_range: [22400, 232f4) PFNs busy</span><br><span class=line>[  136.141229] alloc_contig_range: [22800, 233f4) PFNs busy</span><br><span class=line>[  136.148870] alloc_contig_range: [22800, 234f4) PFNs busy</span><br><span class=line>[  136.156469] alloc_contig_range: [22800, 235f4) PFNs busy</span><br><span class=line>[  136.164026] alloc_contig_range: [22800, 236f4) PFNs busy</span><br></pre></td></tr></table></figure><p>函数调用栈：</p><figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre></td><td class=code><pre><span class=line>dma_alloc_coherent</span><br><span class=line>  \-&gt; dma_alloc_attrs</span><br><span class=line>    \-&gt; dma_direct_alloc</span><br><span class=line>      \-&gt; arch_dma_alloc</span><br><span class=line>        \-&gt; __dma_direct_alloc_pages</span><br><span class=line>          \-&gt; dma_alloc_contiguous</span><br><span class=line>            \-&gt; cma_alloc</span><br><span class=line>              \-&gt; alloc_contig_range</span><br><span class=line>                \-&gt; pr_info_ratelimited(&quot;...PFNs busy\n&quot;)</span><br></pre></td></tr></table></figure><p><code>alloc_contig_range</code>从伙伴系统中分配一定大小的物理页，该接口参数会指定页的起始和结束号。<br>PFN范围不必是pageblock或MAX_ORDER_NR_PAGES对齐的。PFN范围必须属于一个单独的区域。<br>这个例程做的第一件事是尝试MIGRATE_ISOLATE范围内的所有页面块。一旦隔离(isolated)，页面块不应该被其他人修改。</p><figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br><span class=line>52</span><br><span class=line>53</span><br><span class=line>54</span><br><span class=line>55</span><br><span class=line>56</span><br><span class=line>57</span><br><span class=line>58</span><br><span class=line>59</span><br><span class=line>60</span><br><span class=line>61</span><br><span class=line>62</span><br><span class=line>63</span><br><span class=line>64</span><br><span class=line>65</span><br><span class=line>66</span><br><span class=line>67</span><br><span class=line>68</span><br><span class=line>69</span><br><span class=line>70</span><br><span class=line>71</span><br><span class=line>72</span><br><span class=line>73</span><br><span class=line>74</span><br><span class=line>75</span><br><span class=line>76</span><br><span class=line>77</span><br><span class=line>78</span><br><span class=line>79</span><br><span class=line>80</span><br><span class=line>81</span><br><span class=line>82</span><br><span class=line>83</span><br><span class=line>84</span><br><span class=line>85</span><br><span class=line>86</span><br><span class=line>87</span><br><span class=line>88</span><br><span class=line>89</span><br><span class=line>90</span><br><span class=line>91</span><br><span class=line>92</span><br><span class=line>93</span><br><span class=line>94</span><br><span class=line>95</span><br><span class=line>96</span><br><span class=line>97</span><br><span class=line>98</span><br><span class=line>99</span><br><span class=line>100</span><br><span class=line>101</span><br><span class=line>102</span><br><span class=line>103</span><br><span class=line>104</span><br><span class=line>105</span><br><span class=line>106</span><br><span class=line>107</span><br><span class=line>108</span><br><span class=line>109</span><br><span class=line>110</span><br><span class=line>111</span><br><span class=line>112</span><br><span class=line>113</span><br><span class=line>114</span><br><span class=line>115</span><br><span class=line>116</span><br></pre></td><td class=code><pre><span class=line><span class=type>int</span> <span class="title function_">alloc_contig_range</span><span class=params>(<span class=type>unsigned</span> <span class=type>long</span> start, <span class=type>unsigned</span> <span class=type>long</span> end,</span></span><br><span class=line><span class=params>               <span class=type>unsigned</span> migratetype, <span class=type>gfp_t</span> gfp_mask)</span></span><br><span class=line>&#123;</span><br><span class=line>	...</span><br><span class=line>	<span class=comment>/*</span></span><br><span class=line><span class=comment>	 * What we do here is we mark all pageblocks in range as</span></span><br><span class=line><span class=comment>	 * MIGRATE_ISOLATE.  Because pageblock and max order pages may</span></span><br><span class=line><span class=comment>	 * have different sizes, and due to the way page allocator</span></span><br><span class=line><span class=comment>	 * work, we align the range to biggest of the two pages so</span></span><br><span class=line><span class=comment>	 * that page allocator won&#x27;t try to merge buddies from</span></span><br><span class=line><span class=comment>	 * different pageblocks and change MIGRATE_ISOLATE to some</span></span><br><span class=line><span class=comment>	 * other migration type.</span></span><br><span class=line><span class=comment>	 *</span></span><br><span class=line><span class=comment>	 * Once the pageblocks are marked as MIGRATE_ISOLATE, we</span></span><br><span class=line><span class=comment>	 * migrate the pages from an unaligned range (ie. pages that</span></span><br><span class=line><span class=comment>	 * we are interested in).  This will put all the pages in</span></span><br><span class=line><span class=comment>	 * range back to page allocator as MIGRATE_ISOLATE.</span></span><br><span class=line><span class=comment>	 *</span></span><br><span class=line><span class=comment>	 * When this is done, we take the pages in range from page</span></span><br><span class=line><span class=comment>	 * allocator removing them from the buddy system.  This way</span></span><br><span class=line><span class=comment>	 * page allocator will never consider using them.</span></span><br><span class=line><span class=comment>	 *</span></span><br><span class=line><span class=comment>	 * This lets us mark the pageblocks back as</span></span><br><span class=line><span class=comment>	 * MIGRATE_CMA/MIGRATE_MOVABLE so that free pages in the</span></span><br><span class=line><span class=comment>	 * aligned range but not in the unaligned, original range are</span></span><br><span class=line><span class=comment>	 * put back to page allocator so that buddy can use them.</span></span><br><span class=line><span class=comment>	 */</span></span><br><span class=line></span><br><span class=line>	ret = start_isolate_page_range(pfn_max_align_down(start),           -----&lt;<span class=number>1</span>&gt;</span><br><span class=line>	                   pfn_max_align_up(end), migratetype, <span class=number>0</span>);</span><br><span class=line>	<span class=keyword>if</span> (ret &lt; <span class=number>0</span>)</span><br><span class=line>	    <span class=keyword>return</span> ret;</span><br><span class=line></span><br><span class=line>	<span class=comment>/*</span></span><br><span class=line><span class=comment>	 * In case of -EBUSY, we&#x27;d like to know which page causes problem.</span></span><br><span class=line><span class=comment>	 * So, just fall through. test_pages_isolated() has a tracepoint</span></span><br><span class=line><span class=comment>	 * which will report the busy page.</span></span><br><span class=line><span class=comment>	 *</span></span><br><span class=line><span class=comment>	 * It is possible that busy pages could become available before</span></span><br><span class=line><span class=comment>	 * the call to test_pages_isolated, and the range will actually be</span></span><br><span class=line><span class=comment>	 * allocated.  So, if we fall through be sure to clear ret so that</span></span><br><span class=line><span class=comment>	 * -EBUSY is not accidentally used or returned to caller.</span></span><br><span class=line><span class=comment>	 */</span></span><br><span class=line>	ret = __alloc_contig_migrate_range(&amp;cc, start, end);                 -----&lt;<span class=number>2</span>&gt;</span><br><span class=line>	<span class=keyword>if</span> (ret &amp;&amp; ret != -EBUSY)</span><br><span class=line>	    <span class=keyword>goto</span> done;</span><br><span class=line>	ret =<span class=number>0</span>;</span><br><span class=line></span><br><span class=line>	<span class=comment>/*</span></span><br><span class=line><span class=comment>	 * Pages from [start, end) are within a MAX_ORDER_NR_PAGES</span></span><br><span class=line><span class=comment>	 * aligned blocks that are marked as MIGRATE_ISOLATE.  What&#x27;s</span></span><br><span class=line><span class=comment>	 * more, all pages in [start, end) are free in page allocator.</span></span><br><span class=line><span class=comment>	 * What we are going to do is to allocate all pages from</span></span><br><span class=line><span class=comment>	 * [start, end) (that is remove them from page allocator).</span></span><br><span class=line><span class=comment>	 *</span></span><br><span class=line><span class=comment>	 * The only problem is that pages at the beginning and at the</span></span><br><span class=line><span class=comment>	 * end of interesting range may be not aligned with pages that</span></span><br><span class=line><span class=comment>	 * page allocator holds, ie. they can be part of higher order</span></span><br><span class=line><span class=comment>	 * pages.  Because of this, we reserve the bigger range and</span></span><br><span class=line><span class=comment>	 * once this is done free the pages we are not interested in.</span></span><br><span class=line><span class=comment>	 *</span></span><br><span class=line><span class=comment>	 * We don&#x27;t have to hold zone-&gt;lock here because the pages are</span></span><br><span class=line><span class=comment>	 * isolated thus they won&#x27;t get removed from buddy.</span></span><br><span class=line><span class=comment>	 */</span></span><br><span class=line></span><br><span class=line>	lru_add_drain_all();                                                -----&lt;<span class=number>3</span>&gt;</span><br><span class=line></span><br><span class=line>	order = <span class=number>0</span>;</span><br><span class=line>	outer_start = start;</span><br><span class=line>	<span class=keyword>while</span> (!PageBuddy(pfn_to_page(outer_start))) &#123;                      -----&lt;<span class=number>4</span>&gt;</span><br><span class=line>	    <span class=keyword>if</span> (++order &gt;= MAX_ORDER) &#123;</span><br><span class=line>	        outer_start = start;</span><br><span class=line>	        <span class=keyword>break</span>;</span><br><span class=line>	    &#125;</span><br><span class=line>	    outer_start &amp;= ~<span class=number>0UL</span> &lt;&lt; order;</span><br><span class=line>	&#125;</span><br><span class=line></span><br><span class=line>	<span class=keyword>if</span> (outer_start != start) &#123;</span><br><span class=line>	    order = page_order(pfn_to_page(outer_start));</span><br><span class=line></span><br><span class=line>	    <span class=comment>/*</span></span><br><span class=line><span class=comment>	     * outer_start page could be small order buddy page and</span></span><br><span class=line><span class=comment>	     * it doesn&#x27;t include start page. Adjust outer_start</span></span><br><span class=line><span class=comment>	     * in this case to report failed page properly</span></span><br><span class=line><span class=comment>	     * on tracepoint in test_pages_isolated()</span></span><br><span class=line><span class=comment>	     */</span></span><br><span class=line>	    <span class=keyword>if</span> (outer_start + (<span class=number>1UL</span> &lt;&lt; order) &lt;= start)</span><br><span class=line>	        outer_start = start;</span><br><span class=line>	&#125;</span><br><span class=line></span><br><span class=line>	<span class=comment>/* Make sure the range is really isolated. */</span></span><br><span class=line>	<span class=keyword>if</span> (test_pages_isolated(outer_start, end, <span class=literal>false</span>)) &#123;                 -----&lt;<span class=number>5</span>&gt;</span><br><span class=line>	    pr_info_ratelimited(<span class=string>&quot;%s: [%lx, %lx) PFNs busy\n&quot;</span>,</span><br><span class=line>	        __func__, outer_start, end);</span><br><span class=line>	    ret = -EBUSY;</span><br><span class=line>	    <span class=keyword>goto</span> done;</span><br><span class=line>	&#125;</span><br><span class=line></span><br><span class=line>	<span class=comment>/* Grab isolated pages from freelists. */</span></span><br><span class=line>	outer_end = isolate_freepages_range(&amp;cc, outer_start, end);         -----&lt;<span class=number>6</span>&gt;</span><br><span class=line>	<span class=keyword>if</span> (!outer_end) &#123;</span><br><span class=line>	    ret = -EBUSY;</span><br><span class=line>	    <span class=keyword>goto</span> done;</span><br><span class=line>	&#125;</span><br><span class=line></span><br><span class=line>	<span class=comment>/* Free head and tail (if any) */</span></span><br><span class=line>	<span class=keyword>if</span> (start != outer_start)</span><br><span class=line>	    free_contig_range(outer_start, start - outer_start);</span><br><span class=line>	<span class=keyword>if</span> (end != outer_end)</span><br><span class=line>	    free_contig_range(end, outer_end - end);</span><br><span class=line></span><br><span class=line>done:</span><br><span class=line>    undo_isolate_page_range(pfn_max_align_down(start),                -----&lt;<span class=number>7</span>&gt;</span><br><span class=line>                pfn_max_align_up(end), migratetype);</span><br><span class=line>    <span class=keyword>return</span> ret;</span><br><span class=line>&#125;</span><br></pre></td></tr></table></figure><ul><li><p>&lt;1&gt;: start_isolate_page_range将pfn范围内的页设置为隔离（MIGRATE_ISOLATE）</p><ul><li>将页面分配类型设置为<code>MIGRATE_ISOLATE</code>意味着将永远不会分配范围内的空闲页面。任何空闲页面和将来释放的页面将不会再次分配。如果指定的范围包括MOVABLE或CMA以外的迁移类型，则会使用-EBUSY失败。为了最终隔离范围内的所有页面，调用者必须释放范围内的全部页面。test_page_isolated()可以用于测试它。</li><li>请注意，<strong>也没有与页面分配器的强同步。当页面块标记为“已隔离”时，页面可能会被释放</strong>。在某些情况下，页面可能仍然会出现在pcp列表中，这将允许它们的分配，即使它们实际上已经被隔离。根据调用方需要的保证程度，可能需要drain_all_pages（例如__offline_pages需要在检查隔离范围后调用它，以便下次重试）。</li><li>一旦页面块被标记为MIGRATE_ISOLATE，我们就从未对齐的范围（即我们感兴趣的页面）迁移页面。这将把范围内的所有页面作为MIGRATE_ISOLATE放回页面分配器。</li><li>完成此操作后，我们从页面分配器中获取范围内的页面，并将其从伙伴系统中删除。这样，页面分配器将永远不会考虑使用它们。</li><li>这使我们可以将页面块标记回MIGRATE_CMA&#x2F;MIGRATE_MOVABLE，以便将对齐范围内的空闲页面（而不是未对齐的原始范围内的）放回页面分配器，以便好友可以使用它们。</li></ul></li><li><p>&lt;2&gt;: __alloc_contig_migrate_range申请pfn范围内的页，扫描PFN范围页并寻找可迁移的进行迁移，可能返回BUSY，因为存在页无法迁移。</p></li><li><p>&lt;3&gt;: lru_add_drain_all对所有CPU实现缓存的刷新,将每CPU中缓存的页面进行释放</p></li><li><p>&lt;4&gt;: PageBuddy判断一个页是是否在buddy系统中，如果是1，说明还没有分配出去</p></li><li><p>&lt;5&gt;: test_pages_isolated用于检查确保该pfn范围内的页面已经被隔离</p></li><li><p>&lt;6&gt;: isolate_freepages_range则是将指定范围的空闲页面隔离出来</p></li><li><p>&lt;7&gt;: undo_isolate_page_range则是将所有的标记为隔离的页面重新标记为MIGRATE_CMA，至此所需的连续内存页面已经分配到了，无需在乎其迁移属性了，便更改回去。</p></li></ul><blockquote><p>出现<code>PFNs busy</code>是由于在&lt;5&gt;test_pages_isolated中检查到申请pfn范围内的页有没有被隔离出来，才会输出警告信息<br>而没有被隔离的原因是，这些页可能被系统中的其他应用所占用着，而无法被迁移。</p></blockquote><h2 id=参考><a href=#参考 class=headerlink title=参考></a>参考</h2><ul><li><span class=exturl data-url="aHR0cHM6Ly9sd24ubmV0L0FydGljbGVzLzM5NjY1Ny8=">The Contiguous Memory Allocator<i class="fa fa-external-link-alt"></i></span></li><li><span class=exturl data-url=aHR0cHM6Ly9iaXNjdWl0b3MuZ2l0aHViLmlvL2Jsb2cvQ01BLyNBMDAw>CMA<i class="fa fa-external-link-alt"></i></span></li></ul></div><footer class=post-footer><div class=post-copyright><ul><li class=post-copyright-author><strong>本文作者：</strong>winddoing</li><li class=post-copyright-link><strong>本文链接：</strong> <a href=https://winddoing.github.io/post/38033c5c.html title=LInux内核——CMA>https://winddoing.github.io/post/38033c5c.html</a></li><li class=post-copyright-license><strong>版权声明：</strong>本博客所有文章除特别声明外，均采用 <span class=exturl data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC8="><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div><div class=post-tags><a href="/tags/linux/" rel=tag><i class="fa fa-tag"></i> linux</a> <a href="/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" rel=tag><i class="fa fa-tag"></i> 内存管理</a></div><div class=post-nav><div class=post-nav-item><a href=/post/cb918227.html rel=prev title=Linux内核调试——dynamic_debug><i class="fa fa-chevron-left"></i> Linux内核调试——dynamic_debug</a></div><div class=post-nav-item><a href=/post/f9e82db2.html rel=next title=用户空间互斥锁-mutex>用户空间互斥锁-mutex <i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><div class="comments utterances-container"></div></div></main><footer class=footer><div class=footer-inner><div class=copyright>&copy; 2014 – <span itemprop=copyrightYear>2023</span> <span class=with-love><i class="fa fa-heart"></i></span> <span class=author itemprop=copyrightHolder>winddoing</span></div><div class=wordcount><span class=post-meta-item><span class=post-meta-item-icon><i class="fa fa-chart-line"></i></span> <span title=站点总字数>1.1m</span></span> <span class=post-meta-item><span class=post-meta-item-icon><i class="fa fa-coffee"></i></span> <span title=站点阅读时长>16:21</span></span></div><div class=busuanzi-count><span class=post-meta-item id=busuanzi_container_site_uv><span class=post-meta-item-icon><i class="fa fa-users"></i></span> <span class=site-uv title=总访客量><span id=busuanzi_value_site_uv></span></span></span> <span class=post-meta-item id=busuanzi_container_site_pv><span class=post-meta-item-icon><i class="fa fa-eye"></i></span> <span class=site-pv title=总访问量><span id=busuanzi_value_site_pv></span></span></span></div><div class=powered-by>由 <span class=exturl data-url=aHR0cHM6Ly9oZXhvLmlv>Hexo</span> & <span class=exturl data-url="aHR0cHM6Ly90aGVtZS1uZXh0LmpzLm9yZy9taXN0Lw==">NexT.Mist</span> 强力驱动</div></div></footer><script src=https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin=anonymous></script><script src=https://cdnjs.cloudflare.com/ajax/libs/next-theme-pjax/0.5.0/pjax.min.js integrity="sha256-3NkoLDrmHLTYj7csHIZSr0MHAFTXth7Ua/DDt4MRUAg=" crossorigin=anonymous></script><script src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin=anonymous></script><script src=https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin=anonymous></script><script src=https://cdnjs.cloudflare.com/ajax/libs/lozad.js/1.16.0/lozad.min.js integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin=anonymous></script><script src=https://cdnjs.cloudflare.com/ajax/libs/pangu/4.0.7/pangu.min.js integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin=anonymous></script><script src=/js/comments.js></script><script src=/js/utils.js></script><script src=/js/motion.js></script><script src=/js/schemes/muse.js></script><script src=/js/next-boot.js></script><script src=/js/pjax.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.0/search.js integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin=anonymous></script><script src=/js/third-party/search/local-search.js></script><script class=next-config data-name=pdf type=application/json>{"object_url":{"url":"https://cdnjs.cloudflare.com/ajax/libs/pdfobject/2.2.8/pdfobject.min.js","integrity":"sha256-tu9j5pBilBQrWSDePOOajCUdz6hWsid/lBNzK4KgEPM="},"url":"/lib/pdf/web/viewer.html"}</script><script src=/js/third-party/tags/pdf.js></script><script class=next-config data-name=mermaid type=application/json>{"enable":true,"theme":{"light":"default","dark":"dark"},"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mermaid/9.1.1/mermaid.min.js","integrity":"sha256-8L3O8tirFUa8Va4NSTAyIbHJeLd6OnlcxgupV9F77e0="}}</script><script src=/js/third-party/tags/mermaid.js></script><script src=/js/third-party/fancybox.js></script><script data-pjax async src=https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script><script class=next-config data-name=leancloud_visitors type=application/json>{"enable":true,"app_id":"Q8qpjA3fOO7FEUBqcmcQFptF-gzGzoHsz","app_key":"tgUTq5bX3fVmn916EMRe65eJ","server_url":null,"security":false}</script><script src=/js/third-party/statistics/lean-analytics.js></script><script class=next-config data-name=enableMath type=application/json>false</script><script class=next-config data-name=mathjax type=application/json>{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.1/es5/tex-mml-chtml.js","integrity":"sha256-hlC2uSQYTmPsrzGZTEQEg9PZ1a/+SV6VBCTclohf2og="}}</script><script src=/js/third-party/math/mathjax.js></script><script class=next-config data-name=utterances type=application/json>{"enable":true,"repo":"Winddoing/winddoing.github.io","issue_term":"title","theme":"github-light"}</script><script src=/js/third-party/comments/utterances.js></script></body></html>