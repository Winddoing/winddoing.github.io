<!DOCTYPE html><html lang=zh-CN><head><meta charset=UTF-8><meta name=viewport content="width=device-width"><meta name=theme-color content=#222 media="(prefers-color-scheme: light)"><meta name=theme-color content=#222 media="(prefers-color-scheme: dark)"><meta name=generator content="Hexo 6.2.0"><link rel=preconnect href=https://fonts.googleapis.com crossorigin><link rel=preconnect href=https://cdnjs.cloudflare.com crossorigin><link rel=apple-touch-icon sizes=180x180 href=/images/apple-touch-icon-next.png><link rel=icon type=image/png sizes=32x32 href=/favicon.ico><link rel=icon type=image/png sizes=16x16 href=/favicon.ico><link rel=mask-icon href=/images/logo.svg color=#222><meta name=baidu-site-verification content=WIIeufYjj6><link rel=stylesheet href=/css/main.css><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Microsoft+YaHei:300,300italic,400,400italic,700,700italic%7Ccmmi10:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin=anonymous><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin=anonymous><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin=anonymous><script class=next-config data-name=main type=application/json>{"hostname":"winddoing.github.io","root":"/","images":"/images","scheme":"Mist","darkmode":true,"version":"8.12.1","exturl":true,"sidebar":{"position":"right","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"default"},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":"utterances","storage":true,"lazyload":false,"nav":null,"activeClass":"utterances"},"stickytabs":false,"motion":{"enable":true,"async":true,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src=/js/config.js></script><meta name=description content=接触Audio的这几个月,对控制的理解和对alsa框架的理解其中学习的进行总结><meta property=og:type content=article><meta property=og:title content=Audio驱动总结--ALSA><meta property=og:url content=https://winddoing.github.io/post/50356.html><meta property=og:site_name content="Winddoing&#39;s Notes"><meta property=og:description content=接触Audio的这几个月,对控制的理解和对alsa框架的理解其中学习的进行总结><meta property=og:locale content=zh_CN><meta property=og:image content=https://winddoing.github.io/images/2021/11/audio_pcm_bps_rate.png><meta property=og:image content=https://winddoing.github.io/images/audio/alsa/alsa-hardware-link.png><meta property=og:image content=https://winddoing.github.io/images/audio/alsa/audio-hardware.png><meta property=og:image content=https://winddoing.github.io/images/audio/alsa/alsa-struct.png><meta property=og:image content=https://winddoing.github.io/images/audio/alsa/alas-asoc-arch.png><meta property=article:published_time content=2017-07-10T15:07:24.000Z><meta property=article:modified_time content=2023-12-16T04:58:17.937Z><meta property=article:author content=winddoing><meta property=article:tag content=驱动><meta property=article:tag content=alsa><meta property=article:tag content=audio><meta name=twitter:card content=summary><meta name=twitter:image content=https://winddoing.github.io/images/2021/11/audio_pcm_bps_rate.png><link rel=canonical href=https://winddoing.github.io/post/50356.html><script class=next-config data-name=page type=application/json>{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://winddoing.github.io/post/50356.html","path":"post/50356.html","title":"Audio驱动总结--ALSA"}</script><script class=next-config data-name=calendar type=application/json>""</script><title>Audio驱动总结--ALSA | Winddoing's Notes</title><script src=/js/third-party/analytics/baidu-analytics.js></script><script async src=https://hm.baidu.com/hm.js?b96a560ce0a6bfbeaaddc59dc5888b75></script><noscript><link rel=stylesheet href=/css/noscript.css></noscript></head><body itemscope itemtype=http://schema.org/WebPage class=use-motion><div class=headband></div><main class=main><header class=header itemscope itemtype=http://schema.org/WPHeader><div class=header-inner><div class=site-brand-container><div class=site-nav-toggle><div class=toggle aria-label=切换导航栏 role=button><span class=toggle-line></span> <span class=toggle-line></span> <span class=toggle-line></span></div></div><div class=site-meta><a href="/" class=brand rel=start><i class=logo-line></i><p class=site-title>Winddoing's Notes</p><i class=logo-line></i></a><p class=site-subtitle itemprop=description>Follow Excellent, Success will Chase you</p></div><div class=site-nav-right><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class=site-nav><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel=section><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel=section><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel=section><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel=section><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-search"><a role=button class=popup-trigger><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class=search-pop-overlay><div class="popup search-popup"><div class=search-header><span class=search-icon><i class="fa fa-search"></i></span><div class=search-input-container><input autocomplete=off autocapitalize=off maxlength=80 placeholder=搜索... spellcheck=false type=search class=search-input></div><span class=popup-btn-close role=button><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class=search-result-icon><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></div><div class="toggle sidebar-toggle" role=button><span class=toggle-line></span> <span class=toggle-line></span> <span class=toggle-line></span></div><aside class=sidebar><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class=sidebar-nav><li class=sidebar-nav-toc>文章目录</li><li class=sidebar-nav-overview>站点概览</li></ul><div class=sidebar-panel-container><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class=nav><li class="nav-item nav-level-2"><a class=nav-link href=#%E9%9F%B3%E9%A2%91%E5%8F%82%E6%95%B0><span class=nav-number>1.</span> <span class=nav-text>音频参数</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#snd-pcm-lib-buffer-bytes-substream-%E4%B8%8Esnd-pcm-lib-period-bytes-substream><span class=nav-number>1.1.</span> <span class=nav-text>snd_pcm_lib_buffer_bytes(substream)与snd_pcm_lib_period_bytes(substream)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class=nav-link href=#%E9%9F%B3%E9%A2%91%E5%A4%84%E7%90%86%E8%BD%AF%E4%BB%B6><span class=nav-number>2.</span> <span class=nav-text>音频处理软件</span></a></li><li class="nav-item nav-level-2"><a class=nav-link href=#%E7%A1%AC%E4%BB%B6><span class=nav-number>3.</span> <span class=nav-text>硬件</span></a></li><li class="nav-item nav-level-2"><a class=nav-link href=#alsa-ASOC><span class=nav-number>4.</span> <span class=nav-text>alsa - ASOC</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#DAPM><span class=nav-number>4.1.</span> <span class=nav-text>DAPM</span></a></li><li class="nav-item nav-level-3"><a class=nav-link href=#DPCM><span class=nav-number>4.2.</span> <span class=nav-text>DPCM</span></a></li></ol></li><li class="nav-item nav-level-2"><a class=nav-link href=#PCM%E8%AE%BE%E5%A4%87><span class=nav-number>5.</span> <span class=nav-text>PCM设备</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#%E6%94%BE%E9%9F%B3-%E2%80%93-%E5%BA%94%E7%94%A8><span class=nav-number>5.1.</span> <span class=nav-text>放音 – 应用</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#%E4%B8%BA%E4%BB%80%E4%B9%88open%E4%B8%A4%E6%AC%A1pcmC0D0p%E8%AE%BE%E5%A4%87%E8%8A%82%E7%82%B9><span class=nav-number>5.1.1.</span> <span class=nav-text>为什么open两次pcmC0D0p设备节点</span></a></li><li class="nav-item nav-level-4"><a class=nav-link href=#%E4%B8%BA%E4%BB%80%E4%B9%88read%E9%9F%B3%E9%A2%91%E6%96%87%E4%BB%B6%E4%B8%A4%E6%AC%A1-%E5%B9%B6%E4%B8%94%E8%AF%BB%E7%9A%84%E6%95%B0%E6%8D%AE%E5%A4%A7%E5%B0%8F%E4%B8%8D%E4%B8%80%E8%87%B4><span class=nav-number>5.1.2.</span> <span class=nav-text>为什么read音频文件两次,并且读的数据大小不一致</span></a></li><li class="nav-item nav-level-4"><a class=nav-link href=#%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4%E7%94%B3%E8%AF%B7buffer%E5%A4%A7%E5%B0%8F%E7%9A%84%E4%BE%9D%E6%8D%AE><span class=nav-number>5.1.3.</span> <span class=nav-text>用户空间申请buffer大小的依据</span></a></li></ol></li><li class="nav-item nav-level-3"><a class=nav-link href=#%E6%94%BE%E9%9F%B3-%E2%80%93-%E5%86%85%E6%A0%B8><span class=nav-number>5.2.</span> <span class=nav-text>放音 – 内核</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#ASOC%E6%8E%A5%E5%8F%A3><span class=nav-number>5.2.1.</span> <span class=nav-text>ASOC接口</span></a><ol class=nav-child><li class="nav-item nav-level-5"><a class=nav-link href=#soc-pcm-open><span class=nav-number>5.2.1.1.</span> <span class=nav-text>soc_pcm_open</span></a></li><li class="nav-item nav-level-5"><a class=nav-link href=#soc-pcm-hw-params><span class=nav-number>5.2.1.2.</span> <span class=nav-text>soc_pcm_hw_params</span></a></li><li class="nav-item nav-level-5"><a class=nav-link href=#soc-pcm-prepare><span class=nav-number>5.2.1.3.</span> <span class=nav-text>soc_pcm_prepare</span></a></li><li class="nav-item nav-level-5"><a class=nav-link href=#soc-pcm-trigger><span class=nav-number>5.2.1.4.</span> <span class=nav-text>soc_pcm_trigger</span></a></li><li class="nav-item nav-level-5"><a class=nav-link href=#soc-pcm-hw-free><span class=nav-number>5.2.1.5.</span> <span class=nav-text>soc_pcm_hw_free</span></a></li><li class="nav-item nav-level-5"><a class=nav-link href=#soc-pcm-pointer><span class=nav-number>5.2.1.6.</span> <span class=nav-text>soc_pcm_pointer</span></a></li><li class="nav-item nav-level-5"><a class=nav-link href=#soc-pcm-close><span class=nav-number>5.2.1.7.</span> <span class=nav-text>soc_pcm_close</span></a></li></ol></li><li class="nav-item nav-level-4"><a class=nav-link href=#open><span class=nav-number>5.2.2.</span> <span class=nav-text>open</span></a></li><li class="nav-item nav-level-4"><a class=nav-link href=#ioctl><span class=nav-number>5.2.3.</span> <span class=nav-text>ioctl</span></a></li><li class="nav-item nav-level-4"><a class=nav-link href=#close><span class=nav-number>5.2.4.</span> <span class=nav-text>close</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class=nav-link href=#control%E8%AE%BE%E5%A4%87><span class=nav-number>6.</span> <span class=nav-text>control设备</span></a></li><li class="nav-item nav-level-2"><a class=nav-link href=#codec><span class=nav-number>7.</span> <span class=nav-text>codec</span></a></li><li class="nav-item nav-level-2"><a class=nav-link href=#%E6%95%B0%E6%8D%AE%E8%B7%AF%E7%94%B1><span class=nav-number>8.</span> <span class=nav-text>数据路由</span></a></li><li class="nav-item nav-level-2"><a class=nav-link href=#amixer%E7%9A%84%E8%AE%BE%E7%BD%AE><span class=nav-number>9.</span> <span class=nav-text>amixer的设置</span></a></li><li class="nav-item nav-level-2"><a class=nav-link href=#%E8%B0%83%E8%AF%95><span class=nav-number>10.</span> <span class=nav-text>调试</span></a></li><li class="nav-item nav-level-2"><a class=nav-link href=#%E6%80%A7%E8%83%BD><span class=nav-number>11.</span> <span class=nav-text>性能</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#%E9%A2%91%E5%93%8D><span class=nav-number>11.1.</span> <span class=nav-text>频响</span></a></li><li class="nav-item nav-level-3"><a class=nav-link href=#%E6%89%AB%E9%A2%91><span class=nav-number>11.2.</span> <span class=nav-text>扫频</span></a></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author site-overview-item animated" itemprop=author itemscope itemtype=http://schema.org/Person><img class=site-author-image itemprop=image alt=winddoing src=/images/Winddoing.jpg><p class=site-author-name itemprop=name>winddoing</p><div class=site-description itemprop=description>失败缘于忽视细处，成功始于重视小事</div></div><div class="site-state-wrap site-overview-item animated"><nav class=site-state><div class="site-state-item site-state-posts"><a href="/archives/"><span class=site-state-item-count>358</span> <span class=site-state-item-name>日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class=site-state-item-count>112</span> <span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class=site-state-item-count>284</span> <span class=site-state-item-name>标签</span></a></div></nav></div><div class="links-of-author site-overview-item animated"><span class=links-of-author-item><span class=exturl data-url="aHR0cHM6Ly9naXRodWIuY29tL1dpbmRkb2luZw==" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Winddoing"><i class="fab fa-github fa-fw"></i>GitHub</span></span> <span class=links-of-author-item><span class=exturl data-url=aHR0cHM6Ly9naXRlZS5jb20vd2luZGRvaW5n title="Gitee → https:&#x2F;&#x2F;gitee.com&#x2F;winddoing"><i class="fab fa-codiepie fa-fw"></i>Gitee</span></span> <span class=links-of-author-item><span class=exturl data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS91c2Vycy85NTY3MzYxL3dpbmRkb2luZw==" title="StackOverflow → https:&#x2F;&#x2F;stackoverflow.com&#x2F;users&#x2F;9567361&#x2F;winddoing"><i class="fab fa-stack-overflow fa-fw"></i>StackOverflow</span></span> <span class=links-of-author-item><span class=exturl data-url="aHR0cHM6Ly9hcHAudHJhdmlzLWNpLmNvbS9naXRodWIvV2luZGRvaW5nL3dpbmRkb2luZy5naXRodWIuaW8=" title="Travis CI → https:&#x2F;&#x2F;app.travis-ci.com&#x2F;github&#x2F;Winddoing&#x2F;winddoing.github.io"><i class="fas fa-terminal fa-fw"></i>Travis CI</span></span></div><div class="cc-license site-overview-item animated" itemprop=license><span class="exturl cc-opacity" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC8="><img src=https://cdnjs.cloudflare.com/ajax/libs/creativecommons-vocabulary/2020.11.3/assets/license_badges/small/by_nc_sa.svg alt="Creative Commons"></span></div><div class="links-of-blogroll site-overview-item animated"><div class=links-of-blogroll-title><i class="link fa-fw"></i> Links</div><ul class=links-of-blogroll-list><li class=links-of-blogroll-item><span class=exturl data-url="aHR0cHM6Ly93aW5kZG9pbmcuZ2l0Ym9vay5pby9lbWJlZGRlZF9saW51eF9ub3Rlcy8=" title=https:&#x2F;&#x2F;winddoing.gitbook.io&#x2F;embedded_linux_notes&#x2F;>嵌入式相关</span></li><li class=links-of-blogroll-item><span class=exturl data-url="aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2RyZWFtcQ==" title=http:&#x2F;&#x2F;blog.csdn.net&#x2F;sdreamq>CSDN</span></li><li class=links-of-blogroll-item><span class=exturl data-url=aHR0cDovL3d3dy53b3dvdGVjaC5uZXQv title=http:&#x2F;&#x2F;www.wowotech.net&#x2F;>蜗窝科技</span></li><li class=links-of-blogroll-item><span class=exturl data-url=aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpb25neGlhbnpl title=https:&#x2F;&#x2F;blog.csdn.net&#x2F;xiongxianze>xiongxianze</span></li></ul></div><div id=days></div><script>
function show_date_time(){
    window.setTimeout("show_date_time()", 1000);
    BirthDay=new Date("02/26/2014 15:00:00");
    today=new Date();
    timeold=(today.getTime()-BirthDay.getTime());
    sectimeold=timeold/1000
        secondsold=Math.floor(sectimeold);
    msPerDay=24*60*60*1000
        e_daysold=timeold/msPerDay
        daysold=Math.floor(e_daysold);
    e_hrsold=(e_daysold-daysold)*24;
    hrsold=setzero(Math.floor(e_hrsold));
    e_minsold=(e_hrsold-hrsold)*60;
    minsold=setzero(Math.floor((e_hrsold-hrsold)*60));
    seconds=setzero(Math.floor((e_minsold-minsold)*60));
    document.getElementById('days').innerHTML="已运行"+daysold+"天"+hrsold+"小时"+minsold+"分"+seconds+"秒";
}
function setzero(i){
    if (i<10)
    {i="0" + i};
    return i;
}
show_date_time();
</script></div></div></div></aside><div class=sidebar-dimmer></div></header><div class=back-to-top role=button aria-label=返回顶部><i class="fa fa-arrow-up"></i> <span>0%</span></div><div class=reading-progress-bar></div><noscript><div class=noscript-warning>Theme NexT works best with JavaScript enabled</div></noscript><div class="main-inner post posts-expand"><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang=zh-CN><link itemprop=mainEntityOfPage href=https://winddoing.github.io/post/50356.html><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content=/images/Winddoing.jpg><meta itemprop=name content=winddoing></span> <span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Winddoing's Notes"><meta itemprop=description content=失败缘于忽视细处，成功始于重视小事></span> <span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="Audio驱动总结--ALSA | Winddoing's Notes"><meta itemprop=description></span><header class=post-header><h1 class=post-title itemprop="name headline">Audio驱动总结--ALSA</h1><div class=post-meta-container><div class=post-meta><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-calendar"></i></span> <span class=post-meta-item-text>发表于</span><time title="创建时间：2017-07-10 23:07:24" itemprop="dateCreated datePublished" datetime=2017-07-10T23:07:24+08:00>2017-07-10</time></span> <span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-folder"></i></span> <span class=post-meta-item-text>分类于</span> <span itemprop=about itemscope itemtype=http://schema.org/Thing><a href="/categories/%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/" itemprop=url rel=index><span itemprop=name>设备驱动</span></a></span> ， <span itemprop=about itemscope itemtype=http://schema.org/Thing><a href="/categories/%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/%E9%9F%B3%E9%A2%91/" itemprop=url rel=index><span itemprop=name>音频</span></a></span></span> <span id=/post/50356.html class="post-meta-item leancloud_visitors" data-flag-title=Audio驱动总结--ALSA title=阅读次数><span class=post-meta-item-icon><i class="far fa-eye"></i></span> <span class=post-meta-item-text>阅读次数：</span> <span class=leancloud-visitors-count></span></span> <span class=post-meta-item title=阅读次数 id=busuanzi_container_page_pv><span class=post-meta-item-icon><i class="far fa-eye"></i></span> <span class=post-meta-item-text>阅读次数：</span> <span id=busuanzi_value_page_pv></span></span> <span class=post-meta-break></span> <span class=post-meta-item title=本文字数><span class=post-meta-item-icon><i class="far fa-file-word"></i></span> <span class=post-meta-item-text>本文字数：</span> <span>25k</span></span> <span class=post-meta-item title=阅读时长><span class=post-meta-item-icon><i class="far fa-clock"></i></span> <span class=post-meta-item-text>阅读时长 &asymp;</span> <span>22 分钟</span></span></div></div></header><div class=post-body itemprop=articleBody><p>接触Audio的这几个月,对控制的理解和对alsa框架的理解其中学习的进行总结</p><span id=more></span><h2 id=音频参数><a href=#音频参数 class=headerlink title=音频参数></a>音频参数</h2><ul><li>Sample：样本长度(位宽)，音频数据最基本的单位，常见的有8位和16位。</li><li>Channel：声道数，分为单声道mono和立体声stereo。</li><li>Frame：帧，构成一个声音单元，Frame &#x3D; Sample * channel, sample*channel&#x2F;8 Byte。</li><li>Rate：又称Sample rate，采样率，即每秒的采样次数，针对帧而言。</li><li>Interleaved：交错模式，一种音频数据的记录方式，在交错模式下，数据以连续桢的形式存放，即首先记录完桢1的左声道样本和右声道样本（假设为立体声），再开始桢2的记录。而在非交错模式下，首先记录的是一个周期内所有桢的左声道样本，再记录右声道样本，数据是以连续通道的方式存储。多数情况下使用交错模式。</li><li>Period size：周期，每次硬件中断处理音频数据的帧数，对于音频设备的数据读写，以frame为单位。</li><li>Buffer size：数据缓冲区大小，这里特指runtime的buffer size，而不是snd_pcm_hardware定义的buffer_bytes_max。一般来说Buffer size &#x3D; period_size * period_count，period_count相当于处理完一个buffer数据所需的硬件中断次数。单位也是frame</li><li>码率: (编码速率), 码率 &#x3D; 采样频率 * 位宽 * 声道个数</li></ul><figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br></pre></td><td class=code><pre><span class=line>│                                                                   │</span><br><span class=line>├────────────────────────────── Buffer  ────────────────────────────┤</span><br><span class=line>│                                                                   │</span><br><span class=line>├───────────┬──────────┬───────────┬──────────┬──────────┬──────────┤</span><br><span class=line>│           │          │           │          │          │          │</span><br><span class=line>│   perid   │  perid   │  perid    │  perid   │  perid   │  perid   │   6 perids</span><br><span class=line>│           │          │           │          │          │          │</span><br><span class=line>└───────────┴──────────┼───────────┼──────────┴──────────┴──────────┘</span><br><span class=line>                       │           │</span><br><span class=line>            ┌──────────┘           └────────────────────┐</span><br><span class=line>            │                                           │</span><br><span class=line>            ├───────┬────────┬────────┬────────┬────────┤</span><br><span class=line>            │ frame │ frame  │ frame  │ frame  │ frame  │  perid = 5 frames</span><br><span class=line>            └───────┴────────┼────────┼────────┴────────┘</span><br><span class=line>                             │        │</span><br><span class=line>                          ┌──┘        └──┐</span><br><span class=line>                          │              │</span><br><span class=line>                          ├──────┬───────┤</span><br><span class=line>                          │ left │ right │  frame = 2 sample (2channel)</span><br><span class=line>                          └──────┴───────┘</span><br></pre></td></tr></table></figure><blockquote><p>一个buffer由若干个period组成, 一个period由若干个frame组成</p></blockquote><p>这个buffer中有6个period，每当DMA搬运完一个period的数据就会产生一次中断，因此搬运这个buffer中的数据将产生6次中断。<br>ALSA为什么这样做？因为数据缓存区可能很大，一次传输可能会导致不可接受的延迟；为了解决这个问题，alsa把缓存区拆分成多个周期，以周期为单元传输数据</p><p><em><strong>采样率和实际的分频误差在5%左右</strong></em></p><blockquote><p><strong>Period</strong></p><p>The interval between interrupts from the hardware. This defines the input latency, since the CPU will not have any idea that there is data waiting until the audio interface interrupts it.</p><p>The audio interface has a “pointer” that marks the current position for read&#x2F;write in its h&#x2F;w buffer. The pointer circles around the buffer as long as the interface is running.</p><p>Typically, there are an integral number of periods per traversal of the h&#x2F;w buffer, but not always. There is at least one card (ymfpci)<br>that generates interrupts at a fixed rate indepedent of the buffer size (which can be changed), resulting in some “odd” effects compared to more traditional designs.</p><p>Note: h&#x2F;w generally defines the interrupt in frames, though not always.</p><p>Alsa’s period size setting will affect how much work the CPU does. if you set the period size low, there will be more interrupts and the work that is done every interrupt will be done more often. So, if you don’t care about low latency,<br>set the period size large as possible and you’ll have more CPU cycles for other things. The defaults that ALSA provides are in the middle of the range, typically.</p><p>(from an old AlsaDevel thread[1], quoting Paul Davis)</p><p>Retrieved from “<span class=exturl data-url="aHR0cDovL2Fsc2Eub3BlbnNyYy5vcmcvUGVyaW9kIg==">http://alsa.opensrc.org/Period&quot;<i class="fa fa-external-link-alt"></i></span></p><p>来自：<span class=exturl data-url=aHR0cDovL2Fsc2Eub3BlbnNyYy5vcmcvUGVyaW9k>http://alsa.opensrc.org/Period<i class="fa fa-external-link-alt"></i></span></p><p><strong>FramesPeriods</strong></p><p>A frame is equivalent of one sample being played, irrespective of the number of channels or the number of bits. e.g.</p><ul><li>1 frame of a Stereo 48khz 16bit PCM stream is 4 bytes.</li><li>1 frame of a 5.1 48khz 16bit PCM stream is 12 bytes.<br><code>A period is the number of frames in between each hardware interrupt</code>. The poll() will return once a period.<br>The buffer is a ring buffer. The buffer size always has to be greater than one period size. Commonly this is 2*period size, but some hardware can do 8 periods per buffer. It is also possible for the buffer size to not be an integer multiple of the period size.<br>Now, if the hardware has been set to 48000Hz , 2 periods, of 1024 frames each, making a buffer size of 2048 frames. The hardware will interrupt 2 times per buffer. ALSA will endeavor to keep the buffer as full as possible. Once the first period of samples has<br>been played, the third period of samples is transfered into the space the first one occupied while the second period of samples is being played. (normal ring buffer behaviour).</li></ul><p>Additional example</p><p>Here is an alternative example for the above discussion.<br>Say we want to work with a stereo, 16-bit, 44.1 KHz stream, one-way (meaning, either in playback or in capture direction). Then we have:</p><ul><li>‘stereo’ &#x3D; number of channels: 2</li><li><code>1 analog sample</code> is represented with 16 bits &#x3D; 2 bytes</li><li><code>1 frame</code> represents 1 analog sample from all channels; here we have 2 channels, and so:<ul><li><code>1 frame</code> &#x3D; (num_channels) * (1 sample in bytes) &#x3D; (2 channels) * (2 bytes (16 bits) per sample) &#x3D; 4 bytes (32 bits)</li></ul></li><li>To sustain 2x 44.1 KHz <code>analog rate</code> - the system must be capable of <code>data transfer rate</code>, in Bytes&#x2F;sec:<ul><li><code>Bps_rate</code> &#x3D; (num_channels) * (1 sample in bytes) * (analog_rate) &#x3D; (1 frame) * (analog_rate) &#x3D; ( 2 channels ) * (2 bytes&#x2F;sample) * (44100 samples&#x2F;sec) &#x3D; 2<em>2</em>44100 &#x3D; 176400 Bytes&#x2F;sec<br><img data-src=/images/2021/11/audio_pcm_bps_rate.png alt=audio_pcm_bps_rate><br>Now, if ALSA would interrupt each second, asking for bytes - we’d need to have 176400 bytes ready for it (at end of each second), in order to sustain analog 16-bit stereo @ 44.1Khz.</li></ul></li><li>If it would interrupt each half a second, correspondingly for the same stream we’d need 176400&#x2F;2 &#x3D; 88200 bytes ready, at each interrupt;</li><li>if the interrupt hits each 100 ms, we’d need to have 176400*(0.1&#x2F;1) &#x3D; 17640 bytes ready, at each interrupt.<br>We can control when this PCM interrupt is generated, by setting a period size, which is set in frames.</li><li>Thus, if we set 16-bit stereo @ 44.1Khz, and the period_size to 4410 frames &#x3D;&gt; (for 16-bit stereo @ 44.1Khz, 1 frame equals 4 bytes - so 4410 frames equal 4410*4 &#x3D; 17640 bytes) &#x3D;&gt; an interrupt will be generated each 17640 bytes - that is, each 100 ms.</li><li>Correspondingly, buffer_size should be at least 2<em>period_size &#x3D; 2</em>4410 &#x3D; 8820 frames (or 8820*4 &#x3D; 35280 bytes).<br>It seems (writing-an-alsa-driver.pdf), however, that it is the ALSA runtime that decides on the actual buffer_size and period_size, depending on: the requested number of channels, and their respective properties (rate and sampling resolution) - as well as the<br>parameters set in the snd_pcm_hardware structure (in the driver).<br>Also, the following quote may be relevant, from <span class=exturl data-url=aHR0cDovL21haWxtYW4uYWxzYS1wcm9qZWN0Lm9yZy9waXBlcm1haWwvYWxzYS1kZXZlbC8yMDA3LUFwcmlsLzAwMDQ3NC5odG1s>http://mailman.alsa-project.org/pipermail/alsa-devel/2007-April/000474.html<i class="fa fa-external-link-alt"></i></span>:</li></ul><blockquote><blockquote><p>The “frame” represents the unit, 1 frame &#x3D; # channels x sample_bytes.<br>In your case, 1 frame corresponds to 2 channels x 16 bits &#x3D; 4 bytes.</p><p>The periods is the number of periods in a ring-buffer. In OSS, called<br>as “fragments”.</p><p>So,</p><ul><li>buffer_size &#x3D; period_size * periods</li><li>period_bytes &#x3D; period_size * bytes_per_frame</li><li>bytes_per_frame &#x3D; channels * bytes_per_sample</li></ul></blockquote><p>I still don’t understand what ‘period_size’ and a ‘period’ is?</p></blockquote><p>The “period” defines the frequency to update the status, usually viathe invokation of interrupts. The “period_size” defines the frame sizes corresponding to the “period time”. This term corresponds to the “fragment size” on OSS. On major sound hardwares,<br>a ring-buffer is divided to several parts and an irq is issued on each boundary. The period_size defines the size of this chunk.</p><p>On some hardwares, the irq is controlled on the basis of a timer. In this case, the period is defined as the timer frequency to invoke an irq.</p><p>来自：<span class=exturl data-url="aHR0cDovL2Fsc2EtcHJvamVjdC5vcmcvbWFpbi9pbmRleC5waHAvRnJhbWVzUGVyaW9kcw==">http://alsa-project.org/main/index.php/FramesPeriods<i class="fa fa-external-link-alt"></i></span></p></blockquote><ul><li><span class=exturl data-url="aHR0cHM6Ly9tYWlsbWFuLmFsc2EtcHJvamVjdC5vcmcvcGlwZXJtYWlsL2Fsc2EtZGV2ZWwvMjAwNy1BcHJpbC8wMDA0NzQuaHRtbA==">[alsa-devel] Questions about writing a new ALSA driver for a very limitted device<i class="fa fa-external-link-alt"></i></span></li></ul><h3 id=snd-pcm-lib-buffer-bytes-substream-与snd-pcm-lib-period-bytes-substream><a href=#snd-pcm-lib-buffer-bytes-substream-与snd-pcm-lib-period-bytes-substream class=headerlink title=snd_pcm_lib_buffer_bytes(substream)与snd_pcm_lib_period_bytes(substream)></a>snd_pcm_lib_buffer_bytes(substream)与snd_pcm_lib_period_bytes(substream)</h3><p>在驱动中进行dma数据传输时，需要通过<code>snd_pcm_lib_buffer_bytes(substream)</code>获取传输数据的buffer大小和<code>snd_pcm_lib_period_bytes(substream)</code>每次dma传输的数据大小</p><figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br></pre></td><td class=code><pre><span class=line><span class=comment>/**</span></span><br><span class=line><span class=comment> * snd_pcm_lib_buffer_bytes - Get the buffer size of the current PCM in bytes</span></span><br><span class=line><span class=comment> * @substream: PCM substream</span></span><br><span class=line><span class=comment> */</span></span><br><span class=line><span class=type>static</span> <span class=keyword>inline</span> <span class=type>size_t</span> <span class="title function_">snd_pcm_lib_buffer_bytes</span><span class=params>(<span class=keyword>struct</span> snd_pcm_substream *substream)</span></span><br><span class=line>&#123;</span><br><span class=line>    <span class=class><span class=keyword>struct</span> <span class=title>snd_pcm_runtime</span> *<span class=title>runtime</span> =</span> substream-&gt;runtime;</span><br><span class=line>    <span class=keyword>return</span> frames_to_bytes(runtime, runtime-&gt;buffer_size);</span><br><span class=line>&#125;</span><br><span class=line></span><br><span class=line><span class=comment>/**</span></span><br><span class=line><span class=comment> * snd_pcm_lib_period_bytes - Get the period size of the current PCM in bytes</span></span><br><span class=line><span class=comment> * @substream: PCM substream</span></span><br><span class=line><span class=comment> */</span></span><br><span class=line><span class=type>static</span> <span class=keyword>inline</span> <span class=type>size_t</span> <span class="title function_">snd_pcm_lib_period_bytes</span><span class=params>(<span class=keyword>struct</span> snd_pcm_substream *substream)</span></span><br><span class=line>&#123;</span><br><span class=line>    <span class=class><span class=keyword>struct</span> <span class=title>snd_pcm_runtime</span> *<span class=title>runtime</span> =</span> substream-&gt;runtime;</span><br><span class=line>    <span class=keyword>return</span> frames_to_bytes(runtime, runtime-&gt;period_size);</span><br><span class=line>&#125;</span><br></pre></td></tr></table></figure><ul><li>period_size可以控制pcm中断的产生，也就是period_size大小的数据传输完需要一个dma中断。</li><li>buffer_size,period_size的计算？</li></ul><p>在驱动里，我们会设置</p><figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre></td><td class=code><pre><span class=line>period_bytes_min = 1024 * 4 = 4096,</span><br><span class=line>period_bytes_max = 1024 *16,</span><br></pre></td></tr></table></figure><p>alsa会根据上面的最大最小值算出一个合适的值作为runtime-&gt;period_size。</p><p>在<code>sound/core/pcm_native.c</code>中的<code>snd_pcm_hw_constraints_init</code>函数实现了计算各种alsa定义的一些参数规则，其中包含了<code>buffer_size</code>， <code>period_size</code></p><figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br></pre></td><td class=code><pre><span class=line>err = snd_pcm_hw_rule_add(runtime, <span class=number>0</span>, SNDRV_PCM_HW_PARAM_PERIOD_SIZE,</span><br><span class=line>              snd_pcm_hw_rule_div, <span class=literal>NULL</span>,</span><br><span class=line>              SNDRV_PCM_HW_PARAM_BUFFER_SIZE, SNDRV_PCM_HW_PARAM_PERIODS, <span class=number>-1</span>);</span><br><span class=line><span class=keyword>if</span> (err &lt; <span class=number>0</span>)</span><br><span class=line>    <span class=keyword>return</span> err;</span><br><span class=line>err = snd_pcm_hw_rule_add(runtime, <span class=number>0</span>, SNDRV_PCM_HW_PARAM_PERIOD_SIZE,</span><br><span class=line>              snd_pcm_hw_rule_mulkdiv, (<span class=type>void</span>*) <span class=number>8</span>,</span><br><span class=line>              SNDRV_PCM_HW_PARAM_PERIOD_BYTES, SNDRV_PCM_HW_PARAM_FRAME_BITS, <span class=number>-1</span>);</span><br><span class=line><span class=keyword>if</span> (err &lt; <span class=number>0</span>)</span><br><span class=line>    <span class=keyword>return</span> err;</span><br><span class=line>err = snd_pcm_hw_rule_add(runtime, <span class=number>0</span>, SNDRV_PCM_HW_PARAM_PERIOD_SIZE,</span><br><span class=line>              snd_pcm_hw_rule_muldivk, (<span class=type>void</span>*) <span class=number>1000000</span>,</span><br><span class=line>              SNDRV_PCM_HW_PARAM_PERIOD_TIME, SNDRV_PCM_HW_PARAM_RATE, <span class=number>-1</span>);</span><br><span class=line><span class=keyword>if</span> (err &lt; <span class=number>0</span>)</span><br><span class=line>    <span class=keyword>return</span> err;</span><br></pre></td></tr></table></figure><p>参考： <span class=exturl data-url=aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTI3Njk2OTEvYXJ0aWNsZS9kZXRhaWxzLzQ2NzI3NTQz>Alsa period_size&#x2F;periods&#x2F;buffer_size计算逻辑<i class="fa fa-external-link-alt"></i></span></p><h2 id=音频处理软件><a href=#音频处理软件 class=headerlink title=音频处理软件></a>音频处理软件</h2><blockquote><p>Audacity 2.0.5</p></blockquote><h2 id=硬件><a href=#硬件 class=headerlink title=硬件></a>硬件</h2><p>主要由音频总线(I2S,PCM)和控制总线(I2C或SPI)组成。</p><p><img data-src=/images/audio/alsa/alsa-hardware-link.png alt=alsa-hardware-link></p><p><img data-src=/images/audio/alsa/audio-hardware.png alt=audio-hardware></p><h2 id=alsa-ASOC><a href=#alsa-ASOC class=headerlink title="alsa - ASOC"></a>alsa - ASOC</h2><p>在内核设备驱动层，ALSA提供了alsa-driver，同时在应用层，ALSA为我们提供了alsa-lib，应用程序只要调用alsa-lib提供的API，即可以完成对底层音频硬件的控制。</p><p><img data-src=/images/audio/alsa/alsa-struct.png alt=alsa-struct></p><p>ASoC被分为<code>Machine</code>、<code>Platform</code>和<code>Codec</code>三大部分。其中的Machine驱动负责Platform和Codec之间的耦合和设备或板子特定的代码。Platform驱动的主要作用是完成音频数据的管理，最终通过CPU的数字音频接口（DAI）把音频数据传送给Codec进行处理，最终由Codec输出驱动耳机或者是喇叭的音信信号。</p><ul><li>machine<br>用于描述设备组件信息和特定的控制如耳机&#x2F;外放等。</li></ul><blockquote><p>是指某一款机器，可以是某款设备，某款开发板，又或者是某款智能手机，由此可以看出Machine几乎是不可重用的，每个Machine上的硬件实现可能都不一样，CPU不一样，Codec不一样，音频的输入、输出设备也不一样，Machine为CPU、Codec、输入输出设备提供了一个<code>载体</code>。</p></blockquote><p>这一部分将平台驱动和Codec驱动绑定在一起，描述了板级的硬件特征。主要负责Platform和Codec之间的耦合以及部分和设备或板子特定的代码。Machine驱动负责处理机器特有的一些控件和音频事件（例如，当播放音频时，需要先行打开一个放大器）；单独的Platform和Codec驱动是不能工作的，它必须由Machine驱动把它们结合在一起才能完成整个设备的音频处理工作。ASoC的一切都从Machine驱动开始，包括声卡的注册，绑定Platform和Codec驱动等等</p><ul><li>Platform<br>用于实现平台相关的DMA驱动和音频接口等。</li></ul><blockquote><p>一般是指某一个SoC平台，比如pxaxxx,s3cxxxx,omapxxx等等，与音频相关的通常包含该SoC中的时钟、DMA、I2S、PCM等等，只要指定了SoC，那么我们可以认为它会有一个对应的Platform，它只与SoC相关，与Machine无关，这样我们就可以把Platform抽象出来，使得同一款SoC不用做任何的改动，就可以用在不同的Machine中。实际上，把Platform认为是某个SoC更好理解。</p></blockquote><p>这一部分只关心CPU本身，不关心Codec。主要处理两个问题：<code>DMA引擎</code>和<code>SoC集成的PCM、I2S或AC &#39;97数字接口控制</code>。主要作用是完成音频数据的管理，最终通过CPU的数字音频接口（DAI）把音频数据传送给Codec进行处理，最终由Codec输出驱动耳机或者是喇叭的音信信号。在具体实现上，ASoC有把Platform驱动分为两个部分：<code>snd_soc_platform_driver</code>和<code>snd_soc_dai_driver</code>。其中，platform_driver负责管理音频数据，把音频数据通过dma或其他操作传送至cpu dai中，dai_driver则主要完成cpu一侧的dai的参数配置，同时也会通过一定的途径把必要的dma等参数与snd_soc_platform_driver进行交互。</p><ul><li>Codec<br>用于实现平台无关的功能，如寄存器读写接口，音频接口，各widgets的控制接口和DAPM的实现等</li></ul><blockquote><p>字面上的意思就是编解码器，Codec里面包含了I2S接口、D&#x2F;A、A&#x2F;D、Mixer、PA（功放），通常包含多种输入（Mic、Line-in、I2S、PCM）和多个输出（耳机、喇叭、听筒，Line-out），Codec和Platform一样，是可重用的部件，同一个Codec可以被不同的Machine使用。嵌入式Codec通常通过I2C对内部的寄存器进行控制。</p></blockquote><p>这一部分只关心Codec本身，与CPU平台相关的特性不由此部分操作。在移动设备中，Codec的作用可以归结为4种，分别是：</p><ol><li>对PCM等信号进行D&#x2F;A转换，把数字的音频信号转换为模拟信号。</li><li>对Mic、Linein或者其他输入源的模拟信号进行A&#x2F;D转换，把模拟的声音信号转变CPU能够处理的数字信号。</li><li>对音频通路进行控制，比如播放音乐，收听调频收音机，又或者接听电话时，音频信号在codec内的流通路线是不一样的。</li><li>对音频信号做出相应的处理，例如音量控制，功率放大，EQ控制等等。</li></ol><p>ASoC对Codec的这些功能都定义好了一些列相应的接口，以方便地对Codec进行控制。ASoC对Codec驱动的一个基本要求是：<code>驱动程序的代码必须要做到平台无关性，以方便同一个Codec的代码不经修改即可用在不同的平台上</code>。</p><p><img data-src=/images/audio/alsa/alas-asoc-arch.png alt=alsa-asoc-arch></p><p>ASoC对于Alsa来说，就是分别注册PCM&#x2F;CONTROL类型的snd_device设备，并实现相应的操作方法集。图中DAI是数字音频接口，用于配置音频数据格式等。</p><ul><li>Codec驱动向ASoC注册<code>snd_soc_codec</code>和<code>snd_soc_dai</code>设备。</li><li>Platform驱动向ASoC注册<code>snd_soc_platform</code>和<code>snd_soc_dai</code>设备。</li><li>Machine驱动通过<code>snd_soc_dai_link</code>绑定codec&#x2F;dai&#x2F;platform.</li></ul><p>Widget是各个组件内部的小单元。处在活动通路上电，不在活动通路下电。ASoC的DAPM正是通过控制这些Widget的上下电达到动态电源管理的效果。</p><ul><li>path描述与其它widget的连接关系。</li><li>event用于通知该widget的上下电状态。</li><li>power指示当前的上电状态。</li><li>control实现空间用户接口用于控制widget的音量&#x2F;通路切换等。</li></ul><p>对驱动开者来说，就可以很好的解耦了：</p><ul><li>codec驱动的开发者，实现codec的IO读写方法，描述DAI支持的数据格式&#x2F;操作方法和Widget的连接关系就可以了;</li><li>soc芯片的驱动开发者，Platform实现snd_pcm的操作方法集和DAI的配置如操作 DMA，I2S&#x2F;AC97&#x2F;PCM的设定等;</li><li>板级的开发者，描述Machine上codec与platform之间的总线连接， earphone&#x2F;Speaker的布线情况就可以了。</li></ul><h3 id=DAPM><a href=#DAPM class=headerlink title=DAPM></a>DAPM</h3><h3 id=DPCM><a href=#DPCM class=headerlink title=DPCM></a>DPCM</h3><blockquote><p><span class=exturl data-url=aHR0cHM6Ly9naXQua2VybmVsLm9yZy9wdWIvc2NtL2xpbnV4L2tlcm5lbC9naXQvdG9ydmFsZHMvbGludXguZ2l0L3BsYWluL0RvY3VtZW50YXRpb24vc291bmQvc29jL2RwY20ucnN0P2g9djQuMTYtcmM1>Dynamic PCM<i class="fa fa-external-link-alt"></i></span></p></blockquote><h2 id=PCM设备><a href=#PCM设备 class=headerlink title=PCM设备></a>PCM设备</h2><h3 id=放音-–-应用><a href=#放音-–-应用 class=headerlink title="放音 – 应用"></a>放音 – 应用</h3><blockquote><p><code>tinyplay</code>播放音乐</p></blockquote><figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br><span class=line>52</span><br><span class=line>53</span><br><span class=line>54</span><br><span class=line>55</span><br><span class=line>56</span><br><span class=line>57</span><br></pre></td><td class=code><pre><span class=line><span class=meta># strace  tinyplay  pcmrec.wav</span></span><br><span class=line>execve(<span class=string>&quot;/usr/bin/tinyplay&quot;</span>, [<span class=string>&quot;tinyplay&quot;</span>, <span class=string>&quot;pcmrec.wav&quot;</span>], [<span class=comment>/* 16 vars */</span>]) = <span class=number>0</span></span><br><span class=line></span><br><span class=line>...</span><br><span class=line></span><br><span class=line>open(<span class=string>&quot;pcmrec.wav&quot;</span>, O_RDONLY)            = <span class=number>3</span></span><br><span class=line>...</span><br><span class=line><span class=comment>//读取wav格式的音频文件的头数据</span></span><br><span class=line>read(<span class=number>3</span>, <span class=string>&quot;RIFF$\342\4\0WAVEfmt \20\0\0\0\1\0\2\0@\37\0\0\0&#125;\0\0&quot;</span>..., <span class=number>4096</span>) = <span class=number>4096</span></span><br><span class=line></span><br><span class=line><span class=comment>//第一次打开`pcmC0D0p`设备节点, 重新设置硬件参数</span></span><br><span class=line>open(<span class=string>&quot;/dev/snd/pcmC0D0p&quot;</span>, O_RDWR)       = <span class=number>4</span></span><br><span class=line><span class=comment>//ioctl - cmd=SNDRV_PCM_IOCTL_HW_REFINE</span></span><br><span class=line>ioctl(<span class=number>4</span>, <span class=number>0xc25c4110</span>, <span class=number>0x412178</span>)          = <span class=number>0</span></span><br><span class=line>close(<span class=number>4</span>)                                = <span class=number>0</span></span><br><span class=line></span><br><span class=line><span class=comment>//第二次打开`pcmC0D0p`设备节点, 进行音频播放的准备工作和播放</span></span><br><span class=line>open(<span class=string>&quot;/dev/snd/pcmC0D0p&quot;</span>, O_RDWR)       = <span class=number>4</span></span><br><span class=line><span class=comment>//ioctl - cmd=`SNDRV_PCM_IOCTL_INFO`</span></span><br><span class=line>ioctl(<span class=number>4</span>, AGPIOC_ACQUIRE or APM_IOC_STANDBY, <span class=number>0x7f83f3cc</span>) = <span class=number>0</span></span><br><span class=line><span class=comment>//ioctl - cmd=`SNDRV_PCM_IOCTL_HW_PARAMS`</span></span><br><span class=line>ioctl(<span class=number>4</span>, <span class=number>0xc25c4111</span>, <span class=number>0x7f83f170</span>)        = <span class=number>0</span></span><br><span class=line><span class=comment>//ioctl - cmd=`SNDRV_PCM_IOCTL_SW_PARAMS`</span></span><br><span class=line>ioctl(<span class=number>4</span>, <span class=number>0xc0684113</span>, <span class=number>0x7f83f5ec</span>)        = <span class=number>0</span></span><br><span class=line></span><br><span class=line><span class=comment>//在播放期间响应Ctrl+C的中断信号</span></span><br><span class=line>rt_sigaction(SIGINT, &#123;<span class=number>0x10000000</span>, [RT_65 RT_67], <span class=number>0x401240</span> <span class=comment>/* SA_??? */</span>&#125;, &#123;SIG_DFL, [RT_67 RT_68 RT_72 RT_74 RT_75 RT_77 RT_81 RT_89 RT_90 RT_91 RT_93 RT_94], <span class=number>0</span>&#125;, <span class=number>16</span>) = <span class=number>0</span></span><br><span class=line></span><br><span class=line><span class=comment>// mmap</span></span><br><span class=line></span><br><span class=line><span class=comment>// ioctl - cmd=`SNDRV_PCM_IOCTL_SYNC_PTR`</span></span><br><span class=line></span><br><span class=line>read(<span class=number>3</span>, <span class=string>&quot;\320\367\200\367\370\370`\370\220\370\330\370@\372h\371\240\371\320\374\230\373\240\374\341\5\301\1\241\5\221\25&quot;</span>..., <span class=number>12288</span>) = <span class=number>12288</span></span><br><span class=line>read(<span class=number>3</span>, <span class=string>&quot;a\0361\36\241\f\10\376\300\374\320\375\30\375\360\375\340\375\0\377\320\377(\377\370\376p\375p\374\321\0&quot;</span>..., <span class=number>4096</span>) = <span class=number>4096</span></span><br><span class=line><span class=comment>//ioctl - cmd=`SNDRV_PCM_IOCTL_PREPARE`</span></span><br><span class=line>ioctl(<span class=number>4</span>, <span class=number>0x20004140</span>, <span class=number>0x7f83f648</span>)        = <span class=number>0</span></span><br><span class=line><span class=comment>//ioctl - cmd=`SNDRV_PCM_IOCTL_WRITEI_FRAMES`</span></span><br><span class=line>ioctl(<span class=number>4</span>, <span class=number>0x800c4150</span>, <span class=number>0x7f83f648</span>)        = <span class=number>0</span></span><br><span class=line>read(<span class=number>3</span>, <span class=string>&quot;\201\21\301\27q\30\261\25\301\20Q\6x\375h\373\370\373\230\374\210\374x\374p\374\220\374\30\375 \375&quot;</span>..., <span class=number>12288</span>) = <span class=number>12288</span></span><br><span class=line>read(<span class=number>3</span>, <span class=string>&quot;\201\35\1%\241&#x27;\301\32\341\t@\377\250\374\220\372\20\373\30\374\340\373X\374H\374X\376\201\v\321\32&quot;</span>..., <span class=number>4096</span>) = <span class=number>4096</span></span><br><span class=line>ioctl(<span class=number>4</span>, <span class=number>0x800c4150</span>, <span class=number>0x7f83f648</span>)        = <span class=number>0</span></span><br><span class=line></span><br><span class=line>... <span class=comment>//while()&#123; 循环读取播放 &#125;</span></span><br><span class=line></span><br><span class=line>read(<span class=number>3</span>, <span class=string>&quot;\370\375\10\376 \376\210\376X\376x\376\250\376\350\376\360\376\260\376(\377H\377q\0\301\5\1\vq\21&quot;</span>..., <span class=number>12288</span>) = <span class=number>12288</span></span><br><span class=line>read(<span class=number>3</span>, <span class=string>&quot;\221\0021\n\21\f\241\5x\376\30\377\300\377(\377\1\1!\3q\4Q\3\301\4\240\377h\376\210\377&quot;</span>..., <span class=number>4096</span>) = <span class=number>4096</span></span><br><span class=line>ioctl(<span class=number>4</span>, <span class=number>0x800c4150</span>, <span class=number>0x7f83f648</span>)        = <span class=number>0</span></span><br><span class=line>read(<span class=number>3</span>, <span class=string>&quot;P\377\0\377!\0\361\6Q\t\230\377@\376\250\377X\377\361\3\1\16\241\n!\0!\6A\16\241\v&quot;</span>..., <span class=number>12288</span>) = <span class=number>4652</span></span><br><span class=line>read(<span class=number>3</span>, <span class=string>&quot;&quot;</span>, <span class=number>4096</span>)                       = <span class=number>0</span></span><br><span class=line>ioctl(<span class=number>4</span>, <span class=number>0x800c4150</span>, <span class=number>0x7f83f648</span>)        = <span class=number>0</span></span><br><span class=line>read(<span class=number>3</span>, <span class=string>&quot;&quot;</span>, <span class=number>16384</span>)                      = <span class=number>0</span></span><br><span class=line>ioctl(<span class=number>4</span>, <span class=number>0x800c4150</span>, <span class=number>0x7f83f648</span>)        = <span class=number>0</span></span><br><span class=line>close(<span class=number>4</span>)                                = <span class=number>0</span></span><br><span class=line>close(<span class=number>3</span>)                                = <span class=number>0</span></span><br><span class=line>munmap(<span class=number>0x76fe9000</span>, <span class=number>65536</span>)               = <span class=number>0</span></span><br><span class=line>write(<span class=number>1</span>, <span class=string>&quot;Playing sample: 2 ch, 8000 hz, 1&quot;</span>..., <span class=number>38</span>) = <span class=number>38</span>  <span class=comment>//printf</span></span><br><span class=line>exit_group(<span class=number>0</span>)</span><br></pre></td></tr></table></figure><h4 id=为什么open两次pcmC0D0p设备节点><a href=#为什么open两次pcmC0D0p设备节点 class=headerlink title=为什么open两次pcmC0D0p设备节点></a>为什么open两次pcmC0D0p设备节点</h4><ol><li>第一次打开<code>pcmC0D0p</code>,主要为了重新规范硬件<figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br></pre></td><td class=code><pre><span class=line><span class=class><span class=keyword>struct</span> <span class=title>snd_pcm_hw_params</span> &#123;</span></span><br><span class=line>    <span class=type>unsigned</span> <span class=type>int</span> flags;</span><br><span class=line>    <span class=class><span class=keyword>struct</span> <span class=title>snd_mask</span> <span class=title>masks</span>[<span class=title>SNDRV_PCM_HW_PARAM_LAST_MASK</span> -</span></span><br><span class=line><span class=class>                   <span class=title>SNDRV_PCM_HW_PARAM_FIRST_MASK</span> + 1];</span></span><br><span class=line>    <span class=class><span class=keyword>struct</span> <span class=title>snd_mask</span> <span class=title>mres</span>[5];</span>    <span class=comment>/* reserved masks */</span></span><br><span class=line>    <span class=class><span class=keyword>struct</span> <span class=title>snd_interval</span> <span class=title>intervals</span>[<span class=title>SNDRV_PCM_HW_PARAM_LAST_INTERVAL</span> -</span></span><br><span class=line><span class=class>                        <span class=title>SNDRV_PCM_HW_PARAM_FIRST_INTERVAL</span> + 1];</span></span><br><span class=line>    <span class=class><span class=keyword>struct</span> <span class=title>snd_interval</span> <span class=title>ires</span>[9];</span>    <span class=comment>/* reserved intervals */</span></span><br><span class=line>    <span class=type>unsigned</span> <span class=type>int</span> rmask;     <span class=comment>/* W: requested masks */</span></span><br><span class=line>    <span class=type>unsigned</span> <span class=type>int</span> cmask;     <span class=comment>/* R: changed masks */</span></span><br><span class=line>    <span class=type>unsigned</span> <span class=type>int</span> info;      <span class=comment>/* R: Info flags for returned setup */</span></span><br><span class=line>    <span class=type>unsigned</span> <span class=type>int</span> msbits;        <span class=comment>/* R: used most significant bits */</span></span><br><span class=line>    <span class=type>unsigned</span> <span class=type>int</span> rate_num;      <span class=comment>/* R: rate numerator */</span></span><br><span class=line>    <span class=type>unsigned</span> <span class=type>int</span> rate_den;      <span class=comment>/* R: rate denominator */</span></span><br><span class=line>    <span class=type>snd_pcm_uframes_t</span> fifo_size;    <span class=comment>/* R: chip FIFO size in frames */</span></span><br><span class=line>    <span class=type>unsigned</span> <span class=type>char</span> reserved[<span class=number>64</span>]; <span class=comment>/* reserved for future */</span></span><br><span class=line>&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>file: include&#x2F;uapi&#x2F;sound&#x2F;asound.h</p></blockquote></li></ol><p>主要是将用户空间的snd_pcm_hw_params信息和内核空间的进行对比和规范化</p><ol start=2><li>第二次打开<code>pcmC0D0p</code>,主要为了进行音频播放的准备和播放音频信号</li></ol><h4 id=为什么read音频文件两次-并且读的数据大小不一致><a href=#为什么read音频文件两次-并且读的数据大小不一致 class=headerlink title=为什么read音频文件两次,并且读的数据大小不一致></a>为什么read音频文件两次,并且读的数据大小不一致</h4><p>tinyplay中播放时,每次只读取一部分(16KB)的音频文件进行播放</p><figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br></pre></td><td class=code><pre><span class=line>size = pcm_frames_to_bytes(pcm, pcm_get_buffer_size(pcm)); <span class=comment>//size=16384Byte=16KB</span></span><br><span class=line>buffer = <span class=built_in>malloc</span>(size);</span><br><span class=line>...</span><br><span class=line><span class=keyword>do</span> &#123;</span><br><span class=line>	<span class=comment>//buffer 临时存放音频文件的数据的buf</span></span><br><span class=line>	<span class=comment>//size   一次读取的大小(16384Byte)</span></span><br><span class=line>	<span class=comment>//file   打开的音频文件描述符</span></span><br><span class=line>    num_read = fread(buffer, <span class=number>1</span>, size, file);</span><br><span class=line>    <span class=keyword>if</span> (num_read &gt; <span class=number>0</span>) &#123;</span><br><span class=line>        <span class=keyword>if</span> (pcm_write(pcm, buffer, num_read)) &#123;</span><br><span class=line>            <span class=built_in>fprintf</span>(<span class=built_in>stderr</span>, <span class=string>&quot;Error playing sample\n&quot;</span>);</span><br><span class=line>            <span class=keyword>break</span>;</span><br><span class=line>        &#125;</span><br><span class=line>    &#125;<span class=keyword>else</span> <span class=keyword>if</span>(num_read == <span class=number>0</span>) &#123;</span><br><span class=line>        <span class=built_in>memset</span>(buffer, <span class=number>0</span>, size);</span><br><span class=line>        <span class=keyword>if</span>(pcm_write(pcm, buffer, size))&#123;</span><br><span class=line>            <span class=built_in>fprintf</span>(<span class=built_in>stderr</span>, <span class=string>&quot;Error playing sample\n&quot;</span>);</span><br><span class=line>            <span class=keyword>break</span>;</span><br><span class=line>        &#125;</span><br><span class=line>    &#125;</span><br><span class=line>&#125; <span class=keyword>while</span> (!close &amp;&amp; num_read &gt; <span class=number>0</span>);</span><br></pre></td></tr></table></figure><p>在进行strace时,一次播放进行了两次的read系统调用,将每一次read数据的大小相加(12288+4096&#x3D;16384Byte),正好与malloc的buffer大小一致.因此两次的read是由用户空间的函数进行数据分割的.</p><h4 id=用户空间申请buffer大小的依据><a href=#用户空间申请buffer大小的依据 class=headerlink title=用户空间申请buffer大小的依据></a>用户空间申请buffer大小的依据</h4><p>在播放当前歌曲时,所申请的buffer大小为16KB,为什么申请16K?</p><p>音频信息:</p><table><thead><tr><th align=center>采样率</th><th align=center>通道</th><th align=center>位宽(format)</th></tr></thead><tbody><tr><td align=center>44100Hz</td><td align=center>2</td><td align=center>16bit</td></tr></tbody></table><blockquote><p>4KB的buffer大小为<code>tinyplay</code>默认大小,<code>period_size = 1024</code>, <code>period_count = 4</code>决定了buffer大小,而<code>period_size</code>可以进行修改默认大小.</p></blockquote><p>需要申请buffer的大小: 1024 * 4 * 2 * (16 &#x2F; 8) &#x3D; 16384</p><h3 id=放音-–-内核><a href=#放音-–-内核 class=headerlink title="放音 – 内核"></a>放音 – 内核</h3><h4 id=ASOC接口><a href=#ASOC接口 class=headerlink title=ASOC接口></a>ASOC接口</h4><figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br></pre></td><td class=code><pre><span class=line><span class=comment>/* create a new pcm */</span></span><br><span class=line><span class=type>int</span> <span class="title function_">soc_new_pcm</span><span class=params>(<span class=keyword>struct</span> snd_soc_pcm_runtime *rtd, <span class=type>int</span> num)</span></span><br><span class=line>&#123;</span><br><span class=line>	...</span><br><span class=line>	<span class=comment>/* ASoC PCM operations */</span></span><br><span class=line>	<span class=keyword>if</span> (rtd-&gt;dai_link-&gt;dynamic) &#123;</span><br><span class=line>		rtd-&gt;ops.open       = dpcm_fe_dai_open;</span><br><span class=line>		rtd-&gt;ops.hw_params  = dpcm_fe_dai_hw_params;</span><br><span class=line>		rtd-&gt;ops.prepare    = dpcm_fe_dai_prepare;</span><br><span class=line>		rtd-&gt;ops.trigger    = dpcm_fe_dai_trigger;</span><br><span class=line>		rtd-&gt;ops.hw_free    = dpcm_fe_dai_hw_free;</span><br><span class=line>		rtd-&gt;ops.close      = dpcm_fe_dai_close;</span><br><span class=line>		rtd-&gt;ops.pointer    = soc_pcm_pointer;</span><br><span class=line>		rtd-&gt;ops.ioctl      = soc_pcm_ioctl;</span><br><span class=line>	&#125; <span class=keyword>else</span> &#123;</span><br><span class=line>		<span class=comment>//回调函数</span></span><br><span class=line>		rtd-&gt;ops.open       = soc_pcm_open;</span><br><span class=line>		rtd-&gt;ops.hw_params  = soc_pcm_hw_params;</span><br><span class=line>		rtd-&gt;ops.prepare    = soc_pcm_prepare;</span><br><span class=line>		rtd-&gt;ops.trigger    = soc_pcm_trigger;</span><br><span class=line>		rtd-&gt;ops.hw_free    = soc_pcm_hw_free;</span><br><span class=line>		rtd-&gt;ops.close      = soc_pcm_close;</span><br><span class=line>		rtd-&gt;ops.pointer    = soc_pcm_pointer;</span><br><span class=line>		rtd-&gt;ops.ioctl      = soc_pcm_ioctl;</span><br><span class=line>	&#125;</span><br><span class=line></span><br><span class=line>	<span class=keyword>if</span> (platform-&gt;driver-&gt;ops) &#123;</span><br><span class=line>		rtd-&gt;ops.ack        = platform-&gt;driver-&gt;ops-&gt;ack;</span><br><span class=line>		rtd-&gt;ops.copy       = platform-&gt;driver-&gt;ops-&gt;copy;</span><br><span class=line>		rtd-&gt;ops.silence    = platform-&gt;driver-&gt;ops-&gt;silence;</span><br><span class=line>		rtd-&gt;ops.page       = platform-&gt;driver-&gt;ops-&gt;page;</span><br><span class=line>		rtd-&gt;ops.mmap       = platform-&gt;driver-&gt;ops-&gt;mmap;</span><br><span class=line>	&#125;</span><br><span class=line></span><br><span class=line>	<span class=keyword>if</span> (playback)</span><br><span class=line>		snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &amp;rtd-&gt;ops);</span><br><span class=line></span><br><span class=line>	<span class=keyword>if</span> (capture)</span><br><span class=line>		snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &amp;rtd-&gt;ops);</span><br><span class=line>	...</span><br><span class=line>&#125;</span><br></pre></td></tr></table></figure><blockquote><p>file: sound&#x2F;soc&#x2F;soc-pcm.c</p></blockquote><h5 id=soc-pcm-open><a href=#soc-pcm-open class=headerlink title=soc_pcm_open></a>soc_pcm_open</h5><figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br></pre></td><td class=code><pre><span class=line>static int soc_pcm_open(struct snd_pcm_substream *substream)</span><br><span class=line>&#123;</span><br><span class=line>	...</span><br><span class=line>	// CPU &lt;I2S&gt; : jz_i2s_startup</span><br><span class=line>	if (cpu_dai-&gt;driver-&gt;ops-&gt;startup) &#123;</span><br><span class=line>		 ret = cpu_dai-&gt;driver-&gt;ops-&gt;startup(substream, cpu_dai);</span><br><span class=line>	&#125;</span><br><span class=line>	// Platform &lt;DMA&gt; : jz_pcm_open</span><br><span class=line>	if (platform-&gt;driver-&gt;ops &amp;&amp; platform-&gt;driver-&gt;ops-&gt;open) &#123;</span><br><span class=line>		 ret = platform-&gt;driver-&gt;ops-&gt;open(substream);</span><br><span class=line>	&#125;</span><br><span class=line>	// Codec &lt;idec_d3&gt; : jz_icdc_startup</span><br><span class=line>	if (codec_dai-&gt;driver-&gt;ops-&gt;startup) &#123;</span><br><span class=line>		 ret = codec_dai-&gt;driver-&gt;ops-&gt;startup(substream, codec_dai);</span><br><span class=line>	&#125;</span><br><span class=line> 	// Machine &lt;link&gt; : phoenix_spk_sup  file:sound/soc/ingenic/asoc-board/phoenix_icdc.c</span><br><span class=line>	if (rtd-&gt;dai_link-&gt;ops &amp;&amp; rtd-&gt;dai_link-&gt;ops-&gt;startup) &#123;</span><br><span class=line>		 ret = rtd-&gt;dai_link-&gt;ops-&gt;startup(substream);</span><br><span class=line>	&#125;</span><br><span class=line>	...</span><br><span class=line>&#125;</span><br></pre></td></tr></table></figure><h5 id=soc-pcm-hw-params><a href=#soc-pcm-hw-params class=headerlink title=soc_pcm_hw_params></a>soc_pcm_hw_params</h5><figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br></pre></td><td class=code><pre><span class=line><span class=type>static</span> <span class=type>int</span> <span class="title function_">soc_pcm_hw_params</span><span class=params>(<span class=keyword>struct</span> snd_pcm_substream *substream,</span></span><br><span class=line><span class=params>                <span class=keyword>struct</span> snd_pcm_hw_params *params)</span></span><br><span class=line>&#123;</span><br><span class=line>	 ...</span><br><span class=line>	 <span class=comment>// Machine &lt;link&gt; : phoenix_i2s_hw_params</span></span><br><span class=line>	 <span class=keyword>if</span> (rtd-&gt;dai_link-&gt;ops &amp;&amp; rtd-&gt;dai_link-&gt;ops-&gt;hw_params) &#123;</span><br><span class=line>		 ret = rtd-&gt;dai_link-&gt;ops-&gt;hw_params(substream, params);</span><br><span class=line>	 &#125;</span><br><span class=line>	 <span class=comment>// Codec &lt;idec_d3&gt; : icdc_d3_hw_params</span></span><br><span class=line>	 <span class=keyword>if</span> (codec_dai-&gt;driver-&gt;ops-&gt;hw_params) &#123;</span><br><span class=line>		 ret = codec_dai-&gt;driver-&gt;ops-&gt;hw_params(substream, params, codec_dai);</span><br><span class=line>	 &#125;</span><br><span class=line>	 <span class=comment>// CPU &lt;I2S&gt; : jz_i2s_hw_params</span></span><br><span class=line>	 <span class=keyword>if</span> (cpu_dai-&gt;driver-&gt;ops-&gt;hw_params) &#123;</span><br><span class=line>		 ret = cpu_dai-&gt;driver-&gt;ops-&gt;hw_params(substream, params, cpu_dai);</span><br><span class=line>	 &#125;</span><br><span class=line>	 <span class=comment>// Platform &lt;DMA&gt; : jz_pcm_hw_params</span></span><br><span class=line>	 <span class=keyword>if</span> (platform-&gt;driver-&gt;ops &amp;&amp; platform-&gt;driver-&gt;ops-&gt;hw_params) &#123;</span><br><span class=line>		 ret = platform-&gt;driver-&gt;ops-&gt;hw_params(substream, params);</span><br><span class=line> 	&#125;</span><br><span class=line> 	...</span><br><span class=line>&#125;</span><br></pre></td></tr></table></figure><h5 id=soc-pcm-prepare><a href=#soc-pcm-prepare class=headerlink title=soc_pcm_prepare></a>soc_pcm_prepare</h5><figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br></pre></td><td class=code><pre><span class=line><span class=type>static</span> <span class=type>int</span> <span class="title function_">soc_pcm_prepare</span><span class=params>(<span class=keyword>struct</span> snd_pcm_substream *substream)</span></span><br><span class=line>&#123;</span><br><span class=line>	...</span><br><span class=line>	<span class=comment>// Machine &lt;link&gt; : phoenix_i2s_hw_params</span></span><br><span class=line>	<span class=keyword>if</span> (rtd-&gt;dai_link-&gt;ops &amp;&amp; rtd-&gt;dai_link-&gt;ops-&gt;prepare) &#123;</span><br><span class=line>		ret = rtd-&gt;dai_link-&gt;ops-&gt;prepare(substream);</span><br><span class=line>	&#125;</span><br><span class=line>	<span class=comment>// Platform &lt;DMA&gt; :	jz_pcm_prepare</span></span><br><span class=line>	<span class=keyword>if</span> (platform-&gt;driver-&gt;ops &amp;&amp; platform-&gt;driver-&gt;ops-&gt;prepare) &#123;</span><br><span class=line>		ret = platform-&gt;driver-&gt;ops-&gt;prepare(substream);</span><br><span class=line>	&#125;</span><br><span class=line>   	<span class=comment>// Codec &lt;idec_d3&gt; : 默认函数</span></span><br><span class=line>	<span class=keyword>if</span> (codec_dai-&gt;driver-&gt;ops-&gt;prepare) &#123;</span><br><span class=line>		ret = codec_dai-&gt;driver-&gt;ops-&gt;prepare(substream, codec_dai);</span><br><span class=line>	&#125;</span><br><span class=line>	<span class=comment>// CPU &lt;I2S&gt; : 默认函数</span></span><br><span class=line>	<span class=keyword>if</span> (cpu_dai-&gt;driver-&gt;ops-&gt;prepare) &#123;</span><br><span class=line>		ret = cpu_dai-&gt;driver-&gt;ops-&gt;prepare(substream, cpu_dai);</span><br><span class=line>	&#125;</span><br><span class=line>    ...</span><br><span class=line>&#125;</span><br></pre></td></tr></table></figure><h5 id=soc-pcm-trigger><a href=#soc-pcm-trigger class=headerlink title=soc_pcm_trigger></a>soc_pcm_trigger</h5><figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br></pre></td><td class=code><pre><span class=line><span class=type>static</span> <span class=type>int</span> <span class="title function_">soc_pcm_trigger</span><span class=params>(<span class=keyword>struct</span> snd_pcm_substream *substream, <span class=type>int</span> cmd)</span></span><br><span class=line>&#123;</span><br><span class=line>	<span class=comment>// Codec &lt;idec_d3&gt; : icdc_d3_trigger</span></span><br><span class=line>	<span class=keyword>if</span> (codec_dai-&gt;driver-&gt;ops-&gt;trigger) &#123;</span><br><span class=line>		ret = codec_dai-&gt;driver-&gt;ops-&gt;trigger(substream, cmd, codec_dai);</span><br><span class=line>	&#125;</span><br><span class=line>	<span class=comment>// Platform &lt;DMA&gt; :	jz_pcm_trigger</span></span><br><span class=line>	<span class=keyword>if</span> (platform-&gt;driver-&gt;ops &amp;&amp; platform-&gt;driver-&gt;ops-&gt;trigger) &#123;</span><br><span class=line>		ret = platform-&gt;driver-&gt;ops-&gt;trigger(substream, cmd);</span><br><span class=line>	&#125;</span><br><span class=line>	<span class=comment>// CPU &lt;I2S&gt; : jz_i2s_trigger</span></span><br><span class=line>	<span class=keyword>if</span> (cpu_dai-&gt;driver-&gt;ops-&gt;trigger) &#123;</span><br><span class=line>		ret = cpu_dai-&gt;driver-&gt;ops-&gt;trigger(substream, cmd, cpu_dai);</span><br><span class=line>	&#125;</span><br><span class=line>    ...</span><br><span class=line>&#125;</span><br></pre></td></tr></table></figure><h5 id=soc-pcm-hw-free><a href=#soc-pcm-hw-free class=headerlink title=soc_pcm_hw_free></a>soc_pcm_hw_free</h5><figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br></pre></td><td class=code><pre><span class=line><span class=type>static</span> <span class=type>int</span> <span class="title function_">soc_pcm_hw_free</span><span class=params>(<span class=keyword>struct</span> snd_pcm_substream *substream)</span></span><br><span class=line>&#123;</span><br><span class=line>	<span class=comment>/* free any machine hw params */</span></span><br><span class=line>	<span class=comment>// Machine &lt;link&gt; : phoenix_i2s_hw_free</span></span><br><span class=line>	<span class=keyword>if</span> (rtd-&gt;dai_link-&gt;ops &amp;&amp; rtd-&gt;dai_link-&gt;ops-&gt;hw_free)</span><br><span class=line>		rtd-&gt;dai_link-&gt;ops-&gt;hw_free(substream);</span><br><span class=line></span><br><span class=line>	<span class=comment>/* free any DMA resources */</span></span><br><span class=line>	<span class=comment>// Platform &lt;DMA&gt; : snd_pcm_lib_free_pages</span></span><br><span class=line>	<span class=keyword>if</span> (platform-&gt;driver-&gt;ops &amp;&amp; platform-&gt;driver-&gt;ops-&gt;hw_free)</span><br><span class=line>		platform-&gt;driver-&gt;ops-&gt;hw_free(substream);</span><br><span class=line></span><br><span class=line>	<span class=comment>/* now free hw params for the DAIs  */</span></span><br><span class=line>	<span class=comment>// Codec &lt;idec_d3&gt; : 默认函数</span></span><br><span class=line>	<span class=keyword>if</span> (codec_dai-&gt;driver-&gt;ops-&gt;hw_free)</span><br><span class=line>		codec_dai-&gt;driver-&gt;ops-&gt;hw_free(substream, codec_dai);</span><br><span class=line>	<span class=comment>// CPU &lt;I2S&gt; : 默认函数</span></span><br><span class=line>	<span class=keyword>if</span> (cpu_dai-&gt;driver-&gt;ops-&gt;hw_free)</span><br><span class=line>		cpu_dai-&gt;driver-&gt;ops-&gt;hw_free(substream, cpu_dai);</span><br><span class=line>    ...</span><br><span class=line>&#125;</span><br></pre></td></tr></table></figure><h5 id=soc-pcm-pointer><a href=#soc-pcm-pointer class=headerlink title=soc_pcm_pointer></a>soc_pcm_pointer</h5><figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br></pre></td><td class=code><pre><span class=line><span class=type>static</span> <span class=type>snd_pcm_uframes_t</span> <span class="title function_">soc_pcm_pointer</span><span class=params>(<span class=keyword>struct</span> snd_pcm_substream *substream)</span></span><br><span class=line>&#123;</span><br><span class=line>    <span class=comment>// Platform &lt;DMA&gt; :</span></span><br><span class=line>    <span class=keyword>if</span> (platform-&gt;driver-&gt;ops &amp;&amp; platform-&gt;driver-&gt;ops-&gt;pointer)</span><br><span class=line>        offset = platform-&gt;driver-&gt;ops-&gt;pointer(substream);</span><br><span class=line></span><br><span class=line>    <span class=keyword>if</span> (cpu_dai-&gt;driver-&gt;ops-&gt;delay)</span><br><span class=line>        delay += cpu_dai-&gt;driver-&gt;ops-&gt;delay(substream, cpu_dai);</span><br><span class=line></span><br><span class=line>    <span class=keyword>if</span> (codec_dai-&gt;driver-&gt;ops-&gt;delay)</span><br><span class=line>        delay += codec_dai-&gt;driver-&gt;ops-&gt;delay(substream, codec_dai);</span><br><span class=line></span><br><span class=line>    <span class=keyword>if</span> (platform-&gt;driver-&gt;delay)</span><br><span class=line>        delay += platform-&gt;driver-&gt;delay(substream, codec_dai);</span><br><span class=line>&#125;</span><br><span class=line></span><br></pre></td></tr></table></figure><h5 id=soc-pcm-close><a href=#soc-pcm-close class=headerlink title=soc_pcm_close></a>soc_pcm_close</h5><figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br></pre></td><td class=code><pre><span class=line><span class=type>static</span> <span class=type>int</span> <span class="title function_">soc_pcm_close</span><span class=params>(<span class=keyword>struct</span> snd_pcm_substream *substream)</span></span><br><span class=line>&#123;</span><br><span class=line>	 <span class=comment>// CPU &lt;I2S&gt; : jz_i2s_shutdown</span></span><br><span class=line>	<span class=keyword>if</span> (cpu_dai-&gt;driver-&gt;ops-&gt;shutdown)</span><br><span class=line>		cpu_dai-&gt;driver-&gt;ops-&gt;shutdown(substream, cpu_dai);</span><br><span class=line>	<span class=comment>// Codec &lt;idec_d3&gt; : jz_icdc_shutdown</span></span><br><span class=line>	<span class=keyword>if</span> (codec_dai-&gt;driver-&gt;ops-&gt;shutdown)</span><br><span class=line>		codec_dai-&gt;driver-&gt;ops-&gt;shutdown(substream, codec_dai);</span><br><span class=line>	<span class=comment>// Machine &lt;link&gt; : phoenix_spk_sdown</span></span><br><span class=line>	<span class=keyword>if</span> (rtd-&gt;dai_link-&gt;ops &amp;&amp; rtd-&gt;dai_link-&gt;ops-&gt;shutdown)</span><br><span class=line>		rtd-&gt;dai_link-&gt;ops-&gt;shutdown(substream);</span><br><span class=line>	<span class=comment>// Platform &lt;DMA&gt; :	jz_pcm_close</span></span><br><span class=line>	<span class=keyword>if</span> (platform-&gt;driver-&gt;ops &amp;&amp; platform-&gt;driver-&gt;ops-&gt;close)</span><br><span class=line>		platform-&gt;driver-&gt;ops-&gt;close(substream);</span><br><span class=line>	...</span><br><span class=line>&#125;</span><br></pre></td></tr></table></figure><h4 id=open><a href=#open class=headerlink title=open></a>open</h4><figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br></pre></td><td class=code><pre><span class=line>|(sound/core/pcm_native.c )</span><br><span class=line>|-&gt; snd_pcm_playback_open</span><br><span class=line>  \</span><br><span class=line>  |-&gt; snd_pcm_open(file, pcm, SNDRV_PCM_STREAM_PLAYBACK);</span><br><span class=line>    \</span><br><span class=line>    |-&gt; <span class=keyword>while</span>(<span class=number>1</span>)&#123; snd_pcm_open_file(file, pcm, stream); schedule(); &#125;</span><br><span class=line>      \</span><br><span class=line>      |-&gt; snd_pcm_open_substream</span><br><span class=line>		\</span><br><span class=line>		|-&gt; substream-&gt;ops-&gt;open(substream)</span><br><span class=line>		  |(sound/soc/soc-pcm.c)</span><br><span class=line>		  |-&gt; soc_pcm_open</span><br><span class=line>			\</span><br><span class=line>			|-&gt; cpu_dai-&gt;driver-&gt;ops-&gt;startup(substream, cpu_dai);</span><br><span class=line>			  \_**snd_soc_register_component** -&gt; snd_soc_dai_driver -&gt; snd_soc_dai_ops (.startup = jz_i2s_startup)</span><br><span class=line>			|-&gt; codec_dai-&gt;driver-&gt;ops-&gt;startup(substream, codec_dai);</span><br><span class=line>			  \_**snd_soc_register_codec** -&gt; snd_soc_dai_driver -&gt; snd_soc_dai_ops (.startup = jz_icdc_startup)</span><br><span class=line>			|-&gt; rtd-&gt;dai_link-&gt;ops-&gt;startup(substream);</span><br><span class=line>			  \_ **snd_soc_register_card** -&gt; snd_soc_dai_link -&gt; snd_soc_ops (.startup = phoenix_spk_sup)</span><br></pre></td></tr></table></figure><h4 id=ioctl><a href=#ioctl class=headerlink title=ioctl></a>ioctl</h4><blockquote><p>ioctl幻数</p></blockquote><figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br></pre></td><td class=code><pre><span class=line><span class=comment>//获取声卡信息返回给用户空间</span></span><br><span class=line><span class=meta>#<span class=keyword>define</span> SNDRV_PCM_IOCTL_INFO _IOR(<span class=string>&#x27;A&#x27;</span>, 0x01, struct snd_pcm_info)</span></span><br><span class=line><span class=comment>//硬件参数重新规范</span></span><br><span class=line><span class=meta>#<span class=keyword>define</span> SNDRV_PCM_IOCTL_HW_REFINE _IOWR(<span class=string>&#x27;A&#x27;</span>, 0x10, struct snd_pcm_hw_params)</span></span><br><span class=line><span class=comment>//设置硬件参数</span></span><br><span class=line><span class=meta>#<span class=keyword>define</span> SNDRV_PCM_IOCTL_HW_PARAMS _IOWR(<span class=string>&#x27;A&#x27;</span>, 0x11, struct snd_pcm_hw_params)</span></span><br><span class=line><span class=comment>//设置软件参数</span></span><br><span class=line><span class=meta>#<span class=keyword>define</span> SNDRV_PCM_IOCTL_SW_PARAMS _IOWR(<span class=string>&#x27;A&#x27;</span>, 0x13, struct snd_pcm_sw_params)</span></span><br><span class=line><span class=comment>//准备操作</span></span><br><span class=line><span class=meta>#<span class=keyword>define</span> SNDRV_PCM_IOCTL_PREPARE _IO(<span class=string>&#x27;A&#x27;</span>, 0x40)</span></span><br><span class=line><span class=comment>//从用户空间把音频数据拿过来，从wav文件中读出数据</span></span><br><span class=line><span class=meta>#<span class=keyword>define</span> SNDRV_PCM_IOCTL_WRITEI_FRAMES _IOW(<span class=string>&#x27;A&#x27;</span>, 0x50, struct snd_xferi)</span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br></pre></td><td class=code><pre><span class=line>(`sound/core/pcm_native.c`)</span><br><span class=line>|-&gt;	snd_pcm_playback_ioctl</span><br><span class=line>|</span><br><span class=line>|-&gt; snd_pcm_playback_ioctl1 --&gt; 判断cmd &lt;SNDRV_PCM_IOCTL_WRITEI_FRAMES&gt;</span><br><span class=line>|(`sound/core/pcm_lib.c`)</span><br><span class=line>|-&gt; snd_pcm_lib_write --- &gt; struct snd_pcm_substream *substream</span><br><span class=line>|</span><br><span class=line>|-&gt; snd_pcm_lib_write1</span><br><span class=line>		|_call_back--&gt;snd_pcm_lib_write_transfer(数据传输:copy和map)</span><br><span class=line>			|_.(内存和DMA之间的数据传递, 循环搬送直到播放完毕)</span><br><span class=line>					char *hwbuf = runtime-&gt;dma_area + frames_to_bytes(runtime, hwoff);</span><br><span class=line>					if (copy_from_user(hwbuf, buf, frames_to_bytes(runtime, frames)))</span><br><span class=line>		|</span><br><span class=line>		|-&gt; snd_pcm_start(substream) //**启动传输(只是在开始时,调用一次)**</span><br><span class=line>			|</span><br><span class=line>			|-&gt; snd_pcm_action</span><br><span class=line>				|</span><br><span class=line>				|-&gt; snd_pcm_action_single</span><br><span class=line>					|</span><br><span class=line>					|-&gt; &#123;</span><br><span class=line>							res = ops-&gt;pre_action(substream, state);</span><br><span class=line>							if (res &lt; 0)</span><br><span class=line> 						   		return res;</span><br><span class=line>							res = ops-&gt;do_action(substream, state);</span><br><span class=line>							if (res == 0)</span><br><span class=line> 						   		ops-&gt;post_action(substream, state);</span><br><span class=line>							else if (ops-&gt;undo_action)</span><br><span class=line>						    	ops-&gt;undo_action(substream, state);</span><br><span class=line>						&#125;</span><br></pre></td></tr></table></figure><blockquote><p>file: sound&#x2F;core&#x2F;pcm_native.c</p></blockquote><h4 id=close><a href=#close class=headerlink title=close></a>close</h4><p>通过系统调用close, 到release进行关闭</p><figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br></pre></td><td class=code><pre><span class=line>.release =      snd_pcm_release</span><br><span class=line></span><br><span class=line>snd_pcm_release</span><br><span class=line>  |</span><br><span class=line>  |-&gt; snd_pcm_release_substream</span><br><span class=line>	|</span><br><span class=line>	|-&gt; snd_pcm_drop</span><br><span class=line>	  |</span><br><span class=line>	  |-&gt; snd_pcm_stop</span><br><span class=line>		|</span><br><span class=line>		|-&gt; snd_pcm_action(&amp;snd_pcm_action_stop, substream, state)</span><br><span class=line>	|</span><br><span class=line>	|-&gt; substream-&gt;ops-&gt;hw_free(substream)</span><br><span class=line>	|-&gt; substream-&gt;ops-&gt;close(substream)</span><br></pre></td></tr></table></figure><h2 id=control设备><a href=#control设备 class=headerlink title=control设备></a>control设备</h2><h2 id=codec><a href=#codec class=headerlink title=codec></a>codec</h2><h2 id=数据路由><a href=#数据路由 class=headerlink title=数据路由></a>数据路由</h2><h2 id=amixer的设置><a href=#amixer的设置 class=headerlink title=amixer的设置></a>amixer的设置</h2><h2 id=调试><a href=#调试 class=headerlink title=调试></a>调试</h2><p>ASoC添加了debugfs和ftrace的调试支持。</p><figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br></pre></td><td class=code><pre><span class=line>mount -t debugfs none /mnt/</span><br><span class=line><span class="meta prompt_"></span></span><br><span class=line><span class="meta prompt_"># </span><span class=language-bash><span class=built_in>cat</span> available_events | grep <span class=string>&quot;asoc&quot;</span></span></span><br><span class=line>asoc:snd_soc_cache_sync</span><br><span class=line>asoc:snd_soc_jack_notify</span><br><span class=line>asoc:snd_soc_jack_report</span><br><span class=line>asoc:snd_soc_jack_irq</span><br><span class=line>asoc:snd_soc_dapm_connected</span><br><span class=line>asoc:snd_soc_dapm_input_path</span><br><span class=line>asoc:snd_soc_dapm_output_path</span><br><span class=line>asoc:snd_soc_dapm_walk_done</span><br><span class=line>asoc:snd_soc_dapm_widget_event_done</span><br><span class=line>asoc:snd_soc_dapm_widget_event_start</span><br><span class=line>asoc:snd_soc_dapm_widget_power</span><br><span class=line>asoc:snd_soc_dapm_done</span><br><span class=line>asoc:snd_soc_dapm_start</span><br><span class=line>asoc:snd_soc_bias_level_done</span><br><span class=line>asoc:snd_soc_bias_level_start</span><br><span class=line>asoc:snd_soc_preg_read</span><br><span class=line>asoc:snd_soc_preg_write</span><br><span class=line>asoc:snd_soc_reg_read</span><br><span class=line>asoc:snd_soc_reg_write</span><br></pre></td></tr></table></figure><ul><li>在DEBUGFS下，可以查看一个各个组件及widgets的状态。</li><li>在FTRACE下，<code>echo asoc &gt; tracing/set_event</code>打开调试，就可以<code>cat /mnt/tracing/trace</code>查看widget的上下电顺序， 通路的切换等。</li></ul><h2 id=性能><a href=#性能 class=headerlink title=性能></a>性能</h2><h3 id=频响><a href=#频响 class=headerlink title=频响></a>频响</h3><blockquote><p>频率响应 简称频响，英文名称是<code>Frequency Response</code>，在电子学上用来描述一台仪器对于不同频率的信号的处理能力的差异。</p></blockquote><h3 id=扫频><a href=#扫频 class=headerlink title=扫频></a>扫频</h3><blockquote><p>利用正弦波信号的频率随时间在一定范围内反复扫描</p></blockquote></div><footer class=post-footer><div class=post-copyright><ul><li class=post-copyright-author><strong>本文作者：</strong>winddoing</li><li class=post-copyright-link><strong>本文链接：</strong> <a href=https://winddoing.github.io/post/50356.html title=Audio驱动总结--ALSA>https://winddoing.github.io/post/50356.html</a></li><li class=post-copyright-license><strong>版权声明：</strong>本博客所有文章除特别声明外，均采用 <span class=exturl data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC8="><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div><div class=post-tags><a href="/tags/%E9%A9%B1%E5%8A%A8/" rel=tag><i class="fa fa-tag"></i> 驱动</a> <a href="/tags/alsa/" rel=tag><i class="fa fa-tag"></i> alsa</a> <a href="/tags/audio/" rel=tag><i class="fa fa-tag"></i> audio</a></div><div class=post-nav><div class=post-nav-item><a href=/post/32902.html rel=prev title=状态机><i class="fa fa-chevron-left"></i> 状态机</a></div><div class=post-nav-item><a href=/post/8df01b06.html rel=next title=ALSA-DMA>ALSA-DMA <i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><div class="comments utterances-container"></div></div></main><footer class=footer><div class=footer-inner><div class=copyright>&copy; 2014 – <span itemprop=copyrightYear>2023</span> <span class=with-love><i class="fa fa-heart"></i></span> <span class=author itemprop=copyrightHolder>winddoing</span></div><div class=wordcount><span class=post-meta-item><span class=post-meta-item-icon><i class="fa fa-chart-line"></i></span> <span title=站点总字数>1.1m</span></span> <span class=post-meta-item><span class=post-meta-item-icon><i class="fa fa-coffee"></i></span> <span title=站点阅读时长>16:21</span></span></div><div class=busuanzi-count><span class=post-meta-item id=busuanzi_container_site_uv><span class=post-meta-item-icon><i class="fa fa-users"></i></span> <span class=site-uv title=总访客量><span id=busuanzi_value_site_uv></span></span></span> <span class=post-meta-item id=busuanzi_container_site_pv><span class=post-meta-item-icon><i class="fa fa-eye"></i></span> <span class=site-pv title=总访问量><span id=busuanzi_value_site_pv></span></span></span></div><div class=powered-by>由 <span class=exturl data-url=aHR0cHM6Ly9oZXhvLmlv>Hexo</span> & <span class=exturl data-url="aHR0cHM6Ly90aGVtZS1uZXh0LmpzLm9yZy9taXN0Lw==">NexT.Mist</span> 强力驱动</div></div></footer><script src=https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin=anonymous></script><script src=https://cdnjs.cloudflare.com/ajax/libs/next-theme-pjax/0.5.0/pjax.min.js integrity="sha256-3NkoLDrmHLTYj7csHIZSr0MHAFTXth7Ua/DDt4MRUAg=" crossorigin=anonymous></script><script src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin=anonymous></script><script src=https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin=anonymous></script><script src=https://cdnjs.cloudflare.com/ajax/libs/lozad.js/1.16.0/lozad.min.js integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin=anonymous></script><script src=https://cdnjs.cloudflare.com/ajax/libs/pangu/4.0.7/pangu.min.js integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin=anonymous></script><script src=/js/comments.js></script><script src=/js/utils.js></script><script src=/js/motion.js></script><script src=/js/schemes/muse.js></script><script src=/js/next-boot.js></script><script src=/js/pjax.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.0/search.js integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin=anonymous></script><script src=/js/third-party/search/local-search.js></script><script class=next-config data-name=pdf type=application/json>{"object_url":{"url":"https://cdnjs.cloudflare.com/ajax/libs/pdfobject/2.2.8/pdfobject.min.js","integrity":"sha256-tu9j5pBilBQrWSDePOOajCUdz6hWsid/lBNzK4KgEPM="},"url":"/lib/pdf/web/viewer.html"}</script><script src=/js/third-party/tags/pdf.js></script><script class=next-config data-name=mermaid type=application/json>{"enable":true,"theme":{"light":"default","dark":"dark"},"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mermaid/9.1.1/mermaid.min.js","integrity":"sha256-8L3O8tirFUa8Va4NSTAyIbHJeLd6OnlcxgupV9F77e0="}}</script><script src=/js/third-party/tags/mermaid.js></script><script src=/js/third-party/fancybox.js></script><script data-pjax async src=https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script><script class=next-config data-name=leancloud_visitors type=application/json>{"enable":true,"app_id":"Q8qpjA3fOO7FEUBqcmcQFptF-gzGzoHsz","app_key":"tgUTq5bX3fVmn916EMRe65eJ","server_url":null,"security":false}</script><script src=/js/third-party/statistics/lean-analytics.js></script><script class=next-config data-name=enableMath type=application/json>false</script><script class=next-config data-name=mathjax type=application/json>{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.1/es5/tex-mml-chtml.js","integrity":"sha256-hlC2uSQYTmPsrzGZTEQEg9PZ1a/+SV6VBCTclohf2og="}}</script><script src=/js/third-party/math/mathjax.js></script><script class=next-config data-name=utterances type=application/json>{"enable":true,"repo":"Winddoing/winddoing.github.io","issue_term":"title","theme":"github-light"}</script><script src=/js/third-party/comments/utterances.js></script></body></html>