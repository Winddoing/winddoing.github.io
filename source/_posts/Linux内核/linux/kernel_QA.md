---
title: 内核常见问题
categories:
  - Linux内核
  - linux
tags:
  - linux
abbrlink: 57226
date: 2017-11-18 23:07:24
---
常见错误的总结；

<!--more-->

## Unhandled kernel unaligned access

### 思路:

1. 数据被冲掉(也就是其他数据的覆盖)
2. DDR出错(除非新调试的内存,不然机率很小)

### alignment fault的代码编写方式

#### 指针转换：

将低位宽类型的指针转换为高位宽类型的指针，如：将`char *` 转为`int *`，或将`void *`转为结构体指针。这类操作是导致alignment fault的最主要的来源，在分析定位问题时，需要特别关注。对于出现异常却又必须这样使用的场景，对这类转换后的指针进行访问时，如果不能确认其对应的地址是对齐的，则应该使用memcpy访问(memcpy方式不存在对齐问题)。另外，建议转换后立即使用，不要将其传递到其他函数和模块，防止扩展，带来潜在的问题。

#### 使用packed属性或者编译选项

这样的操作会关闭编译器的自动填充功能，从而使结构体中各个字段紧凑排列，如果排列时未处理好对齐，则可能导致alignment fault。一些场景下(内核中也较常见)确实需要用户自行紧凑排列结构体，可节省空间(在内存资源稀缺的场景下，很有用)，此时需要特别关注对齐问题，建议通过填充的方法尽量对齐，如此可能会导致空间浪费，但是会提升访问性能，典型的“以空间换时间”的思路。如果对空间有强烈要求，而可以接受性能损失，也可以不考虑对齐，不做padding，但在访问这些结构体的数据时，需要全部使用memcpy的方式。


## BUG: soft lockup - CPU#0 stuck for 22s!

### 思路:

1. 死锁
2. 死循环


## not syncing: softlockup: hung tasks
