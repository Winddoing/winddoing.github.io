---
layout: post
title: 动态分配二维数组
thread: 166
categories:
  - 程序设计
  - C
tags:
  - 数组
  - 动态分配
abbrlink: 42179
date: 2014-04-12 00:00:00
---

### 动态创建

* 动态数组是指在声明时没有确定数组大小的数组；当要用它时，C语言中用malloc语句重新指出数组的大小。使用动态数组的优点是可以根据用户需要，有效利用存储空间。

* 有时根据题意需得根据输入的二维数来动态的创建二维数组，那么此时就不能想以前一样直接定义多少行多少列了。因为不知道行列多少，假如设定太大浪费空间，申请太小完成不了程序的数据存储。因此需要合理的开辟二维空间。
<!--more-->
### 动态数组与静态数组的对比

>对于静态数组，其创建非常方便，使用完也无需释放，要引用也简单，但是创建后无法改变其大小是其致命弱点！
对于动态数组，其创建麻烦，使用完必须由程序员自己释放，否则严重会引起内存泄露。但其使用非常灵活，能根据程序需要动态分配大小。

### 遵循原则

>申请的时候从外层往里层，逐层申请；
释放的时候从里层往外层，逐层释放。

### 构建所需指针

>对于构建一维动态数组，需要一维指针；
对于二维，则需要一维，二维指针；
三维需要一，二，三维指针；
依此类推。

* 以下的两种方法都可以建立动态的二维空间数组。

### 方法一：

* 使用指针动态分配

		int i,j;
		int r,c;
		int **a;  //创建二维指针来指向数组
		scanf("%d%d",&r,&c);
		a  = (int **) malloc(sizeof(int *) * r);//注意申请的指针格式
		for (j=0;j<r;j++){
		a[j] = (int *) malloc(sizeof(int) * c);
		……
		……
		}

* 释放为：

		for (j=0;j<r;j++)
		 free(a[j]);//先释放一维指针
		 free(a);//最后释放我二维指针

### 方法二：

* 建立链表来存放二维数组。

		typedef struct arr
		{
		    int *array;
		}arr;
		main()
		{
		    arr *array1;
		    int rowx,rowy;
		    int i,j,k=0;
		    scanf("%d %d",&rowx,&rowy);
		    array1=(arr *)malloc(sizeof(arr)*rowx);//创建链表数组
		    for(i=0;i<rowx;i++)
		                //再在每一个链表中创建一维数组，这样整体就构成二维数组
		        array1[i].array=(int *)malloc(sizeof(int)*rowy);
		……
		……

* 释放同上：

		for (j=0;j<rowx;j++)
		 free(array1[j].array);
		 free(array);

		｝

### 示例

	#include <stdlib.h>
	#include <stdio.h>

	int main()
	{
		int n1,n2,n3;
		int ***array;
		int i,j,k;

		puts("输入一维长度:");
		scanf("%d",&n1);
		puts("输入二维长度:");
		scanf("%d",&n2);
		puts("输入三维长度:");
		scanf("%d",&n3);

		array=(int***)malloc(n1*sizeof(int**));//第一维
		for(i=0; i<n1; i++)
		{
			array[i]=(int**)malloc(n2*sizeof(int*)); //第二维
			for(j=0;j<n2;j++)
			{
				array[i][j]=(int*)malloc(n3*sizeof(int)); //第三维
				for(k=0;k<n3;k++)
				{
					array[i][j][k]=i+j+k+1;
					printf("%d\t",array[i][j][k]);
				}
				puts("");
			}
			puts("");
		}
		for(i=0;i<n1;i++)
		{
			for(j=0;j<n2;j++)
			{
				free(array[i][j]);//释放第三维指针
			}
		}
		for(i=0;i<n1;i++)
		{
			free(array[i]);//释放第二维指针
		}
		free(array);//释放第一维指针

		return 0;
	}
