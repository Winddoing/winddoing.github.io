---
layout: post
title: 数据压缩算法---霍夫曼编码（Huffman）
date: '2019-02-23 15:34'
tags:
  - huffman
categories:
  - 多媒体
  - 编码
abbrlink: 3506
---

霍夫曼编码是一种基于`最小冗余编码`的压缩算法。最小冗余编码是指，如果知道一组数据中符号出现的频率，就可以用一种特殊的方式来表示符号从而减少数据需要的存储空间。
- 用较少的位对出现频率高的符号编码
- 用较多的位对出现频率低的符号编码

一个符号不一定必须是文本字符，它可以是任何大小的数据，但往往它只占一个字节。

> Huffman Coding：译为哈夫曼编码、赫夫曼编码、霍夫曼编码。 是`可变字长编码(VLC)`的一种。用于`无损数据压缩`的`熵编码（权编码）`算法，是一种通过字符出现频率，根据二叉树实现。

<!--more-->

## 编码示例

### 编码字符统计

| 符号 | 概率  | 每个实例的熵 |
|:----:|:-----:|:------------:|
|  U   | 12/72 |  2.584 963   |
|  V   | 18/72 |  2.000 000   |
|  W   | 7/72  |  3.362 570   |
|  X   | 15/72 |  2.263 034   |
|  Y   | 20/72 |  1.847 997   |

#### 熵和最小冗余

每个数据集都有一定的信息量，这就是所谓的熵。一组数据的熵是数据中每个符号熵的总和
```
Sz = -lg2 Pz
```
> `Pz` 就数据集中z出现的频率

```
Su = -lg2(12/72) = 2.584 963位
```
> 72个字符的字符串中，U字符最少可以使用3位表示（四舍五入）

### 构造霍夫曼树

![huffman_tree](/images/2019/02/huffman_tree.png)

**出现频率越多的会越在上层，编码也越短，出现频率越少的就越在下层，编码也越长**

> 用霍夫曼树压缩数据，给定一个具体的符号，从树的根开始，然后沿着树的叶向叶子结点追踪。在向下追踪的过程中.
> - 当向左分支移动时，向当前编码的末尾追加`0`；
> - 当向右分支移动时，向当前编码的末尾追加`1`

### 编码表

| 字符 | 编码 |
|:----:|:----:|
|  U   | '101'  |
|  V   |  '01'  |
|  W   | '100'  |
|  X   |  '00'  |
|  Y   |  '11'  |

### 编码效率

- 不压缩数据大小：72*8=576bit
- 压缩后数据大小：12*3+18*2+7*3+15*2+20*2=163bit

- **压缩比**：1 - 163/576 = 71.7%


在通常情况下，霍夫曼编码并不是最高效的压缩方法，但它压缩和解压缩的速度非常快。
- 一般来说，造成霍夫曼编码比较耗时的原因是它需要`扫描两次数据`：一次用来计算频率；另一次才是用来压缩数据。
- 而解压缩数据非常高效，因为解码每个符号的序列只需要扫描一次霍夫曼树。


## 参考

* [霍夫曼编码压缩算法](http://blog.jobbole.com/20091/)
